{
  "name" : "1511.09080.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : "Exploiting Anonymity in Approximate Linear Programming: Scaling to Large Multiagent MDPs (Extended Version)",
    "authors" : [ "Philipp Robbel", "Frans A. Oliehoek", "Mykel J. Kochenderfer" ],
    "emails" : [ ],
    "sections" : [ {
      "heading" : "1 Introduction",
      "text" : "Cooperative multiagent systems (MASs) present an important framework for modeling the interaction between agents that collaborate to solve a task. In the decision-theoretic community, models like the Markov Decision Process (MDP) and its partially observable extensions have seen widespread use to model and solve such complex planning problems for single and multiple agents in stochastic worlds. Multiagent settings, however, are known to suffer from negative complexity results as they scale to realistic settings (Boutilier 1996). This is because state and action spaces tend to grow exponentially with the agent number, making common solution methods that rely on the full enumeration of the joint spaces prohibitive.\nMany problem representations thus attempt to exploit structure in the domain to improve efficiency. Factored MDPs (FMDPs) represent the problem in terms of a state space S that is spanned by a number of state variables, or factors, X1, . . . , XN (Boutilier, Dean, and Hanks 1999). Their multiagent extension (FMMDP) exploits a similar decomposition over the action space A and allows the direct representation of the “locality of interaction” that commonly arises in many multiagent settings (Guestrin, Koller, and Parr 2002).\nUnfortunately, the representational benefits from factored descriptions do not in general translate into gains for policy computation (Koller and Parr 1999). Even in extremely decentralized settings, for example DecMDPs (Bernstein et al. 2002), the value function is coupled because the actions of any agent will affect the rewards received in distant parts of the system. In FMMDPs this coupling is exacerbated by the fact that each agent in principle should condition its action on the entire state (Oliehoek, Whiteson, and Spaan 2013). Still, many solution methods successfully exploit structure in the domain, both in exact and approximate settings, and have demonstrated scalability to large state spaces (Hoey et al. 1999; Raghavan et al. 2012; Cui et al. 2015).\nar X\niv :1\n51 1.\n09 08\n0v 2\n[ cs\n.A I]\n2 0\nFe b\nIn this paper we focus on approaches that additionally address larger numbers of agents through value factorization, assuming that smaller, localized value function components can approximate the global value function well (Guestrin et al. 2003; Kok and Vlassis 2006). The approximate linear programming (ALP) approach of Guestrin et al. (2003) is one of the few approaches in this class that retains no exponential dependencies in the number of agents and variables through the efficient computation of the constraints in the linear program based on a variable elimination (VE) method. While the approach improved scalability dramatically, the method retains an exponential dependency on the induced tree-width (the size of the largest intermediate term formed during VE), meaning that its feasibility depends fundamentally on the connectivity and scale of the factor graph defined by the FMMDP and chosen basis function coverage.\nWe present an approach that aims to mitigate the exponential dependency of VE (both in space and time) on the induced width, which is caused by the need to represent all combinations of state and action variables that appear in each manipulated factor. In many domains, however, different combinations lead to similar effects, or influence. Serving as a running example is a disease control scenario over large graphs consisting of uncontrolled and controlled nodes, along with the connections that define possible disease propagation paths (Ho et al. 2015; Cheng et al. 2013). In this setting the aggregate infection rate of the parent nodes, independent of their individual identity, fully defines the behavior of the propagation model. This observation extends to many MASs that are more broadly concerned with the control of dynamic processes on networks, e.g. with stochastic fire propagation models or energy distribution in power grids (Liu, Slotine, and Barabasi 2011; Cornelius, Kath, and Motter 2013).\nWe propose to exploit this anonymity of influences for more efficient solution methods for MMDPs. Our particular contributions are as follows:\n1. We introduce a novel redundant representation (RR) for the factors that VE manipulates which involves count aggregators. This representation is exponentially more compact then regular flat representations and can also be exponentially more compact than existing “shattered” representations (Taghipour et al. 2013; Milch et al. 2008).\n2. We show how to derive an efficient VE algorithm, RR-VE, that makes use of the redundant representation, and prove its correctness. While the induced tree width does not change, since operations on the factors modified during VE can now run in less than exponential time with respect to the number of variables, RR-VE can scale theoretically to much larger problems.\n3. We then propose RR-ALP, which extends the ALP approach by making use of RR-VE, and maintains identical solutions. The RR-ALP consists of equivalent but smaller constraints sets for factored MDPs that support anonymous influence.\n4. We show an empirical evaluation of our methods that demonstrates speed-ups of the ALP method by an order of magnitude in a sampled set of random disease propagation graphs with 30 nodes. We also demonstrate the ability to scale to problem sizes that were previously infeasible to solve with the ALP solution method and show how the obtained policy outperforms a hand-crafted heuristic by a wide margin in a 50-node disease control problem with 25 agents."
    }, {
      "heading" : "2 Background",
      "text" : "We first discuss the necessary background on factored multiagent MDPs and their efficient solution methods that are based on value factorization."
    }, {
      "heading" : "2.1 Factored Multiagent MDPs",
      "text" : "Markov decision processes are a general framework for decision making under uncertainty (Kochenderfer 2015; Puterman 2005). An infinite-horizon Markov decision process (MDP) is defined by the tuple 〈S,A, T,R, γ〉, where S = {s1, . . . , s|S|} and A = {a1, . . . , a|A|} are the finite sets of states and actions, T the transition\nprobability function specifying P (s′ | s, a), R(s, a) the immediate reward function, and γ ∈ [0, 1] the discount factor of the problem.\nFactored MDPs (FMDPs) exploit structure in the state space S and define the system state by an assignment to the state variables X = {X1, . . . , Xn}. Transition and reward function decompose into a two-slice temporal Bayesian network (2TBN) consisting of independent factors, each described by their scope-restricted conditional probability distributions (CPDs) (Boutilier, Dean, and Hanks 1999).\nIn the case of collaborative multiagent systems, the agent set A = {A1, . . . , Ag} additionally spans a joint action space A that is generally exponential in the number of agents. The factored multiagent MDP (FMMDP) is a tractable representation that introduces action variables into the 2TBN (Guestrin, Koller, and Parr 2002) (see Figure 1 for an illustration). The FMMDP transition function can be written as\nP (x′ | x,a) = ∏ i Ti(x ′ i | x[Pa(X ′i)],a[Pa(X ′i)]) (1)\nwhere Pa(X ′i) refers to the parent nodes of X ′ i in the 2TBN (covering both state and action variables), and x[Pa(X ′i)] to their value in state x. The value of the respective action variables is analogously denoted by a[Pa(X ′i)]. Collaborative FMMDPs assume that each agent i observes part of the global reward and is associated with (restricted scope) local reward function Ri, such that the global reward factors additively as R(x,a) =∑g\ni=1Ri(x[Ci],a[Di]) for some subsets of state and action variables Ci and Di, respectively. The solution to an (M)MDP is a (joint) policy that optimizes some optimality criterion about the rewards, e.g. the expected sum of discounted rewards that can be achieved from any state. We consider value-based solution methods that store this expected return for every state x in a (state) value function V(x). The optimal value function V∗(x) represents the maximum expected return possible from every state (Puterman 2005). Such an (optimal) value function can be used to extract an (optimal) policy by performing a back-projection through the transition function to compute the so-called Q-function:\n∀x,a Q∗(x,a) = R(x,a) + γ ∑ x′ P (x′ | x,a)V∗(x), (2)\nand subsequently acting greedy with respect to the Q-function: the optimal action at x is a∗ = arg maxQ∗(x,a)."
    }, {
      "heading" : "2.2 Control of Epidemics on Graphs",
      "text" : "We use the control of a disease outbreak over a graph as a running example from the wider problem class of controlling dynamic processes on networks (Ho et al. 2015). The disease outbreak dynamics follow a version\nof the susceptible-infected-susceptible (SIS) model with homogeneous model parameters in the network (Bailey 1957). SIS dynamics have been thoroughly studied for many years but only few approaches consider the complex control problem of epidemic processes (Nowzari, Preciado, and Pappas 2015; Ho et al. 2015).\nSIS dynamics with homogeneous parameters are modeled as an FMMDP as follows. We define the network as a (directed or undirected) graph G = (V,E) with controlled and uncontrolled vertices V = (Vc, Vu) and edge set E ⊆ V × V . The state space S is spanned by state variables X1, . . . , Xn, one per associated vertex Vi, encoding the health of that node. The agent set A = {A1, . . . , A|Vc|} factors similarly over the controlled vertices Vc in the graph and denote an active modulation of the flow out of node Vi ∈ Vc. Note that this model assumes binary state variables Xi = {0, 1} = {healthy, infected}, and actions Ai = {0, 1} = {do not vaccinate, vaccinate} and that Au = {0} for all uncontrolled nodes Vu.\nLet xi and ai denote the state and action for a single node. The transition function factors on a per-node basis into Ti(x′i = infected | x[Pa(X ′i)], ai) defined as:\nTi ,\n{ (1− ai)(1− ∏ j(1− βjixj)) if xi = 0\n(1− ai) (1− δi) otherwise (3)\ndistinguishing the two cases that Xi was infected at the previous time step (bottom) or not (top). Parameters βji and δi are the known infection transmission probabilities from node j to i, and node i’s recovery rate, respectively. The reward function factors as:\nR(x,a) = −λ1 ‖a‖1 − λ2 ‖x‖1 (4)\nwhere the L1 norm records a cost λ2 per infected node and an action cost λ1 per vaccination action at a controlled node."
    }, {
      "heading" : "2.3 Efficient Solution of Large FMMDPs",
      "text" : "We build upon the work by Guestrin et al. (2003), who present approximate solution methods for FMMDPs that are particularly scalable in terms of the agent number. The approach represents the global Q-value function as the sum of appropriately chosen smaller value function components, each defined over a subset of state and action variables. Referred to as factored linear value functions, they permit efficient operations, such as the computation of the jointly maximizing action in a state, by treating it as a constraint optimization problem (e.g., (Dechter 2013)) where the maximizing configuration can be found with methods such as variable elimination (VE) that avoid the enumeration of exponentially many actions.\nTo compute a factored linear value function, the same authors present an efficient method to compactly represent the constraints in the approximate linear programming (ALP) solution to MDPs. Their extensions circumvent exponentially many constraints by implicitly making use of the above VE trick with factored linear value functions: since the constraints in the linear program can be interpreted as a maximization over sums of local terms, it is possible to replace them by an equivalent, smaller set of constraints based on the same insights as above. The remainder of this subsection gives more detail on this efficient solution method.\nFactored Value Functions\nValue factorization is one successful approach that addresses both large S and A by representing the joint value function as a linear combination of locally-scoped terms. Each local term applies to a part of the system and covers potentially multiple, even overlapping, state factors: V(x) = ∑i Vi(x[Ci]) for local state scopes Ci ⊆ {X1, . . . , Xn}. Note that in the limit of a single value function term this representation is simply a single joint value function in the global state x; still, one may hope that a set of lower-dimensional components may yield an adequate approximation in a large structured system.\nIn the case of factored linear value functions given a set of (possibly non-linear) basis functions H = {h1, . . . , hk}, V can be written as the linear combination V(x) = ∑k j=1 wjhj(x) where hj is defined over some subset of variables Chj ⊆ X (omitted for clarity), and wj is the weight associated with basis hj .\nFactored linear (state) value functions induce factored Q-value functions if transitions and rewards are factored into local terms. In this case, the back-projection in the computation of the Q-value function can be computed efficiently by avoiding the sum over exponentially many successor states in Equation 2 (Guestrin 2003). This is because the expectation over an individual basis function hj(x[Chj ]) can be computed efficiently since the scope of the variables that appear as parents of Xi ∈ Chj in the 2TBN remains local. These expectations are referred to as basis back-projections of the functions hj and denoted by gj(x,a).\nDefinition 1 (Basis back-projection). Given a basis function hj : C → R, defined over scope C ⊆ X, and a factored 2TBN transition model P (x′ | x,a) (see Equation 1), define the basis back-projection of hj as:\ngj(x,a) , ∑ x′ P (x ′ | x,a)hj(x′[C])\n= ∑\nc′ P (c ′ | x,a)hj(c′) = ∑\nc′ P (c ′ | x[Pa(C)],a[Pa(C)])hj(c′)\n(5)\nwhere Pa(C) , ⋃\nXi∈C Pa(Xi) denotes the union of respective parent (state and action) variables in the 2TBN.\nFunctions gj are thus again locally-scoped, defined precisely over the parent scope Pa(C) (omitted for clarity in the remainder of the presentation). Basis back-projections are used to compute a factored Q-value function:\nQ(x,a) = R(x,a) + γ∑x′ P (x′|x,a)∑j wjhj(x′) = ∑ r Rr(x[Cr],a[Dr]) + γ ∑ j wjgj(x,a)\n= ∑ iQi(x[Ci],a[Di]) (6)\nwhere the last line in Equation 6 follows by associating disjoint subsets of local reward functions and basis backprojections with each Qi. The factor graph spanned by a factored Q-value function instantiated in a particular state x is in this context often referred to as a coordination graph (CG).\nVE\nThe variable elimination (VE) algorithm can be used for computing the max over a set of locally-scoped functions in a factor graph efficiently. Similarly to maximum a posteriori (MAP) estimation in Bayesian networks, VE maximizes over single variables at a time rather than enumerating all possible joint configurations followed by picking the maximizing one (Koller and Friedman 2009).\nVariable elimination performs two operations, AUGMENT and REDUCE, repeatedly for every variable Xl to be eliminated from the factor graph. Here, AUGMENT corresponds to the sum of functions that depend on Xl and REDUCE to the maximization over Xl in the result (see Figure 2). The execution time is exponential in the size of the largest intermediate term formed which depends on the chosen elimination order. While the problem of determining the optimal elimination order is NP-complete, effective heuristics for variable ordering exist in practice (Koller and Friedman 2009).\nVE also finds application in computing the maximizing joint action in a coordination graph defined over locally-scoped Q-value function terms, i.e.,\na∗ = arg max a ∑ i Qi(x[Ci],a[Di])\ncan be done efficiently with the decision-making equivalent to VE in a Bayesian network (Guestrin, Koller, and Parr 2002; Kok and Vlassis 2006). As a result, action selection in a particular state x can avoid the direct enumeration of exponentially many (joint) action choices."
    }, {
      "heading" : "ALP",
      "text" : "VE can be used for efficient joint action selection in a particular state given a factored Q-function, but it does not give a way to directly compute such a factored Q-function. The approximate linear programming (ALP) variant introduced by (Guestrin et al. 2003) does allow this by implicitly making use of the above VE technique. It\nf∈F f over the state\nspace.\nbuilds on the regular ALP method for solving MDPs which computes the best approximation (in a weighted L1 norm sense) to the optimal value function in the space spanned by the basis functions (Puterman 2005). The basic ALP formulation for an infinite horizon discounted MDP given basis choice h1, . . . , hk is given by:\nmin w\n∑ x α(x) ∑ i wihi(x)\ns.t. ∑ i wihi(x) ≥ [R(x,a) + γ ∑ x′ P (x ′ | x,a)∑i wihi(x′)]∀x,a (7)\nfor state relevance weights α(x) (assumed uniform here) and variableswi unbounded. The ALP yields a solution in time polynomial in the sizes of S and A but these are exponential for MASs.\nGuestrin (2003) introduces an efficient implementation of the ALP for factored linear value functions that avoids the exponentially many constraints in the ALP. It applies if the basis functions have local scope and transitions and rewards are factored. Underlying it are two insights:\nFirst, the sum over exponentially many successor states x′ in the constraints in Equation 7 can be avoided by realizing that the right-hand side of the constraints corresponds to the (factored) Q-function that was previously shown to admit efficient computation via basis back-projections (Definition 1).\nThe second insight is that all (exponentially many) constraints in the ALP can be reformulated as follows:\n∀x,a ∑i wihi(x) ≥ R(x,a) + γ∑i wi gi(x,a) ⇒ ∀x,a 0 ≥ R(x,a) +∑i wi[γgi(x,a)− hi(x)] ⇒ 0 ≥ maxx,a[ ∑ r Rr(x[Cr],a[Dr]) + ∑ i wi[γgi(x,a)− hi(x)]]\n(8)\nThe reformulation replaces the exponential set of linear constraints with a single non-linear constraint (last row in Equation 8). Using a procedure similar to VE, this max constraint can be implemented with a small set of linear constraints, avoiding the enumeration of the exponential state and action spaces. To see this, consider an arbitrary intermediate term obtained during VE, e′(x[C]) = REDUCE(e(x[C ∪ {Xk}]), Xk). Enforcing that e′ is maximal over its domain can be implemented with |Dom(e′)| new variables and |Dom(e)| new linear constraints in the ALP (Guestrin 2003):\ne′(x[C]) ≥ e(x[C ∪ {Xk}]) ∀x[C ∪ {Xk}] ∈ Dom(e). (9)\nThe total number of linear constraints to implement the max constraint in Equation 8 is only exponential in the size of the largest intermediate term formed during VE."
    }, {
      "heading" : "3 Anonymous Influence",
      "text" : "At the core of the ALP solution method lies the assumption that VE can be carried out efficiently in the factor graph spanned by the local functions that make up the max constraint of Equation 8, i.e. that the scopes of all intermediate terms during VE remain small. This assumption is often violated in many graphs of interest, e.g., in disease control where nodes may possess large in- or out-degrees.\nIn this section we develop a novel approach to deal with larger scope sizes in VE than were previously feasible. Underlying it is the insight that in the class of graph-based problems considered here, only the joint effects of sets of variables—rather than their identity—suffices to compactly describe the factors that appear in the max constraint and are manipulated during VE. We introduce a novel representation that is exponentially smaller than the equivalent full encoding of intermediate terms and show how VE retains correctness.\nFirst, we address the representation of “joint effects” before showing how it can be exploited computationally during VE and in the ALP. In our exposition we assume binary variables but the results carry over to the more general, discrete variable setting."
    }, {
      "heading" : "3.1 Mixed-Mode Functions",
      "text" : "We define count aggregator functions to summarize the “anonymous influence” of a set of variables. In the disease propagation scenario for example, the number of active parents uniquely defines the transition model Ti; the identity of the parent nodes is irrelevant for representing Ti. The following definitions formalize this intuition.\nDefinition 2 (Count Aggregator). Let Z = { Z1, . . . , Z|Z| } be a set of binary variables, Zi ∈ {0, 1}. The count\naggregator (CA) #{Z} : Z1× . . .×Z|Z| 7→ {0, . . . , |Z|} is defined as: #{Z}(z) , ∑|Z|\ni=1 zi. Z is also referred to as the count scope of CA #{Z}.\nHence, CAs simply summarize the number of variables that appear ‘enabled’ in its domain. Conceptual similarities with generalized (or ‘lifted’) counters in first-order inference are discussed in Section 7. Functions that rely on CAs can be represented compactly.\nDefinition 3 (Count Aggregator Function). A count aggregator function (CAF), is a function f : Z → R that maps Z to the reals by making use of a CA. That is, there exists a function f : {0, . . . , |Z|} → R such that f can be defined with the function composition operator as:\nf(z) , [f ◦#{Z}] (z). (10)\nTo make clear f ’s use of a CA, we use the notation f(#(z)).\nCAFs have a compact representation which is precisely the function f. It is compact, since it can be represented using |Z| + 1 numbers and |Z| + 1 2|Z|. Generally, whenever function representations are explicitly referred to in this paper, the fractal font is used.\nWe now introduce so-called “mixed-mode” functions f that depend both on CAs and on other variables X that are not part of any CA:\nDefinition 4 (Mixed-Mode Function). A function f : X × Z → R is called a mixed-mode function (MMF), denoted f(x,#(z)), if and only if ∀x ∃fX s.t. f(x, z) = fX(#(z)). That is, for each instantiation x, there exists a CAF fX(#(z)). We refer to Xi ∈ X as proper variables and Zj ∈ Z as count variables in the scope of f .\nExample 1. Consider the conditional probability distribution Ti(Xi | Pa(Xi)) of a (binary) node Xi and its parents in the (binary) disease propagation graph. Let xi and x̄i denote the case that node i is infected and not infected, respectively. Then Ti(Xi | #{Pa(Xi)}) is a mixed-mode function that induces two CAFs, one for xi and one for x̄i.\nMixed-mode functions generalize simply to those with multiple CAs, f : X×Z1× . . .×ZN → R, denoted f(x,#1(z1), . . . ,#N (zN )). The following cases can occur:\n1. MMFs with fully disjoint scopes have mutually disjoint proper and count variable sets, i.e., X ∩ Zi = ∅ ∀i = 1, . . . , N and Zi ∩ Zj = ∅ ∀i 6= j;\n2. MMFs have shared proper and count variables if and only if ∃i s.t. X ∩ Zi 6= ∅;\n3. MMFs have non-disjoint counter scopes if and only if ∃(i, j), i 6= j s.t. Zi ∩ Zj 6= ∅.\nIn our treatment of MMFs we often refer to the canonical notation f(x, y, z,#1(a, b, z),#2(b, c)) to denote a general MMF that includes both shared proper and count variables, as well as non-disjoint counter scopes.\nSummarizing, it is possible to represent certain anonymous influences using mixed-mode functions. In the following we will show that these can be compactly represented, which subsequently forms the basis for a more efficient VE algorithm."
    }, {
      "heading" : "3.2 Compact Representation of MMFs",
      "text" : "Just as CAFs, a mixed-mode function f has a compact representation f : X × {0, ..., |Z|} → R where f(x,#(z)) , f(x, ∑|Z| i=1 zi). A mixed-mode function f can thus be described with (at most) K\n|X|(|Z| + 1) parameters where K is an upper bound on |Dom(Xi)|.\nAs mentioned before, we also consider MMFs with multiple CAs. In particular, let us examine a function f(#1(a, b),#2(b, c)) with two CAs that have a overlapping scope since both depend on shared variable B. In order to consistently deal with overlaps in the count scope, previous work has considered so-called shattered representations (Taghipour et al. 2013; Milch et al. 2008). A MMF with overlapping count scopes f(#1(a, b),#2(b, c)) can always be transformed into an equivalent one without overlapping count scopes f ′(#′1(a),# ′ 2(c),#(b)) by defining a new function that is equivalent to it:\nf ′(#′1(a),# ′ 2(c),#(b)) , f(#1(a, b),#2(b, c)).\nWe can now distinguish between different representations of these MMFs with overlapping count scopes.\nDefinition 5 (Shattered Representation). The shattered representation of f is the representation of f ′, i.e.\nf(#1(a, b),#2(b, c)) , f(k1, k2, k3)\nwhere k1 := a, k2 := c, k3 := b and f : {0, 1} × {0, 1} × {0, 1} → R.\nWe introduce a novel redundant representation of f . Redundant representations retain compactness with many overlapping count scopes. This becomes relevant when we introduce operations on MMFs (e.g., for variable elimination) in later sections of the paper.\nDefinition 6 (Redundant Representation). The redundant representation of MMF f(#1(a, b),#2(b, c)) is a function f : {0, 1, 2} × {0, 1, 2} → R:\nf(#1(a, b),#2(b, c)) , f(k1, k2)\nwhere k1 := a+ b and k2 := b+ c.\nIf we choose to store MMFs with redundant representations, we may introduce incompatible assignments to variables that appear in overlapping count scopes. The following definition formalizes this observation.\nDefinition 7 (Consistent Count Combination). Let #1{A,B},#2{B,C} be two CAs with overlapping count scopes. We say that a pair (k1, k2) is a consistent count combination (consistent CC) for #1,#2 if and only if there exists an assignment (a, b, c) such that (k1, k2) = (#1(a, b),#2(b, c)). If no such (a, b, c) exists, then (k1, k2) is called an inconsistent CC. Further, let f(#1,#2) be a MMF. We say that a consistent CC (k1, k2) for #1,#2 is a consistent entry f(k1, k2) of the representation of f . Similarly, if (k1, k2) is an inconsistent CC, then f(k1, k2) is referred to as an inconsistent entry.\nInconsistent entries can only occur in redundant representations since the shattered representation of f is defined for f ′ without overlapping count scopes. Even though redundant representations appear to have a disadvantage since they contain inconsistent entries, they also have a big advantage: as we show next, they can be exponentially more compact than shattered ones. Moreover, as detailed in the rest of this document, the disadvantage of the inconsistent entries can be avoided altogether by making sure that we never query such inconsistent entries in our algorithms.\nLemma 1. Consider MMF f : X × Z1 × . . . × ZN → R, N ≥ 2. Let Z = ⋃N\ni=1 Zi. In the worst case, a partition of Z requires p = min{2N − 1, |Z|} splits into mutually disjoint sets and the shattered representation of f is of size O(Sp) where S is an upper bound on the resulting set sizes. The same function has a redundant representation of size O(KN ) where K is an upper bound on |Zi|+ 1. Example 2. Consider MMF f(#1{A,B,C,D,E}, #2{A,B,X, Y, Z}, #3{A,C,W,X}) with overlapping count scopes. The redundant representation of f requires 6 ·6 ·5 = 180 parameters but contains inconsistent entries. The shattered representation defined using equivalent MMF f ′(#{A},#{B}, #{C},#{D,E},#{X}, #{W},#{Y, Z}) requires 288 parameters.\nNote that, in general, the difference in size between shattered and un-shattered representations can be made arbitrarily large. We now show how mixed-mode functions with compact redundant representations can be exploited during variable elimination and during constraint generation in the ALP."
    }, {
      "heading" : "4 Efficient Variable Elimination",
      "text" : "Here we describe how AUGMENT and REDUCE are efficiently implemented to work directly on the redundant representations of MMFs. Our goal is to leverage compact representation throughout the VE algorithm, i.e., to avoid shattering of function scopes if possible. Particular care has to be taken to ensure correctness since we observed previously that reduced representations contain inconsistent entries."
    }, {
      "heading" : "Augment",
      "text" : "AUGMENT takes a set of MMFs and adds them together. We implement this operation directly in the redundant representation. AUGMENT(g, h) returns a function f that is defined as: ∀x, y, k1 ∈ {0, . . . , N1}, k2 ∈ {0, . . . , N2}\nf(x, y, k1, k2) = g(x, k1) + h(y, k2). (11)\nThe implementation simply loops over all x, y, k1, k2 to compute all entries (which may be consistent or inconsistent)."
    }, {
      "heading" : "Reduce",
      "text" : "REDUCE removes a variable by maxing it out. Here we show how this operation is implemented for MMFs directly using the redundant representation. Let g(x, y, z,#1(a, b, z),#2(b, c)) be a MMF with redundant representation g(x, y, z, k1, k2). We discriminate different cases:\n1. Maxing out a proper variable: If we max out x, f(y, z, k1, k2) , max {g(0, y, z, k1, k2), g(1, y, z, k1, k2)}\n2. Maxing out a non-shared count variable: If we max out a, f(x, y, z, k1, k2) , max{g(x, y, z, k1, k2), g(x, y, z, k1 + 1, k2)}. The resulting function has signature f(x, y, z,#′1(b, z),#′2(b, c)). The values of x, y, z, b, c are fixed (by the l.h.s. of the definition) in such a way that #′1(b, z) = k1 and # ′ 2(b, c) = k2.\nThe maximization that we perform over a ∈ {0, 1} therefore has the ability to increase k1 by 1 or not, which leads to the above maximization in the redundant representation.\n3. Maxing out a shared count variable: If we max out b, f(x, y, z, k1, k2) , max{g(x, y, z, k1, k2), g(x, y, z, k1 + 1, k2 + 1)} This is similar to the previous case, but since b occurs in both #′1 and #′2, it may either increase both k1 and k2, or neither.\n4. Maxing out a shared proper/count variable: In case we max out z, f(x, y, k1, k2) , max{g(x, y, 0, k1, k2), g(x, y, 1, k1 + 1, k2)}. Since z occurs as both proper and count variable (in #1), a choice of z = 1 also increments k1 by 1 while z = 0 does not."
    }, {
      "heading" : "Correctness of RR-VE",
      "text" : "We refer to VE with the elementary operations defined as above as redundant representation VE (RR-VE). RRVE is correct, i.e., it arrives at the identical solution as VE using the full tabular representation of intermediate functions. The proof depends on the following two lemmas:\nLemma 2. When the input functions are correctly defined on their consistent entries, AUGMENT is correct.\nProof. The implementation of AUGMENT as given in (11) may lead to an f that contains inconsistent entries. In particular, this will happen when the scopes of #1,#2 contain a shared variable. However, we will make sure that when using f later on, we will only query consistent entries. That is, when querying the function f(x, y,#1(a, b),#2(b, c)) via arguments (x, y, a, b, c) we will never retrieve such inconsistent entries. Therefore, we only need to show that the consistent entries are computed correctly. In particular, we need to show that\n∀x,y,a,b,c f(x, y,#1(a, b),#2(b, c)) = g(x,#1(a, b)) + h(y,#2(b, c)) = g(x, a+ b) + h(y, b+ c)\n{we define k1 := a+ b, k2 := b+ c } = g(x, k1) + h(y, k2)\nwhich is exactly the value that (11) computes for (consistent) entry f(x, y, k1, k2). The only thing that is left to prove, therefore, is that the entries that we query for g, h are also consistent. However, since we access these input function using the same count combination (k1, k2), which is a consistent CC resulting from x, y, a, b, c, this must be the case per the assumption stated in the Lemma.\nLemma 3. When the input functions are correctly defined on their consistent entries, REDUCE is correct.\nProof. In Appendix A.\nTheorem 1. RR-VE is correct, i.e., it arrives at the identical solution as VE using the full tabular representation of intermediate functions.\nProof. We have shown that AUGMENT is correct for consistent entries in f (Lemma 2). The VE algorithm passes the result of AUGMENT to REDUCE (see Figure 2). In any of the cases implemented by REDUCE, only consistent count combinations for counters #1 and #2 are computed. It follows that the max operation will be over consistent entries in g, which are correct. Since there are no other modifications to the regular VE algorithm, RR-VE is correct."
    }, {
      "heading" : "5 Exploiting Anonymity in the ALP",
      "text" : "The results for RR-VE can be exploited in the ALP solution method that was introduced in Section 2.3. The non-linear max constraint in Equation 8 is defined over functions ci , γgi − hi ∀hi ∈ H and reward factors Rj , j = 1, . . . , r, which are all locally-scoped and together span a factor graph. As outlined previously, a VE procedure over this factor graph can translate the non-linear constraint into a set of linear constraints that is reduced compared to the standard formulation of the ALP.\nThe key insight of this section is that for a class of factored (M)MDPs defined with count aggregator functions in the 2TBN (i.e., precisely those that support anonymous influence), the same intuition about reduced representations as in the previous section applies to implement the non-linear max constraint even more compactly. We showed previously for the running example of disease control how anonymity naturally arises in the transition model of the stochastic process.\nWe first establish that basis functions hi ∈ H , when back-projected through the 2TBN (which now includes mixed-mode functions), retain correct basis back-projections gi with reduced representations. The basis backprojection is computed with summation and product operations only (Equation 5). We have previously shown that summation (AUGMENT) of mixed-mode functions is correct for its consistent entries. The same result holds for multiplication when replacing the sum operation with a multiplication. It follows that gi (and ci) share the compact reduced representations derived in Section 3 and that they are correctly defined on their consistent entries.\nThe exact implementation of the max constraint in Equation 8 with RR-VE proceeds as for the regular VE case. All correctness results for RR-VE apply during the computation of the constraints in the RR-ALP. The number of variables and constraints is exponential only in the size of the representation of the largest mixedmode function formed during RR-VE. Further, the representation with the smaller set of constraints is exact and yields the identical value function solution as the ALP that does not exploit anonymous influence."
    }, {
      "heading" : "6 Experimental Evaluation",
      "text" : "We evaluate our methods on undirected disease propagation graphs with 30 and 50 nodes. For the first round of experiments, we contrast runtimes of the normal VE/ALP method (where possible) with those that exploit “anonymous influence” in the graph. Since the obtained value functions for both methods are identical, the focus of this evaluation is on runtime performance over a sampled set of random graphs. We then consider a disease control problem with 25 agents in a densely connected 50-node graph that cannot be solved with the normal ALP. Problems of this size (|S| = 250, |A| = 225) are prohibitively large for exact solution methods to apply and are commonly solved heuristically. To assess quality of the RR-ALP solution, we evaluate its policy performance against a vaccination heuristic in simulation.\nIn all experiments, we use indicator functions IXi , IX̄i on each state variable (covering the two valid instantiations {healthy, infected}) as the basis set H in the (RR-)ALP. We use identical transmission and node recovery rates throughout the graph, β = 0.6, δ = 0.3. Action costs are set to λ1 = 1 and infection costs to λ2 = 50. All experiments use the identical greedy elimination heuristic for both VE and RR-VE, which minimizes the scope size of intermediate terms at the next iteration."
    }, {
      "heading" : "Runtime Comparison",
      "text" : "We use graph-tool (Peixoto 2014) to generate 10 random graphs with an out-degree k sampled from P (k) ∝ 1/k, k ∈ [1, 10]. Out-degrees per node thus vary in [1, 10]; the mean out-degree in the graphs in the test set ranges from 2.8 (graph 1) to 4.2 (graph 10). Figure 3 illustrates a subset of the resulting networks.\nThe runtime results comparing the VE/ALP method to RR-VE/RR-ALP are summarized in Table 1. Shown are the number of constraints for each method, the wall-clock times for VE to generate the constraints, and the ALP runtimes to solve the value function after the constraints have been computed. The last three columns show the relative magnitude of each measure, i.e. the gains in efficiency of the methods exploiting anonymous influence in each of the 10 random graphs. On average, the RR-ALP solution time reduces to 16% of the original ALP runtime while maintaining the identical solution. Reductions by a factor of 50 are observed for two of the random graphs in the set (corresponding to the highlighted entries in the last column).\nWe performed a final experiment with a graph with a larger out-degree (k sampled from the interval [1, 20], shown at the right of Figure 3). The disease propagation problem over this graph cannot be solved with the normal VE/ALP because of exponential blow-up of intermediate terms. The version exploiting anonymous influence completes successfully, performing constraint computation using RR-VE in 124.7s and generating |CRR| = 5816731 constraints."
    }, {
      "heading" : "Policy Performance",
      "text" : "In this section we show results of policy simulation for three distinct policies in the disease control task over two random graphs (30 nodes with 15 agents and 50 nodes with 25 agents, both with a maximum out-degree per node set to 15 neighbors). The disease control problem over both graphs is infeasible for the regular VE/ALP\ndue to the exponential increase of intermediate factors during VE. We compare the solution of our RR-ALP method to a random policy and a heuristic policy that applies a vaccination action at Xi if Xi is infected in the current state and belongs to the controlled nodes Vc in the graph. The heuristic is reactive and does not provide anticipatory vaccinations if some of its parent nodes are infected; we refer to it as the “copystate” heuristic in our evaluation. It serves as our main comparison metric for these large and densely connected graphs where optimal solutions are not available.\nTo evaluate the policy performance, we compute the mean returns from 50 randomly sampled starting states s0 after 200 steps of policy simulation (each mean return is computed over 50 independent runs from a given s0). Figure 4 shows statistics of these mean returns, i.e., each sample underlying a box plot corresponds to a mean estimate from each of the 50 initial states. The box plots thus provide an indication of the sensitivity to the initial conditions s0 in the disease graph.\nThe “copystate” heuristic works reasonably well in the 30-node/15-agent problem (left-hand side of Figure 4) but is consistently outperformed by the RR-ALP solution which can administer anticipatory vaccinations. This effect actually becomes more pronounced with fewer agents: we experimented with 6 agents in the identical graph and the results (not shown) indicate that the “copystate” heuristic performs significantly worse than the random policy. This is presumably because blocking out disease paths early becomes more important with fewer agents since the lack of agents in other regions of the graph cannot make up for omissions later.\nIn the 50-node/25-agent scenario the reactive “copystate” heuristic does not provide a statistically significant improvement over a random policy (right-hand side of Figure 4). It is outperformed by the RR-ALP solution by roughly a factor of 3 in our experiments. In the same figure it is also apparent that the performance of the heuristic depends heavily on the initial state of the disease graph.\nNot shown in the Figure is that the RR-ALP policy also had a smaller variance within all simulations from an individual initial state s0, indicating not only better performance in expectation, but also higher reliability in\neach single case."
    }, {
      "heading" : "7 Related Work",
      "text" : "Many recent algorithms tackle domains with large (structured) state spaces. For exact planning in factored domains, SPUDD exploits a decision diagram-based representation (Hoey et al. 1999). Monte Carlo tree search (MCTS) has been a popular online approximate planning method to scale to large domains (Silver, Sutton, and Müller 2008). These methods do not apply to exponential action spaces without further approximations. Ho et al. (2015), for example, evaluated MCTS with three agents for a targeted version of the disease control problem. Recent variants that exploit factorization (Amato and Oliehoek 2015) may be applicable.\nOur work is based on earlier contributions of Guestrin (2003) on exploiting factored value functions to scale to large factored action spaces. Similar assumptions can be exploited by inference-based approaches to planning which have been introduced for MASs where policies are represented as finite state controllers (Kumar, Zilberstein, and Toussaint 2011). There are no assumptions about the policy in our approach. The variational framework of Cheng et al. (2013) uses belief propagation (BP) and is exponential in the cluster size of the graph. Their results are shown for 20-node graphs with out-degree 3 and a restricted class of chain graphs. Our method remains exponential in tree-width but exploits anonymous influence in the graph to scale to random graphs with denser connectivity.\nGeneralized counts in first-order (FO) models eliminate indistiguishable variables in the same predicate in a single operation (Sanner and Boutilier 2009; Milch et al. 2008). Our contributions are distinct from FO methods. Anonymous influence applies in propositional models and to node sets that are not necessarily indistiguishable in the problem. We also show that shattering into disjoint counter scopes is not required during VE and show how this results in efficiency gains during VE.\nThere is a conceptual link to approaches that exploit anonymity or influence-based abstraction in decentralized or partially-observable frameworks. Oliehoek, Witwicki, and Kaelbling (2012) define influence-based policy abstraction for factored Dec-POMDPs, which formalizes how different policies of other agents may lead to the same influence. Roughly stated, this work can be seen to give some justification of the idea of using factored value functions. While optimal influence search for TD-POMDPs (Witwicki and Durfee 2010;\nWitwicki, Oliehoek, and Kaelbling 2012) only searches the space of unique influences (which implicitly does take into account the working of aggregation operators), such a procedure is not yet available for general factored Dec-POMDPs, and would require imposing decentralization constraints (i.e., restrictions on what state factors agents can base their actions on) for MMDPs. Our approach, in contrast, does not impose such constraints and provides a more scalable approach for MMDPs by introducing a practical way of dealing with aggregation operators.\nAlso closely related is the work by Varakantham, Adulyasak, and Jaillet (2014) on exploiting agent anonymity in transitions and rewards in a subclass of Dec-MDPs with specific algorithms to solve them. Our definition of anonymity extends to both action and state variables; our results on compact, redundant representation of anonymous influence further also applies outside of planning (e.g., for efficient variable elimination)."
    }, {
      "heading" : "8 Conclusions and Future Work",
      "text" : "This paper introduces the concept of “anonymous influence” in large factored multiagent MDPs and shows how it can be exploited to scale variable elimination and approximate linear programming beyond what has been previously solvable. The key idea is that both representational and computational benefits follow from reasoning about influence of variable sets rather than variable identity in the factor graph. These results hold for both single and multiagent factored MDPs and are exact reductions, yielding the identical result to the normal VE/ALP, while greatly extending the class of graphs that can be solved. Potential future directions include approximate methods (such as loopy BP) in the factor graph to scale the ALP to even larger problems and to support increased basis function coverage in more complex graphs."
    }, {
      "heading" : "Acknowledgments",
      "text" : "F.O. is supported by NWO Innovational Research Incentives Scheme Veni #639.021.336."
    }, {
      "heading" : "A Correctness of Redundant Representation VE",
      "text" : "Here we prove Lemma 3 that is used to show correctness of Redundant Representation VE (RR-VE) in Section 4."
    }, {
      "heading" : "Correctness of Reduce",
      "text" : "Lemma 4. When the input functions are correctly defined on their consistent entries, REDUCE is correct.\nProof. We need to show that for a function g(x, y, z,#1(a, b, z),#2(b, c)) if we reduce by maxing out any variable, we indeed get the desired function f . Again, the resulting representation might contain inconsistent entries, but we only need to show correctness for the consistent entries, since only those will be queried. This is because the result of REDUCE only occurs as input to AUGMENT in Figure 2 and we have shown previously that only consistent entries are queried from these input functions.\nWe discriminate the different cases:\nMaxing out a Proper Variable If we max out x, our redundant representation performs the operation\nf(y, z, k1, k2) , max {g(0, y, z, k1, k2), g(1, y, z, k1, k2)} (12)\nAssume an arbitrary y, z, a, b, c. We need to show that f represents function f correctly, i.e.\nf(y, z,#1(a, b, z),#2(b, c)) = max x∈{0,1} g(x, y, z,#1(a, b, z),#2(b, c))\nWe start with the r.h.s.:\nmax x∈{0,1} g(x, y, z,#1(a, b, z),#2(b, c)) =\nmax {g(0, y, z,#1(a, b, z),#2(b, c)), g(1, y, z,#1(a, b, z),#2(b, c))} (13)\nSuppose #1(a, b, z) = k1 and #2(b, c) = k2. Then (13) is equal to\nmax {g(0, y, z, k1, k2), g(1, y, z, k1, k2)}\nbut this is exactly how f(x, y, z, k1, k2) is defined, thereby showing that this representation of f is correct provided that the accessed entries for g are correct. But g is only accessed on (k1, k2), which is a consistent entry that we assumed to be correct. Realizing that we showed correctness for the arbitrarily selected y, z, a, b, c, and hence for all y, z, a, b, c, we complete the proof.\nMaxing out a Non-Shared Count Variable If we max out a, our redundant representation performs the operation\nf(x, y, z, k1, k2) , max {g(x, y, z, k1, k2), g(x, y, z, k1 + 1, k2)} (14) Assume an arbitrary x, y, z, b, c. We need to show that f represents function f correctly, i.e.\nf(x, y, z,#′1(b, z),#2(b, c)) = max a∈{0,1} g(x, y, z,#1(a, b, z),#2(b, c)),\nwith #′1(b, z) being a reduced CA. We start with the r.h.s.:\nmax a∈{0,1} g(x, y, z,#1(a, b, z),#2(b, c)) =\nmax {g(x, y, z,#1(0, b, z),#2(b, c)), g(x, y, z,#1(1, b, z),#2(b, c))} (15)\nSuppose #1(0, b, z) = k1, #2(b, c) = k2 then #1(1, b, z) = k1 + 1 such that (15) is equal to\nmax {g(x, y, z, k1, k2), g(x, y, z, k1 + 1, k2)}\nbut this is exactly how f(x, y, z, k1, k2) is defined, thereby showing that this representation of f is correct for the arbitrarily selected x, y, z, b, c, and hence for all x, y, z, b, c, provided that g(x, y, z, k1, k2) and g(x, y, z, k1 + 1, k2) are computed correctly. But both (k1, k2) and (k1 + 1, k2) results from settings of particular values for a, b, c, z and thus are consistent CCs. Since we assumed that the input functions are correct on the consistent entiries, the computation of f is correct.\nMaxing out a Shared Counter Variable We are given g(x, y, z,#1(a, b, z),#2(b, c)) which is represented as g(x, y, z, k1, k2). If we max out b, our redundant representation performs the following operation.\nf(x, y, z, k1, k2) , max {g(x, y, z, k1, k2), g(x, y, z, k1 + 1, k2 + 1)} (16)\nHere we want to show that this leads to the correct result. That is, we need to prove that the represented functions represent the right thing:\n∀x,y,z,a,c f(x, y, z,#′1(a, z),#′2(c)) = max b∈{0,1} g(x, y, z,#1(a, b, z),#2(b, c)),\nwith #′1(a, z),# ′ 2(c) being reduced CAs.\nAssume an arbitrary x, y, z, a, c. We need to show that\nf(x, y, z,#′1(a, z),# ′ 2(c)) = max\nb∈{0,1} g(x, y, z,#1(a, b, z),#2(b, c))\nWe start with the r.h.s.:\nmax b∈{0,1} g(x, y, z,#1(a, b, z),#2(b, c)) =\nmax {g(x, y, z,#1(a, 0, z),#2(0, c)), g(x, y, z,#1(a, 1, z),#2(1, c))} (17)\nSuppose#1(a, 0, z) = k1, #2(0, c) = k2 then #1(a, 1, z) = k1 + 1 and #2(1, c) = k2 + 1, such that (17) is equal to max {g(x, y, z, k1, k2), g(x, y, z, k1 + 1, k2 + 1)} but this is exactly how f(x, y, z, k1, k2) is defined, thereby showing that this representation of f is correct for the arbitrarily selected x, y, z, a, c, and hence for all x, y, z, a, c, provided that g(x, y, z, k1, k2) and g(x, y, z, k1 + 1, k2 + 1) are correct. Again, these are consistent entries, thus completing the proof.\nMaxing out a Shared Proper/Counter Variable In case we max out z, our redundant representation performs the operation\nf(x, y, k1, k2) , max {g(x, y, 0, k1, k2), g(x, y, 1, k1 + 1, k2)} (18)\nAssume an arbitrary x, y, a, b, c. We need to show that f represents function f correctly, i.e.\nf(x, y,#′1(a, b),#2(b, c)) = max z∈{0,1} g(x, y, z,#1(a, b, z),#2(b, c)),\nwith #′1(a, b) being a reduced CA. We start with the r.h.s.:\nmax z∈{0,1} g(x, y, z,#1(a, b, z),#2(b, c)) =\nmax {g(x, y, 0,#1(a, b, 0),#2(b, c)), g(x, y, 1,#1(a, b, 1),#2(b, c))} (19)\nSuppose #1(a, b, 0) = k1, #2(b, c) = k2. Then #1(a, b, 1) = k1 + 1, such that (19) is equal to\nmax {g(x, y, 0, k1, k2), g(x, y, 1, k1 + 1, k2)}\nbut this is exactly how f(x, y, z, k1, k2) is defined. Since the maximization is over consistent entries, this shows that this representation of f is correct for the arbitrarily selected x, y, a, b, c, and hence for all x, y, a, b, c, thus completing the proof."
    } ],
    "references" : [ ],
    "referenceMentions" : [ ],
    "year" : 2016,
    "abstractText" : "Many exact and approximate solution methods for Markov Decision Processes (MDPs) exploit structure in the problem and are based on factorization of the value function. Especially multiagent settings, however, are known to suffer from an exponential increase in value component sizes as interactions become denser, meaning that approximation architectures are restricted in the problem sizes and types they can handle. We present an approach to mitigate this limitation for certain types of multiagent systems, exploiting a property that can be thought of as “anonymous influence” in the factored MDP. Anonymous influence summarizes joint variable effects efficiently whenever the explicit representation of variable identity in the problem can be avoided. We show how representational benefits from anonymity translate into computational efficiencies, both for variable elimination in a factor graph and for the approximate linear programming solution to factored MDPs. Our methods scale to factored MDPs that were previously unsolvable, such as the control of a stochastic disease process over densely connected graphs with 50 nodes and 25 agents.",
    "creator" : "LaTeX with hyperref package"
  }
}