{
  "name" : "1103.3123.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : "Reduced Ordered Binary Decision Diagram with Implied Literals: A New knowledge Compilation Approach",
    "authors" : [ "Yong Lai", "Dayou Liu", "Shengsheng Wang" ],
    "emails" : [ "laiy07@mails.jlu.edu.cn" ],
    "sections" : [ {
      "heading" : null,
      "text" : "Key words: knowledge compilation, target language, ROBDD, implied literals"
    }, {
      "heading" : "1 Introduction",
      "text" : "Reasoning problems in their general form are intractable and knowledge compilation has been emerging as a key direction of research for dealing with such kind of intractability [1-5]. The basic idea of knowledge compilation is to split the reasoning process into two phases: an off-line compilation phase, in which the propositional theory is compiled into some tractable target language, and an on-line query-answering phase, in which the compiled target is used to efficiently answer the queries. And the compiling time in off-line phase can be amortized by a (potentially) exponential number of on-line queries.\nThe target language is one of key aspects for any compilation approach. There have existed dozens of target languages so far, such as Horn theories [1], prime implicates/implicants [6, 7], reduced ordered binary decision diagram (ROBDD) [8, 9], free binary decision diagram (FBDD) [5, 10], decomposable negation normal form (DNNF, three subsets d-DNNF, DNNFT and d-DNNFT) [3, 11, 12], EPCCL theory [4, 13] and so on. Therefore, it is important to choose an appropriate target language in practical applications. Darwiche and Marquis argue that the choice of a target language must be based on two key aspects: the succinctness of the target compilation language, and the class of queries and transformations that the language supports in polytime [5]. Moreover, they propose the classic knowledge compilation map, which analyzes many existing target compilation languages according to the above aspects. On this basis, some researchers extend the knowledge compilation map [12, 14, 15].\nROBDD is one of the most tractable target languages which satisfy all of querying requirements involved in the knowledge compilation map (as far as we know, the compilation languages meeting these requirements include ROBDD, MODS, d-DNNFT and EPCCL theory [5, 12, 13]) and has been quite influential in many communities such as model checking [16], AI planning [17], abductive inference [18], terminological reasoning in description logic SHIQ [19] and so on. However, ROBDD seems a bit redundant for some Boolean formulas. For example, it is well known that the ROBDD representing the Boolean formula (x1 ↔ y1) ∧ … ∧ (xn ↔ yn) has exponential size over the variables order x1 < … < xn < y1 < … < yn. In fact, when xi is assigned some value (true or false), yi must have the same value. This characteristic limits the application of this language to some specific areas. Therefore, in order to reduce this kind of redundancy and extend its real applications, it is very necessary to make some small changes of ROBDD without loss of too much tractability. Based on this motivation, we do the following work in this paper:\n1. We add some literals called implied literals in the nodes of ROBDD meaning that the formula represented by the node implies them. We call this new target language ROBDD-L. Given a number i, we discuss a subset of ROBDD-L called ROBDD-i – precisely i implied literals in each node. It is obvious that ROBDD-0 is isomorphic to ROBDD. Then we show that there is exactly one ROBDD-i representing a given formula over a specific variables order.\n2. We show that ROBDD-∞ is an interesting subset of ROBDD-L: it is the most succinct subset of ROBDD-L and we propose an algorithm which can transform every sentence of ROBDD-L into an equivalent sentence of ROBDD-∞ in polytime. Furthermore, we prove that ROBDD-∞ can meet all the query requirements except SE mentioned in the knowledge compilation map (it is unknown whether ROBDD-∞ satisfies SE or not).\n3. We propose a compilation algorithm (called Build) which can compile any Boolean formula into ROBDD-i (0 ≤ i ≤ ∞). And we optimize Build to propose a ROBDD-∞ compilation algorithm called Build-inf and discuss three optimization techniques. In addition, we propose two algorithms called Inf2FBDD and Inf2ROBDD which\ncan transform any ROBDD-∞ into FBDD and ROBDD, respectively. Combining Build, Build-inf, Inf2FBDD and Inf2ROBDD and all the operations supported by ROBDD-L in polytime, we devise a ROBDD-L package called BDDjLu and report some experimental results."
    }, {
      "heading" : "2 Reduced Ordered Binary Decision Diagram with Implied Literals",
      "text" : "In the sequel X = {x1, … , xn} is the set of Boolean variables. A Boolean formula, hereafter simply called a formula, is constructed from true, false and variables using the negation operator ¬, conjunction operator ∧ and disjunction operator ∨. A literal is either a variable x (positive literal) or its negation¬x (negative literal). Given a literal l, its negation ¬l is ¬x if l is x and ¬l is x otherwise. A clause C is a set of literals representing their disjunction. C is a Horn clause if it contains at most one positive literal. A term T is a set of literals representing their conjunction. T is consistent iff there does not exist any variable x such that both x and ¬x belong to T. A Boolean formula in conjunctive normal form (CNF) is a set of clauses representing their conjunction. A CNF formula is Horn theory if all clauses are Horn clause. A Boolean formula in negation normal form (NNF) is constructed from true, false and literals using only the conjunction and disjunction operators. It is obvious that any clause, term and CNF formula is in NNF. A practical representation of NNF formula [3, 5] is a rooted, directed acyclic graph (DAG) where each leaf node is labeled with true, false or a literal; and each internal node is labeled with ∧ or ∨ and can have arbitrarily many children.\nAn assignment A over the variables set X (we also say that A is a X-assignment) is a set of literals such that A does not contains any literal and its negation. A is complete over X if A contains one and only one literal for any variable x in X (i.e., there exists exactly one element in {x, ¬x} ∩ A for any variable x ∈ X), otherwise it is partial. It is obvious that there exists 2| X | complete assignments over X. Any complete assignment satisfies true and falsifies false. A complete assignment A satisfies a literal l over X iff l ∈ A, A falsifies it otherwise; A satisfies a formula ¬ϕ over X iff it falsifies ϕ, and A falsifies it otherwise; A satisfies a formula ϕ1 ∧ ϕ2 over X iff it satisfies both ϕ1 and ϕ2, and A falsifies it otherwise; A satisfies ϕ1 ∨ ϕ2 over X iff it satisfies either ϕ1 or ϕ2, and A falsifies it otherwise. A model M of any formula is a complete assignment satisfies it. We call a formula satisfiable if it has at least one model, and we say it is unsatisfiable otherwise. We say a formula over X is a tautology if all complete assignments over X satisfy it. Given two formulas ϕ1 and ϕ2 over X, ϕ1 implies ϕ2 (denoted by ϕ1 ⇒ ϕ2) iff the models of ϕ1 is subsumed by the ones of ϕ2, ϕ1 is equivalent to ϕ2 (denoted by ϕ1 ⇔ ϕ2) iff both ϕ1 ⇒ ϕ2 and ϕ2 ⇒ ϕ1. Now we give the definition of reduced ordered binary decision diagram with implied literals step by step.\nDefinition 1. A binary decision diagram with implied literals (BDD-L) is a rooted DAG. Each node v is either terminal or non-terminal and represents some formula φ(v) in NNF. There exist two kinds of terminal nodes: False node (denoted by ⊥) which represents false, and True nodes labeled by a set of literals L(v) called implied literals which represent the term conjoining all the literals in L(v). And each non-terminal node v is associated with a Boolean variable var(v), implied literals L(v) and two children, called low child lo(v) and high child hi(v). Given a non-False node v, it is denoted by 〈L(v)〉 if it is a True node, otherwise it is denoted by 〈var(v), lo(v), hi(v), L(v)〉. At each non-terminal node v, var(v) does not appear in L(v), any variable appearing in L(v) does not appear in its descendent nodes, and the low (resp. high) branch is depicted as a dash (resp. solid) line corresponding to the case where the variable is assigned false (resp. true). So given a non-terminal node v, we have that:\n( ) ( ( )) (( ( ) ( ( ))) ( ( ) ( ( )))). v l L v var v lo v var v hi v ( ) φ φ φ= ∈ ∧ ¬ ∧ ∨ ∧ ∗∧ Usually, an implied literal corresponds to a simple fact implied by knowledge base, such as John does not like pink coat, Jim just like jeans and so on. In BDD-L, some or all simple facts are pulled out and stored explicitly at the root. From above Definition 1, we know that the only difference between BDD-L and BDD [8] is the implied literals. When every node in BDD-L is mandatory for no implied literal, then BDD-L is equivalent to BDD and (*) will be φ(v) = (¬var(v) ∧ φ(lo(v))) ∨ (var(v) ∧ φ(hi(v))). And FBDD can be seen as a special kind of BDD-0 such that each variable appears at most once on any path. For simplicity, we suppose that at least one child of a non-terminate node is non-False and the implied literals of a non-False node represent a consistent tern.\nIn the implementation, we use a hash table called nodes table to record all the nodes in BDD-L, another hash table called implied literals table, which allows us to deal with the same sets of implied literals only once in some operations (see Section 4), is used to record all the sets of implied literals in BDD-L, L(v) for any node v in the nodes table is an index pointing to some entry in implied literals table, L(u) and L(v) share the same entry if L(u) = L(v), the data unit size in implied literals table records the size of L(v) in order to facilitate model counting (see Section 4).\nAn example about BDD-L is showed in Figure 1. In the following, we denote the set of the variables appearing in v (i.e., var(v) and the variables appearing in L(v)) and its descendent nodes as VARS(v), the number of nodes in the BDD-L as | u |, where u is the root of the BDD-L, path(v) is a term and any literal ¬x (resp. x) belongs to it iff there exists some node v′ with the variable x such that its low (resp. high) branch appearing in the path from the root to v. The maximal set of implied literals, which is used frequently in this paper, is defined as follows:\nDefinition 2. Given a BDD-L and a non-False node v in it, the maximal set of implied literals L∞(v) is defined as follows:\n( ) is a True node; ( ) { ( )} ( ( )) ( ) ;\n( ) ( ) { ( )} ( ( )) ( ) ; ( ) ( ( ( )) ( ( ))) otherwise.\nL v v L v var v L hi v lo v\nL v L v var v L lo v hi v L v L hi v L lo v ∞ ∞ ∞\n∞ ∞ ⎧ ⎪ ∪ ∪ =⊥⎪= ⎨ ∪ ¬ ∪ =⊥⎪ ⎪ ∪ ∩⎩\nObviously, L(v) is a subset of L∞(v) for any non-False node v. Given any BDD-L, we can compute the maximal set of implied literals for all of its nodes in polytime with the use of dynamic programming, which is used in almost all algorithms in this paper.\nDefinition 3. A BDD-L is ordered (OBDD-L) if 1. The set of variables is imposed over a given linear order <; 2. Given a node u and its child v, var(u) is less than any variable appearing in v; 3. For any non-terminal node v, any variable appearing in L(v) is less than the ones appearing in L∞(v) but not\nin L(v), formally, ((( ( ) ( )) ( ( ) \\ ( ) ( ) \\ ( ))) ).x x L v x L v x L v L v x L v L v x x∞ ∞′ ′ ′∀ ∈ ∨ ¬ ∈ ∧ ∈ ∨ ¬ ∈ → <\nFrom the above definition, it is obvious that BDD-L in Figure 1 is not ordered as it does not satisfy the condition 2 and 3 in Definition 3, and we have some simple conclusions which are used in the proofs of some propositions: given a non-False node v, it is easy to prove that φ(v) is satisfiable (used in the proof of Proposition 1) by induction, because at least one child of v is non-False and the implied literals represent a consistent term; given any node u and its child v in an OBDD-L, VARS(v) ⊂ VARS(u) (used in the proof of Proposition 4); given a non-False node v, the condition 3 is obviously satisfied if L(u) = L∞(u) (used in the proof of Proposition 4). And the following proposition holds:\nProposition 1. Given any non-False node v in any OBDD-L, each element in L∞(v) is exactly a literal implied by φ(v), i.e., L∞(v) = {l : φ(v) ⇒ l}.\nProof. By induction on the size of | v |. Assume that the conclusion holds for | v | ≤ n. The case | v | = 1 is immediately. We proceed by case analysis:\n(1) lo(v) = ⊥: We have that L∞(v) = L(v) ∪ {var(v)} ∪ L∞(hi(v)) from Definition 2. By induction hypothesis, L∞(hi(v)) = {l : φ(hi(v)) ⇒ l}. This means that there exists some formula ϕ such that φ(hi(v)) ⇔ ∧(l ∈ L∞(hi(v))) ∧ ϕ. Then by (*)\n( ) ( ( )) ( ( ) ( ( ( ))) ).v l L v var v l L hi vφ ϕ∞= ∈ ∧ ∧ ∈ ∧∧ ∧ It is obvious that φ(v) ⇒ l for any l ∈ L∞(v). Assume that there exists some literal l such that φ(v) ⇒ l and l ∉ L∞(v). And any non-False node in OBDD-L represents a satisfiable formula. Then ϕ ⇒ l, this conflicts with the induction hypothesis.\n(2) hi(v) = ⊥: It is analogous to (1). (3) Otherwise, we have that L∞(v) = L(v) ∪ (L∞(lo(v)) ∩ L∞(hi(v))) from Definition 2. By induction hypothesis,\nL∞(hi(v)) = {l : φ(hi(v)) ⇒ l} (resp. L∞(lo(v)) = {l : φ(lo(v)) ⇒ l}). This means that there exists some formula ϕ such that φ(hi(v)) ⇔ ∧(l ∈ L∞(hi(v))) ∧ ϕ (resp. φ(lo(v)) ⇔ ∧(l ∈ L∞(lo(v))) ∧ ϕ′). Then by (*) ( ) ( ( )) (( ( ) ( ( ( ))) ) ( ( ) ( ( ( ))) )).v l L v var v l L lo v var v l L hi vφ ϕ ϕ∞ ∞ ′= ∈ ∧ ¬ ∧ ∈ ∧ ∨ ∧ ∈ ∧∧ ∧ ∧ It is obvious that φ(v) ⇒ l for any l ∈ L∞(v). Assume that there exists some literal l such that φ(v) ⇒ l and l ∉ L∞(v). By Definition 3, then ϕ ⇒ l or ϕ′ ⇒ l, this conflicts with the induction hypothesis. ■\nIf we displace the OBDD-L with BDD-L in Proposition 1, then the proposition doesn’t hold. The BDD-L in Figure 1 is a counterexample for it, where L∞(v) = ∅ and the formula represented by this BDD-L implies any\nliteral. Definition 4. An OBDD-L is reduced (ROBDD-L) if 1. No two distinct nodes u and v have the identical variable, implied literals, low child and high child; 2. No node has two identical children; Definition 5. Given a number 0 ≤ i ≤ ∞, a OBDD-L precisely has i implied literals (OBDD-i) if (1) each node\nv has i implied literals, or (2) j (j < i) implied literals and L(v) = L∞(v). A ROBDD-i is a reduced OBDD-i. Particularly, OBDD-∞ is also called “OBDD with as many implied literals as possible”. It is obvious that\nROBDD-0 is isomorphic to ROBDD. By Proposition 1, we have that L(v) = L∞(v) for any node v in OBDD-∞, then the False node does not appear in any OBDD-∞.\nFigure 2 are a ROBDD-0 and a ROBDD-1 about the formula (x1 ↔ y1) ∧ (x2 ↔ y2) over the variables order x1 < x2 < y1 < y2. The nodes in ROBDD-0 are obviously less than those in ROBDD-1. Furthermore, all the ROBDDs-i (i > 0) presenting this formula over the same variables order are the same. If this formula is extended to (x1 ↔ y1) ∧ … ∧ (xn ↔ yn) over x1 < … < xn < y1 < … < yn, then ROBDD-0 will have more than 2n + 1 nodes, while the number of nodes in ROBDD-i (i > 0) is 2n + 1.\nIt is well known that for any formula there is exactly one ROBDD representing it. We will show that for any 0 ≤ i ≤ ∞, ROBDD-i also has this property. First, we give the definition of Condition [3, 5], which is a useful logical operation in practical applications. Note that we do not restrict this definition to the NNF formulas here.\nDefinition 6. Let ϕ be a formula over the variables set X and let T be a consistent term. The conditioning of ϕ on T (denoted by ϕ | T, simply denoted by ϕ | l if T = {l}) is a formula obtained by replacing every variable x in ϕ with true (resp. false) if x ∈ T (resp. ¬x ∈ T).\nGiven any formula ϕ, variable x, literal l and consistent term T, by Theorem 1 in [3], we have that: ϕ ⇔ (ϕ | l) ∧ l if ϕ ⇒ l; ϕ ⇔ ϕ | x if ϕ | x ⇔ ϕ | ¬x (we say x can be omitted in ϕ). Given two equivalent formulas ϕ1 and ϕ2, all variables do not appear in both ϕ1 and ϕ2 can be omitted. And given an OBDD-L with root v, according to (*), φ(v) | L(v) ∪ ¬var(x) (resp. φ(v) | L(v) ∪ var(x)) is equivalent to φ(lo(v)) (resp. φ(hi(v))). These observations are used in the proofs of many propositions in this paper, including the following conclusion.\nProposition 2. For any formula ϕ over the set of variables X = {x1, … , xn} with the linear order x1 < … < xn, and any 0 ≤ i ≤ ∞, there is exactly one ROBDD-i to represent ϕ.\nProof. By induction on the size of X. The case | X | = 0 is obvious. Assume now that we have proven this proposition for | X | ≤ n. We proceed to show it for | X | = n + 1.\nFirst we show that there exists some ROBDD-i equivalent to ϕ. By the induction hypothesis, this assertion is obvious if there exists some variable x ∈ X that can be omitted in ϕ. Otherwise, we construct a ROBDD-i equivalent to ϕ (In fact, it is just the idea of the compilation algorithm Build, see Section 5). Let {l1, … , lm} be the set of literals implied by ϕ such that the variable of lj is less than the one of lj′ if j < j′, let L(v) = {l1, … , lm′}, where m′ = min{m, i}. If there does not exist any variable appearing in ϕ but not in L(v), then 〈L(v)〉 is equivalent to ϕ. Otherwise let var(v) be the minimum variable appearing in ϕ but not in L(v). It is obvious ϕ | L(v) ∪ {¬x} is not equivalent to ϕ | L(v) ∪ {x}. By the induction hypothesis, the ROBDDs-i corresponding to ϕ | L(v) ∪ {¬x} and ϕ | L(v) ∪ {x} are not identical to each other, and let lo(v) and hi(v) be their roots, respectively. It is obvious that the DAG with the root v is a ROBDD-i such that φ(v) is equivalent to ϕ.\nThen assume that there exist two ROBDDs-i with the roots u and v for ϕ, we prove that they are identical to each other. It is obvious that L(u) = L(v) by Proposition 1 and the definition of ROBDD-i. And if var(u) ≠ var(v), without loss of generality we assume that var(u) < var(v), this means that var(u) can be omitted in ϕ, then the\nROBDD-i with the root u must have two identical children by the induction hypothesis. This conflicts with the condition 1 of Definition 4. So the formula represented by low (resp. high) child of v1 must be equivalent to the one represented by low (resp. high) child of v2 (otherwise the formula represented by v1 is not equivalent to the one represented by v2), then we know that the low (resp. high) child of v1 is identical to the low (resp. high) child of v2 by induction hypothesis. This means that v1 is identical to v2. ■\nAlthough any ROBDD-i is a reduced OBDD-i, there exists some OBDD-i (0 < i < ∞) such that the corresponding ROBDD-i has more nodes. An example is showed in Figure 3, where the OBDD-i has 5 nodes and the ROBDD-i has 7 nodes. However, this kind of “strange phenomenon” will not occur when i = 0 or i = ∞.\nProposition 3. Given any formula ϕ, the corresponding ROBDD-i has the least number of nodes among all OBDDs-i equivalent to ϕ and each OBDD-i can be transformed into the equivalent ROBDD-i in linear time if i = 0 or i = ∞.\nProof. An algorithm called Reduce which can transform any OBDD-i into the corresponding ROBDD-i in linear time is presented in Figure 4. The function MK is called to guarantee the condition 2 of Definition 4: given any node u, if some identical node has appeared before, then MK(v) returns the old one, otherwise it returns u. The condition 1 of Definition 4 is guaranteed by Line 5 (no matter whether i = ∞ or not, L(lo(u)) = ∅ if lo(u) = hi(u), so L(u) does not need to be changed). Every step in a single call (without consideration of the recursive calls) of Reduce can terminal in constant time, include the call of MK, whose running time is constant (readers are referred to [9] for the reason). With the cache G1, there are at most | v | recursive calls of Reduce. So Reduce(v) can terminate in linear time. And in a single call of Reduce, at most one new node is introduced into the result (i.e. a new node is introduced only when MK(u) returns u itself). We have that the nodes in the resulting ROBDD-0 or ROBDD-∞ is not more than the ones in the input. Then the conclusion is obvious by Proposition 2. ■\n3 On the Succinctness of ROBDD-L\nIn this section, we first show that ROBDD-∞ is the most succinct part in OBDD-L, then prove that ROBDD-i is not at least as succinct as ROBDD-j for i < j. These mean that ROBDD-i is indeed a different target language from ROBDD-j with i ≠ j and ROBDD-∞ is strictly more succinct than any ROBDD-i (i < ∞), including ROBDD. Finally, we show that ROBDD-∞ is strictly less succinct than any FBDD. From these results, we can obtain some other conclusions. The definition of succinctness is as follows [5]:\nDefinition 7. Let L1 and L2 be two subsets of NNF. L1 is at least as succinct as L2, if and only if there exists a polynomial p such that for every sentence α ∈ L2, there exists an equivalent sentence β ∈ L1 where | β | ≤ p ⋅ | α |. Here, | α | and | β | are the sizes of α and β, respectively. L1 is strictly more succinct than L2 if and only if L1 is at least as succinct as L2, while L2 is not at least as succinct as L1.\nNote that on the one hand the fact L1 is strictly less succinct than L2 does not prevent that L1 is more space efficient than L2 for some kind of knowledge bases, on the other hand the succinctness is only concerned about the best case, in fact for the compilation languages without uniqueness, the time cost of finding the best representation of the knowledge base is so high that usually it is impractical to use such kind of algorithms. Therefore, it is possible that given two languages L1 and L2 such that L1 is strictly more succinct than L2, compared with the L2 compilers, some L1 compiler can generate more space efficient compilation results for some kind of knowledge bases. We will validate this assertion in Section 6.\nProposition 4. ROBDD-∞ is the most succinct subset in OBDD-L. In fact, given any OBDD-L, let n be the number of the non-terminal nodes such that neither of its children is the False node, then this OBDD-L can be transformed into the corresponding ROBDD-∞ in polytime and the nodes of the ROBDD-∞ is not more than 2n + 1.\nProof. We use a specific algorithm to prove this proposition. An algorithm which can transform any OBDD-L into the equivalent ROBDD-∞ in polytime is presented in Figure 5. In order to avoid making too many recursive calls, we maintain a cache G2 which stores previously computed outputs of the function Add-to-inf-sub. On Lines 5-9, we search the nearest node v′ from v such that neither of the children of v′ is the False node. It is obvious that this loop can terminal in polytime.\nWe first show that the output of Add-to-inf-sub is indeed an OBDD-∞ equivalent to its input such that VARS(u) ⊆ VARS(v), and then Reduce(Add-to-inf-sub(v)) returns the corresponding ROBDD-∞ by Proposition 3. We prove it by induction on the size of | v |. The case | v | = 1 is immediate. Assume that the conclusion holds for | v | ≤ n. When | v | = n + 1, the output of Add-to-inf-sub obviously meets the requirements if v′ is a True node. Otherwise we have | lo(v′) | ≤ n and | hi(v′) | ≤ n. By the induction hypothesis, the output of Add-to-inf-sub(lo(v′)) (resp. Add-to-inf-sub(hi(v′)) is an OBDD-∞ equivalent to φ(lo(v′)) (resp. φ(hi(v′))). After Line 15 (resp. Line 17), the BDD-L with the root lo(u) (resp. hi(u)) is still an OBDD-∞. Given any literal l ∈ L(u) and x is the variable of l, if l appears in v′ or some ancestor node of v′, and then x doesn’t appear in any descendent node of v′, we have that x doesn’t appear in any descendent node of u because VARS(lo(u)) ⊆ VARS(lo(v′)) and VARS(hi(u)) ⊆ VARS(hi(v′)) by the induction hypothesis. Otherwise l ∈ L∞(lo(v′)) and l ∈ L∞(hi(v′)) by Definition 2, then by Proposition 1 and the induction hypothesis, l ∈ L(Add-to-inf-sub(lo(v′))) and l ∈ L(Add-to-inf-sub(hi(v′))), then l is deleted on Lines 15 and 17, it means that x doesn’t appear in any descendent node u. So the output of Add-to-inf-sub(v) is a BDD-L. By Definition 3, var(v′) is less than any variable appearing in lo(v′) and hi(v′), and then var(v′) is less than any variable appearing in lo(u) and hi(u) because VARS(lo(u)) ⊆ VARS(lo(v′)) and VARS(hi(u)) ⊆ VARS(hi(v′)). We know that L(lo(u)) does not share any literal with L(hi(u)) and neither of lo(u) and hi(u) is the False node, this means that L(u) = L∞(u) by Definition 2, and then the condition 3 of Definition 3 is satisfied in v. So the output of Add-to-inf-sub(v) is an OBDD-∞.\nThen we show that the call of Add-to-inf-sub(v) can terminate in polytime for any ROBDD-L with the root v, then Add-to-inf(v) can terminate in polytime because we can compute L∞(v′) for any node v′ in polytime (Line 23) and the output can be transformed into the equivalent ROBDD-∞ in polytime by Proposition 3 on Line 24. It is obvious that a single call of Add-to-inf-sub can terminate in polytime because every step except the recursive calls can terminal in polytime. With the cache G2, there are at most n recursive calls of Add-to-inf-sub. So Add-to-inf-sub(v) can terminate in polytime.\nFinally, in a single call of Add-to-inf-sub, exactly two new nodes (i.e., lo(u) and hi(u)) will be introduced into the resulting OBDD-∞. Together with the root, there exist 2n + 1 nodes in the resulting OBDD-∞. By Proposition 3, there exist at most 2n + 1 nodes in the resulting ROBDD-∞. In summary, the conclusion holds. ■\nIt is pointed out that the algorithm Add-to-inf immediately give us a ROBDD-∞ compilation method, i.e., firstly compile the knowledge base into ROBDD, and then use the algorithm Add-to-inf to turn the result into ROBDD-∞. In addition, we point out one observation about Add-to-inf as follows:\nObservation 1. If the input of Add-to-inf-sub satisfies the formula represented by the low child of any node is not equivalent to the high child, then its output also satisfies this condition. We can prove it by induction. So we only need to delete the redundant nodes from the output of Add-to-inf-sub in the algorithm Reduce.\nAs the algorithm Add-to-inf plays a key role in this paper, we give an example to show how it works. Example 1. Let us consider the ROBDD-0 in Figure 2. For simplicity, we omit the implied literals table here,\nand the nodes table of ROBDD is showed in Figure 6(a). First, we compute the maximal set of implied literals for each node in ROBDD. Then Add-to-inf-sub(v10) is called. As both children of v10 are non-False, Add-to-inf-sub(v9) is called on the Line 14. Similarly, Add-to-inf-sub(v7) is called on the Line 14. After running Lines 5-9, v′ = v1. Then u is assigned as 〈{¬y1, ¬y2}〉 and it is put into G2. L(lo(u)) is assigned as {¬y2} on Line 15, this means that vIV is generated. Then Add-to-inf-sub(v5) is called on the Line 16. Similarly, 〈{¬y1, y2}〉 and it is put into G2, L(hi(u)) is assigned as {y2} on Line 17, this means that vII is generated. Then 〈x2, IV, II, {¬y1}〉 is put into G2. Back to the calling of Add-to-inf-sub(v10), L(lo(u)) is assigned as {¬y1} on Line 15, this means that vVI is generated. Similarly, L(hi(u)) is assigned as {y1} on Line 17 and vV is generated. Finally, Add-to-inf-sub(v10) returns 〈x1, VI, V, ∅〉, which is the root of the resulting OBDD-∞ (its nodes table is showed in Figure 6(c), and it is showed in Figure 6(d)). On Lines 24, we run Reduce on the OBDD-∞, and the ROBDD-∞ in Figure 2 is generated.\nProposition 5. Given any two number i < j, ROBDD-i is not at least as succinct as ROBDD-j. Proof. According to Definition 7, we just need to provide a counterexample here. Let us consider the formula\nbelow over the linear order x1 < … < x i + 1 < x1, 1 < … < x1, i+1 < … < xn, 1 < … < xn, i + 1: 1 1,1 1 1, 1 ,1 , 1(( ) ( )) (( ) ( )).i n n nx x x x x x x x+ +↔ ∧ ∧ ↔ ∧ ∧ ↔ ∧ ∧ ↔L L L n i\nThe size of ROBDD-i representing this formula is exponential, while the size of ROBDD-(i + 1) is polynomial. And ROBDD-(i + 1) is as same as ROBDD-j. ■\nNow we know that ROBDD-∞ is strictly more succinct than ROBDD by the above two propositions, then a question occurs: is it possible that ROBDD-∞ has a linear size as ROBDD for some kind of knowledge bases. The following proposition, which is useful for proving that the size of ROBDD-i (0 < i ≤ ∞) corresponding to some formula ϕ is exponential in the size of ϕ, will answer this question.\nProposition 6. Given any formula ϕ over the variables x1 < … < xn and 0 < i ≤ ∞, if ϕ ⇒ C does not hold for any non-tautology clause such that xn does not appear in it, then we have that: all of the ROBDD-i corresponding to ϕ are the same; assume that ROBDD-i has the root v and ROBDD has the root u, then\n| | 1 | | 2 | | 5 2 u v u−⎡ ⎤ ≤ ≤ ⋅ −⎢ ⎥⎢ ⎥ .\nProof. The case ϕ = false is impossible. Given any non-terminal node v1 in ROBDD-1, we have that L∞(v1) has no other literal except xn and ¬xn, otherwise there exists some literal l such that l ∉ {xn, ¬xn} and ϕ ∧ path(v1) ⇒ l by Proposition 1, and then ϕ ⇒ ¬path(v1) ∨ l, it is obvious that ¬path(v1) ∨ l is a non-tautology clause and xn does not appear in it, this is impossible. So there does not exist some node v2 such that var(v2) = xn, otherwise we have that: any father v3 of v2 satisfies L∞(v3) = ∅ by Definition 3 and Proposition 2; the children of v2 are ⊥ and 〈∅〉 by Definition 4. These two assertions conflict with each other. Then given any True node v4, L∞(v4) has no other literal except xn and ¬xn for the same reason as v1. In summary, given any node v′ in ROBDD-1, | L∞(v1) | ≤ 1. Then by Definition 5, all of the ROBDD-i corresponding to ϕ are the same.\nWe call Add-to-inf(u) to transform the ROBDD into the ROBDD-∞. Given any non-terminal node u1 in ROBDD with var(u1) < xn, neither of its children is the False node, otherwise, without loss of generality, assume that lo(u1) = ⊥, ϕ ∧ path(u1) ⇒ var(u1), and then ϕ ⇒ ¬path(u1) ∨ var(u1), it is obvious that ¬path(u1) ∨ var(u1) is a non-tautology clause and xn does not appear in it, this is impossible. So there exists some path from u1 to u2 such that var(u2) = xn, otherwise φ(u1) ⇔ true. Obviously, one child of u2 is ⊥, while other child is 〈∅〉. So xn cannot be omitted in any non-terminal node in ROBDD. Then the number of non-terminal nodes such that neither of its children is the False node in ROBDD is not more than | u | − 3. We have that | v | ≤ 2 ⋅ (| u | − 3) + 1 = 2 ⋅ | u | − 5 by Proposition 4.\nLet non-False node u3 be one child of u1, the new node created in the single call of Add-to-inf-sub(u1) must be equivalent to φ(u3) if L∞(u3) is empty, the new node must be equivalent to φ(u3) or φ(u3) | xn if xn ∈ L∞(u3), the new node must be equivalent to φ(u3) or φ(u3) | ¬xn otherwise. Let Φ1 = {φ(u3): L∞(u3) = ∅, u3 ≠ 〈∅〉}, Φ2 = {φ(u3): xn ∈ L∞(u3)}, Φ3 = {φ(u3) | xn: xn ∈ L∞(u3)}, Φ4 = {φ(u3): ¬xn ∈ L∞(u3)}, Φ5 = {φ(u3) | ¬xn: ¬xn ∈ L∞(u3)}. Obviously, the elements in Φj (1 ≤ j ≤ 5) are not equivalent to each other, the elements in Φ1 ∪ Φ2 ∪ Φ4 are not equivalent to each other, | Φ1 ∪ Φ2 ∪ Φ4 | = | Φ1 | + | Φ2 | + | Φ4 | = | u | − 3 (without the root u and the terminal nodes). Given any formula ϕ1 ∈ Φ1 ∪ Φ2 ∪ Φ3 ∪ Φ4 ∪ Φ5 without the appearance of xn, ϕ1 could only appears in Φ1, Φ3 and Φ5 if ϕ1 = true, otherwise ϕ1 could only be equivalent to some formula in Φ3 and Φ5 because xn cannot be omitted in any non-terminal node in ROBDD. Let Φ6 = {ϕ1: ϕ1 ∈ Φ3 and ϕ1 is equivalent to some formula in Φ5}. It is obvious that\n6 3 5 2 4 | | 3| | min(| |,| |) min(| |,| |) 2 u −⎡ ⎤Φ ≤ Φ Φ = Φ Φ ≤ ⎢ ⎥⎢ ⎥\nand each element in ROBDD corresponds to at least one node in the output of Add-to-inf-sub(u). By Observation 1, we only need to delete redundant nodes from the output of Add-to-inf-sub(u) because the input is an ROBDD, then we have that\n6 | | 3 | | 1| | 1 (| | 3) | | 1 2 2 u uv u − −⎡ ⎤ ⎡ ⎤≥ + − − Φ ≥ + =⎢ ⎥ ⎢ ⎥⎢ ⎥ ⎢ ⎥ . ■\nNow we turn to show that ROBDD-∞ is strictly less succinct than FBDD: Proposition 7. ROBDD-∞ is strictly less succinct than FBDD. Proof. First, we use a specific algorithm to show that FBDD is as succinct as ROBDD-∞. An algorithm which can transform any ROBDD-∞ into the equivalent FBDD in polytime is presented in Figure 7. Here we treat FBDD as a subset of BDD-0, i.e., for any non-False in FBDD, L(v) = ∅. By induction, it is easy to prove that Inf2FBDD is correct.\nThen we show that ROBDD-∞ is not as succinct as FBDD by given a counterexample. Let us consider the formula ϕ = (x1 ↔ y1) ∨ … ∨ (xn ↔ yn) over the variables order x1 < … < xn < y1 < … < yn. It is well known that\nthere exists a linear FBDD equivalent to ϕ and the size of ROBDD representing ϕ is exponential. Obviously, ϕ does not imply any non-tautology clause without the appearance of yn. By Proposition 6, the size of ROBDD-∞ representing ϕ is exponential. So the conclusion holds. ■\nBy Propositions 4, 5, 7, Proposition 3.1 in [5], and the transitivity of succinctness, we know that: Corollary 1. ROBDD-∞ is strictly less succinct than DNNF and d-DNNF; ROBDD-∞ is incomparable to\nDNF, CNF, IP and PI."
    }, {
      "heading" : "4 The Operations of ROBDD-∞",
      "text" : "We have showed that ROBDD-∞ is the most succinct subset in OBDD-L in the previous section. In order to evaluate the inferential power of this interesting subset, we analyze the operations that ROBDD-∞ supports in polytime with respect to the criterion proposed in the knowledge map in this section. The following queries and transformations have been considered in the knowledge map. We just recall them here and readers are referred to [5] for their importance.\nDefinition 8. Given any subset L of NNF, L satisfies CO (resp. VA) iff there exists a polytime algorithm that maps every formula ϕ from L to 1 if ϕ is consistent (resp. valid), and to 0 otherwise; L satisfies CE iff there exists a polytime algorithm that maps every formula ϕ from L and every clause C to 1\nif ϕ ⇒ C holds, and to 0 otherwise; L satisfies IM iff there exists a polytime algorithm that maps every formula ϕ from L and every term T to 1 if\nT ⇒ ϕ holds, and to 0 otherwise; L satisfies EQ (resp. SE) iff there exists a polytime algorithm that maps every pair of formulas ϕ, γ from L to\n1 if ϕ ⇔ γ (resp. ϕ ⇒ γ) holds, and to 0 otherwise; L satisfies CT iff there exists a polytime algorithm that maps every formula ϕ from L and some the variables\nset X which includes all of the variables appearing in ϕ to a non-negative integer that represents the number of models of ϕ over X (in binary notation).\nL satisfies ME iff there exists a polynomial p(., .) and an algorithm that outputs all models of an arbitrary formula ϕ from L over some the variables set X which includes all of the variables appearing in ϕ in time p(n, m), where n is the size of ϕ and m is the number of its models over X.\nDefinition 9. Given any subset L of NNF, L satisfies CD iff there exists a polytime algorithm that maps every formula ϕ from L and every consistent\nterm T to a formula from L that is logically equivalent to ϕ | T. L satisfies FO iff there exists a polytime algorithm that maps every formula ϕ from L and every subset X of\nthe set of variables appearing in ϕ to a formula from L that is equivalent to ∃X.ϕ, i.e. the formula that does not mention any variable from X and for every formula γ that does not mention any variable from X, we have ϕ ⇒ γ precisely when ∃X.ϕ ⇒ γ. If the property holds for singleton X, we say that L satisfies SFO.\nL satisfies ∧C (resp. ∨C) iff there exists a polytime algorithm that maps every finite set of formulas ϕ1, … , ϕn from L to a formula of L that is logically equivalent to ϕ1 ∧ … ∧ ϕn (resp. ϕ1 ∨ … ∨ ϕn).\nL satisfies ∧BC (resp. ∨BC) iff there exists a polytime algorithm that maps every pair of formulas ϕ and γ from L to a formula of L that is logically equivalent to ϕ ∧ γ (resp. ϕ ∨ γ).\nL satisfies ¬C iff there exists a polytime algorithm that maps every formula ϕ from L to a formula of L that is logically equivalent to ¬ϕ.\nTable 1. The polytime query of ROBDD-∞. √ means “satisfies”, means “does not satisfy unless P = NP”, and ? means “unknown”. o\nL CO VA CE IM EQ SE CT ME ROBDD √ √ √ √ √ √ √ √\nROBDD-∞ √ √ √ √ √ ? √ √ FBDD √ √ √ √ ? o √ √\nd-DNNF √ √ √ √ ? o √ √ Table 1 summarizes query-related properties of ROBDD-∞. As ROBDD, FBDD and d-DNNF are three of the most widely used target languages in practical applications, their properties are also showed here for comparison. Proposition 8. The results in Table 1 hold. Proof. CO, VA and EQ: Recall that for any formula, there is exactly one ROBDD-∞ representing it. This means, in particular, that there is exactly one ROBDD-∞ for the constant formula true (resp. false): the True node with no implied literal (resp. False node). And given two ROBDDs-∞, they are equivalent if and only if they are the same. So we have that: (1) Deciding the satisfiability and validity of a ROBDD-∞ can be done in constant time, it means that CO and VA are satisfied; (2) Deciding the equivalence between two ROBDDs-∞ can be done in polytime, it means that EQ is satisfied.\nCT, CE, IM and ME: Counting the models of a ROBDD-∞ over a set of variables can be done in linear time. An algorithm is presented in Figure 8. A single call of Count can terminal in constant time with the data unit size in implied literals table. With the cache G4, the number of recursive calls is | v |. Then this algorithm has a linear time complexity. Furthermore, we prove that the result of Count(v, X) equals to the number of models of φ(v) over X by induction on the size of | v |. The case | v | = 1 is immediate. Assume that Count(v, X) returns the correct\nresult for | v | ≤ n. When | v | = n + 1, it is obvious that | lo(v) | ≤ n and | hi(v) | ≤ n. According to (*), the number of models of φ(v) equals to the sum of number of models of (∧l ∈ L(v)) ∧ ¬var(v) ∧ φ(lo(v)) and (∧l ∈ L(v)) ∧ var(v) ∧ φ(hi(v)). By the induction hypothesis and Definition 3, and the number of models of (∧l ∈ L(v)) ∧ ¬var(v) ∧ φ(lo(v)) (resp. (∧l ∈ L(v)) ∧ var(v) ∧ φ(hi(v))) equals to Count(lo(v), X) / 2 | L(v) | + 1 (resp. Count(hi(v), X) / 2 | L(v) | + 1). So the induction hypothesis holds. It means that CT is satisfied. In Proposition 9, we will show that ROBDD-∞ satisfies CD. Then by Lemma A.3, A.4 and A.7 in [5], we know that ROBDD-∞ satisfies ME, CE and IM. ■\nWe know that two broad areas in formal verification of hardware are distinguished: checking whether a combinational circuit complies with a given specification; checking whether a circuit's behavior conforms to certain desired properties. The former is a case of equivalence checking, while the latter is mostly a case of clausal entailment. So ROBDD-∞ is potential to be widely used in verification field.\nNote that we just need some fragment information (i.e., the size) of the implied literals in Count and we pre-record them in implied literals table so that we can visit a node of ROBDD-∞ in constant time. The same situation occurs in computing the minimum cardinality [3], which is useful in model-based diagnose, we only need an extra data unit in implied literals table to pre-record the number of negative literals in implied literals set. By Proposition 4, every OBDD-L can be transformed into the corresponding ROBDD-∞ in polytime, and then we have that:\nCorollary 2. OBDD-L satisfies CO, VA, CE, IM, EQ, CT and ME.\nTable 2. The polytime transformations of ROBDD-∞. √ means “satisfies”, means “does not satisfy”, means “does not satisfy unless P = NP”, and ? means “unknown”. •\no\nL CD FO SFO ∧C ∧BC ∨C ∨BC ¬C ROBDD √ • √ • √ • √ √\nROBDD-∞ √ • • • ? • • • FBDD √ • o • o • o √\nd-DNNF √ o o o o o o ? Table 2 summarizes transformation-related properties of ROBDD-∞. Again, Properties of d-DNNF, FBDD and ROBDD are also showed here for comparison. Proposition 9. The results in Table 2 hold. Proof. CD: An algorithm is presented in Figure 9. With the cache G5, this function Condition-sub will terminate in polytime. And we have showed that Add-to-inf can terminate in polytime in the previous section. So the algorithm Condition has a polynomial time complexity. Moreover, we prove that the result of Condition-sub(v, T) is an OBDD-L equivalent to φ(v) | T by induction on the size of | v |. The case | v | = 1 is immediate. Assume that the output of Condition-sub(v, T) is an OBDD-L equivalent to φ(v) | T and VARS(u) ⊆ VARS(v) for | v | ≤ n. When | v | = n + 1, it is obvious that | lo(v) | ≤ n and | hi(v) | ≤ n. By (*) and Definition 6, we have that\n( ) | ( ( )) | (( ( ) | ( ( )) | ) ( ( ) | ( ( )) | )).v T l L v T var v T lo v T var v T hi v Tφ φ φ= ∈ ∧ ¬ ∧ ∨ ∧∧ Line 13 guarantees that at least one child of u is non-False if u is non-terminal. Then by the induction hypothesis and Definition 3, the DAG with the root u is an OBDD-L such that φ(u) ⇔ φ(v) | T and VARS(u) ⊆ VARS(v). Note that L(v) \\ T and L(v) ∩ ¬T ≠ ∅ are needed to be computed just once for the same sets of implied literals set with the use of implied literals table. This means that the implied literals table is helpful for saving the computing time of the logical operations such as conditioning, clausal entailment and so on.\n∨BC, ∨C, SFO and FO: Check the following formula over the variables order x1 < … < xn < y1 < … < yn < z: 1 1(( ) ( ))n nx y x yϕ γ∨ = ↔ ∧ ∧ ↔ ∨L z\nThe ROBDD-∞ corresponding to ϕ with the root v has a linear size and the ROBDD-∞ corresponding to γ only has the node 〈{z}〉. The ROBDD-0 corresponding to ϕ ∨ γ is obviously exponential and ϕ ∨ γ satisfies the condition in Proposition 6, so the size of the corresponding ROBDD-∞ is also exponential. Therefore, there exists no polytime algorithm which can map the ROBDDs-∞ corresponding to ϕ and γ to the ROBDD-∞ corresponding to ϕ ∨ γ. This means that ∨BC cannot be satisfied. Then ∨C also cannot be satisfied. Let var(u) = x, L(u) = ∅, lo(u) = v and hi(u) = 〈{z}〉. Obviously, φ(u) ⇔ (x ∧ ϕ) ∨ (¬x ∧ γ). So there exists no polytime algorithm which can map the ROBDD-∞ with the root u to the ROBDD-∞ corresponding to ∃x.φ(u) because ϕ ∨ γ ⇔ ∃x.((x ∧ ϕ) ∨ (¬x ∧ γ)). This means that SFO cannot be satisfied. Then FO also cannot be satisfied.\n∧C: By Corollary 1, ROBDD-∞ is not at least as succinct as CNF, and then there exists some CNF formula ϕ that cannot be transformed into the corresponding ROBDD-∞ in polytime. Obviously, each clause in ϕ can be transformed into the corresponding ROBDD-∞ in linear time. If ROBDD-∞ satisfies ∧C, then ϕ can be transformed into the corresponding ROBDD-∞ in polytime. This is impossible. So ∧C cannot be satisfied.\n¬C: Here is a counterexample over the variables order x1 < … < xn < y1 < … < yn: 1 1(( ) ( ))n nx y xϕ = ↔ ∧ ∧ ↔L y\nObviously, ¬ϕ satisfies the condition in Proposition 6 and the size of the ROBDD corresponding to it is exponential, so the size of the corresponding ROBDD-∞ is also exponential. However, the size of the ROBDD-∞ corresponding to ϕ is linear. So there exists no polytime algorithm which can map the ROBDD-∞ corresponding to ϕ to the ROBDD-∞ corresponding to ¬ϕ. This means that ¬C cannot be satisfied. ■\nWe close this section by a detailed theoretical comparison between ROBDD, ROBDD-∞, FBDD and d-DNNF. ROBDD and ROBDD-∞ have the uniqueness over a specific variables order, while neither FBDD nor d-DNNF has this property. ROBDD-∞ is strictly more succinct than ROBDD, but it is strictly less succinct than FBDD, which is strictly less succinct than d-DNNF. From Table 1, ROBDD satisfies SE which ROBDD-∞ does not satisfy, while ROBDD-∞ satisfies EQ which neither FBDD nor d-DNNF satisfies. In the future, practical applications might need some other class of queries (i.e., not involved in the knowledge compilation map) such that ROBDD can answer them in polytime, while none of ROBDD-∞, FBDD and d-DNNF can, or both ROBDD and ROBDD-∞ can answer them in polytime, while neither FBDD nor d-DNNF can, or only d-DNNF cannot. From Table 2, it seems that both d-DNNF and ROBDD-∞ have some problems for the transformations, while FBDD is a bit better than them. Fortunately, the transformations usually are completed in the off-line phase.\n5 Compiling Propositional Theory into ROBDD-i\nIn this section we present two compilation algorithms about ROBDD-i (0 ≤ i ≤ ∞). We focus on top-down compilation algorithms rather than bottom-up ones for the reasons that: we do not know whether ROBDD-∞ satisfies ∧BC or not; a well-known problem with the bottom-up methods is that the intermediate results that arise in the process can grow so large as to make further manipulation impossible, even when the final result would have a tractable size [20] (in the extreme case when the knowledge base is unsatisfiable, the final compilation result of ROBDD-i will has only one node, but the intermediate results may be satisfiable and have many nodes). First, we propose a compilation algorithm called Build for ROBDD-i (0 ≤ i ≤ ∞). Then we optimize it by the use of\nsome specific models of propositional theory and devise another algorithm called Build-inf for ROBDD-∞. Finally, we introduce some techniques which are potential to improve the performance of Build and Build-inf when the input is in CNF."
    }, {
      "heading" : "5.1 Compilation Algorithm",
      "text" : "The compilation algorithm Build is presented in Figure 10. Its correctness is guaranteed by the following proposition.\nProposition 10. Given any propositional formula ϕ, Build(ϕ, i) can terminate in finite time and its output is the corresponding ROBDD-i.\nProof. Let X be the set of variables appearing in ϕ. We prove the proposition by induction on the size of | X |. Assume that Build(ϕ, i) can terminate in finite time and its output is the ROBDD-i corresponding to ϕ with the root v such that VARS(v) ⊆ X if | X | ≤ n. The case | X | = 0 is immediate. When | X | = n + 1, we proceed by case analysis:\nϕ is unsatisfiable: The conclusion is obvious. ϕ is equivalent to true after Line 9: The conclusion is obvious. Otherwise: After Line 9, let X1 and X2 be the set of variables appearing in ϕ | ¬xj and ϕ | xj, respectively. By the induction hypothesis, Build(ϕ | ¬xj, i) (resp. Build(ϕ | xj, i)) can terminate in finite time and its output is the ROBDD-i corresponding to ϕ | ¬xj (resp. ϕ | xj) such that VARS(lo(v)) ⊆ X1 (resp. VARS(hi(v)) ⊆ X2). Then Build(ϕj, i) can terminate in finite time, VARS(v) ⊆ X, the conditions in Definition 1 and Definition 3 are satisfied. Lines 4-8 guarantee the condition in Definition 5. The loop on Lines 10-16 guarantees that ϕ | ¬xj is not equivalent to ϕ | xj. By Proposition 2, lo(v) is not identical to hi(v). The call of MK guarantees the condition 1 in Definition 4. And the loop must terminate at some j, otherwise the condition on Line 17 will be satisfied, which corresponds to the case that ϕ is equivalent to true after Line 9. Then the output of Build(ϕ, X, i) is the ROBDD-i corresponding to ϕ. ■\nIt is pointed out that Line 11 in the algorithm Build is not needed any more if i = 0 or ∞, and we just need to call the algorithm Reduce to turn the result into ROBDD or ROBDD-∞. Particularly, we do not even need to Line 1 and Lines 4-9 if i = 0, then Build is equivalent to Algorithm 5 in [20] when the input is in CNF. We can displace the algorithm Build with the algorithm Build-inf in Figure 11 if i = ∞. In the algorithm Build-inf, Decide(ϕ) will return a model of ϕ if it is satisfiable, otherwise the empty set will be returned. It is trivial to prove that it is correct to use the function Get-imps to compute all literals implied by ϕ.\nObviously, by using Get-imps, we can significantly reduce the number of calling the function Decide. In fact, the efficiency of the algorithm is heavily dependent on the calling number and efficiency of Decide. So Get-imps is helpful for improving the efficiency. It is pointed out that we can limit the literals in C to the ones appearing in ϕ on Line 2 if ϕ is in NNF because a NNF formula can only imply the literals appearing it. By some proof analogous to the one of Proposition 10, the algorithm Build-inf is correct:\nProposition 11. Given any propositional formula ϕ, Build-inf(ϕ) can terminate in finite time and its output is the corresponding ROBDD-∞."
    }, {
      "heading" : "5.2 Some Techniques to Improve the Performance of Build-inf",
      "text" : "The algorithm Build-inf in Figure 11 is adapted to any propositional formula. However, knowledge base often is represented as a CNF formula as human can read and write it with ease. Here are some techniques which are potential to improve the performance of Build and Build-inf to compile a CNF formula: (1) aims at reducing the number of calling the function Decide, (2) is used to reduce the time of such calling, and the purpose of (3) is to reduce the number of recursive calling of Build-inf-sub.\n(1) Horn lower approximation As previously pointed out, the efficiency of the algorithm is heavily dependent on the calling number of\nDecide. Given a CNF formula ϕ, a Horn lower approximation is a Horn theory implying ϕ, so ϕ implies a literal only if any Horn lower approximation of ϕ implies it. And it is well known that all implied literals of Horn theory can be computed in polytime. We exploit these properties to reduce the number of calling Decide, i.e., the function Get-imps will be displaced by the function Get-imps-CNF in Figure 12. We give an example to show how Get-imps-CNF works.\nExample 2. Let ϕ = {x1 ∨ x3, ¬x2 ∨ x3, ¬x1 ∨ ¬x4, x3 ∨ x4} and Ω = ∅. C = {x1, ¬x1, x2, ¬x2, x3, ¬x3, x4, ¬x4} after running Line 11. Obviously, ϕ does not imply x1. Assume that Decide(ϕ ∪ {¬x1}) on Line 14 returns a model M = {¬x1, ¬x2, x3, ¬x4}. Then Horn-app(ϕ, M) generates a Horn lower approximation ϕ′ = {x3, ¬x2 ∨ x3, ¬x1 ∨ ¬x4}. ϕ′ only implies x3. After running Line 17, C = {x3}. Then we find that ϕ also implies x3. Note that we only need to employ SAT solver twice here, while solver will be called at least 3 up to 5 times in Get-imps (dependent on the models obtained by solver).\nIn fact, a model M of ϕ is also a Horn lower approximation (each literal in M can be seen as a unit Horn clause). However, the approximation generated by Horn-app(ϕ, M) is obviously greater than M, i.e., M ⇒ Horn-app(ϕ, M), for example, the Horn approximation in Example 2 have 6 models. The idea of Horn theory approximation in [1] is generating a greatest lower bound (GLB). However, [21] showed that this problem is at least NP[ (log )]p O n -hard. It seems that generating a GLB is not desirable in Build-inf.\n(2) Employing high-performance SAT solver We know that we need to employ SAT solver on Lines 1, 5, 6 and 11 in Build. Despite that Build-inf can avoid many times of such employment, efficiency of SAT solver still significantly affect the efficiency of Build-inf (we can see it in Section 6). Fortunately, there exist many efficient complete SAT solvers so far, such as MiniSAT [22], PrecoSAT [23], CryptoMiniSat [24] and so on. All these modern complete SAT solvers are based on the classic DPLL procedure [25], which employs a systematic search to find a model of the inputting CNF formula. In fact, it has been showed that DPLL procedure is closely related to knowledge compilation. For example, [26] proposed an algorithm to exploit DPLL search to generate Horn GLB; [20] proposed a new method to map different versions of exhaustive DPLL search to different compilation languages as ROBDD, FBDD, and d-DNNF, [12] extended this idea to map another version of systematic search to EPCCL theory.\nResearch in recent years has greatly improved the efficiency and scalability of systematic search methods. Techniques contributing to this improvement include two-literal watch scheme for fast BCP, clause learning by conflict analysis, dependency directed backtracking, new variable ordering heuristics, timely restarts, and so on [20, 22-24]. We emphasize that that clause learning by conflict analysis is very useful here as we always perform DPLL search on the same CNF formula (i.e. knowledge base) only under different initial partial assignments1, which leads to that learnt clauses can be inherited by other DPLL searches.\n(3) CNF caching In order to save the compiling time, the function Build-inf-sub will be trying to not compiling the same CNF formula twice, we exploit the CNF caching scheme introduced in [27] to do this. Assume the knowledge base needed to be compiled is ϕ0 = C1 ∧ … ∧ Cn. We know that each input ϕ of Build-inf-sub comes from conditioning ϕ0 on a partial assignment A. Given any two inputs ϕ = ϕ0 | A and ϕ′ = ϕ0 | A′, ϕ ⇔ ϕ′ if the following conditions hold: the variables appearing in A and A′ are the same; let bv be a vector with n bit, bv(i) = 1 if Ci shares some literal with A, otherwise bv(i) = 0, bv′ is generated from A′ in the same way, bv equals to bv′. For example, let ϕ = (x1 ∨ ¬x2) ∧ (¬x1 ∨ x2) ∧ (x3 ∨ ¬x4), we know that ϕ | x1 ∧ x2 is equivalent to ϕ | ¬x1 ∧ ¬x2 by this scheme."
    }, {
      "heading" : "5.3 Transforming ROBDD-∞ into ROBDD",
      "text" : "As pointed out previously, the algorithm Build can be turned into Algorithm 5 in [20] when the input is in CNF. However, the experimental results in [20] show that the efficiency of Algorithm 5 is needed to be further improved. In this subsection, we present an alternative ⎯ we show that any ROBDD-∞ can be transformed into the equivalent ROBDD using the algorithm Inf2ROBDD in Figure 13. And we will see that this approach outperforms Algorithm 5 in [20] in the next section. Note that on Line 10, we just need to displace the node 〈∅〉 in the ROBDD whose root is u2 with u1 to get the conjunct since any variable in VARS(u2) is less than the one in VARS(u1).\nProposition 12. Given any ROBDD-∞ with the root v, Inf2ROBDD(v) can terminate in finite time and its output is the corresponding ROBDD.\nProof. It is trivial to prove by induction that the output of Inf2R-sub(v, T) is the ROBDD corresponding to φ(v) ∧ T, where VARS(v) and T do not share any variable with each other. Then this proposition holds. ■\n1 Both Build-inf and DPLL procedure are implemented iteratively."
    }, {
      "heading" : "6 Preliminary Experimental Results",
      "text" : "In this section, we report some experimental results about our ROBDD-L package BDDjLu. In BDDjLu, any CNF formula can be compiled into ROBDD-i (0 ≤ i < ∞) by the algorithm Build or ROBDD-∞ by the algorithm Build-inf, and all the operations supported by ROBDD-∞ in polytime are included. BDDjLu also contains the algorithms Inf2ROBDD and Inf2FBDD. As pointed out previously, in Build and Build-inf, SAT solver will be employed to decide whether a CNF formula is satisfiable or not, get the implied literals in a CNF formula, decide whether the variables can be omitted in CNF formula. So we also implement a DPLL-based SAT solver based on the one used in [13, 28], in which we exploit some techniques including two-literal watch scheme for fast BCP, clause learning by conflict analysis, dependency directed backtracking, variable ordering heuristics VSIDS.\nWe compare BDDjLu against a d-DNNF compiler called c2d2 [26]. ROBDD-∞, FBDD and ROBDD are generated by Build-inf, Inf2FBDD and Inf2ROBDD, respectively. It seems that a ROBDD compiler and a FBDD compiler were implemented by Huang and Darwiche in [20]. But we cannot find them on the Internet. We also contacted Huang and Darwiche to get these two compilers, unfortunately they did not reply. The directives -reduce and -dt-method 4 (i.e., min-fill heuristic for constructing d-trees) are used in c2d. -reduce is helpful to generate a smaller d-DNNF and -dt-method 4 seems to work best on a broad set of benchmarks3. In our experiments, the variables are denoted by their indices (i.e. some natural numbers) and xj < xk iff j < k. All experiments are conducted on a computer with a 2.79 GHz CPU and 512 MB of RAM. The timeout for each problem is set to 1000 seconds.\nWe test BDDjLu and c2d on some benchmarks from SATLIB4 and the experimental results are showed in Table 3, where problem types (#vars, #cls and #models indicate the number of variables, clauses and models of corresponding instance, respectively), compilation output sizes of d-DNNF, ROBDD-∞, FBDD and ROBDD (#nodes and #edges indicate the number of nodes and edges, respectively), individual compiling time5 (- indicates timeout or memory overflow) and the time cost of employing SAT solver in Build-inf (sat indicates it) are reported.\n2 http://reasoning.cs.ucla.edu/c2d/ 3 Knot Pipatsrisawat, a past member in the Automated Reasoning group at UCLA, said these in the private communication between us. 4 http://people.cs.ubc.ca/~hoos/SATLIB/benchm.html 5 For FBDD (resp. ROBDD), it is the sum of the time cost of Build-inf and Inf2FBDD (resp. Inf2ROBDD).\nThe results in Table 3 show that the compilation quality of BDDjLu for ROBDD-∞ is higher than c2d for CBS_k3_n100_m403_*, par8-2-c, par15-2-c, uf200-01, uf200-02 and sat-grid-pbl-0015. And c2d is more high-quality for flat200-2, flat200-3 and uf200-03. c2d cannot compile hole10, while BDDjLu cannot compile flat200-1 and sat-grid-pbl-0020 6 . Neither c2d nor BDDjLu can compile par32-2-c and sat-grid-pbl-0025. Compared with the experimental results in [20], the FBDD generated by Inf2FBDD is obviously smaller for flat200-* and uf200-*. For all instances that can be compiled into ROBDD-∞, the size of ROBDD-∞ is obviously small than FBDD, while the size of FBDD is obviously smaller than ROBDD except sat-grid-pbl-0015. These validate the assertion in Section 3. Turning to running time, BDDjLu for ROBDD-∞ is faster than c2d except flat200-1 and sat-grid-pbl-*7. flat200-2, flat200-3 and uf200-* can be compiled by transforming the corresponding ROBDD-∞ into ROBDD now, while the ROBDD compiler reported in [20] cannot compile them in 900s with a 2.4 GHz CPU and 4 GB RAM.\nOverall, the ROBDD-∞ is obviously smaller than the ROBDD for each instance. The algorithm Build-inf in BDDjLu is more high-quality than c2d for the benchmark corresponding to small ROBDD-∞, and it is faster for most of problems when c2d uses min-fill heuristic to construct d-trees. Compared with the compilers reported in [20], it seems that Inf2FBDD and Inf2ROBDD are two good alternatives to compile CNF formulas into FBDDs and ROBDDs, respectively. As the time cost of employing SAT solver in Build-inf plays a very important role in the total running time of generating ROBDD-∞, we shall straight embed some highly efficient modern SAT solver into BDDjLu. In addition, we shall design good variables order rather than current simple order in BDDjLu to generate more space-efficient compilation results in future.\nFinally, we note that, in comparison with d-DNNF, FBDD and ROBDD, we need a little additional processing on the implied literals of ROBDD-∞ in the querying. Fortunately, on the one hand, some operations (e.g., model counting, computing the minimum cardinality) only need some fragment information about implied literals, therefore, we can visit any node of ROBDD-∞ in constant time; on the other hand, we can reduce the number of processing for other operations with the use of implied literals table."
    }, {
      "heading" : "7 Conclusions",
      "text" : "In this paper, we introduce a new compilation approach ROBDD-L by associating some implied literals in each node of ROBDD. Then an interesting kind of subsets of ROBDD-L is discussed: given a number i, we call the corresponding subset ROBDD-i, which requires that all of its nodes should be precisely associated by i implied literals. In particular, the ROBDD-0 whose nodes have no implied literal is isomorphic to ROBDD; the ROBDD-∞ requires that every node should be associated by the implied literals as many as possible. Given a number i and a Boolean formula, we show that there is exactly one ROBDD-i representing it over a specific variables order.\nFurthermore, we show that every sentence of OBDD-L can be transformed into an equivalent sentence of ROBDD-∞ in polytime. This means that ROBDD-∞ is the most succinct subset of OBDD-L. Particularly, ROBDD-∞ is strictly more succinct than ROBDD. Compared with FBDD and d-DNNF, ROBDD-∞ is strictly less succinct. And we propose the algorithm Inf2FBDD which can transform any ROBDD-∞ into FBDD. In order to evaluate the inferential power of this interesting subset, we compare it with ROBDD, FBDD and d-DNNF by the operations that can be supported in polytime with respect to the knowledge compilation map. For the queries, ROBDD satisfies SE which ROBDD-∞ does not satisfy, while ROBDD-∞ satisfies EQ which FBDD and d-DNNF does not satisfy. For the transformations, ROBDD satisfies CD, SFO, ∧BC, ∨BC and ¬C, both ROBDD-∞ and d-DNNF only satisfy CD, and FBDD satisfies CD and ¬C.\nFinally, we propose the compilation algorithm Build which can compile any Boolean formula into a ROBDD-i for any i. Based on it, we propose the ROBDD-∞ compilation algorithm Build-inf and discuss three optimization techniques. In addition, we show that every ROBDD-∞ can be transformed into ROBDD by proposing the algorithm Inf2ROBDD. Combining Build, Build-inf, Inf2FBDD, Inf2ROBDD and all the operations supported by ROBDD-L in polytime, we devise the ROBDD-L package BDDjLu and test it on some benchmarks from SATLIB. Preliminary experimental results show that: for the same instance, ROBDD-∞ is obviously smaller than ROBDD; Build-inf in BDDjLu is more high-quality than c2d for the benchmarks corresponding to small compilation results, and it is faster for most of problems when c2d uses min-fill heuristic to construct d-trees; it seems that it is better to transform the ROBDD-∞ into FBDD and ROBDD using Inf2FBDD and Inf2ROBDD. And both efficiency and compilation quality of BDDjLu have potential to be improved by embedding a modern SAT solver and devising a better variables order.\nAcknowledgements We thank Professor Bart Selman for the suggestions about this paper. We also thank Dr. Knot Pipatsrisawat for the useful information about c2d provided by him. Finally, we thank the anonymous referees for their review of this paper. Our work is supported by the NNSF of China grant 60873149 and 60973088."
    } ],
    "references" : [ {
      "title" : "Knowledge compilation and theory approximation",
      "author" : [ "B. Selman", "H. Kautz" ],
      "venue" : "Journal of the Association for Computing Machinery,",
      "citeRegEx" : "1",
      "shortCiteRegEx" : "1",
      "year" : 1996
    }, {
      "title" : "A survey on knowledge compilation",
      "author" : [ "M. Cadoli", "F. Donini" ],
      "venue" : "AI Communications,",
      "citeRegEx" : "2",
      "shortCiteRegEx" : "2",
      "year" : 1997
    }, {
      "title" : "Decomposable negation normal form",
      "author" : [ "A. Darwiche" ],
      "venue" : "Journal of the Association for Computing Machinery,",
      "citeRegEx" : "3",
      "shortCiteRegEx" : "3",
      "year" : 2001
    }, {
      "title" : "Knowledge Compilation Using Extension Rule",
      "author" : [ "H. Lin", "J.G. Sun" ],
      "venue" : "Journal of Automated Reasoning,",
      "citeRegEx" : "4",
      "shortCiteRegEx" : "4",
      "year" : 2004
    }, {
      "title" : "A knowledge compilation map",
      "author" : [ "A. Darwiche", "P. Marquis" ],
      "venue" : "Journal of Artificial Intelligence Research,",
      "citeRegEx" : "5",
      "shortCiteRegEx" : "5",
      "year" : 2002
    }, {
      "title" : "Compilation for critically constrained knowledge bases",
      "author" : [ "R. Schrag" ],
      "venue" : "Proceedings of the Thirteenth National Conference on Artificial Intelligence,",
      "citeRegEx" : "6",
      "shortCiteRegEx" : "6",
      "year" : 1996
    }, {
      "title" : "Knowledge compilation using theory prime implicates",
      "author" : [ "P. Marquis" ],
      "venue" : "Proceedings of the Fourteenth International Joint Conference on Artificial Intelligence,",
      "citeRegEx" : "7",
      "shortCiteRegEx" : "7",
      "year" : 1995
    }, {
      "title" : "Graph-based algorithms for Boolean function manipulation",
      "author" : [ "R. Bryant" ],
      "venue" : "IEEE Transactions on Computers,",
      "citeRegEx" : "8",
      "shortCiteRegEx" : "8",
      "year" : 1986
    }, {
      "title" : "An introduction to binary decision diagrams",
      "author" : [ "H. Andersen" ],
      "venue" : null,
      "citeRegEx" : "9",
      "shortCiteRegEx" : "9",
      "year" : 1998
    }, {
      "title" : "Efficient analysis and manipulation of OBDDs can be extended to FBDDs",
      "author" : [ "J. Gergov", "C. Meinel" ],
      "venue" : "IEEE Transactions on Computers,",
      "citeRegEx" : "10",
      "shortCiteRegEx" : "10",
      "year" : 1994
    }, {
      "title" : "On the tractability of counting theory models and its application to truth maintenance and belief revision",
      "author" : [ "A. Darwiche" ],
      "venue" : "Journal of Applied Non-Classical Logics,",
      "citeRegEx" : "11",
      "shortCiteRegEx" : "11",
      "year" : 2001
    }, {
      "title" : "New compilation languages based on structured decomposability",
      "author" : [ "K. Pipatsrisawat", "A. Darwiche" ],
      "venue" : "Proceedings of the Twenty-Third AAAI Conference on Artificial Intelligence,",
      "citeRegEx" : "12",
      "shortCiteRegEx" : "12",
      "year" : 2008
    }, {
      "title" : "Extending the knowledge compilation map: Krom, Horn, Affine and Beyond",
      "author" : [ "H. Fargier", "P. Marquis" ],
      "venue" : "Proc. of AAAI'08, Menlo Park: AAAI press,",
      "citeRegEx" : "14",
      "shortCiteRegEx" : "14",
      "year" : 2008
    }, {
      "title" : "Extending the knowledge compilation map: Closure principles",
      "author" : [ "H. Fargier", "P Marquis" ],
      "venue" : "Proceedings of the 18th European Conference on Artificial Intelligence, Amsterdam: IOS press,",
      "citeRegEx" : "15",
      "shortCiteRegEx" : "15",
      "year" : 2008
    }, {
      "title" : "Model Checking",
      "author" : [ "E. Clarke", "O. Grumberg", "D. Peled" ],
      "venue" : null,
      "citeRegEx" : "16",
      "shortCiteRegEx" : "16",
      "year" : 2000
    }, {
      "title" : "Conformant planning via symbolic model checking",
      "author" : [ "A. Cimatti", "M. Roveri" ],
      "venue" : "Journal of Artificial Intelligence Research,",
      "citeRegEx" : "17",
      "shortCiteRegEx" : "17",
      "year" : 2000
    }, {
      "title" : "Terminological reasoning in SHIQ with ordered binary decision diagrams",
      "author" : [ "S. Rudolph", "M. Krötzsch", "P. Hitzler" ],
      "venue" : "Proceedings of the Twenty-Third AAAI Conference on Artificial Intelligence,",
      "citeRegEx" : "18",
      "shortCiteRegEx" : "18",
      "year" : 2008
    }, {
      "title" : "Evaluating abductive hypotheses using an EM algorithm on BDDs",
      "author" : [ "K. Inoue", "T. Sato", "M. Ishihata", "Y. Kameya", "H. Nabeshima" ],
      "venue" : "Proceedings of the Twenty-First International Joint Conference on Artificial Intelligence,",
      "citeRegEx" : "19",
      "shortCiteRegEx" : "19",
      "year" : 2009
    }, {
      "title" : "The language of search",
      "author" : [ "J. Huang", "A. Darwiche" ],
      "venue" : "Journal of Artificial Intelligence Research,",
      "citeRegEx" : "20",
      "shortCiteRegEx" : "20",
      "year" : 2007
    }, {
      "title" : "Semantical and computational aspects of Horn approximations",
      "author" : [ "M. Cadoli", "F. Scarcello" ],
      "venue" : "Artificial Intelligence,",
      "citeRegEx" : "21",
      "shortCiteRegEx" : "21",
      "year" : 2000
    }, {
      "title" : "An Extensible SAT-solver",
      "author" : [ "N. Eén", "N. Sörensson" ],
      "venue" : "Proceedings of 6th International Conference on Theory and Applications of Satisfiability Testing,",
      "citeRegEx" : "22",
      "shortCiteRegEx" : "22",
      "year" : 2003
    }, {
      "title" : "Lingeling, Plingeling, PicoSAT and PrecoSAT at SAT Race",
      "author" : [ "A. Biere" ],
      "venue" : "Technical Report",
      "citeRegEx" : "23",
      "shortCiteRegEx" : "23",
      "year" : 2010
    }, {
      "title" : "Extending SAT Solvers to Cryptographic Problems",
      "author" : [ "M. Soos", "K. Nohl", "C. Castelluccia" ],
      "venue" : "Proceedings of 12th International Conference on Theory and Applications of Satisfiability Testing,",
      "citeRegEx" : "24",
      "shortCiteRegEx" : "24",
      "year" : 2009
    }, {
      "title" : "A computing procedure for quantification theory",
      "author" : [ "M. Davis", "H. Putnam" ],
      "venue" : "Journal of the Association for Computing Machinery,",
      "citeRegEx" : "25",
      "shortCiteRegEx" : "25",
      "year" : 1960
    }, {
      "title" : "Algorithms for propositional KB approximation",
      "author" : [ "Y. Boufkhad" ],
      "venue" : "Proceedings of the Fifteenth AAAI Conference on Artificial Intelligence,",
      "citeRegEx" : "26",
      "shortCiteRegEx" : "26",
      "year" : 1998
    }, {
      "title" : "New advances in compiling CNF to decomposable negation normal form",
      "author" : [ "A. Darwiche" ],
      "venue" : "Proceedings of Sixteenth European Conference on Artificial Intelligence,",
      "citeRegEx" : "27",
      "shortCiteRegEx" : "27",
      "year" : 2004
    }, {
      "title" : "Model counting and planning using extension rule",
      "author" : [ "Y. Lai", "D. Ouyang", "D. Cai", "S. Lu" ],
      "venue" : "Journal of Computer Research and Development,",
      "citeRegEx" : "28",
      "shortCiteRegEx" : "28",
      "year" : 2009
    } ],
    "referenceMentions" : [ {
      "referenceID" : 0,
      "context" : "Reasoning problems in their general form are intractable and knowledge compilation has been emerging as a key direction of research for dealing with such kind of intractability [1-5].",
      "startOffset" : 177,
      "endOffset" : 182
    }, {
      "referenceID" : 1,
      "context" : "Reasoning problems in their general form are intractable and knowledge compilation has been emerging as a key direction of research for dealing with such kind of intractability [1-5].",
      "startOffset" : 177,
      "endOffset" : 182
    }, {
      "referenceID" : 2,
      "context" : "Reasoning problems in their general form are intractable and knowledge compilation has been emerging as a key direction of research for dealing with such kind of intractability [1-5].",
      "startOffset" : 177,
      "endOffset" : 182
    }, {
      "referenceID" : 3,
      "context" : "Reasoning problems in their general form are intractable and knowledge compilation has been emerging as a key direction of research for dealing with such kind of intractability [1-5].",
      "startOffset" : 177,
      "endOffset" : 182
    }, {
      "referenceID" : 4,
      "context" : "Reasoning problems in their general form are intractable and knowledge compilation has been emerging as a key direction of research for dealing with such kind of intractability [1-5].",
      "startOffset" : 177,
      "endOffset" : 182
    }, {
      "referenceID" : 0,
      "context" : "There have existed dozens of target languages so far, such as Horn theories [1], prime implicates/implicants [6, 7], reduced ordered binary decision diagram (ROBDD) [8, 9], free binary decision diagram (FBDD) [5, 10], decomposable negation normal form (DNNF, three subsets d-DNNF, DNNFT and d-DNNFT) [3, 11, 12], EPCCL theory [4, 13] and so on.",
      "startOffset" : 76,
      "endOffset" : 79
    }, {
      "referenceID" : 5,
      "context" : "There have existed dozens of target languages so far, such as Horn theories [1], prime implicates/implicants [6, 7], reduced ordered binary decision diagram (ROBDD) [8, 9], free binary decision diagram (FBDD) [5, 10], decomposable negation normal form (DNNF, three subsets d-DNNF, DNNFT and d-DNNFT) [3, 11, 12], EPCCL theory [4, 13] and so on.",
      "startOffset" : 109,
      "endOffset" : 115
    }, {
      "referenceID" : 6,
      "context" : "There have existed dozens of target languages so far, such as Horn theories [1], prime implicates/implicants [6, 7], reduced ordered binary decision diagram (ROBDD) [8, 9], free binary decision diagram (FBDD) [5, 10], decomposable negation normal form (DNNF, three subsets d-DNNF, DNNFT and d-DNNFT) [3, 11, 12], EPCCL theory [4, 13] and so on.",
      "startOffset" : 109,
      "endOffset" : 115
    }, {
      "referenceID" : 7,
      "context" : "There have existed dozens of target languages so far, such as Horn theories [1], prime implicates/implicants [6, 7], reduced ordered binary decision diagram (ROBDD) [8, 9], free binary decision diagram (FBDD) [5, 10], decomposable negation normal form (DNNF, three subsets d-DNNF, DNNFT and d-DNNFT) [3, 11, 12], EPCCL theory [4, 13] and so on.",
      "startOffset" : 165,
      "endOffset" : 171
    }, {
      "referenceID" : 8,
      "context" : "There have existed dozens of target languages so far, such as Horn theories [1], prime implicates/implicants [6, 7], reduced ordered binary decision diagram (ROBDD) [8, 9], free binary decision diagram (FBDD) [5, 10], decomposable negation normal form (DNNF, three subsets d-DNNF, DNNFT and d-DNNFT) [3, 11, 12], EPCCL theory [4, 13] and so on.",
      "startOffset" : 165,
      "endOffset" : 171
    }, {
      "referenceID" : 4,
      "context" : "There have existed dozens of target languages so far, such as Horn theories [1], prime implicates/implicants [6, 7], reduced ordered binary decision diagram (ROBDD) [8, 9], free binary decision diagram (FBDD) [5, 10], decomposable negation normal form (DNNF, three subsets d-DNNF, DNNFT and d-DNNFT) [3, 11, 12], EPCCL theory [4, 13] and so on.",
      "startOffset" : 209,
      "endOffset" : 216
    }, {
      "referenceID" : 9,
      "context" : "There have existed dozens of target languages so far, such as Horn theories [1], prime implicates/implicants [6, 7], reduced ordered binary decision diagram (ROBDD) [8, 9], free binary decision diagram (FBDD) [5, 10], decomposable negation normal form (DNNF, three subsets d-DNNF, DNNFT and d-DNNFT) [3, 11, 12], EPCCL theory [4, 13] and so on.",
      "startOffset" : 209,
      "endOffset" : 216
    }, {
      "referenceID" : 2,
      "context" : "There have existed dozens of target languages so far, such as Horn theories [1], prime implicates/implicants [6, 7], reduced ordered binary decision diagram (ROBDD) [8, 9], free binary decision diagram (FBDD) [5, 10], decomposable negation normal form (DNNF, three subsets d-DNNF, DNNFT and d-DNNFT) [3, 11, 12], EPCCL theory [4, 13] and so on.",
      "startOffset" : 300,
      "endOffset" : 311
    }, {
      "referenceID" : 10,
      "context" : "There have existed dozens of target languages so far, such as Horn theories [1], prime implicates/implicants [6, 7], reduced ordered binary decision diagram (ROBDD) [8, 9], free binary decision diagram (FBDD) [5, 10], decomposable negation normal form (DNNF, three subsets d-DNNF, DNNFT and d-DNNFT) [3, 11, 12], EPCCL theory [4, 13] and so on.",
      "startOffset" : 300,
      "endOffset" : 311
    }, {
      "referenceID" : 11,
      "context" : "There have existed dozens of target languages so far, such as Horn theories [1], prime implicates/implicants [6, 7], reduced ordered binary decision diagram (ROBDD) [8, 9], free binary decision diagram (FBDD) [5, 10], decomposable negation normal form (DNNF, three subsets d-DNNF, DNNFT and d-DNNFT) [3, 11, 12], EPCCL theory [4, 13] and so on.",
      "startOffset" : 300,
      "endOffset" : 311
    }, {
      "referenceID" : 3,
      "context" : "There have existed dozens of target languages so far, such as Horn theories [1], prime implicates/implicants [6, 7], reduced ordered binary decision diagram (ROBDD) [8, 9], free binary decision diagram (FBDD) [5, 10], decomposable negation normal form (DNNF, three subsets d-DNNF, DNNFT and d-DNNFT) [3, 11, 12], EPCCL theory [4, 13] and so on.",
      "startOffset" : 326,
      "endOffset" : 333
    }, {
      "referenceID" : 4,
      "context" : "Darwiche and Marquis argue that the choice of a target language must be based on two key aspects: the succinctness of the target compilation language, and the class of queries and transformations that the language supports in polytime [5].",
      "startOffset" : 235,
      "endOffset" : 238
    }, {
      "referenceID" : 11,
      "context" : "On this basis, some researchers extend the knowledge compilation map [12, 14, 15].",
      "startOffset" : 69,
      "endOffset" : 81
    }, {
      "referenceID" : 12,
      "context" : "On this basis, some researchers extend the knowledge compilation map [12, 14, 15].",
      "startOffset" : 69,
      "endOffset" : 81
    }, {
      "referenceID" : 13,
      "context" : "On this basis, some researchers extend the knowledge compilation map [12, 14, 15].",
      "startOffset" : 69,
      "endOffset" : 81
    }, {
      "referenceID" : 4,
      "context" : "ROBDD is one of the most tractable target languages which satisfy all of querying requirements involved in the knowledge compilation map (as far as we know, the compilation languages meeting these requirements include ROBDD, MODS, d-DNNFT and EPCCL theory [5, 12, 13]) and has been quite influential in many communities such as model checking [16], AI planning [17], abductive inference [18], terminological reasoning in description logic SHIQ [19] and so on.",
      "startOffset" : 256,
      "endOffset" : 267
    }, {
      "referenceID" : 11,
      "context" : "ROBDD is one of the most tractable target languages which satisfy all of querying requirements involved in the knowledge compilation map (as far as we know, the compilation languages meeting these requirements include ROBDD, MODS, d-DNNFT and EPCCL theory [5, 12, 13]) and has been quite influential in many communities such as model checking [16], AI planning [17], abductive inference [18], terminological reasoning in description logic SHIQ [19] and so on.",
      "startOffset" : 256,
      "endOffset" : 267
    }, {
      "referenceID" : 14,
      "context" : "ROBDD is one of the most tractable target languages which satisfy all of querying requirements involved in the knowledge compilation map (as far as we know, the compilation languages meeting these requirements include ROBDD, MODS, d-DNNFT and EPCCL theory [5, 12, 13]) and has been quite influential in many communities such as model checking [16], AI planning [17], abductive inference [18], terminological reasoning in description logic SHIQ [19] and so on.",
      "startOffset" : 343,
      "endOffset" : 347
    }, {
      "referenceID" : 15,
      "context" : "ROBDD is one of the most tractable target languages which satisfy all of querying requirements involved in the knowledge compilation map (as far as we know, the compilation languages meeting these requirements include ROBDD, MODS, d-DNNFT and EPCCL theory [5, 12, 13]) and has been quite influential in many communities such as model checking [16], AI planning [17], abductive inference [18], terminological reasoning in description logic SHIQ [19] and so on.",
      "startOffset" : 361,
      "endOffset" : 365
    }, {
      "referenceID" : 16,
      "context" : "ROBDD is one of the most tractable target languages which satisfy all of querying requirements involved in the knowledge compilation map (as far as we know, the compilation languages meeting these requirements include ROBDD, MODS, d-DNNFT and EPCCL theory [5, 12, 13]) and has been quite influential in many communities such as model checking [16], AI planning [17], abductive inference [18], terminological reasoning in description logic SHIQ [19] and so on.",
      "startOffset" : 387,
      "endOffset" : 391
    }, {
      "referenceID" : 17,
      "context" : "ROBDD is one of the most tractable target languages which satisfy all of querying requirements involved in the knowledge compilation map (as far as we know, the compilation languages meeting these requirements include ROBDD, MODS, d-DNNFT and EPCCL theory [5, 12, 13]) and has been quite influential in many communities such as model checking [16], AI planning [17], abductive inference [18], terminological reasoning in description logic SHIQ [19] and so on.",
      "startOffset" : 444,
      "endOffset" : 448
    }, {
      "referenceID" : 2,
      "context" : "A practical representation of NNF formula [3, 5] is a rooted, directed acyclic graph (DAG) where each leaf node is labeled with true, false or a literal; and each internal node is labeled with ∧ or ∨ and can have arbitrarily many children.",
      "startOffset" : 42,
      "endOffset" : 48
    }, {
      "referenceID" : 4,
      "context" : "A practical representation of NNF formula [3, 5] is a rooted, directed acyclic graph (DAG) where each leaf node is labeled with true, false or a literal; and each internal node is labeled with ∧ or ∨ and can have arbitrarily many children.",
      "startOffset" : 42,
      "endOffset" : 48
    }, {
      "referenceID" : 7,
      "context" : "From above Definition 1, we know that the only difference between BDD-L and BDD [8] is the implied literals.",
      "startOffset" : 80,
      "endOffset" : 83
    }, {
      "referenceID" : 2,
      "context" : "First, we give the definition of Condition [3, 5], which is a useful logical operation in practical applications.",
      "startOffset" : 43,
      "endOffset" : 49
    }, {
      "referenceID" : 4,
      "context" : "First, we give the definition of Condition [3, 5], which is a useful logical operation in practical applications.",
      "startOffset" : 43,
      "endOffset" : 49
    }, {
      "referenceID" : 2,
      "context" : "Given any formula φ, variable x, literal l and consistent term T, by Theorem 1 in [3], we have that: φ ⇔ (φ | l) ∧ l if φ ⇒ l; φ ⇔ φ | x if φ | x ⇔ φ | ¬x (we say x can be omitted in φ).",
      "startOffset" : 82,
      "endOffset" : 85
    }, {
      "referenceID" : 8,
      "context" : "Every step in a single call (without consideration of the recursive calls) of Reduce can terminal in constant time, include the call of MK, whose running time is constant (readers are referred to [9] for the reason).",
      "startOffset" : 196,
      "endOffset" : 199
    }, {
      "referenceID" : 4,
      "context" : "The definition of succinctness is as follows [5]: Definition 7.",
      "startOffset" : 45,
      "endOffset" : 48
    }, {
      "referenceID" : 4,
      "context" : "1 in [5], and the transitivity of succinctness, we know that: Corollary 1.",
      "startOffset" : 5,
      "endOffset" : 8
    }, {
      "referenceID" : 4,
      "context" : "We just recall them here and readers are referred to [5] for their importance.",
      "startOffset" : 53,
      "endOffset" : 56
    }, {
      "referenceID" : 4,
      "context" : "7 in [5], we know that ROBDD-∞ satisfies ME, CE and IM.",
      "startOffset" : 5,
      "endOffset" : 8
    }, {
      "referenceID" : 2,
      "context" : "The same situation occurs in computing the minimum cardinality [3], which is useful in model-based diagnose, we only need an extra data unit in implied literals table to pre-record the number of negative literals in implied literals set.",
      "startOffset" : 63,
      "endOffset" : 66
    }, {
      "referenceID" : 18,
      "context" : "We focus on top-down compilation algorithms rather than bottom-up ones for the reasons that: we do not know whether ROBDD-∞ satisfies ∧BC or not; a well-known problem with the bottom-up methods is that the intermediate results that arise in the process can grow so large as to make further manipulation impossible, even when the final result would have a tractable size [20] (in the extreme case when the knowledge base is unsatisfiable, the final compilation result of ROBDD-i will has only one node, but the intermediate results may be satisfiable and have many nodes).",
      "startOffset" : 370,
      "endOffset" : 374
    }, {
      "referenceID" : 18,
      "context" : "Particularly, we do not even need to Line 1 and Lines 4-9 if i = 0, then Build is equivalent to Algorithm 5 in [20] when the input is in CNF.",
      "startOffset" : 111,
      "endOffset" : 115
    }, {
      "referenceID" : 0,
      "context" : "The idea of Horn theory approximation in [1] is generating a greatest lower bound (GLB).",
      "startOffset" : 41,
      "endOffset" : 44
    }, {
      "referenceID" : 19,
      "context" : "However, [21] showed that this problem is at least NP[ (log )] p O n -hard.",
      "startOffset" : 9,
      "endOffset" : 13
    }, {
      "referenceID" : 20,
      "context" : "Fortunately, there exist many efficient complete SAT solvers so far, such as MiniSAT [22], PrecoSAT [23], CryptoMiniSat [24] and so on.",
      "startOffset" : 85,
      "endOffset" : 89
    }, {
      "referenceID" : 21,
      "context" : "Fortunately, there exist many efficient complete SAT solvers so far, such as MiniSAT [22], PrecoSAT [23], CryptoMiniSat [24] and so on.",
      "startOffset" : 100,
      "endOffset" : 104
    }, {
      "referenceID" : 22,
      "context" : "Fortunately, there exist many efficient complete SAT solvers so far, such as MiniSAT [22], PrecoSAT [23], CryptoMiniSat [24] and so on.",
      "startOffset" : 120,
      "endOffset" : 124
    }, {
      "referenceID" : 23,
      "context" : "All these modern complete SAT solvers are based on the classic DPLL procedure [25], which employs a systematic search to find a model of the inputting CNF formula.",
      "startOffset" : 78,
      "endOffset" : 82
    }, {
      "referenceID" : 24,
      "context" : "For example, [26] proposed an algorithm to exploit DPLL search to generate Horn GLB; [20] proposed a new method to map different versions of exhaustive DPLL search to different compilation languages as ROBDD, FBDD, and d-DNNF, [12] extended this idea to map another version of systematic search to EPCCL theory.",
      "startOffset" : 13,
      "endOffset" : 17
    }, {
      "referenceID" : 18,
      "context" : "For example, [26] proposed an algorithm to exploit DPLL search to generate Horn GLB; [20] proposed a new method to map different versions of exhaustive DPLL search to different compilation languages as ROBDD, FBDD, and d-DNNF, [12] extended this idea to map another version of systematic search to EPCCL theory.",
      "startOffset" : 85,
      "endOffset" : 89
    }, {
      "referenceID" : 11,
      "context" : "For example, [26] proposed an algorithm to exploit DPLL search to generate Horn GLB; [20] proposed a new method to map different versions of exhaustive DPLL search to different compilation languages as ROBDD, FBDD, and d-DNNF, [12] extended this idea to map another version of systematic search to EPCCL theory.",
      "startOffset" : 227,
      "endOffset" : 231
    }, {
      "referenceID" : 18,
      "context" : "Techniques contributing to this improvement include two-literal watch scheme for fast BCP, clause learning by conflict analysis, dependency directed backtracking, new variable ordering heuristics, timely restarts, and so on [20, 22-24].",
      "startOffset" : 224,
      "endOffset" : 235
    }, {
      "referenceID" : 20,
      "context" : "Techniques contributing to this improvement include two-literal watch scheme for fast BCP, clause learning by conflict analysis, dependency directed backtracking, new variable ordering heuristics, timely restarts, and so on [20, 22-24].",
      "startOffset" : 224,
      "endOffset" : 235
    }, {
      "referenceID" : 21,
      "context" : "Techniques contributing to this improvement include two-literal watch scheme for fast BCP, clause learning by conflict analysis, dependency directed backtracking, new variable ordering heuristics, timely restarts, and so on [20, 22-24].",
      "startOffset" : 224,
      "endOffset" : 235
    }, {
      "referenceID" : 22,
      "context" : "Techniques contributing to this improvement include two-literal watch scheme for fast BCP, clause learning by conflict analysis, dependency directed backtracking, new variable ordering heuristics, timely restarts, and so on [20, 22-24].",
      "startOffset" : 224,
      "endOffset" : 235
    }, {
      "referenceID" : 25,
      "context" : "(3) CNF caching In order to save the compiling time, the function Build-inf-sub will be trying to not compiling the same CNF formula twice, we exploit the CNF caching scheme introduced in [27] to do this.",
      "startOffset" : 188,
      "endOffset" : 192
    }, {
      "referenceID" : 18,
      "context" : "As pointed out previously, the algorithm Build can be turned into Algorithm 5 in [20] when the input is in CNF.",
      "startOffset" : 81,
      "endOffset" : 85
    }, {
      "referenceID" : 18,
      "context" : "However, the experimental results in [20] show that the efficiency of Algorithm 5 is needed to be further improved.",
      "startOffset" : 37,
      "endOffset" : 41
    }, {
      "referenceID" : 18,
      "context" : "And we will see that this approach outperforms Algorithm 5 in [20] in the next section.",
      "startOffset" : 62,
      "endOffset" : 66
    }, {
      "referenceID" : 26,
      "context" : "So we also implement a DPLL-based SAT solver based on the one used in [13, 28], in which we exploit some techniques including two-literal watch scheme for fast BCP, clause learning by conflict analysis, dependency directed backtracking, variable ordering heuristics VSIDS.",
      "startOffset" : 70,
      "endOffset" : 78
    }, {
      "referenceID" : 24,
      "context" : "We compare BDDjLu against a d-DNNF compiler called c2d [26].",
      "startOffset" : 55,
      "endOffset" : 59
    }, {
      "referenceID" : 18,
      "context" : "It seems that a ROBDD compiler and a FBDD compiler were implemented by Huang and Darwiche in [20].",
      "startOffset" : 93,
      "endOffset" : 97
    }, {
      "referenceID" : 18,
      "context" : "Compared with the experimental results in [20], the FBDD generated by Inf2FBDD is obviously smaller for flat200-* and uf200-*.",
      "startOffset" : 42,
      "endOffset" : 46
    }, {
      "referenceID" : 18,
      "context" : "flat200-2, flat200-3 and uf200-* can be compiled by transforming the corresponding ROBDD-∞ into ROBDD now, while the ROBDD compiler reported in [20] cannot compile them in 900s with a 2.",
      "startOffset" : 144,
      "endOffset" : 148
    }, {
      "referenceID" : 18,
      "context" : "Compared with the compilers reported in [20], it seems that Inf2FBDD and Inf2ROBDD are two good alternatives to compile CNF formulas into FBDDs and ROBDDs, respectively.",
      "startOffset" : 40,
      "endOffset" : 44
    } ],
    "year" : 2011,
    "abstractText" : "Knowledge compilation is an approach to tackle the computational intractability of general reasoning problems. According to this approach, knowledge bases are converted off-line into a target compilation language which is tractable for on-line querying. Reduced ordered binary decision diagram (ROBDD) is one of the most influential target languages. We generalize ROBDD by associating some implied literals in each node and the new language is called reduced ordered binary decision diagram with implied literals (ROBDD-L). Then we discuss a kind of subsets of ROBDD-L called ROBDD-i with precisely i implied literals (0 ≤ i ≤ ∞). In particular, ROBDD-0 is isomorphic to ROBDD; ROBDD-∞ requires that each node should be associated by the implied literals as many as possible. We show that ROBDD-i has uniqueness over some specific variables order, and ROBDD-∞ is the most succinct subset in ROBDD-L and can meet most of the querying requirements involved in the knowledge compilation map. Finally, we propose an ROBDD-i compilation algorithm for any i and a ROBDD-∞ compilation algorithm. Based on them, we implement a ROBDD-L package called BDDjLu and then get some conclusions from preliminary experimental results: ROBDD-∞ is obviously smaller than ROBDD for all benchmarks; ROBDD-∞ is smaller than the d-DNNF the benchmarks whose compilation results are relatively small; it seems that it is better to transform ROBDDs-∞ into FBDDs and ROBDDs rather than straight compile the benchmarks.",
    "creator" : "Acrobat PDFMaker 7.0 for Word"
  }
}