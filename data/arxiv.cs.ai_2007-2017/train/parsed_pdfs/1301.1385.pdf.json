{
  "name" : "1301.1385.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : "Translating NP-SPEC into ASP",
    "authors" : [ "Mario Alviano", "Wolfgang Faber" ],
    "emails" : [ "mario@alviano.com,", "wf@wfaber.com" ],
    "sections" : [ {
      "heading" : "1 Introduction",
      "text" : "NP-SPEC is a language that was proposed in [4,2] in order to specify problems in the complexity class NP in a simple, clear, and declarative way. The language is based on Datalog with circumscription, in which some predicates are circumscribed, while others are not and are thus “left open”. Some practical features are added to this basic language, often by means of reductions.\nThe original software system supporting NP-SPEC was described in [2] and was written in the ECLiPSe Constraint Programming System, based on Prolog. A second software system, SPEC2SAT1, was proposed in [3], which rewrites NP-SPEC into propositional formulas for testing satisfiability. The system has also been tested quite extensively in [5], also for several problems taken from CSPLIB, with promising results.\nInterestingly, to our knowledge so far no attempt has been made to translate NPSPEC into Answer Set Programming (ASP), which is very similar in spirit to Datalog with circumscription, and thus a good candidate as a transformation target. Moreover, several efficient ASP software systems are available, which should guarantee good performance. A crucial advantage of ASP versus propositional satisfiability is the fact that NP-SPEC problem descriptions are in general not propositional, and therefore a reduction from NP-SPEC to SAT has to include an implicit instantiation (or grounding) step. Also ASP allows for variables, and ASP systems indeed provide optimized grounding procedures, which include many advanced techniques from database theory (such as indexing, join-ordering, etc). This takes the burden of instantiating in a smart way from the NP-SPEC translation when using ASP systems. ? This work was supported by M.I.U.R. within the PRIN project LoDeN. 1 http://www.dis.uniroma1.it/cadoli/research/projects/NP-SPEC/ code/SPEC2SAT/ ar X\niv :1\n30 1.\n13 85\nv1 [\ncs .A\nI] 8\nJ an\n2 01\nIn this paper we provide a translation from NP-SPEC into various variants of ASP. We discuss properties and limitations of the translation and also provide a prototype implementation, for which we provide a preliminary experimental analysis, which shows that our approach is advantageous, in particular that it pays off if grounding tasks are delegated to existing systems. The rest of the paper is structured as follows: in section 2 we review the language NP-SPEC and give a very brief account of ASP. In section 3 we provide the main ingredients for translations from NP-SPEC to ASP, and discuss properties and limitations. In section 4 we report on preliminary experimental results. Finally, in section 5 we draw our conclusions."
    }, {
      "heading" : "2 Preliminaries: NP-SPEC and ASP",
      "text" : "We first provide a brief definition of NP-SPEC programs. For details, we refer to [2]. We also note that a few minor details in the input language of SPEC2SAT (in which the publicly available examples are written) are different to what is described in [2]. We will usually stick to the syntax of SPEC2SAT.\nAn NP-SPEC program consists of two main sections2: one section called DATABASE and one called SPECIFICATION, each of which is preceded by the respective keyword.\n2.1 DATABASE\nThe database section defines extensional predicates or relations and (interpreted) constants. Extensional predicates are defined by writing\np = {t1, . . . , tn};\nwhere p is a predicate symbol and each ti is a tuple with matching arity. For unary predicates, each tuple is simply an integer or a constant symbol; for arity greater than 1, it is a comma-separated sequence of integers or constant symbols enclosed in round brackets. Unary extensions that are ranges of integers can also be abbreviated to n..m, where n and m are integers or interpreted constants. Constant definitions are written as\nc = i;\nwhere i is an integer.\nExample 1. The following defines the predicate edge representing a graph with six nodes and nine edges, and a constant n representing the number of nodes.\nDATABASE\nn = 6; edge = {(1, 2), (3, 1), (2, 3), (6, 2), (5, 6), (4, 5), (3, 5), (1, 4), (4, 1)};\n2 SPEC2SAT also has a third, apparently undocumented section called SEARCH, which seems to define only output features and which we will not describe here.\n2.2 SPECIFICATION\nThe SPECIFICATION section consists of two parts: a search space declaration and a stratified Datalog program. The search space declaration serves as a domain definition for “guessed” predicates and must be one or more of the metafacts Subset(d, p), Permutation(d, p), Partition(d, p, n), and IntFunc(d, p, n..m), which we will describe below.\nSubset(d, p). This is the basic construct to which all following search space declaration constructs are reduced in the semantic definition in [2]. Here, d is a domain definition, which is either an extensional predicate, a range n..m, or a Cartesian product (><), union (+), intersection (∗), or difference (−) of two domains. Symbol p is a predicate identifier and the intended meaning is that the extension of p can be any subset of the domain definition’s extension, thus giving rise to nondeterminism or a “guess”.\nExample 2. Together with the code of Example 1, the following specification will represent all subgraphs (including the original graph) as extensions of predicate subgraph.\nSPECIFICATION\nSubset(edge, subgraph).\nPermutation(d, p). Concerning this construct, d is again a domain definition, and p will have an extension in which each tuple of d is present and an additional argument associates a unique integer between 1 and the cardinality of the extension of d (say, c) to each tuple, thereby defining a permutation. The extensions of p thus define a bijective functions from tuples of the extension of d to {1..c}.\nExample 3. Together with the code of Example 1, the following specification will represent all enumerations of edges.\nSPECIFICATION\nPermutation(edge, edgeorder).\nOne extension of edgeorder that reflects the ordering of the edges as written in Example 1 is\nedgeorder(1, 2, 1), edgeorder(3, 1, 2), edgeorder(2, 3, 3), edgeorder(6, 2, 4), edgeorder(5, 6, 5), edgeorder(4, 5, 6), edgeorder(3, 5, 7), edgeorder(1, 4, 8), edgeorder(4, 1, 9).\nPartition(d, p, n). Also in this case p will have one argument more than d. In this case, extensions of p will define functions from tuples of the extension of d to {1..n}, thereby defining n (possibly empty) partitions.\nExample 4. Together with the code of Example 1, the following specification will represent all possible pairs of graphs that partition the input graph.\nSPECIFICATION\nPartition(edge, partition, 2).\nOne extension of partition that has the first four edges in the first partition (i.e., partition 0) and the last five edges in the second partition (i.e., partition 1) would be\npartition(1, 2, 0), partition(3, 1, 0), partition(2, 3, 0), partition(6, 2, 0), partition(5, 6, 1), partition(4, 5, 1), partition(3, 5, 1), partition(1, 4, 1), partition(4, 1, 1).\nIntFunc(d, p, n..m). Again, p will have one argument more than d. Here, extensions of p will define functions from tuples of the extension of d to {n..m}.\nExample 5. The following specification is equivalent to the one in Example 4:\nSPECIFICATION\nIntFunc(edge, partition, 0..1).\nStratified Datalog Program. The stratified Datalog program is written using < −− as the rule implication symbol. It may contain built-in predicates (==, <, >, >=, <=, ! =), arithmetic expressions, and stratified aggregates (COUNT, SUM, MIN, MAX). It may also contain integrity constraints, in which case rule heads contain the special symbol fail. Rule implication is denoted by < −−, the aggregates are written as for example SUM(p(∗, , Y), Z : n..m) where: ∗ specifies the argument to be aggregated over; variables that are not shared with other rule literals are local (as a special case the anonymous variable ) and represent the arguments that are not fixed; variables that are shared with other rule literals are considered fixed in the aggregation; and variable Z will contain the valuation of the aggregate, which will must be in the range n..m. Comments may be written in C++ style (using / ∗ ∗/ or //).\nExample 6. As an example, consider the well-known Hamiltonian Cycle problem. The NP-SPEC distribution contains an example program for an example graph:\nDATABASE\nn = 6; //no. of nodes edge = {(1, 2), (3, 1), (2, 3), (6, 2), (5, 6), (4, 5), (3, 5), (1, 4), (4, 1)};\nSPECIFICATION\nPermutation({1..n}, path). fail < −− path(X, P), path(Y, P+ 1), NOT edge(X, Y). fail < −− path(X, n), path(Y, 1), NOT edge(X, Y).\nThe DATABASE section contains an encoding of the example graph by means of the binary predicate edge and defines a constant n for representing the number of nodes of that graph. Implicitly it is assumed that the nodes are labeled by integers from 1 to n. The SPECIFICATION section then first guesses a permutation of the nodes and then verifies the Hamiltonian Cycle condition by means of integrity constraints, one exploiting the linear order of the permutation identifiers, and another one to close the cycle from the last permutation identifier to the first one.\nThe semantics of NP-SPEC programs is provided by means of Datalog with Circumscription, in which some predicates are minimized. That means that among all models only those which are minimal with respect to the minimized predicates are accepted. Moreover, among these only those which make the special symbol fail false are considered and referred to as answers. All metafacts are reduced to the basic metafact Subset that effectively states that the predicate defined by the metafact is not minimized. For further details of the semantics, we refer to [2].\nConcerning ASP, we only give a very brief overview, details may be found in works such as [1,13,8]. An ASP program consists of rules"
    }, {
      "heading" : "L1 ∨ · · · ∨ Lk : − Body",
      "text" : "where the Li are literals containing variables and constants3 (possibly containing strong negation) and Body, which is a conjunction of literals, that may also contain built-ins, aggregates and default negation. Rules without heads act like integrity constraints. The semantics is based on the Gelfond-Lifschitz reduct [11] and also guarantees minimality of the answer sets.\nPractical ASP systems differ in several details, for instance several do not support disjunction in rule heads, built-in predicates and arithmetic expressions may differ and also aggregates are sometimes written in slightly different ways. In this paper, we will use the syntax of gringo (http://potassco.sourceforge.net/) and DLV (http://www.dlvsystem.com). Both systems assume that the input programs are safe, that is, each variable in a rule must also occur in a positive body atom. While gringo can also parse disjunctive programs, clasp, the solver it is often used with, can only deal with nondisjunctive programs.\nExample 7. As an example, consider the Hamiltonian Cycle problem and instance from above. An ASP encoding similar to the NP-SPEC program seen earlier would be:\n#const n = 6 edge(1, 2). edge(3, 1). edge(2, 3). edge(6, 2). edge(5, 6). edge(4, 5). edge(3, 5). edge(1, 4). edge(4, 1). d(1..n). path(X, 1)∨path(X, 2)∨path(X, 3)∨path(X, 4)∨path(X, 5)∨path(X, 6) : − d(X). : − path(X, A), path(Y, A), X ! = Y. : − path(X, P), path(Y, Z), not edge(X, Y), Z = P+ 1. : − path(X, n), path(Y, 1), not edge(X, Y).\nThis program is usable for gringo with clasp, using the --shift option (transforming the disjunctive rule into several nondisjunctive ones), and DLV. We can observe that the extensional definition is rewritten into a number of facts and that the constant definition also just changes syntax. As for the permutation statement, here we first use a predicate d representing the domain definition, and then a disjunctive rule and an integrity constraint. The disjunctive rule states that each tuple in the domain definition must be assigned one of the numbers 1 to 6, and the integrity constraint enforces the bijection,\n3 Many modern ASP systems also allow for function symbols, but they are not needed here.\nthat is, no different tuples of the domain definition must be assigned the same number. The final two integrity constraints are direct translations from the NP-SPEC program. The only difference is the arithmetic expression that has been moved outside the fact in order to conform to DLV’s syntax (gringo would also have accepted the immediate translation from the NP-SPEC program)."
    }, {
      "heading" : "3 Translation from NP-SPEC to ASP",
      "text" : "We now report how the various constructs of NP-SPEC programs can be translated into ASP. We start with the DATABASE section constructs. An extensional declaration of the form p = {t1, . . . , tn} will be translated to facts p(t1) · · · p(tn), and one of the form p = {n..m} will be translated to facts p(n) · · · p(m). Constant declarations such as c = i, instead, will be managed in-memory.\nNow for the main task, translating the SPECIFICATION constructs. We first look at metafacts. The simplest one is Subset(d, p). The exact translation of this metafact (and all others as well) depends on how d is specified. First assume that it is an extensional predicate d of arity n, then we can directly use it and produce\np(X1, . . . , Xn) ∨ −p(X1, . . . , Xn) : − d(X1, . . . , Xn).\nOtherwise, we will create an extensional predicate d of appropriate arity (assuming that it is a fresh symbol) as follows:\n– for the Cartesian product p >< q, the following set of facts is created: {d(x1, . . . , xi+j) | p(x1, . . . , xi) ∧ q(xi+1, . . . , xi+j)}, where i and j are the arities of p and q, respectively; – for the union p+ q, the following set of facts is created: {d(x1, . . . , xi) | p(x1, . . . , xi) ∨ q(x1, . . . , xi)}, where i is the arity of both p and q; – for the intersection p ∗ q, the following set of facts is created: {d(x1, . . . , xi) | p(x1, . . . , xi) ∧ q(x1, . . . , xi)}, where i is the arity of both p and q; and – for the difference p− q, the following set of facts is created: {d(x1, . . . , xi) | p(x1, . . . , xi) ∧ ¬.q(x1, . . . , xi)}, where i is the arity of both p and q, and¬.q(x1, . . . , xi) is true if and only if the fact q(x1, . . . , xi) is not part of the translation.\nFor nested domain definitions, we just repeat this process recursively using fresh symbols in each recursive step. In the following we will assume that domain definitions have been treated in this way and that the top-level predicate of the translation is d. If available (for instance when using gringo or lparse), we can also use choice rules for translating Subset(d, p):\n{p(X1, . . . , Xn) : d(X1, . . . , Xn)}.\nFor the metafact Permutation(d, p), we will create\np(X1, . . . , Xn, 1) ∨ . . . ∨ p(X1, . . . , Xn, c) : − d(X1, . . . , Xn). : − p(X1, . . . , Xn, A), p(Y1, . . . , Yn, A), X1! = Y1.\n... : − p(X1, . . . , Xn, A), p(Y1, . . . , Yn, A), Xn! = Yn.\nwhere n is the arity of d and c is the cardinality of d. The first rule specifies intuitively that for each tuple in d one of p(X1, . . . , Xn, 1) · · · p(X1, . . . , Xn, c) should hold, and by minimality exactly one of these will hold. The integrity constraints ensure that no different numbers will be associated to the same tuple. As an alternative to the disjunctive rule, one can use a choice rule\n1{p(X1, . . . , Xn, 1..c)}1 : − d(X1, . . . , Xn).\nInstead of the n integrity constraints it is possible to write just one using an aggregate, if available. In the DLV syntax, one could write\n: − #count{X1, . . . , Xn : p(X1, . . . , Xn, A)} > 1, p( , . . . , , A).\nor in gringo syntax\n: − 2 #count{p(X1, . . . , Xn, A)}, p( , . . . , , A).\nThe remaining metafacts are actually much simpler to translate, as the bijection criterion does not have to be checked. For Partition(d, p, k), we will simply create\np(X1, . . . , Xn, 0) ∨ . . . ∨ p(X1, . . . , Xn, k− 1) : − d(X1, . . . , Xn).\nor the respective choice rule\n1{p(X1, . . . , Xn, 0..k− 1)}1 : − d(X1, . . . , Xn).\nwhere n is the arity of d. For IntFunc(d, p, i..j), we will simply create\np(X1, . . . , Xn, i) ∨ . . . ∨ p(X1, . . . , Xn, j) : − d(X1, . . . , Xn).\nor the respective choice rule\n1{p(X1, . . . , Xn, i..j)}1 : − d(X1, . . . , Xn).\nwhere n is the arity of d. What remains are the Datalog rules of the SPECIFICATION section. Essentially, each Head < −− Body is directly translated into Head′ : − Body′, with only minor differences. If Head is fail, then Head′ is empty, otherwise it will be exactly the same. The difference between Body and Body′ is due to different syntax for arithmetics, aggregates and due to safety requirements. Concerning arithmetics, gringo can accept almost the same syntax as NP-SPEC with only minor differences (#abs instead of abs, #pow instead of ˆ), while DLV is much more restrictive. DLV currently does not support negative integers and it does not provide constructs corresponding to abs and ˆ. Moreover, arithmetic expressions may not be nested in DLV programs, but this limitation can be overcome by flattening the expressions.\nConcerning aggregates, DLV and gringo support similar syntax, which is a little bit different from the one used in NP-SPEC but rather straightforward to rewrite according to the following schema: Arguments marked with asterisks are first replaced with fresh variables; these are the arguments on which the aggregation function is applied. Apart\nfrom COUNT, exactly one asterisk may appear in each aggregate. Hence, an aggregate SUM(p(∗, , Y), Z : n..m) is written in DLV’s syntax as\n#sum{X : p(X, , Y)} = Z, d(Z)\nand in gringo’s syntax as\nZ #sum[p(X, , Y) = X] Z, d(Z)\nwhere X is a fresh variable and d is a fresh predicate defined by facts d(n) · · · d(m). Aggregates MIN and MAX are rewritten similarly, while an aggregate\nCOUNT(p(∗, , ∗, Y), Z : n..m)\nis written in DLV’s syntax as\n#count{X1, X2 : p(X1, , X2, Y)} = Z, d(Z)\nand in gringo’s syntax by\nZ #count{p(X1, , X2, Y)} Z, d(Z).\nA more difficult problem presents the safety conditions enforced by the ASP systems. NP-SPEC has a fairly lax safety criterion, while for instance DLV requires each variable to occur in a positive, non-builtin body literal, and also gringo has a similar criterion. This mismatch can be overcome by introducing appropriate domain predicates when needed."
    }, {
      "heading" : "4 Experiments",
      "text" : "We have created a prototype implementation of the transformation described in section 3, which is available at http://archives.alviano.com/npspec2asp/. It is written in C++ using bison and flex, and called NPSPEC2ASP. The implementation at the moment does only rudimentary correctness checks of the program and is focussed on generating ASP programs for correct NP-SPEC input. Moreover, at the moment it generates only the disjunctive rules described in section 3 rather than the choice rules, but we plan to add the possibility to create variants of the ASP code in the near future. For the experiments, the transformation used for Permutation produced the integrity constraint with the counting aggregate.\nWe used this implementation to test the viability of our approach, in particular assessing the efficiency of the proposed rewriting in ASP with respect to the previously available transformation into SAT. In the benchmark we included several instances available on the NP-SPEC site. More specifically, we considered two sets of instances, namely the miscellanea and csplib2npspec benchmarks. Even if these instances have been conceived for demonstrating the expressivity of the language rather than for assessing the efficiency of an evaluator, it turned out that even for these comparatively small instances there are quite marked performance differences. Below we provide some more details on the testcases in the miscellanea benchmark.\n– Coloring is an instance of the Graph Coloring problem, i.e., given a graph G and a set of k colors, checking whether it is possible to assign a color to each node of G in such a way that no adjacent nodes of G share the same color. The tested instance has 6 nodes and 3 colors. – In the Diophantine problem, three positive integers a, b, c are given, and an integer solution to the equation ax2 + by = c is asked for. The parameters of the tested instance are a = 5, b = 3, and c = 710. – The Factoring problem consists of finding two non-trivial factors (i.e., greater than 1) of a given integer n. In the tested instance, n = 10000. – In the Hamiltonian Cycle problem a graph G is given, and a cycle traversing each node exactly once is searched. The tested graph has 6 nodes. – An instance of the Job Shop Scheduling problem consists of integers n (jobs), m (tasks), p (processors), and D (global deadline). Jobs are ordered collections of tasks, and each task is performed on a processor for some time. Each processor can perform one task at a time, and the tasks belonging to the same job must be performed in order. The problem is checking whether it is possible for all jobs to meet deadline D. In the testcase, n = 6, m = 36, p = 6, and D = 55. – In the Protein Folding problem, a sequence of n elements in {H,P} is given, and the goal is to find a connected, non-overlapping shape of the sequence on a bidimensional, discrete grid, so that the number of “contacts”, i.e., the number of non-sequential pairs of H for which the Euclidean distance of the positions is 1, is in a given range R. In the testcase, n = 6, and R = {1..12}. – In the Queens problem, an integer n is given, and the goal is to place n nonattacking queens on a n× n chessboard. In the tested instance, n = 5. – Given an arrayA of integers, the Sorting problem consists of arranging the elements of A in non-descending order. In the tested instance, the array has 7 elements. – An instance of the Subset Sum problem comprises a finite set A, a size s(a) ∈ N+ for each a ∈ A, and B ∈ N+. The goal of the problem is checking whether there is a subset A′ of A such that the sum of the sizes of the elements in A′ is exactly B. In the tested instance, set A has 5 elements and B = 10. – In a Sudoku, the goal is to fill a given (partially filled) grid with the numbers 1 to 9, so that every column, row, and 3 × 3 box indicated by slightly heavier lines has the numbers 1 to 9. – 3-SAT is a well-known NP-complete problem: Given a propositional formula T in conjunctive normal form, in which each clause has exactly three literals, is T satisfiable, i.e., does there exist an assignment of variables of T to {true, false} that makes T evaluate to true? The tested instance has 3 clauses. – The Tournament Scheduling problem consists of assigning the matches to rounds of a round-robin tournament for a sports league. The match is subject to several constraints, such as: (i) complementary teams t1 and t2 have complementary schedules, i.e., for each round r, if t1 plays home in r then t2 plays away in r, and vice versa; (ii) two top matches cannot take place at distance smaller than a given value; (iii) any team cannot match two top teams at distance smaller than a given value. (See [5] for details.) The tested instance has 6 teams.\nBelow we describe the testcases in the csplib2npspec benchmark.\n– Given n ∈ N, find a vector s = (s1, ..., sn) such that (i) s is a permutation of Zn = {0, 1, . . . , n − 1}; and (ii) the interval vector v = (|s2 − s1|, |s3 − s2|, . . . , |sn − sn−1|) is a permutation of Zn\\{0} = {1, 2, . . . , n−1}. A vector v satisfying these conditions is called an all-interval series of size n; the problem of finding such a series is the All-interval Series problem of size n. In the tested instance, n = 20.\n– In the BACP (balanced academic curriculum problem), each course has associated a number of credits and can have other courses as prerequisites. The goal is to assign a period to every course in a way that the number of courses and the amount of credits per period are in given ranges, and the prerequisite relationships are satisfied. The tested instance comprises 7 courses and 2 periods.\n– A BIBD is defined as an arrangement of v distinct objects into b blocks such that each block contains exactly k distinct objects, each object occurs in exactly r different blocks, and every two distinct objects occur together in exactly λ blocks. The parameters of the tested instance are v = 7, b = 7, k = 3, r = 3, and λ = 1.\n– In the Car Sequencing problem, a number of cars are to be produced; they are not identical, because different options are available as variants on the basic model. The assembly line has different stations which install the various options (airconditioning, sun-roof, etc.). These stations have been designed to handle at most a certain percentage of the cars passing along the assembly line. Consequently, the cars must be arranged in a sequence so that the capacity of each station is never exceeded. In the testcase there are 10 cars, 6 variants on a basic model, and 5 options. – A Golomb ruler is a set of m integers 0 = a1 < a2 < · · · < am such that the m(m − 1)/2 differences aj − ai (1 ≤ i < j ≤ m) are distinct. In the tested instance, m = 8 and am must be lesser than or equals to 10. – Langford’s problem is to arrange k sets of numbers 1 to n so that each appearance of the number m is m numbers on from the last. In the tested instance, k = 3 and n = 9.\n– Given integers n and b, the objective of the Low Autocorrelation problem is to construct a binary sequence Si of length n, where each bit takes the value +1 or -1, so that E = ∑n−1 k=1(Ck) 2 ≤ b, where Ck = ∑n−k−1\ni=0 Si · Si+k. In the tested instance, n = 5 and b = 2. – An order n magic square is a n × n matrix containing the numbers 1 to n2, with each row, column and main diagonal summing up to the same value. In our setting, n = 3.\n– The Ramsey problem is to color the edges of a complete graph with n nodes using at most k colors, in such a way that there is no monochromatic triangle in the graph. In the tested instance, n = 5 and k = 3.\n– The Round-robin Tournament problem is to schedule a tournament of n teams over n − 1 weeks, with each week divided into n/2 periods, and each period divided into two slots. A tournament must satisfy the following three constraints: every team plays once a week; every team plays at most twice in the same period over the tournament; every team plays every other team. In our setting, n = 4. – Schur’s Lemma problem is to put n balls labelled {1, . . . , n} into 3 boxes so that for any triple of balls (x, y, z) with x + y = z, not all are in the same box. In the tested instance, n = 10.\n– In the Social Golfer problem there are n golfers, each of whom play golf once a week, and always in groups of s. The goal is to determine a schedule of play for these golfers, to last l weeks, such that no golfer plays in the same group as any other golfer on more than one occasion. In our setting, n = 8, s = 2, and l = 4.\nThe experiment has been executed on an Intel Core2 Duo P8600 2.4 GHz with 4 GB of central memory, running Linux Mint Debian Edition (wheezy/sid) with kernel Linux 3.2.0-2-amd64. The tools SPEC2SAT and NPSPEC2ASP have been compiled with gcc 4.6.3. The other tools involved in the experiment are satz 215.2 [14], minisat 1.14 [7], gringo 3.0.4 [10], clasp 2.0.6 [9], and DLV 2011-12-21 [12].\nIn our experiment, we first measured the running time required by SPEC2SAT and NPSPEC2ASP to rewrite the input specification into SAT and ASP, respectively. Then, for each SAT encoding produced by SPEC2SAT, we ran three SAT solvers, namely satz, minisat and clasp, to obtain one solution if one exists. For each of these executions we measured the time to obtain the solution or the assertion that none exists, thus the sum of the running times of SPEC2SAT and of the SAT solvers. Moreover, for each ASP encoding produced by NPSPEC2ASP, we ran two instantiators, namely gringo and DLV (with option --instantiate). For each of these runs we measured the time required to compute the ground ASP program, thus the sum of the running times of NPSPEC2ASP and of the instantiator. Finally, for each ground ASP program computed by gringo and DLV, we computed one solution by using clasp and DLV, respectively, and measured the overall time required by the tool-chain. We have also measured the sizes of the instantiated formulas and programs. For SPEC2SAT, we report the number of clauses in the produced formula and the number of propositional variables occurring in it. For DLV and gringo we report the number of ground rules produced and the number of ground atoms occurring in them. There is a slight difference in the statistics provided by DLV and gringo: DLV does not count ground atoms (and facts) that were already found to be true; to be more comparable, we added the number of facts for DLV.\nExperimental results concerning the miscellanea benchmark are reported in Table 1. We first observe that the time required by NPSPEC2ASP is below the measurement accuracy, while the execution time of SPEC2SAT is higher, sometimes by several orders of magnitude. In fact, SPEC2SAT has to compute a ground SAT instance to pass to a SAT solver, while NPSPEC2ASP outputs a non-ground ASP program. A fairer comparison is obtained by adding to the time taken by NPSPEC2ASP the time required by the ASP instantiator to obtain a ground ASP program. Columns gringo and “DLV inst” report these times, which are however always less than those of SPEC2SAT. In Table 2 it can be seen that also the number of ground rules produced by the ASP systems is usually smaller than the number of clauses produced by SPEC2SAT, even if often the number of ground atoms exceeds the number of propositional variables.\nConcerning the computation of one solution from each ground specification, all considered SAT and ASP solvers are fast in almost all tests. The only exceptions are satz for proteinFolding, which exceeds the allotted time, and DLV for jobShopScheduling, whose execution lasted around 88 seconds. We also note that DLV has not been tested on 2 instances containing negative integers, which are not allowed in the DLV language.\nTable 3 reports experimental results concerning the csplib2npspec benchmark. We start by observing that instances in this benchmark are more resource demanding than\ninstances in the miscellanea benchmark. In fact, we note that golombRuler is too difficult for SPEC2SAT, which did not terminate on the allotted time on this instance. On the other hand, the rewriting provided by NPSPEC2ASP is processed in around 28 seconds by gringo+clasp and in around 24 seconds by DLV. Another hard instance is allInterval, for which only satz and DLV terminated in the allotted time. All other solvers, includ-\ning gringo+clasp, exceeded the allotted time, even if the NPSPEC2ASP rewriting and the instantiation by gringo is produced in less time than the output of SPEC2SAT. This instance is an outlier in our experiments. In almost all other instances the ASP solvers compute solutions in less than 1 second, while SAT solvers typically require several seconds, see in particular langford, magicSquare and lowAutocorrelation. The size of the programs produced by the ASP instantiators is always smaller than the size of the formulas produced by SPEC2SAT, sometimes by orders of magnitude, even if the number of ground atoms often exceeds the number of propositional variables. A major cause for the difference in size appear to be aggregates in the problem specification, which are supported natively by ASP systems, but require expensive rewritings for SAT solvers.\nThe experimental results show that translating NP-SPEC programs into ASP rather than SAT seems to be preferable, due to the fact that sophisticated instantiation techniques can be leveraged. Moreover, also the nondeterministic search components of ASP systems can compete well with SAT solvers, making the use of ASP solvers very attractive for practical purposes."
    }, {
      "heading" : "5 Conclusion",
      "text" : "In this paper we have presented a transformation of NP-SPEC programs into ASP. The translation is modular and not complex at all, allowing for very efficient transformations. Compared to the previously available transformation into Boolean satisfiability, there are a number of crucial differences: While our transformation is from a formalism with variables into another formalism with variables, Boolean satisfiability of course does not allow for object variables. Therefore any transformation to that language has\nto do an implicit instantiation. It is obvious that instantiation can be very costly, and thus using sophisticated instantiation methods is often crucial. However, optimization methods for instantiation are often quite involved and not easy to implement, and therefore adopting them in a transformation is detrimental. After all, the appeal of transformations are usually their simplicity and the possibility to re-use existing software after the transformation. Our transformation method does just that; by not instantiating it is possible to re-use existing instantiators inside ASP systems, many of which use quite sophisticated techniques like join ordering heuristics, dynamic indexing and many more. We have provided a prototype implementation that showcases this advantage. Even if only rather small examples were tested, already in most of those cases a considerable advantage of our method can be observed.\nThere is a second aspect of our work, which regards ASP. As can be seen in section 3, the translation of Permutation either gives rise to possibly many integrity constraints or one with an aggregate. In any case, all current ASP instantiators will materialize all associations between tuples of the domain definition and the permutation identifiers, even if the identifiers are not really important for solving the problem. This means that there are obvious symmetries in the instantiated program. There exist proposals for symmetry breaking in ASP (e.g. [6]), but they typically employ automorphism detection. We argue that in cases like this, a statement like Permutation, Partition, or IntFunc would make sense as a language addition for ASP solvers, which could exploit the fact that the permutation identifiers introduce a particular known symmetry pattern that does not have to be detected by any external tool.\nFuture work consists of consolidating the prototype software and extending the experimentation. Moreover, we intend to investigate the possibility to extend our transformation to work with other languages that are similar to NP-SPEC. Finally, we also intend to explore the possibility and impact of introducing Permutation, Partition, or IntFunc into ASP languages."
    } ],
    "references" : [ {
      "title" : "Knowledge Representation, Reasoning and Declarative Problem Solving",
      "author" : [ "C. Baral" ],
      "venue" : "Cambridge University Press",
      "citeRegEx" : "1",
      "shortCiteRegEx" : null,
      "year" : 2003
    }, {
      "title" : "An Executable Specification Language for Solving all the Problems in NP",
      "author" : [ "M. Cadoli", "G. Ianni", "L. Palopoli", "A. Schaerf", "D. Vasile" ],
      "venue" : "Computer Languages 26(2/4), 165–195",
      "citeRegEx" : "2",
      "shortCiteRegEx" : null,
      "year" : 2000
    }, {
      "title" : "SAT as an effective solving technology for constraint problems",
      "author" : [ "M. Cadoli", "T. Mancini", "F. Patrizi" ],
      "venue" : "pp. 39–47. No. CS-2005-03 in Computer Science Group Technical Reports, Dipartimento di Ingegneria,",
      "citeRegEx" : "3",
      "shortCiteRegEx" : "3",
      "year" : 2005
    }, {
      "title" : "NP-SPEC: An executable specification language for solving all problems in NP",
      "author" : [ "M. Cadoli", "L. Palopoli", "A. Schaerf", "D. Vasile" ],
      "venue" : "Proceedings of the First International Workshop on Practical Aspects of Declarative Languages. Lecture Notes in Computer Science, vol. 1551, pp. 16–30. Springer",
      "citeRegEx" : "4",
      "shortCiteRegEx" : null,
      "year" : 1999
    }, {
      "title" : "Compiling problem specifications into SAT",
      "author" : [ "M. Cadoli", "A. Schaerf" ],
      "venue" : "Artificial Intelligence 162(1–2), 89–120",
      "citeRegEx" : "5",
      "shortCiteRegEx" : null,
      "year" : 2005
    }, {
      "title" : "Symmetry-breaking answer set solving",
      "author" : [ "C. Drescher", "O. Tifrea", "T. Walsh" ],
      "venue" : "AI Communications 24(2), 177–194",
      "citeRegEx" : "6",
      "shortCiteRegEx" : null,
      "year" : 2011
    }, {
      "title" : "An extensible SAT-solver",
      "author" : [ "N. Eén", "N. Sörensson" ],
      "venue" : "SAT. pp. 502–518",
      "citeRegEx" : "7",
      "shortCiteRegEx" : null,
      "year" : 2003
    }, {
      "title" : "Potassco: The potsdam answer set solving collection",
      "author" : [ "M. Gebser", "B. Kaufmann", "R. Kaminski", "M. Ostrowski", "T. Schaub", "M.T. Schneider" ],
      "venue" : "AI Communications 24(2), 107–124",
      "citeRegEx" : "8",
      "shortCiteRegEx" : null,
      "year" : 2011
    }, {
      "title" : "Conflict-driven answer set solving",
      "author" : [ "M. Gebser", "B. Kaufmann", "A. Neumann", "T. Schaub" ],
      "venue" : "Twentieth International Joint Conference on Artificial Intelligence (IJCAI-07). pp. 386–392. Morgan Kaufmann Publishers",
      "citeRegEx" : "9",
      "shortCiteRegEx" : null,
      "year" : 2007
    }, {
      "title" : "Gringo : A new grounder for answer set programming",
      "author" : [ "M. Gebser", "T. Schaub", "S. Thiele" ],
      "venue" : "Baral, C., Brewka, G., Schlipf, J. (eds.) Logic Programming and Nonmonotonic Reasoning — 9th International Conference, LPNMR’07. Lecture Notes in Computer Science, vol. 4483, pp. 266–271. Springer Verlag, Tempe, Arizona",
      "citeRegEx" : "10",
      "shortCiteRegEx" : null,
      "year" : 2007
    }, {
      "title" : "Classical Negation in Logic Programs and Disjunctive Databases",
      "author" : [ "M. Gelfond", "V. Lifschitz" ],
      "venue" : "New Generation Computing 9, 365–385",
      "citeRegEx" : "11",
      "shortCiteRegEx" : null,
      "year" : 1991
    }, {
      "title" : "The DLV System",
      "author" : [ "N. Leone", "G. Pfeifer", "W. Faber", "F. Calimeri", "T. Dell’Armi", "T. Eiter", "G. Gottlob", "G. Ianni", "G. Ielpa", "C. Koch", "S. Perri", "A. Polleres" ],
      "venue" : "Proceedings of the 8th European Conference on Logics in Artificial Intelligence (JELIA). Lecture Notes in Computer Science,",
      "citeRegEx" : "12",
      "shortCiteRegEx" : "12",
      "year" : 2002
    }, {
      "title" : "The DLV System for Knowledge Representation and Reasoning",
      "author" : [ "N. Leone", "G. Pfeifer", "W. Faber", "T. Eiter", "G. Gottlob", "S. Perri", "F. Scarcello" ],
      "venue" : "ACM Transactions on Computational Logic 7(3), 499–562",
      "citeRegEx" : "13",
      "shortCiteRegEx" : null,
      "year" : 2006
    }, {
      "title" : "A constraint-based approach to narrow search trees for satisfiability",
      "author" : [ "C.M. Li" ],
      "venue" : "Information Processing Letters 71(2), 75–80",
      "citeRegEx" : "14",
      "shortCiteRegEx" : null,
      "year" : 1999
    } ],
    "referenceMentions" : [ {
      "referenceID" : 3,
      "context" : "NP-SPEC is a language that was proposed in [4,2] in order to specify problems in the complexity class NP in a simple, clear, and declarative way.",
      "startOffset" : 43,
      "endOffset" : 48
    }, {
      "referenceID" : 1,
      "context" : "NP-SPEC is a language that was proposed in [4,2] in order to specify problems in the complexity class NP in a simple, clear, and declarative way.",
      "startOffset" : 43,
      "endOffset" : 48
    }, {
      "referenceID" : 1,
      "context" : "The original software system supporting NP-SPEC was described in [2] and was written in the ECLPS Constraint Programming System, based on Prolog.",
      "startOffset" : 65,
      "endOffset" : 68
    }, {
      "referenceID" : 2,
      "context" : "A second software system, SPEC2SAT1, was proposed in [3], which rewrites NP-SPEC into propositional formulas for testing satisfiability.",
      "startOffset" : 53,
      "endOffset" : 56
    }, {
      "referenceID" : 4,
      "context" : "The system has also been tested quite extensively in [5], also for several problems taken from CSPLIB, with promising results.",
      "startOffset" : 53,
      "endOffset" : 56
    }, {
      "referenceID" : 1,
      "context" : "For details, we refer to [2].",
      "startOffset" : 25,
      "endOffset" : 28
    }, {
      "referenceID" : 1,
      "context" : "We also note that a few minor details in the input language of SPEC2SAT (in which the publicly available examples are written) are different to what is described in [2].",
      "startOffset" : 165,
      "endOffset" : 168
    }, {
      "referenceID" : 1,
      "context" : "This is the basic construct to which all following search space declaration constructs are reduced in the semantic definition in [2].",
      "startOffset" : 129,
      "endOffset" : 132
    }, {
      "referenceID" : 1,
      "context" : "For further details of the semantics, we refer to [2].",
      "startOffset" : 50,
      "endOffset" : 53
    }, {
      "referenceID" : 0,
      "context" : "Concerning ASP, we only give a very brief overview, details may be found in works such as [1,13,8].",
      "startOffset" : 90,
      "endOffset" : 98
    }, {
      "referenceID" : 12,
      "context" : "Concerning ASP, we only give a very brief overview, details may be found in works such as [1,13,8].",
      "startOffset" : 90,
      "endOffset" : 98
    }, {
      "referenceID" : 7,
      "context" : "Concerning ASP, we only give a very brief overview, details may be found in works such as [1,13,8].",
      "startOffset" : 90,
      "endOffset" : 98
    }, {
      "referenceID" : 10,
      "context" : "The semantics is based on the Gelfond-Lifschitz reduct [11] and also guarantees minimality of the answer sets.",
      "startOffset" : 55,
      "endOffset" : 59
    }, {
      "referenceID" : 4,
      "context" : "(See [5] for details.",
      "startOffset" : 5,
      "endOffset" : 8
    }, {
      "referenceID" : 13,
      "context" : "2 [14], minisat 1.",
      "startOffset" : 2,
      "endOffset" : 6
    }, {
      "referenceID" : 6,
      "context" : "14 [7], gringo 3.",
      "startOffset" : 3,
      "endOffset" : 6
    }, {
      "referenceID" : 9,
      "context" : "4 [10], clasp 2.",
      "startOffset" : 2,
      "endOffset" : 6
    }, {
      "referenceID" : 8,
      "context" : "6 [9], and DLV 2011-12-21 [12].",
      "startOffset" : 2,
      "endOffset" : 5
    }, {
      "referenceID" : 11,
      "context" : "6 [9], and DLV 2011-12-21 [12].",
      "startOffset" : 26,
      "endOffset" : 30
    }, {
      "referenceID" : 5,
      "context" : "[6]), but they typically employ automorphism detection.",
      "startOffset" : 0,
      "endOffset" : 3
    } ],
    "year" : 2013,
    "abstractText" : "NP-SPEC is a language for specifying problems in NP in a declarative way. Despite the fact that the semantics of the language was given by referring to Datalog with circumscription, which is very close to ASP, so far the only existing implementations are by means of ECLPS Prolog and via Boolean satisfiability solvers. In this paper, we present translations from NP-SPEC into various forms of ASP and analyze them. We also argue that it might be useful to incorporate certain language constructs of NP-SPEC into mainstream ASP.",
    "creator" : "LaTeX with hyperref package"
  }
}