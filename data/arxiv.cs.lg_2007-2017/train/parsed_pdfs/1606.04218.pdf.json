{
  "name" : "1606.04218.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : "Conditional Generative Moment-Matching Networks",
    "authors" : [ "Yong Ren", "Jialian Li", "Yucen Luo", "Jun Zhu" ],
    "emails" : [ "{renyong15@mails,", "luoyc15@mails,", "jl12@mails,", "dcszj@mail}.tsinghua.edu.cn" ],
    "sections" : [ {
      "heading" : "1 Introduction",
      "text" : "Deep generative models (DGMs) characterize the distribution of observations with a multilayered structure of hidden variables under nonlinear transformations. Among various deep learning methods, DGMs are natural choice for those tasks that require probabilistic reasoning and uncertainty estimation, such as image generation [1], multimodal learning [30], and missing data imputation. Recently, the predictive power, which was often shown inferior to pure recognition networks (e.g., deep convolutional networks), has also been significantly improved by employing the discriminative max-margin learning [18].\nFor the arguably more challenging unsupervised learning, [5] presents a generative adversarial network (GAN), which adopts a game-theoretical min-max optimization formalism. GAN has been extended with success in various tasks [1, 21]. However, the min-max formalism is often hard to solve. The recent work [3, 19] presents generative moment matching networks (GMMN), which has a simpler objective function than GAN while retaining the advantages of deep learning. GMMN defines a generative model by sampling from some simple distribution (e.g., uniform) followed through a parametric deep network. To learn the parameters, GMMN adopts maximum mean discrepancy (MMD) [7], a moment matching criterion where kernel mean embedding techniques are used to avoid unnecessary assumptions of the distributions. Back-propagation can be used to calculate the gradient as long as the kernel function is smooth.\nA GMMN network estimates the joint distribution of a set of variables. However, we are more interested in a conditional distribution in many cases, including (1) predictive modeling: compared to a generative model that defines the joint distribution p(x,y) of input data x and response variable y, a conditional model p(y|x) is often more direct without unnecessary assumptions on modeling x, and leads to better performance with fewer training examples [16, 23]; (2) contextual generation: in some cases, we are interested in generating samples based on some context, such as class labels [21], visual attributes [32] or the input information in cross-modal generation (e.g., from image to text [31] or vice versa [2]); and (3) building large networks: conditional distributions are essential building blocks of a large generative probabilistic model. One recent relevant work [1] provides a good example of stacking multiple conditional GAN networks [21] in a Laplacian pyramid structure to generate natural images.\nar X\niv :1\n60 6.\n04 21\n8v 1\n[ cs\n.L G\n] 1\n4 Ju\nn 20\n16\nIn this paper, we present conditional generative moment-matching networks (CGMMN) to learn a flexible conditional distribution when some input variables are given. CGMMN largely extends the capability of GMMN to address a wide range of application problems as mentioned above, while keeping the training process simple. Specifically, CGMMN admits a simple generative process, which draws a sample from a simple distribution and then passes the sample as well as the given conditional variables through a deep network to generate a target sample. To learn the parameters, we develop conditional maximum mean discrepancy (CMMD), which measures the Hilbert-Schmidt norm (generalized Frobeniu norm) between the kernel mean embedding of an empirical conditional distribution and that of our generative model. Thanks to the simplicity of the conditional generative model, we can easily draw a set of samples to estimate the kernel mean embedding as well as the CMMD objective. Then, optimizing the objective can be efficiently implemented via back-propagation. We evaluate CGMMN in a wide range of tasks, including predictive modeling, contextual generation, and Bayesian dark knowledge [15], an interesting case of distilling dark knowledge from Bayesian models. Our results on various datasets demonstrate that CGMMN can obtain competitive performance in all these tasks."
    }, {
      "heading" : "2 Preliminary",
      "text" : "In this section, we briefly review some preliminary knowledge, including maximum mean discrepancy (MMD) and kernel embedding of conditional distributions."
    }, {
      "heading" : "2.1 Hilbert Space Embedding",
      "text" : "We begin by providing an overview of Hilbert space embedding, where we represent distributions by elements in a reproducing kernel Hilbert space (RKHS). A RKHS F on X with kernel k is a Hilbert space of functions f : X → R. Its inner product 〈·, ·〉F satisfies the reproducing property: 〈f(·), k(x, ·)〉F = f(x). Kernel functions are not restricted on Rd. They can also be defined on graphs, time series and structured objects [11]. We usually view φ(x) := k(x, ·) as a (usually infinite dimension) feature map of x. The most interesting part is that we can embed a distribution by taking expectation on its feature map:\nµX := EX [φ(X)] = ∫\nΩ\nφ(X)dP (X).\nIf EX [k(X,X)] ≤ ∞, µX is guaranteed to be an element in the RKHS. This kind of kernel mean embedding provides us another perspective on manipulating distributions whose parametric forms are not assumed, as long as we can draw samples from them. This technique has been widely applied in many tasks, including feature extractor, density estimation and two-sample test [7, 27]."
    }, {
      "heading" : "2.2 Maximum Mean Discrepancy",
      "text" : "Let X = {xi}Ni=1 and Y = {yi}Mj=1 be the sets of samples from distributions PX and PY , respectively. Maximum Mean Discrepancy (MMD), also known as kernel two sample test [7], is a frequentist estimator to answer the query whether PX = PY based on the observed samples. The basic idea behind MMD is that if the generating distributions are identical, all the statistics are the same. Formally, MMD defines the following difference measure:\nMMD[K, PX , PY ] := sup f∈K (EX [f(X)]− EY [f(Y )]),\nwhere K is a class of functions. [7] found that the class of functions in an universal RKHS F is rich enough to distinguish any two distributions and MMD can be expressed as the difference of their mean embeddings. Here, universality requires that k(·, ·) is continuous and F is dense in C(X) with respect to the L∞ norm, where C(X) is the space of bounded continuous functions on X . We summarize the result in the following theorem:\nTheorem 1 [7] Let K be a unit ball in a universal RKHS F , defined on the compact metric space X , with an associated continuous kernel k(·, ·). When the mean embedding µp, µq ∈ F , the MMD objective function can be expressed as MMD[K, p, q] = ‖µp − µq‖2F . Besides, MMD[K, p, q] = 0 if and only if p = q.\nIn practice, an estimate of the MMD objective compares the square difference between the empirical kernel mean embeddings:\nL̂2MMD = ∥∥∥∥∥∥ 1N N∑ i=1 φ(xi)− 1 M M∑ j=1 φ(yi) ∥∥∥∥∥∥ 2\nF\n,\nwhich can be easily evaluated by expanding the square and using the associated kernel k(·, ·). Asymptotically, L̂2MMD is an unbiased estimator."
    }, {
      "heading" : "2.3 Kernel Embedding of Conditional Distributions",
      "text" : "The kernel embedding of a conditional distribution P (Y |X) is defined as: µY |x := EY |x[φ(Y )] =∫ Ω φ(y)dP (y|x). Unlike the embedding of a single distribution, the embedding of a conditional distribution is not a single element in RKHS, but sweeps out a family of points in the RKHS, each indexed by a fixed value of x. Formally, the embedding of a conditional distribution is represented as an operator CY |X , which satisfies the following properties:\n1. µY |x = CY |Xφ(x); 2. EY |x[g(Y )|x] = 〈g, µY |x〉G , (1)\nwhere G is the RKHS corresponding to Y . [29] found that such an operator exists under some assumptions, using the technique of crosscovariance operator CXY : G → F :\nCXY := EXY [φ(X)⊗ φ(Y )]− µX ⊗ µY ,\nwhere ⊗ is the tensor product. An interesting property is that CXY can also be viewed as an element in the tensor product space G ⊗ F . The result is summarized as follows.\nTheorem 2 [29] Assuming that EY |X [g(Y )|X] ∈ F , the embedding of conditional distributions CY |X defined as CY |X := CY XC−1XX satisfies properties 1 and 2.\nGiven a dataset DXY = {(xi,yi)}Ni=1 of size N drawn i.i.d. from P (X,Y ), we can estimate the conditional embedding operator as ĈY |X = Φ(K + λI)−1Υ>, where Φ = (φ(y1), ..., φ(yN )),Υ = (φ(x1), ..., φ(xN )),K = Υ\n>Υ and λ serves as regularization. The estimator is an element in the tensor product space F ⊗G and satisfies properties 1 and 2 asymptotically. When the domain of X is finite, we can also estimate C−1XX and CY X directly (See Appendix A.2.2 for more details)."
    }, {
      "heading" : "3 Conditional Generative Moment-Matching Networks",
      "text" : "We now present CGMMN, including a conditional maximum mean discrepancy criterion as the training objective, a deep generative architecture and a learning algorithm."
    }, {
      "heading" : "3.1 Conditional Maximum Mean Discrepancy",
      "text" : "Given conditional distributions PY |X and PZ|X , we aim to test whether they are the same in the sense that when X = x is fixed whether PY |x = PZ|x holds or not. When the domain of X is finite, a straightforward solution is to test whether PY |x = PZ|x for each x separately by using MMD. However, this is impossible when X is continuous. Even in the finite case, as the separate tests do not share statistics, we may need an extremely large number of training data to test a different model for each single value of x. Below, we present a conditional maximum mean discrepancy criterion, which avoids the above issues.\nRecall the definition of kernel mean embedding of conditional distributions. When X = x is fixed, we have the kernel mean embedding µY |x = CY |Xφ(x). As a result, if we have CY |X = CZ|X , then µY |x = µZ|x is also satisfied for every fixed x. By the virtue of Theorem 1, that PY |x = PZ|x follows as the following theorem states.\nTheorem 3 Assuming thatF is a universal RKHS with an associated kernel k(·, ·), EY |X [g(Y )|X] ∈ F , EZ|X [g(Z)|X] ∈ F and CY |X , CZ|X ∈ F ⊗ G. If the embedding of conditional distributions CY |X = CZ|X , then PY |X = PZ|X in the sense that for every fixed x, we have PY |x = PZ|x.\nThe above theorem gives us a sufficient condition to guarantee that two conditional distributions are the same. We use the operators to measure the difference of two conditional distributions and we call it conditional maximum mean discrepancy (CMMD), which is defined as follows:\nL2CMMD = ∥∥CY |X − CZ|X∥∥2F⊗G .\nSuppose we have two sample sets DsXY = {(xi,yi)}Ni=1 and DdXY = {(xi,yi)}Mi=1. Similar as in MMD, in practice we compare the square difference between the empirical estimates of the conditional embedding operators:\nL̂2CMMD = ∥∥∥ĈdY |X − ĈsY |X∥∥∥2F⊗G ,\nwhere the superscripts s and d denote the two sets of samples, respectively. For notation clarity, we define K̃ = K + λI . Then, using kernel tricks, we can compute the difference only in term of kernel gram matrices:\nL̂2CMMD = ∥∥Φd(Kd + λI)−1Υ>d − Φs(Ks + λI)−1Υ>s ∥∥2F⊗G\n=Tr ( KdK̃ −1 d LdK̃ −1 d ) + Tr ( KsK̃ −1 s LsK̃ −1 s ) − 2 · Tr ( KsdK̃ −1 d LdsK̃ −1 s ) ,\n(2)\nwhere Φd := (φ(yd1), ..., φ(y d N )) and Υd := (φ(x d 1), ..., φ(x d N )) are implicitly formed feature matrices, Φs and Υs are defined similarly for dataset DsXY . Kd = Υ>d Υd and Ks = Υ>s Υs are the gram matrices for input variables, while Ld = Φ>d Φd and Ls = Φ > s Φs are the gram matrices for output variables. Finally, Ksd = Υ>s Υd and Lds = Φ > d Φs are the gram matrices between the two datasets on input and out variables, respectively.\nIt is worth mentioning that we have assumed that the conditional mean embedding operator CY |X ∈ F ⊗ G to have the CMMD objective well-defined, which needs some smoothness assumptions such that C−3/2XX CXY is Hilbert-Schmidt [8]. In practice, the assumptions may not hold, however, the empirical estimator Φ(K + λI)−1Υ> is always an element in the tensor product space which gives as a well-justified approximation (i.e., the Hilbert-Schmidt norm exists) for practical use [29].\nRemark 1 Taking a close look on the objectives of MMD and CMMD, we can find some interesting connections. Suppose N = M . By omitting the constant scalar, the objective function of MMD can be rewritten as L̂2MMD = Tr(Ld · 1) + Tr(Ls · 1)− 2 · Tr(Lds · 1), where 1 is the matrix with all entities equaling to 1. The objective function of CMMD can be expressed as L̂2CMMD = Tr(Ld · C1) + Tr(Ls · C2)− 2 · Tr(Lds · C3), where C1, C2, C3 are some matrices based on the conditional variables x in both data sets. The difference is that instead of putting uniform weights on the gram matrix as in MMD, CMMD applies non-uniform weights, reflecting the influence of conditional variables. Similar observations have been shown in [29] for the conditional mean operator, where the estimated conditional embedding µY |x is a non-uniform weighted combination of φ(xi)."
    }, {
      "heading" : "3.2 CGMMN Nets",
      "text" : "We now present a conditional DGM and train it by the CMMD criterion. One desirable property of the DGM is that we can easily draw samples from it to estimate the CMMD objective. Below, we present such a network that takes both the given conditional variables and an extra set of random variables as inputs, and then passes through a deep neural network with nonlinear transformations to produce the samples of the target variables.\nSpecifically, our network is built on the fact that for any distribution P on sample space K and any continuous distribution Q on L that are regular enough, there is a function G : L → K such that G(x) ∼ P , where x ∼ Q [12]. This fact has been recently explored by [3, 19] to define a deep generative model and estimate the parameters by the MMD criterion. For a conditional model, we would like the function G to depend on the given values of input variables. This can be fulfilled via a process as illustrated in Fig. 1, where the inputs of a deep neural network (DNN) consist of two parts — the input variables x and an extra set of stochastic variables H ∈ Rd that follow some continuous\ndistribution. For simplicity, we put a uniform prior on each hidden unit p(h) = d∏ i=1 U(hi), where U(h) = I(0≤h≤1) is a uniform distribution on [0, 1] and I(·) is the indicator function that equals to 1 if the predicate holds and 0 otherwise. After passing both x and h through the DNN, we get a sample from the conditional distribution P (Y |x): y = f(x,h|w), where f denotes the deterministic mapping function represented by the network with parametersw. By default, we concatenate x and h and fill x̃ = (x,h) into the network. In this case, we have y = f(x̃|w).\nDue to the flexibility and rich capability of DNN on fitting nonlinear functions, this generative process can characterize various conditional distributions well. For example, a simple network can consist of multiple layer perceptrons (MLP) activated by some non-linear functions such as the rectified linear unit (ReLu) [22]. Of course the hidden layer is not restricted to MLP, as long as it supports gradient propagation. We also use convolutional neural networks (CNN) as hidden layers [25] in our experiments. It is worth mentioning that there exist other ways to combine the conditional variables x with the auxiliary variables H . For example, we can add a corruption noise to the conditional variables x to produce the input of the\nnetwork, e.g., define x̃ = x+ h, where h may follow a Gaussian distribution N (0, ηI) in this case. With the above generative process, we can train the network by optimizing the CMMD objective with proper regularization. Specifically, let DsXY = {(xdi ,ydi )}Ni=1 denote the given training dataset. To estimate the CMMD objective, we draw a set of samples from the above generative model, where the conditional variables can be set by sampling from the training set with/without small perturbation (More details are in the experimental section). Thanks to its simplicity, the sampling procedure can be easily performed. Precisely, we provide each x in the training dataset to the generator to get a new sample and we denote DdXY = {(xsi ,ysi )}Mi=1 as the generated samples. Then, we can optimize the CMMD objective in Eq. (2) by gradient descent. See more details in Appendix A.1.\nAlgorithm 1 Stochastic gradient descent for CGMMN 1: Input: Dataset D = {(xi,yi)}Ni=1 2: Output: Learned parameters w 3: Randomly divide training dataset D into mini batches 4: while Stopping criterion not met do 5: Draw a minibatch B from D; 6: For each x ∈ B, generate a y; and set B′ to contain all the generated (x,y); 7: Compute the gradient ∂L̂\n2 CMMD ∂w on B and B ′; 8: Update w using the gradient with proper regularizer. 9: end while\nNote that the inverse matrices K̃−1s and K̃ −1 d in the CMMD objective are independent of the model parameters, suggesting that we are not restricted to use differentiable kernels on the conditional variables x. Since the computation cost for kernel gram matrix grows cubically with the sample size, we present an mini-batch version algorithm in Alg. 1 and some discussions can be found in Appendix A.2.1."
    }, {
      "heading" : "4 Experiments",
      "text" : "We now present a diverse range of applications to evaluate our model, including predictive modeling, contextual generation and an interesting case of Bayesian dark knowledge [15]. Our results demonstrate that CGMMN is competitive in all the tasks."
    }, {
      "heading" : "4.1 Predictive Performance",
      "text" : ""
    }, {
      "heading" : "4.1.1 Results on MNIST dataset",
      "text" : "We first present the prediction performance on the widely used MINIST dataset, which consists of images in 10 classes. Each image is of size 28× 28 and the gray-scale is normalized to be in range [0, 1]. The whole dataset is divided into 3 parts with 50, 000 training examples, 10, 000 validation examples and 10, 000 testing examples.\nFor prediction task, the conditional variables are the images x ∈ [0, 1]28×28, and the generated sample is a class label, which is represented as a vector y ∈ R10+ and each yi denotes the confidence that x is in class i. We consider two types of architectures in CGMMN — MLP and CNN.\nWe compare our model, denoted as CGMMN in the MLP case and CGMMN-CNN in the CNN case, with Varitional Auto-encoder (VA) [14], which is an unsupervised DGM learnt by stochastic variational methods. To use VA for classification, a subsequent classifier is built — We first learn feature representations by VA and then learn a linear SVM on these features using Pegasos algorithm [26]. We also compare with maxmargin DGMs (denoted as MMVA with MLP as hidden layers and CMMVA in the CNN case) [18], which is a state-of-the-art DGM for prediction, and several other strong baselines, including Stochastic Pooling [33], Network in Network [20], Maxout Network [6] and Deeply-supervised nets (DSN) [17].\nIn the MLP case, the model architecture is shown in Fig. 1 with an uniform distribution for hidden variables of dimension 5. Note that since we do not need much randomness for the prediction task, this low-dimensional hidden space is sufficient. In fact, we did not observe much difference with a higher dimension (e.g., 20 or 50), which simply makes the training slower. The MLP has 3 hidden layers with hidden unit number (500, 200, 100) with the ReLu activation function. A minibatch size of 500 is adopted. In the CNN case, we use the same architecture as [18], where there are 32 feature maps in the first two convolutional layers and 64 feature maps in the last three hidden layers. An MLP of 500 hidden units is adopted at the end of convolutional layers. The ReLu activation function is used in the convoluational layers and sigmoid function in the last layer. We do not pre-train our model and a minibatch size of 500 is adopted as well. The total number of parameters in the network is comparable with the competitors [6, 17, 18, 20].\nIn both settings, we use AdaM [13] to optimize parameters. After training, we simply draw a sample from our model conditioned on the input image and choose the index of maximum element of y as its prediction.Table 1 shows the results. We can see that CGMMN-CNN is competitive with various state-of-the-art competitors that do not use data augumentation or multiple model voting (e.g., CMMVA). DSN benefits from using more supervision signal in every hidden layer and outperforms\nthe other competitors. 4.1.2 Results on SVHN dataset\nTable 2: Error rates (%) on SVHN dataset\nModel Error Rate CVA+Pegasos [18] 25.3 CGMMN-CNN 3.13 CNN [25] 4.9 CMMVA [18] 3.09 Stochastic Pooling [33] 2.80 Network in Network [20] 2.47 Maxout Network [6] 2.35 DSN [17] 1.92 We then report the prediction performance on the Street View House Numbers (SVHN) dataset. SVHN is a large dataset consisting of color images of size 32× 32 in 10 classes. The dataset consists of 598, 388 training examples, 6, 000 validation examples and 26, 032 testing examples. The task is significantly harder than classifying hand-written digits. Following [18, 25], we preprocess the data by Local Contrast Normalization (LCN). The architecture of out network is similar to that in MNIST and we only use CNN as middle layers here. A minibatch size of 300 is used and the other settings are the same as the MNIST experiments.\nTable 2 shows the results. Through there is a gap between our CGMMN and some discriminative deep networks such as DSN, our results are comparable with those of CMMVA, which the state-of-the-art DGM for prediction. CGMMN is compatible with various network architectures and we are expected to get better results with more sophisticated structures."
    }, {
      "heading" : "4.2 Generative Performance",
      "text" : ""
    }, {
      "heading" : "4.2.1 Results on MNIST dataset",
      "text" : "We first test the generating performance on the widely used MNIST dataset. For generating task, the conditional variables are the image labels. Since y takes a finite number of values, as mentioned in Sec. 2.3, we estimate CY X and C−1XX directly and combine them as the estimation of CY |X (See Appendix A.2.2 for practical details).\nThe architecture is the same as before but exchanging the position of x and y. For the input layer, besides the label information y as conditional variables (represented by a one-hot-spot vector of dimension 10), we further draw a sample from a uniform distribution of dimension 20, which is sufficiently large. Overall, the network is a 5-layer MLP with input dimension 30 and the middle layer hidden unit number (64, 256, 256, 512), and the output layer is of dimension 28× 28, which represents the image in pixel. A minibatch of size 200 is adopted.\nFig. 2 shows some samples generated using our CGMMN, where in (b) the conditional variable y is randomly chosen from the 10 possible values, and in (c) y is pre-fixed at class 0. As we can see, when conditioned on label 0, almost all the generated samples are really in that class.\nAs in [19], we investigate whether the models learn to merely copy the data. We visualize the nearest neighbors in the MNIST dataset of several samples generated by CGMMN in terms of Euclidean pixelwise distance [5] in Fig. 3. As we can see, by this metric, the samples are not merely the copy.\nAs also discussed in [19], real-world data can be complicated and high-dimensional and autoencoder can be good at representing data in a code space that captures enough statistical information to reliably reconstruct the data. For example, visual data, while represented in a high dimension often exists on a low-dimensional manifold. Thus it is beneficial to combine autoencoders with our CGMMN models to generate more smooth images, in contrast to Fig. 2 where there are some noise in the generated samples. Precisely, we first learn an auto-encoder and produce code representations of the training data, then freeze the auto-encoder weights and learn a CGMMN to minimize the CMMD objective between the generated codes using our CGMMN and the training data codes. The generating results are shown in Fig. 4. Comparing to Fig. 2, the samples are more clear."
    }, {
      "heading" : "4.2.2 Results on Yale Face dataset",
      "text" : "We now show the generating results on the Extended Yale Face dataset [9], which contains 2, 414 grayscale images for 38 individuals of dimension 32× 32. There are about 64 images per subject, one per different facial expression or configuration. A smaller version of the dataset consists of 165 images of 15 individuals and the generating result can be found in Appendix A.4.2.\nWe adopt the same architecture as the first generating experiment for MNIST, which is a 5-layer MLP with an input dimension of 50 (12 hidden variables and 38 dimensions for conditional variables, i.e., labels) and the middle layer hidden unit number (64, 256, 256, 512). A mini-batch size of 400 is adopted. The other settings are the same as in the MNIST experiment. The overall generating results are shown in Fig. 5, where we really generate diverse images for different individuals. Again, as shown in Appendix A.4.1, the generated samples are not merely the copy of training data.\n4.3 Distill Bayesian Models\nOur final experiment is to apply CGMMN to distill knowledge from Bayesian models by learning a conditional distribution model for efficient prediction. Specifically, let θ denote the random variables. A Bayesian model first computes the posterior distribution given the training set D = {(xi,yi)}Ni=1 as p(θ|D). In the prediction stage, given a new input x, a response sample y is generated via probability p(y|x,D) =∫ p(y|x,θ)p(θ|D)dθ. This procedure usually involves a complicated integral thus is time consuming. [15] show that we can learn a relatively simple student network to distill knowledge from the teacher network (i.e., the Bayesian model) and approximately represent the predictive distribution p(y|x,D) of the teacher network.\nOur CGMMN provides a new solution to build such a student network for Bayesian dark knowledge. To learn CGMMN, we need two datasets to estimate the CMMD objective — one is\ngenerated by the teacher network and the other one is generated by CGMMN. The former sampled dataset serves as the training dataset for our CGMMN and the latter one is generated during the training process of it. For high-dimensional data, adopting the same strategy as [15], we sample “near\" the training data to generate the former dataset (i.e., perturbing the inputs in the training set slightly before sending to the teacher network to sample y).\nDue to the space limitation, we test our model on a regression problem on the Boston housing dataset, which was also used in [10, 15], while deferring the other results on a synthetic dataset to Appendix A.3. The dataset consists of 506 data points where each data is of dimension 13. We first train a PBP model [10], which is a scalable method for posterior inference in Bayesian neural networks, as the teacher and then distill it using our CGMMN model. We test whether the distilled model will degrade the prediction performance.\nWe distill the PBP model [10] using an MLP network with three hidden layers and (100, 50, 50) hidden units for middle layers. We draw N = 3, 000 sample pairs {(xi, yi)}Ni=1 from the PBP network, where xi is the input variables that\nserve as conditional variables in our model. For a fair comparison, xi is generated by adding noise into training data to avoid fitting the testing data directly. We evaluate the prediction performance on the original testing data by root mean square error (RMSE). Table 3 shows the results. We can see that the distilled model does not harm the prediction performance. It is worth mentioning that we are not restricted to distill knowledge from PBP. In fact, any Bayesian models can be distilled using CGMMN."
    }, {
      "heading" : "5 Conclusions and Discussions",
      "text" : "We present conditional generative moment-matching networks (CGMMN), which is a flexible framework to represent conditional distributions. CGMMN largely extends the ability of previous DGM based on maximum mean discrepancy (MMD) while keeping the training process simple as well, which is done by back-propagation. Experimental results on various tasks, including predictive modeling, data generation and Bayesian dark knowledge, demonstrate competitive performance.\nConditional modeling has been practiced as a natural step towards improving the discriminative ability of a statistical model and/or relaxing unnecessary assumptions of the conditional variables. For deep learning models, sum product networks (SPN) [24] provide exact inference on DGMs and its conditional extension [4] improves the discriminative ability; and the recent work [21] presents a conditional version of the generative adversarial networks (GAN) [5] with wider applicability. Besides, the recent proposed conditional variational autoencoder [28] also works well on structured prediction. Our work fills the research void to significantly improve the applicability of momentmatching networks."
    }, {
      "heading" : "Acknowledgments",
      "text" : "The work was supported by the National Basic Research Program (973 Program) of China (Nos. 2013CB329403, 2012CB316301), National NSF of China (Nos. 61322308, 61332007), Tsinghua TNList Lab Big Data Initiative, and Tsinghua Initiative Scientific Research Program (Nos. 20121088071, 20141080934)."
    }, {
      "heading" : "A Appendix",
      "text" : "A.1 Gradient Calculation\nThe CMMD objective can be optimized by gradient descent. Precisely, for any network parameter w, we have that:\n∂L̂2CMMD ∂w = M∑ i=1 ∂L̂2CMMD ∂ysi ∂ysi ∂w ,\nwhere the term ∂ysi ∂w\ncan be calculated via back-propagation throughout the DNN and we use the chain rule to compute\n∂L̂2CMMD ∂ysi = Tr\n( K̃−1s KsK̃ −1 s\n∂Ls ∂ysi\n) − 2 · Tr ( K̃−1s KsdK̃ −1 d\n∂Lds ∂ysi\n) .\nThe derivative of the kernel gram matrix (i.e., ∂Ls ∂ysi and ∂Lds ∂ysi ) can be calculated directly as long as the kernel function of output samples y is differentiable, e.g., Gaussian RBF kernel kσ(y,y′) = exp{−‖y−y\n′‖2 2σ2 }.\nA.2 Implementation details\nHere we list some practical considerations to improve the performance of our models.\nA.2.1 Minibatch Training The CMMD objective and its gradient involve an inverse operation on matrix such as Kd +λI , which has O(N3) time complexity to compute. This is unbearable when the data size is large. Here, we present a minibatch based training algorithm to learn the CGMMN models. Specifically, in each training epoch, we first choose a small subset B ⊂ D and generate an equal number of samples based on the observation x ∈ B (i.e., we provide each x ∈ B to the generator to get a new sample). The overall algorithm is provided in Alg. 1. To further accelerate the algorithm, we can pre-compute the inverse matrices K̃−1d and K̃ −1 s as cached data.\nEssentially, the algorithm uses a single mini-batch to approximate the whole dataset. When the dataset is “simple\" such as MNIST, a mini-batch of size 200 is enough to represent the whole dataset, however, for more complex datasets, larger mini-bath size is needed.\nA.2.2 Finite Case for Conditional Variables Recall the empirical estimator of conditional kernel embedding operator as mentioned in Sec. 2.3: ĈY |X = Φ(K + λI)\n−1Υ>, where we need to compute the inverse of kernel gram matrix of the condition variables. Since the domain of the variables is finite, the gram matrix is not invertible in most cases. Although we can impose a λ to make the gram matrix invertible forcibly, this method cannot get the best result in practice. Besides, the main effect of λ is serving as regularization to avoid overfitting, not to make the gram matrix invertible [8].\nFortunately, the problem can be avoided by choosing special kernels and estimating the conditional operator directly. More precisely, we use Kronechker Delta kernel on conditioned variables X , i.e., k(x, x′) = δ(x, x′). Suppose that x ∈ {1, ...,K}, then the corresponding feature map φ(x) is the standard basis of ex ∈ RK . Recall that CY |X = CY XC−1XX , instead of using the estimation before, we now can estimate C−1XX directly since it can be expressed as follows:\nC−1XX = P (x = 1) ... 0. . . 0 ... p(x = K)  −1 .\nObviously, the problem of inverse operator disappears.\nA.2.3 Kernel Choosing\nIn general, we adopted Gaussian kernels as in GMMN. We also tried the strategy that combines several Gaussian kernels with different bandwidths, but it didn’t make noticeable difference.\nWe tuned the bandwidth on the training set, and found that the bandwidth is appropriate if the distance of two samples (i.e., ‖x− y‖2/σ2) is in range [0, 1].\nA.3 Distill Knowledge from Bayesian Models\nWe evaluate our model on a toy dataset, following the setting in [15]. Specifically, the dataset is generated by random sampling 20 one-dimensional inputs x uniformly in the interval [−4, 4]. For each x, the response variable y is computed as y = x3 + , where ∼ N (0, 9). We first fit the data using probabilistic backpropagation (PBP) [10], which is a scalable method for posterior inference in Bayesian neural networks. Then we use CGMMN with a two-layer MLP architecture, which is of size (100, 50), to distill the knowledge for the PBP network (same architecture as CGMMN) using 3, 000 samples that are generated from it.\nFig. 6 shows the distilled results. We can see that the distilled model is highly similar with the original one, especially on the mean estimation.\nA.4 More Results on Yale Face Dataset\nA.4.1 Interpolation for Extended Yale Face samples\nOne of the interesting aspects of a deep generative model is that it is possible to directly explore the data manifold. As well as to verify that our CGMMN will not merely copy the training data, we perform linear interpolation on the first dimension of the hidden variables and set the other dimensions to be 0. Here we use the same settings as in Sec. 4.2.2.\nFig. 7 shows the result. Each column is conditioned on a different individual and we can find that for each individual, as the value of the first dimension varies, the generated samples have the same varying trend in a continuous manner. This result verifies that our model has a good latent representation for the training data and will not merely copy the training dataset.\nA.4.2 Results for smaller version of Yale Face Dataset\n(a) Different individuals (b) Individual 15\nwide diversity of different individuals. Obviously, our CGMMN will not merely copy the training dataset since each figure of (b) in Fig. 8 is meaningful and unique."
    } ],
    "references" : [ {
      "title" : "Deep generative image models using a laplacian pyramid of adversarial networks",
      "author" : [ "E. Denton", "S. Chintala", "A. Szlam", "R. Fergus" ],
      "venue" : "NIPS",
      "citeRegEx" : "1",
      "shortCiteRegEx" : null,
      "year" : 2015
    }, {
      "title" : "Learning to generate chairs",
      "author" : [ "A. Dosovitskiy", "J. Springenberg", "M. Tatarchenko", "T. Brox" ],
      "venue" : "tables and cars with convolutional networks. arXiv:1411.5928",
      "citeRegEx" : "2",
      "shortCiteRegEx" : null,
      "year" : 2015
    }, {
      "title" : "Training generative neural networks via maximum mean discrepancy optimization",
      "author" : [ "G. Dziugaite", "D. Roy", "Z. Ghahramani" ],
      "venue" : "UAI",
      "citeRegEx" : "3",
      "shortCiteRegEx" : null,
      "year" : 2015
    }, {
      "title" : "Discriminative learning of sum-product networks",
      "author" : [ "R. Gens", "P. Domingos" ],
      "venue" : "NIPS",
      "citeRegEx" : "4",
      "shortCiteRegEx" : null,
      "year" : 2012
    }, {
      "title" : "Generative adverisarial nets",
      "author" : [ "I. Goodfellow", "J. Pouget-Abadie", "M. Mirza", "B. Xu", "D. Warde-Farley", "S. Ozair", "A. Courville", "Y. Bengio" ],
      "venue" : "NIPS",
      "citeRegEx" : "5",
      "shortCiteRegEx" : null,
      "year" : 2014
    }, {
      "title" : "Maxout networks",
      "author" : [ "I. Goodfellow", "D. Warde-Farley", "M. Mirza", "A. Courville", "Y. Bengio" ],
      "venue" : "ICML",
      "citeRegEx" : "6",
      "shortCiteRegEx" : null,
      "year" : 2013
    }, {
      "title" : "A kernel two-sample test",
      "author" : [ "A. Gretton", "K. Borgwardt", "M. Rasch", "B. Scholkopf", "A. Smola" ],
      "venue" : "JMLR",
      "citeRegEx" : "7",
      "shortCiteRegEx" : null,
      "year" : 2008
    }, {
      "title" : "Conditional mean embedding as regressors",
      "author" : [ "S. Grunewalder", "G. Lever", "L. Baldassarre", "S. Patterson", "A. Gretton", "M. Pontil" ],
      "venue" : "ICML",
      "citeRegEx" : "8",
      "shortCiteRegEx" : null,
      "year" : 2012
    }, {
      "title" : "Face recognition using laplacianfaces",
      "author" : [ "X. He", "S. Yan", "Y. Hu", "P. Niyogi", "H. Zhang" ],
      "venue" : "IEEE Trans. Pattern Anal. Mach. Intelligence, 27(3):328–340",
      "citeRegEx" : "9",
      "shortCiteRegEx" : null,
      "year" : 2005
    }, {
      "title" : "Probabilistic backpropagation for scalable learning of bayesian neural networks",
      "author" : [ "J. Hernandez-Lobato", "R. Adams" ],
      "venue" : "ICML",
      "citeRegEx" : "10",
      "shortCiteRegEx" : null,
      "year" : 2015
    }, {
      "title" : "Kernel methods in machine learning",
      "author" : [ "T. Hofmann", "B. Scholkopf", "A. Smola" ],
      "venue" : "The Annals of Statistics, 36(3):1171–1220",
      "citeRegEx" : "11",
      "shortCiteRegEx" : null,
      "year" : 2008
    }, {
      "title" : "Foundations of modern probability",
      "author" : [ "O. Kallenbery" ],
      "venue" : "New York: Springer",
      "citeRegEx" : "12",
      "shortCiteRegEx" : null,
      "year" : 2002
    }, {
      "title" : "Adam: A method for stochastic optimization",
      "author" : [ "D. Kingma", "J. Ba" ],
      "venue" : "ICLR",
      "citeRegEx" : "13",
      "shortCiteRegEx" : null,
      "year" : 2015
    }, {
      "title" : "Auto-encoding variational bayes",
      "author" : [ "D. Kingma", "M. Welling" ],
      "venue" : "ICLR",
      "citeRegEx" : "14",
      "shortCiteRegEx" : null,
      "year" : 2014
    }, {
      "title" : "Bayesian dark knowledge",
      "author" : [ "A. Korattikara", "V. Rathod", "K. Murphy", "M. Welling" ],
      "venue" : "NIPS",
      "citeRegEx" : "15",
      "shortCiteRegEx" : null,
      "year" : 2015
    }, {
      "title" : "Conditional random fields: Probabilistic models for segmenting and labeling sequence data",
      "author" : [ "J. Lafferty", "A. McCallum", "F. Pereira" ],
      "venue" : "ICML",
      "citeRegEx" : "16",
      "shortCiteRegEx" : null,
      "year" : 2001
    }, {
      "title" : "Deeply-supervised nets",
      "author" : [ "C. Lee", "S. Xie", "P. Gallagher", "Z. Zhang", "Z. Tu" ],
      "venue" : "AISTATS",
      "citeRegEx" : "17",
      "shortCiteRegEx" : null,
      "year" : 2015
    }, {
      "title" : "Max-margin deep generative models",
      "author" : [ "C. Li", "J. Zhu", "T. Shi", "B. Zhang" ],
      "venue" : "NIPS",
      "citeRegEx" : "18",
      "shortCiteRegEx" : null,
      "year" : 2015
    }, {
      "title" : "Generative moment matching networks",
      "author" : [ "Y. Li", "K. Swersky", "R. Zemel" ],
      "venue" : "ICML",
      "citeRegEx" : "19",
      "shortCiteRegEx" : null,
      "year" : 2015
    }, {
      "title" : "Network in network",
      "author" : [ "M. Lin", "Q. Chen", "S. Yan" ],
      "venue" : "ICLR",
      "citeRegEx" : "20",
      "shortCiteRegEx" : null,
      "year" : 2014
    }, {
      "title" : "Conditional generative adversarial nets",
      "author" : [ "M. Mirza", "S. Osindero" ],
      "venue" : "ArXiv:1411.1784v1",
      "citeRegEx" : "21",
      "shortCiteRegEx" : null,
      "year" : 2014
    }, {
      "title" : "Rectified linear units improve restricted boltzmann machines",
      "author" : [ "V. Nair", "G. Hinton" ],
      "venue" : "ICML",
      "citeRegEx" : "22",
      "shortCiteRegEx" : null,
      "year" : 2010
    }, {
      "title" : "On discriminative vs",
      "author" : [ "A. Ng", "M.I. Jordan" ],
      "venue" : "generative classifiers: a comparison of logistic regression and naive bayes. NIPS",
      "citeRegEx" : "23",
      "shortCiteRegEx" : null,
      "year" : 2001
    }, {
      "title" : "Sum-product networks: A new deep architecture",
      "author" : [ "H. Poon", "P. Domingos" ],
      "venue" : "UAI",
      "citeRegEx" : "24",
      "shortCiteRegEx" : null,
      "year" : 2011
    }, {
      "title" : "Convolutional neural networks applied to house numbers digit classification",
      "author" : [ "P. Sermanet", "S. Chintala", "Y. Lecun" ],
      "venue" : "ICPR",
      "citeRegEx" : "25",
      "shortCiteRegEx" : null,
      "year" : 2012
    }, {
      "title" : "Pegasos: Primal estimated sub-gradient solver for svm",
      "author" : [ "S. Shalev-Shwartz", "Y. Singer", "N. Srebro", "A. Cotter" ],
      "venue" : "Mathmetical Programming, Series B",
      "citeRegEx" : "26",
      "shortCiteRegEx" : null,
      "year" : 2011
    }, {
      "title" : "A hilbert space embedding for distributions",
      "author" : [ "A. Smola", "A. Gretton", "L. Song", "B. Scholkopf" ],
      "venue" : "International Conference on Algorithmic Learning Theory",
      "citeRegEx" : "27",
      "shortCiteRegEx" : null,
      "year" : 2007
    }, {
      "title" : "Learning structured output representation using deep conditional generative models",
      "author" : [ "K. Sohn", "X. Yan", "H. Lee" ],
      "venue" : "NIPS",
      "citeRegEx" : "28",
      "shortCiteRegEx" : null,
      "year" : 2015
    }, {
      "title" : "Hilbert space embeddings of conditional distributions with applications to dynamical systems",
      "author" : [ "L. Song", "J. Huang", "A. Smola", "K. Fukumizu" ],
      "venue" : "ICML",
      "citeRegEx" : "29",
      "shortCiteRegEx" : null,
      "year" : 2009
    }, {
      "title" : "Multimodal learning with deep boltzmann machines",
      "author" : [ "N. Srivastava", "R. Salakhutdinov" ],
      "venue" : "NIPS",
      "citeRegEx" : "30",
      "shortCiteRegEx" : null,
      "year" : 2012
    }, {
      "title" : "Show and tell: A neural image caption generator",
      "author" : [ "O. Vinyals", "A. Toshev", "S. Bengio", "D. Erhan" ],
      "venue" : "arXiv:1411.4555v2",
      "citeRegEx" : "31",
      "shortCiteRegEx" : null,
      "year" : 2015
    }, {
      "title" : "Attribute2image: Conditional image generation from visual attributes",
      "author" : [ "X. Yan", "J. Yang", "K. Sohn", "H. Lee" ],
      "venue" : "arXiv:1512.00570",
      "citeRegEx" : "32",
      "shortCiteRegEx" : null,
      "year" : 2015
    }, {
      "title" : "Stochastic pooling for regularization of deep convolutional neural networks",
      "author" : [ "M. Zeiler", "R. Fergus" ],
      "venue" : "ICLR",
      "citeRegEx" : "33",
      "shortCiteRegEx" : null,
      "year" : 2013
    } ],
    "referenceMentions" : [ {
      "referenceID" : 0,
      "context" : "Among various deep learning methods, DGMs are natural choice for those tasks that require probabilistic reasoning and uncertainty estimation, such as image generation [1], multimodal learning [30], and missing data imputation.",
      "startOffset" : 167,
      "endOffset" : 170
    }, {
      "referenceID" : 29,
      "context" : "Among various deep learning methods, DGMs are natural choice for those tasks that require probabilistic reasoning and uncertainty estimation, such as image generation [1], multimodal learning [30], and missing data imputation.",
      "startOffset" : 192,
      "endOffset" : 196
    }, {
      "referenceID" : 17,
      "context" : ", deep convolutional networks), has also been significantly improved by employing the discriminative max-margin learning [18].",
      "startOffset" : 121,
      "endOffset" : 125
    }, {
      "referenceID" : 4,
      "context" : "For the arguably more challenging unsupervised learning, [5] presents a generative adversarial network (GAN), which adopts a game-theoretical min-max optimization formalism.",
      "startOffset" : 57,
      "endOffset" : 60
    }, {
      "referenceID" : 0,
      "context" : "GAN has been extended with success in various tasks [1, 21].",
      "startOffset" : 52,
      "endOffset" : 59
    }, {
      "referenceID" : 20,
      "context" : "GAN has been extended with success in various tasks [1, 21].",
      "startOffset" : 52,
      "endOffset" : 59
    }, {
      "referenceID" : 2,
      "context" : "The recent work [3, 19] presents generative moment matching networks (GMMN), which has a simpler objective function than GAN while retaining the advantages of deep learning.",
      "startOffset" : 16,
      "endOffset" : 23
    }, {
      "referenceID" : 18,
      "context" : "The recent work [3, 19] presents generative moment matching networks (GMMN), which has a simpler objective function than GAN while retaining the advantages of deep learning.",
      "startOffset" : 16,
      "endOffset" : 23
    }, {
      "referenceID" : 6,
      "context" : "To learn the parameters, GMMN adopts maximum mean discrepancy (MMD) [7], a moment matching criterion where kernel mean embedding techniques are used to avoid unnecessary assumptions of the distributions.",
      "startOffset" : 68,
      "endOffset" : 71
    }, {
      "referenceID" : 15,
      "context" : "However, we are more interested in a conditional distribution in many cases, including (1) predictive modeling: compared to a generative model that defines the joint distribution p(x,y) of input data x and response variable y, a conditional model p(y|x) is often more direct without unnecessary assumptions on modeling x, and leads to better performance with fewer training examples [16, 23]; (2) contextual generation: in some cases, we are interested in generating samples based on some context, such as class labels [21], visual attributes [32] or the input information in cross-modal generation (e.",
      "startOffset" : 383,
      "endOffset" : 391
    }, {
      "referenceID" : 22,
      "context" : "However, we are more interested in a conditional distribution in many cases, including (1) predictive modeling: compared to a generative model that defines the joint distribution p(x,y) of input data x and response variable y, a conditional model p(y|x) is often more direct without unnecessary assumptions on modeling x, and leads to better performance with fewer training examples [16, 23]; (2) contextual generation: in some cases, we are interested in generating samples based on some context, such as class labels [21], visual attributes [32] or the input information in cross-modal generation (e.",
      "startOffset" : 383,
      "endOffset" : 391
    }, {
      "referenceID" : 20,
      "context" : "However, we are more interested in a conditional distribution in many cases, including (1) predictive modeling: compared to a generative model that defines the joint distribution p(x,y) of input data x and response variable y, a conditional model p(y|x) is often more direct without unnecessary assumptions on modeling x, and leads to better performance with fewer training examples [16, 23]; (2) contextual generation: in some cases, we are interested in generating samples based on some context, such as class labels [21], visual attributes [32] or the input information in cross-modal generation (e.",
      "startOffset" : 519,
      "endOffset" : 523
    }, {
      "referenceID" : 31,
      "context" : "However, we are more interested in a conditional distribution in many cases, including (1) predictive modeling: compared to a generative model that defines the joint distribution p(x,y) of input data x and response variable y, a conditional model p(y|x) is often more direct without unnecessary assumptions on modeling x, and leads to better performance with fewer training examples [16, 23]; (2) contextual generation: in some cases, we are interested in generating samples based on some context, such as class labels [21], visual attributes [32] or the input information in cross-modal generation (e.",
      "startOffset" : 543,
      "endOffset" : 547
    }, {
      "referenceID" : 30,
      "context" : ", from image to text [31] or vice versa [2]); and (3) building large networks: conditional distributions are essential building blocks of a large generative probabilistic model.",
      "startOffset" : 21,
      "endOffset" : 25
    }, {
      "referenceID" : 1,
      "context" : ", from image to text [31] or vice versa [2]); and (3) building large networks: conditional distributions are essential building blocks of a large generative probabilistic model.",
      "startOffset" : 40,
      "endOffset" : 43
    }, {
      "referenceID" : 0,
      "context" : "One recent relevant work [1] provides a good example of stacking multiple conditional GAN networks [21] in a Laplacian pyramid structure to generate natural images.",
      "startOffset" : 25,
      "endOffset" : 28
    }, {
      "referenceID" : 20,
      "context" : "One recent relevant work [1] provides a good example of stacking multiple conditional GAN networks [21] in a Laplacian pyramid structure to generate natural images.",
      "startOffset" : 99,
      "endOffset" : 103
    }, {
      "referenceID" : 14,
      "context" : "We evaluate CGMMN in a wide range of tasks, including predictive modeling, contextual generation, and Bayesian dark knowledge [15], an interesting case of distilling dark knowledge from Bayesian models.",
      "startOffset" : 126,
      "endOffset" : 130
    }, {
      "referenceID" : 10,
      "context" : "They can also be defined on graphs, time series and structured objects [11].",
      "startOffset" : 71,
      "endOffset" : 75
    }, {
      "referenceID" : 6,
      "context" : "This technique has been widely applied in many tasks, including feature extractor, density estimation and two-sample test [7, 27].",
      "startOffset" : 122,
      "endOffset" : 129
    }, {
      "referenceID" : 26,
      "context" : "This technique has been widely applied in many tasks, including feature extractor, density estimation and two-sample test [7, 27].",
      "startOffset" : 122,
      "endOffset" : 129
    }, {
      "referenceID" : 6,
      "context" : "Maximum Mean Discrepancy (MMD), also known as kernel two sample test [7], is a frequentist estimator to answer the query whether PX = PY based on the observed samples.",
      "startOffset" : 69,
      "endOffset" : 72
    }, {
      "referenceID" : 6,
      "context" : "[7] found that the class of functions in an universal RKHS F is rich enough to distinguish any two distributions and MMD can be expressed as the difference of their mean embeddings.",
      "startOffset" : 0,
      "endOffset" : 3
    }, {
      "referenceID" : 6,
      "context" : "Theorem 1 [7] Let K be a unit ball in a universal RKHS F , defined on the compact metric space X , with an associated continuous kernel k(·, ·).",
      "startOffset" : 10,
      "endOffset" : 13
    }, {
      "referenceID" : 28,
      "context" : "[29] found that such an operator exists under some assumptions, using the technique of crosscovariance operator CXY : G → F :",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 28,
      "context" : "Theorem 2 [29] Assuming that EY |X [g(Y )|X] ∈ F , the embedding of conditional distributions CY |X defined as CY |X := CY XC XX satisfies properties 1 and 2.",
      "startOffset" : 10,
      "endOffset" : 14
    }, {
      "referenceID" : 7,
      "context" : "It is worth mentioning that we have assumed that the conditional mean embedding operator CY |X ∈ F ⊗ G to have the CMMD objective well-defined, which needs some smoothness assumptions such that C XX CXY is Hilbert-Schmidt [8].",
      "startOffset" : 222,
      "endOffset" : 225
    }, {
      "referenceID" : 28,
      "context" : ", the Hilbert-Schmidt norm exists) for practical use [29].",
      "startOffset" : 53,
      "endOffset" : 57
    }, {
      "referenceID" : 28,
      "context" : "Similar observations have been shown in [29] for the conditional mean operator, where the estimated conditional embedding μY |x is a non-uniform weighted combination of φ(xi).",
      "startOffset" : 40,
      "endOffset" : 44
    }, {
      "referenceID" : 11,
      "context" : "Specifically, our network is built on the fact that for any distribution P on sample space K and any continuous distribution Q on L that are regular enough, there is a function G : L → K such that G(x) ∼ P , where x ∼ Q [12].",
      "startOffset" : 220,
      "endOffset" : 224
    }, {
      "referenceID" : 2,
      "context" : "This fact has been recently explored by [3, 19] to define a deep generative model and estimate the parameters by the MMD criterion.",
      "startOffset" : 40,
      "endOffset" : 47
    }, {
      "referenceID" : 18,
      "context" : "This fact has been recently explored by [3, 19] to define a deep generative model and estimate the parameters by the MMD criterion.",
      "startOffset" : 40,
      "endOffset" : 47
    }, {
      "referenceID" : 0,
      "context" : "U(h) = I(0≤h≤1) is a uniform distribution on [0, 1] and I(·) is the indicator function that equals to 1 if the predicate holds and 0 otherwise.",
      "startOffset" : 45,
      "endOffset" : 51
    }, {
      "referenceID" : 21,
      "context" : "For example, a simple network can consist of multiple layer perceptrons (MLP) activated by some non-linear functions such as the rectified linear unit (ReLu) [22].",
      "startOffset" : 158,
      "endOffset" : 162
    }, {
      "referenceID" : 24,
      "context" : "We also use convolutional neural networks (CNN) as hidden layers [25] in our experiments.",
      "startOffset" : 65,
      "endOffset" : 69
    }, {
      "referenceID" : 14,
      "context" : "4 Experiments We now present a diverse range of applications to evaluate our model, including predictive modeling, contextual generation and an interesting case of Bayesian dark knowledge [15].",
      "startOffset" : 188,
      "endOffset" : 192
    }, {
      "referenceID" : 0,
      "context" : "Each image is of size 28× 28 and the gray-scale is normalized to be in range [0, 1].",
      "startOffset" : 77,
      "endOffset" : 83
    }, {
      "referenceID" : 0,
      "context" : "For prediction task, the conditional variables are the images x ∈ [0, 1]28×28, and the generated sample is a class label, which is represented as a vector y ∈ R + and each yi denotes the confidence that x is in class i.",
      "startOffset" : 66,
      "endOffset" : 72
    }, {
      "referenceID" : 17,
      "context" : "Table 1: Error rates (%) on MNIST dataset Model Error Rate VA+Pegasos [18] 1.",
      "startOffset" : 70,
      "endOffset" : 74
    }, {
      "referenceID" : 17,
      "context" : "04 MMVA [18] 0.",
      "startOffset" : 8,
      "endOffset" : 12
    }, {
      "referenceID" : 17,
      "context" : "97 CVA + Pegasos [18] 1.",
      "startOffset" : 17,
      "endOffset" : 21
    }, {
      "referenceID" : 32,
      "context" : "47 Stochastic Pooling [33] 0.",
      "startOffset" : 22,
      "endOffset" : 26
    }, {
      "referenceID" : 19,
      "context" : "47 Network in Network [20] 0.",
      "startOffset" : 22,
      "endOffset" : 26
    }, {
      "referenceID" : 5,
      "context" : "47 Maxout Network [6] 0.",
      "startOffset" : 18,
      "endOffset" : 21
    }, {
      "referenceID" : 17,
      "context" : "45 CMMVA [18] 0.",
      "startOffset" : 9,
      "endOffset" : 13
    }, {
      "referenceID" : 16,
      "context" : "45 DSN [17] 0.",
      "startOffset" : 7,
      "endOffset" : 11
    }, {
      "referenceID" : 13,
      "context" : "39 We compare our model, denoted as CGMMN in the MLP case and CGMMN-CNN in the CNN case, with Varitional Auto-encoder (VA) [14], which is an unsupervised DGM learnt by stochastic variational methods.",
      "startOffset" : 123,
      "endOffset" : 127
    }, {
      "referenceID" : 25,
      "context" : "To use VA for classification, a subsequent classifier is built — We first learn feature representations by VA and then learn a linear SVM on these features using Pegasos algorithm [26].",
      "startOffset" : 180,
      "endOffset" : 184
    }, {
      "referenceID" : 17,
      "context" : "We also compare with maxmargin DGMs (denoted as MMVA with MLP as hidden layers and CMMVA in the CNN case) [18], which is a state-of-the-art DGM for prediction, and several other strong baselines, including Stochastic Pooling [33], Network in Network [20], Maxout Network [6] and Deeply-supervised nets (DSN) [17].",
      "startOffset" : 106,
      "endOffset" : 110
    }, {
      "referenceID" : 32,
      "context" : "We also compare with maxmargin DGMs (denoted as MMVA with MLP as hidden layers and CMMVA in the CNN case) [18], which is a state-of-the-art DGM for prediction, and several other strong baselines, including Stochastic Pooling [33], Network in Network [20], Maxout Network [6] and Deeply-supervised nets (DSN) [17].",
      "startOffset" : 225,
      "endOffset" : 229
    }, {
      "referenceID" : 19,
      "context" : "We also compare with maxmargin DGMs (denoted as MMVA with MLP as hidden layers and CMMVA in the CNN case) [18], which is a state-of-the-art DGM for prediction, and several other strong baselines, including Stochastic Pooling [33], Network in Network [20], Maxout Network [6] and Deeply-supervised nets (DSN) [17].",
      "startOffset" : 250,
      "endOffset" : 254
    }, {
      "referenceID" : 5,
      "context" : "We also compare with maxmargin DGMs (denoted as MMVA with MLP as hidden layers and CMMVA in the CNN case) [18], which is a state-of-the-art DGM for prediction, and several other strong baselines, including Stochastic Pooling [33], Network in Network [20], Maxout Network [6] and Deeply-supervised nets (DSN) [17].",
      "startOffset" : 271,
      "endOffset" : 274
    }, {
      "referenceID" : 16,
      "context" : "We also compare with maxmargin DGMs (denoted as MMVA with MLP as hidden layers and CMMVA in the CNN case) [18], which is a state-of-the-art DGM for prediction, and several other strong baselines, including Stochastic Pooling [33], Network in Network [20], Maxout Network [6] and Deeply-supervised nets (DSN) [17].",
      "startOffset" : 308,
      "endOffset" : 312
    }, {
      "referenceID" : 17,
      "context" : "In the CNN case, we use the same architecture as [18], where there are 32 feature maps in the first two convolutional layers and 64 feature maps in the last three hidden layers.",
      "startOffset" : 49,
      "endOffset" : 53
    }, {
      "referenceID" : 5,
      "context" : "The total number of parameters in the network is comparable with the competitors [6, 17, 18, 20].",
      "startOffset" : 81,
      "endOffset" : 96
    }, {
      "referenceID" : 16,
      "context" : "The total number of parameters in the network is comparable with the competitors [6, 17, 18, 20].",
      "startOffset" : 81,
      "endOffset" : 96
    }, {
      "referenceID" : 17,
      "context" : "The total number of parameters in the network is comparable with the competitors [6, 17, 18, 20].",
      "startOffset" : 81,
      "endOffset" : 96
    }, {
      "referenceID" : 19,
      "context" : "The total number of parameters in the network is comparable with the competitors [6, 17, 18, 20].",
      "startOffset" : 81,
      "endOffset" : 96
    }, {
      "referenceID" : 12,
      "context" : "In both settings, we use AdaM [13] to optimize parameters.",
      "startOffset" : 30,
      "endOffset" : 34
    }, {
      "referenceID" : 17,
      "context" : "2 Results on SVHN dataset Table 2: Error rates (%) on SVHN dataset Model Error Rate CVA+Pegasos [18] 25.",
      "startOffset" : 96,
      "endOffset" : 100
    }, {
      "referenceID" : 24,
      "context" : "13 CNN [25] 4.",
      "startOffset" : 7,
      "endOffset" : 11
    }, {
      "referenceID" : 17,
      "context" : "9 CMMVA [18] 3.",
      "startOffset" : 8,
      "endOffset" : 12
    }, {
      "referenceID" : 32,
      "context" : "09 Stochastic Pooling [33] 2.",
      "startOffset" : 22,
      "endOffset" : 26
    }, {
      "referenceID" : 19,
      "context" : "80 Network in Network [20] 2.",
      "startOffset" : 22,
      "endOffset" : 26
    }, {
      "referenceID" : 5,
      "context" : "47 Maxout Network [6] 2.",
      "startOffset" : 18,
      "endOffset" : 21
    }, {
      "referenceID" : 16,
      "context" : "35 DSN [17] 1.",
      "startOffset" : 7,
      "endOffset" : 11
    }, {
      "referenceID" : 17,
      "context" : "Following [18, 25], we preprocess the data by Local Contrast Normalization (LCN).",
      "startOffset" : 10,
      "endOffset" : 18
    }, {
      "referenceID" : 24,
      "context" : "Following [18, 25], we preprocess the data by Local Contrast Normalization (LCN).",
      "startOffset" : 10,
      "endOffset" : 18
    }, {
      "referenceID" : 18,
      "context" : "As in [19], we investigate whether the models learn to merely copy the data.",
      "startOffset" : 6,
      "endOffset" : 10
    }, {
      "referenceID" : 4,
      "context" : "We visualize the nearest neighbors in the MNIST dataset of several samples generated by CGMMN in terms of Euclidean pixelwise distance [5] in Fig.",
      "startOffset" : 135,
      "endOffset" : 138
    }, {
      "referenceID" : 18,
      "context" : "The architecture follows from [19].",
      "startOffset" : 30,
      "endOffset" : 34
    }, {
      "referenceID" : 18,
      "context" : "As also discussed in [19], real-world data can be complicated and high-dimensional and autoencoder can be good at representing data in a code space that captures enough statistical information to reliably reconstruct the data.",
      "startOffset" : 21,
      "endOffset" : 25
    }, {
      "referenceID" : 8,
      "context" : "2 Results on Yale Face dataset We now show the generating results on the Extended Yale Face dataset [9], which contains 2, 414 grayscale images for 38 individuals of dimension 32× 32.",
      "startOffset" : 100,
      "endOffset" : 103
    }, {
      "referenceID" : 14,
      "context" : "[15] show that we can learn a relatively simple student network to distill knowledge from the teacher network (i.",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 14,
      "context" : "For high-dimensional data, adopting the same strategy as [15], we sample “near\" the training data to generate the former dataset (i.",
      "startOffset" : 57,
      "endOffset" : 61
    }, {
      "referenceID" : 9,
      "context" : "Due to the space limitation, we test our model on a regression problem on the Boston housing dataset, which was also used in [10, 15], while deferring the other results on a synthetic dataset to Appendix A.",
      "startOffset" : 125,
      "endOffset" : 133
    }, {
      "referenceID" : 14,
      "context" : "Due to the space limitation, we test our model on a regression problem on the Boston housing dataset, which was also used in [10, 15], while deferring the other results on a synthetic dataset to Appendix A.",
      "startOffset" : 125,
      "endOffset" : 133
    }, {
      "referenceID" : 9,
      "context" : "We first train a PBP model [10], which is a scalable method for posterior inference in Bayesian neural networks, as the teacher and then distill it using our CGMMN model.",
      "startOffset" : 27,
      "endOffset" : 31
    }, {
      "referenceID" : 9,
      "context" : "093 We distill the PBP model [10] using an MLP network with three hidden layers and (100, 50, 50) hidden units for middle layers.",
      "startOffset" : 29,
      "endOffset" : 33
    }, {
      "referenceID" : 23,
      "context" : "For deep learning models, sum product networks (SPN) [24] provide exact inference on DGMs and its conditional extension [4] improves the discriminative ability; and the recent work [21] presents a conditional version of the generative adversarial networks (GAN) [5] with wider applicability.",
      "startOffset" : 53,
      "endOffset" : 57
    }, {
      "referenceID" : 3,
      "context" : "For deep learning models, sum product networks (SPN) [24] provide exact inference on DGMs and its conditional extension [4] improves the discriminative ability; and the recent work [21] presents a conditional version of the generative adversarial networks (GAN) [5] with wider applicability.",
      "startOffset" : 120,
      "endOffset" : 123
    }, {
      "referenceID" : 20,
      "context" : "For deep learning models, sum product networks (SPN) [24] provide exact inference on DGMs and its conditional extension [4] improves the discriminative ability; and the recent work [21] presents a conditional version of the generative adversarial networks (GAN) [5] with wider applicability.",
      "startOffset" : 181,
      "endOffset" : 185
    }, {
      "referenceID" : 4,
      "context" : "For deep learning models, sum product networks (SPN) [24] provide exact inference on DGMs and its conditional extension [4] improves the discriminative ability; and the recent work [21] presents a conditional version of the generative adversarial networks (GAN) [5] with wider applicability.",
      "startOffset" : 262,
      "endOffset" : 265
    }, {
      "referenceID" : 27,
      "context" : "Besides, the recent proposed conditional variational autoencoder [28] also works well on structured prediction.",
      "startOffset" : 65,
      "endOffset" : 69
    } ],
    "year" : 2016,
    "abstractText" : "Maximum mean discrepancy (MMD) has been successfully applied to learn deep generative models for characterizing a joint distribution of variables via kernel mean embedding. In this paper, we present conditional generative moment-matching networks (CGMMN), which learn a conditional distribution given some input variables based on a conditional maximum mean discrepancy (CMMD) criterion. The learning is performed by stochastic gradient descent with the gradient calculated by back-propagation. We evaluate CGMMN on a wide range of tasks, including predictive modeling, contextual generation, and Bayesian dark knowledge, which distills knowledge from a Bayesian model by learning a relatively small CGMMN student network. Our results demonstrate competitive performance in all the tasks.",
    "creator" : "LaTeX with hyperref package"
  }
}