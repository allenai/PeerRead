{
  "name" : "1705.00211.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : "Partitioning Algorithm for Detecting Eventuality Coincidence in Temporal Double recurrence",
    "authors" : [ "B.O. Akinkunmi" ],
    "emails" : [ ],
    "sections" : [ {
      "heading" : null,
      "text" : "patterns of occurrences that are repeated) in time, has been developed within the context of temporal reasoning that enabled reasoning about the problem of coincidence. i.e. if two complex eventualities (or eventuality sequences) consisting respectively of component eventualities x0, x1,....,xr and y0, y1, ..,ys both recur over an interval k and all eventualities are of fixed durations, is there a subinterval of k over which the occurrence xp and yq for 1 p  r and 1 q  s coincide.\nWe present the ideas behind a new algorithm for detecting the coincidence of eventualities xp and yq within a cycle of the double recurrence of x and y. The algorithm is based on the novel concept of gcd-partitions that requires the partitioning of each of the incidences of both x and y into eventuality sequences each of which components have a duration that is equal to the greatest common divisor of the durations of x and y. The main idea behind the algorithm is the fact that there exists a subinterval of the cycle of double recurrence over which any pair of component eventualities from the gcd-partitions of x and y, are fully incident. Thus we only need determine whether or not a coincidence happens during one of those intervals when such a pair from the gcd-partition, with which xp and yq are non-disjoint for each of the incidences of x and y, fully coincide. The gcd-partitioning of a double recurrence significantly reduces the search space that one needs to explore while looking for the coincidence of xp and yq from a cycle of multiple recurrence to two periods of x and y.\nThe worst-case running time of the partitioning algorithm is linear in the maximum of the durations of x and y, while the worst case running time of an algorithm exploring a complete cycle is quadratic in the durations of x and y. Hence the partitioning algorithm works faster than the cyclical exploration in the worst case.\nKeywords: temporal reasoning, double recurrence, regular patterns, partitioning."
    }, {
      "heading" : "1. Introduction",
      "text" : "The problem of temporal recurrence is known in knowledge representation [1, 8, 9]. The concept entails having recurring incidences of an eventuality (such as state, event, action)[6] or an eventuality sequence over an interval. An example of an eventuality sequence recurring calendar time state sequence recurring over time is the days of the week sequence: <Monday, Tuesday, Wednesday, Thursday, Friday, Saturday, Sunday>. When two different sequences recur over an interval, it is sometimes the case in the process of planning or scheduling that we either want certain pairs of states in either of the sequences to coincide either for, (borrowing the language of distributed systems), liveness reasons (i.e. in order to make a plan to succeed) or not coincide for safety reasons(i.e. in order to prevent an unwanted situation).\nThe problem of coincidence in double and regular temporal recurrence was introduced in [2]. The computational solution proposed in that paper requires temporal projection over a cycle of double recurrence or in other words, one needs to explore only a cycle of double recurrence in order to determine coincidence. This paper presents a solution to the problem of coincidence in\ndouble regular recurrence that is based on the notion of partitions. The solution presented here requires projection over two periods of the occurrence of the eventuality sequences which are shorter intervals than the cycles of recurrence.\nOur interest in this problem has been motivated by the need to enable a planner/scheduler cope with reasoning about the possible occurrence of the preconditions of an action in the context of double recurrence as opposed to a single recurrence addressed in [8]. Given that two sequences of eventualities x0, x1,....,xr and y0, y1, ..,ys (such that any pair of eventualities from the x sequence or the y sequence are mutually exclusive) both recur over some interval, and a planner requires the coincidence of an eventuality pair xp and yq from the sequences, in order to carry out a certain action. Can a planner infer the existence (or otherwise) of such an interval which is a subinterval of two intervals over which xp and yq are both true. In other words can a planner anticipate the occurrence or otherwise of such a coincidence?\nSometimes in addition to knowing that a coincidence which is a pre-requisite for an action will happen, it is also important, that the planner/scheduler must be able to know within which time limit the coincidence will happen. This is particularly useful where the planner is dealing with deadlines and may have other alternatives to that course of action. In that regard, the main result of [2] is that if a coincidence for those eventualities would exist at all, one must happen within every cycle of double recurrence. In the light of that knowledge, one should have to computationally explore a whole cycle of double recurrence in order to determine coincidence.\nA simple example of the coincidence problem from a factory domain arises when a piece of factory machinery which must work continuously for five days which must be followed by a maintenance process that must last three continuous days, but the maintenance engineer will not be available on a Wednesday. In this case a scheduler must reason about the avoidance of a situation in which the maintenance period includes a Wednesday. Here there are two repeated regular patterns. One involves the weekday sequence: Monday, Tuesday, Wednesday, Thursday, Friday, Saturday and Sunday while the other involves the factory’s repeated switching from a state of working (5 days) to a state of maintenance (3 days).\nIn this example a scheduler must hope that he can avoid a situation in which one of the three consecutive maintenance days is a Wednesday. If the factory starts working on a Monday, Then the first maintenance days will be a Saturday to Monday. Then the next one will be a Sunday to Tuesday, while the third one will be a Monday to Wednesday. The next three maintenance sessions will all include a Wednesday. Thus our planner should know that it cannot possibly avoid a situation in which Wednesday is a maintenance day.\nThe conclusion in the last paragraph was arrived at following an explicit exploration into any arbitrary cycle, using our knowledge of the eventualities that make up the two recurring sequences, and their relative durations. In this case there are two sequences. The first one is the sequence of weekdays with eventualities <Monday, Tuesday, Wednesday…Sunday>, each with a duration of 1 day. The second sequence consists of two eventualities <Working_period, Maintenance_period>, where the first eventuality has a duration of 5 days, while the other one has a duration of three days. The duration of the first sequence is 7 days long while the other sequence is 8 days long. A solution based on such temporal projection will be computationally costly. It will take temporal projection over 56 days (which is a cycle of the double recurrence of the two eventuality sequences) in the worst case in order to conclude whether or not a coincidence will happen.\nThe problems described above are examples of the coincidence problem which arises in contexts described by an extension of Koomen’s parlance [8, 9] as “double recurrence”. In this paper, even though, our ultimate goal is to present an algorithmic solution to the problem of eventuality coincidence which arises when one is required to carry out planning or scheduling within such a context, but in the process, we accompany every definition with a logical formalization which enables us to prove basic properties about temporal relations of eventualities within two sequences. All theorems in this paper can be proved logically except Theorem 5.1 whose proof is based on the properties of pseudo-random number generators. However we believe that the paper should be readable to those who are not interested in logical formalization and proofs.\nIn a sense, we can view this problem as a (temporal reasoning) search problem. We are searching an interval over which two different eventualities recur for a coincidence of a pair of components from the two recurring eventualities. We can divide an interval over which temporal double recurrence happens into cycles. Each cycle is exactly like others in terms of the temporal relations between any pair of components from the two eventualities. As such it has been shown that any search for coincidence within an interval over which double recurrence take place can be narrowed down to any arbitrary cycle[2]. This paper presents the key ideas behind an algorithm that uses the concept of gcd-partitions to narrow down the search space further.\nA partition for an eventuality sequence is any other eventuality sequence whose duration is the same as it. A gcd-partition for a recurring pair of sequence eventualities x, y is another pair of sequence eventualities w, z such that:\n- w is a partition of x and z is a partition of y. - the duration of each of the component eventualities in w and z is equal to the greatest\ncommon divisor of the durations of x and y.\nA basic property of gcd-partitions is that any pair of component eventualities from each of the sequences w and z would both be maximally (fully) incident over some subinterval of any cycle of the double recurrence of x and y. Therefore we can narrow down our search to those intervals, over which the pairs of components of w and z that each share a common interval with xp and yq respectively, are fully coincident.\nThus eventualities xp and yq coincide within any cycle of the double recurrence of x and y if and only if:\nThere is an eventuality pair wr and zs from the gcd partition w and z such that: - any incidence of xp is non-disjoint with any incidence of wr within any incidence of x - any incidence of yq is non-disjoint with any incidence of zs within any incidence of y - the incidences of wr and zs being the same implies the corresponding incidences of xp\nand yq that are non-disjoint with those of wr and zs respectively are non-disjoint.\nAs such there are three major parts to the algorithm needed to implement this solution. The first part should find the greatest common divisor of the durations of x and y. The second part should create a gcd partition w, z for the pair of eventualities x and y storing the exact (qualitative and quantitative) relationships between incidences of xp (yq) and those of components of the partition w (z respectively) with which it is non-disjoint. The third part algorithm will then determine whether if any pair of such components from w and z happen over the same time interval would imply that the incidences of xp and yq are non-disjoint.\nThe worst case running time of the part of the second part of the algorithm is linear in the maximum duration of the incidence of the eventualities of x and y. That is asymptotically more significant than the running time of an algorithm that finds the greatest common divisor which is the square the logarithm of the maximum of the durations of x and y. The worst case running time of the third part of the algorithm however is constant. This is because if incidences of xp (yq) is non-disjoint with incidences of more than two components of w ( respectively z) then it is guaranteed that there is a pair of non-disjoint incidences of xp and yq within a cycle of the double recurrence of x and y. Thus we will show that the running time of the algorithm is linear in the maximum of the durations. This result is better than the running time of a cyclical exploration in the worst case.\nThis paper uses the same language of the reified first order logic used in [2] which notation is briefly presented in section 2. The problem of coincidence within the context of double recurrence is formally presented in section 3. Our solution to the problem of coincidence is presented in section 5 makes use of the concept of gcd partitions, which is introduced in section 4. Section 4 presents the key properties of partitions and gcd-partitions that lead to the key theorem about gcd-partitions (i.e. Theorem 5.1) which form the basis of the algorithm in section 6.\nThe paper ends with an algorithmic analysis of the two main algorithms involved in the proposed solution and compares their performance with the simple temporal projection algorithm proposed in [2].\n2. Background\n2.1 Notation The logical language used in this paper is standard many sorted first-order logic with equality. It is exactly the same language used in [2]. Using a logical language here enables us to prove some key results that lead to the algorithm. However, readers who are not interested in the proofs should be able to read the paper while avoiding the logical formalization which is always preceded by a prosaic interpretation. The domains include Eventualities, (time intervals) Intervals, Time Maps and (interval relations) Relations, which will include all of Allen’s relations and others introduced earlier in this paper and the domains of ordinals and natural numbers. A time interval is time unit over which a proposition may be regarded as being either true or false[3, 4]. It connotes the idea of an interval of time. In some literature a time interval is regarded as a pair of time points[5]. A time map is a sequence of contiguous time intervals. Each individual time interval in a time map can be accessed by applying a variety of functions introduced later.\nAn Eventuality is either an event or a process (simple eventuality) or a sequence of other eventualities (complex eventuality) described by a proposition. An example of a simple eventuality is ‘it is Monday’ or ‘Green light is on’. An example of this is ‘Weekdays’ which is a sequence of ‘Monday’, ‘Tuesday’ etc. Another example is ‘Traffic light’ which is a sequence of Red, Amber, and Green lights. An eventuality is reified in the language. [7]. Each eventuality has an assigned length, which designates the number of component eventualities. There is an ordering among these components. Intuitively, a time- map should be understood as a sequence of contiguous time intervals, so that it is possible identify the order of the intervals in the time map. That is done in this paper by using indices, so that tm[k] represents the k th interval in the\ntime- map. The notation tm[k] should be a syntactic denotation for a function taking a time-map and the integer k, and returning a time interval.\nWe will use the standard logical operators: conjunction , disjunction , equivalence ,\nimplication  and (unary) negation . The scope of a quantified variable is the rest of the sentence. Whenever necessary, we delimit the scope of a quantified variable by the explicit use of parentheses. The precedence of the logical operators is as assumed for first order predicate\nlogic, i.e. precedence of  is higher than those of  and  which is higher than those of  and\n.\nThe predicates used in our theory include the standard predicates for associating eventualities with time intervals otherwise known as truth predicates. We use the predicates here as used in [8] i.e. TT (true throughout), MT (maximal truth) and RT (recurrently true). We define the partition relationship, Part between an eventuality and a sequence of eventualities. We shall introduce the notion of partitions later. We define interval relation predicate Intrel, as a relation between an interval, a temporal relation and another interval. This enables us to make interval relations terms, so that we can reason about the similarity of interval relations between two pairs of intervals. The double recurrence predicate MRT defines the double recurrence of two eventualities over some interval. The signatures for the predicates are given below:\nTT, MT, RT: Eventuality  Interval  Boolean\nIntrel: Interval  Relation  Interval  Boolean\nMRT: Eventuality  Eventuality  Interval  Boolean\nAux: Interval  Interval  Interval  Boolean\nOf the truth predicates described above, true over(TT) is the most primitive, capturing the notion of an eventuality being True over an interval. The other truth predicates will be defined in terms of TT subsequently.\nIn the rest of the paper, we use the letters x, y, w and z without subscripts to represent eventualities. When x, y, w, and z are made bold, they represent lists of eventualities of finite length. The symbols i, j, k and l with or without suffixes, are used for temporal intervals, while we use p, q, r, s, t, u as variable ordinals for identifying components of an eventuality. We write wp as a shorthand for the application of the component function (just ahead) to obtain the p+1 th component of the eventualities w. Time maps are denoted by tm with or without subscripts.\nThe list of functions used here and their description is given below.\ndur: Interval  . This function returns a natural number signifying the duration of given interval. Even when a natural unit for duration measures the unit of an interval as a real number, as long as all the measured intervals in the domain are rational numbers, the interval durations can be measured in a smaller unit (for example, 10 -6 th of a second) that allows durational values to be natural numbers.\ncover: Interval  Interval  Interval The cover function (defined in section 2.2) of two meeting intervals is the interval that covers the two intervals. The function is a partial function defined only for any pair of meeting intervals.\ncover*: Time-Map  Interval The cover* function (defined in section 2.2) of a time map is a single interval covering the entire time map.\n : Eventuality  Interval-Set ( returns a period set)\nUsually, we denote a period of occurrence by  with or without suffixes. As such\nwhen we write:\n  (x).\nWe are saying that  is a period of the occurrence of x.\n : Eventuality  Eventuality  Interval-set ( returns a cycle set for the double recurrence of the two eventualities)\nSo that when we write  (x, y), we are saying that  is a cycle of the double recurrence of x and y.\n+ : Eventuality  Eventuality  Eventuality\nThe function + returns some eventuality, that corresponds to the two eventualities being true simultaneously.\n: Eventuality  Interval  Time-Map\nThe function  returns for an eventuality x, the contiguous sequence of intervals which are its periods within the interval, if x recurs over that interval. It returns an empty list if x is not recurrently true over the given interval.\nThus (x, j) returns a time-map of x’ s occurrence within the time interval j.\nIndex: Time-Map  N  Interval The index function returns the p th interval of a time map, where p is the given ordinal. We will write tm[p] as a short hand for index(tm, p).\nAs a notation (x, j)[p] refers to the pth interval over which x is maximally true\nwith interval j.\ndim: Time-Map  N This function returns for a given time-map, the maximum ordinal for which index will return an interval.\n : Eventuality  Interval  Interval The function returns the first sub interval of the given interval over which the eventuality is maximally true i.e. its interval of maximal occurrence within the given interval. If there\nare more than one such sub intervals,  is undefined.\nIf x is a sequence of eventualities x1, x2…..xn, then (xr, (x, j)[p]) refers to the sub interval within the p th interval of maximum occurrence of x within j over which xr is maximally true.\nlen: Eventuality  N The function returns the number of components that make up the eventuality. Intuitively we think of the components of an eventuality being in a sequence.\nhead: Time-Map  Interval The function returns the first interval in the time map.\ntail: Time-Map  Time-Map The function returns the list excluding the first element. It returns the value ‘nil’ if the time-map consist of only one interval.\ncomp: Eventuality  N  Eventuality This partial function returns the component of the given eventuality, whose position is indicated by the ordinal. As we have indicated earlier, we will write wp as shorthand for comp(w, p).\nThus we proceed to formally state the problem of coincidence within the context of double recurrence.\n2. 2 Interval Calculus Allen [3] formulated the interval calculus, as a means of representing time, along with a computationally efficient reasoning algorithm based on constraint propagation. Allen had argued that time points proposed earlier by McDermott [11], was inadequate.\nAllen defined a linear logic of time based on the concept of intervals. In this logic, time intervals are treated as individuals. A number of qualitative binary relations are defined on intervals. The basic ones are:\nMeets Ends After Starts Contains Overlaps Equals 1\nThe names assigned to these relations fit the relationship the reader is likely to assign to them intuitively. For example, an interval i Meets another interval j if i starts before j and ends just when j is starting so that they have no interval between them, and no subinterval in common.\nBased on these interval relations, we define (like Koomen) four additional temporal relations between time intervals: disjoint, within, subinterval and the same-beginning relations.\nDefinition 2.2.1 (Disjoint relation) The time intervals j and k are disjoint if and only if either j is after k, or k is after j or j meets k or k meets.\nj, k. Intrel(j disjoint k) Intrel(j, after, k)  Intrel(k, after, j) \nIntrel(k meets j)  Intrel(j meets, k)\n1 We do not differentiate between the Allen’s Equal relation and the equality predicate (=) in first order predicate calculus.\nAs usual we will write j disjoint k or k disjoint j. Note that disjoint is a symmetric relation.\nDefinition 2.2.2(Within relation) The interval j is within k if and only if either j starts k or j ends k or j is during k or j equals k.\nj, k. Intrel(j within k)  Intrel(j, starts, k)  Intrel(j, ends, k)  Intrel(k, contains, j)\nSometimes we find it necessary to refer to the subinterval relation. This relation will be a disjunction of the within relation and equality.\nDefinition 2.2.3 (The Subinterval relation) An interval is a subinterval of another, if it is either within that interval or equal to it.\nj, k. Intrel(j, sub, k)  Intrel(j, within, k)  k = j\nDefinition 2.2.4 (Samebegin relation) The time intervals j and k have the same beginning if and only if either j equals k, or k starts j or j starts k\nj, k. Intrel(j, samebegin, k) Intrel(j, starts, k)  Intrel(k, starts, j)  k = j\nAllen’s interval relations implicitly assume the existence of some other interval apart from the related pair, whose existence is an aspect of the definition of the given relation. For example, the fact that interval j is before interval k, indicates the existence of some interval meeting k and met by j. Similarly, the fact that j starts k implies the existence of some interval met by j and ending k. If j overlaps k however, there are two auxiliary intervals: One starting j and meeting k, and another ending k and met by j. It is the existence of such interval that enabled the definition of all of Allen’s interval relations in terms of the relation meets.\nIt is also important to note that auxiliary intervals defined for any pair of non-disjoint intervals, exclude any interval shared by both intervals. Those intervals are defined as common intervals as Definition 2.2.5. Thus, here we define formally the concept of an auxiliary interval for two nondisjoint intervals.\nDefinition 2.2.5a (Auxiliary Intervals) Given any two distinct non- disjoint intervals, an auxiliary interval is any interval, which starts or ends one of the two intervals, and meets or is met by the other.\nj, k, m . Intrel(k, disjoint, j)  Aux(k, j, m)   (k = j) \n(Intrel(m, starts, j)  Intrel(m, ends, j)  Intrel(j starts m)  Intrel(j ends m) ) \n(Intrel(m, meets, k)  Intrel(k, meets, m))\nDefinition 2.2.5b Given any two disjoint non- meeting intervals an auxiliary interval meets one and is met by the other.\nj, k, m . Intrel (k, disjoint, j)  Aux(k, j, m) \nIntrel(k, meets, j)  Intrel(j, meets, k) \n( Intrel(k meets m)  Intrel(m meets k))  ( Intrel(m, meets, j)  Intrel(j meets m)\n)\nFrom our definition it is intuitively clear that two equal or meeting intervals have no auxiliary intervals. As such\nj, k. m. (Intrel(j, meets k)  j =k)  Aux(k, j, m)\nDefinition 2.2.6 (Common Intervals) The function common returns for any given non-disjoint interval pair their maximal common sub interval.\nj, k m. Intrel(j disjoint k) \ncommon(k, j) = m  Intrel(m, sub, j)  Intrel(m, sub, k)\n (m1. Intrel(m, sub, m1)  Intrel(m1, sub, j)  Intrel(m1, sub, k))\nNow we define the idea of a time interval that covers two meeting intervals. This concept is referred to in this paper as in [8], as the cover of the two intervals.\nDefinition 2.2.7 (The cover of two intervals) The cover of two meeting intervals is the interval that is started by the earlier interval and ended by the latter interval.\nj, k, m. cover(j, k) = m  Intrel(j, meets, k)  Intrel(j, starts, m)  Intrel(k ends m)\nThe next axiom describes the basic property of time maps.\nAxiom 2.2.8 Each interval in a time map meets with the next interval in the map.\n tm, p. 1 p < dim(tm)  Intrel(tm[p] meets tm[p+1])\nFinally, we extend the concept of cover to a time map by defining the unary function cover* for time-maps.\nDefinition 2.2.9 (cover * of a time map) The partial function cover* (defined for a time map) returns a single interval which covers the entire time map.\n tm, m. cover*(tm) = m  (dim(tm) = 1  m = tm[1]) \n(dim(tm) > 1  Intrel(tm[1] starts m)  Intrel(tm[dim(tm)] ends m)\nThis definition clearly spells out what the temporal relations between individual eventualities in the time-map tm[p] and its cover, the interval m will be."
    }, {
      "heading" : "3. Maximal Truths, Sequences and Recurrences",
      "text" : "Axiom 3.1a (Maximal truth of eventualities of length 1) A simple eventuality x is maximally true over an interval j if x is true over j and x is not true over any interval which is a super interval of j, or overlaps or is overlapped by j.\n x, k . len(x) =1 \n(MT(x, k)  TT(x, k)  (j. Intrel(j, overlaps, k)  Intrel(k, Overlaps j) \nIntrel(k, within, j)   TT(x, j)))\nAxiom 3.1b (The truth of eventualities of length greater than 1) If an eventuality x of length greater than 1 is true over an interval j, then its first component x0 is maximally true over some interval starting subinterval of j, and provided the length is at least p, the p-1 th component is maximally true over a subinterval of j which meets another subinterval of j over which the k th component is maximally true.\nx,k. len(x) > 1 \n( TT(x, k)   k1. MT(x0, k1)  Intrel(k1 starts k)  (p. 0 < p  len(x) -1  k2, k3. Intrel(k2, within, k)  Intrel(k3, within, k)  MT(xp-1, k2)  MT(xp, k3)  Intrel(k2 meets k3) )\nAxiom 3.1c(The maximal truth of eventualities of length greater than 1) If an eventuality is of length greater than 1, then it is maximally true over an interval when it is true over the same interval.\nx, k. len(x) > 1 \nMT(x, k)  TT(x, k)\nWe are treating eventuality sequences as a solid eventuality and as such they are only true over intervals that they are maximally true over.\nThe next theorem establishes the relationship between truth and maximal truth for all eventualities. It follows from definitions 3.1a and 3.1c.\nTheorem 3.2 If an eventuality x is maximally true over an interval j, it is also true over the same interval.\nx. MT(x, j)  TT(x, j)\nA basic domain assumption is the fact that a proposition defining an eventuality cannot be true forever. The next Axiom formalizes this domain assumption.\nAxiom 3.3 (Nothing is true forever) If an eventuality x is true over an interval j, then j is a part of or equal to some interval k over which x is maximally true.\nx, j. TT(x, j)  k. MT(x, k)  (j = k  Intrel(j within k))\nThe next axiom introduces a slight restriction needed to achieve the representation of regular recurrence. While this may slightly limit the applicability of the domain, as we have seen before in the examples in section 1, there are domains where this restriction does not limit.\nAxiom 3.4 (Fixed duration eventualities) If an eventuality x is maximally true over two different intervals j and k, then the durations of j and k are equal.\n x, j, k. MT(x, j)  MT(x, k)  dur(j) = dur(k)\nSuch an assumption will be valid when we are dealing with eventualities with fixed duration of maximal incidence, as opposed to variable durations. All of the results of this paper are based on\nthis assumption. As such, the results discussed here in section 3 and 4 will be invalid in a domain where there is some fuzziness about how long a state or event may take. An example of fuzziness is when an event takes between 2 and 3 hours to complete. Interestingly, there are applications for which we do not have to contemplate the problem of fuzziness. However we return to the problem of fuzzy durations later.\nWe now define the truth of an eventuality x+y which is defined as the coincidence of x and y. As introduced earlier + when applied to a pair of eventualities returns an eventuality that corresponds to the incidences of the two eventualities sharing a common subinterval. However + can only be formally defined in terms of the truth of the product of its application. That is presented here:\nDefinition 3.5 (+ operators for eventualities) a. We say that the eventuality x + y is maximally true over an interval if and only if that interval is a common subinterval of two non-disjoint intervals such that x is maximally true over one of the intervals and y is maximally true over the other.\nx, y, k. MT(x + y, k)  j, i. MT(x, j)  MT(y, i)  Intrel(i, disjoint j)\n k = common(j, i)\nb. Eventuality x + y is true over an interval k if and only if k is a subinterval of some other interval over which x + y is maximally true.\nx, y, k. TT(x + y, k)   j. MT(x + y, j)  Intrel(k, subs, j)\nThe following Theorem contains some properties of the + operator. All of the properties follow from Definition 3.5.\nTheorem 3.6 (Properties of +) a. The operator + is commutative.\nx, y, k. MT(x+y, k)  MT(y+x, k)\nb. For all x and y, x + y is downward hereditary irrespective of the Shoham type of x and y..\nx, y, k. MT(x+y, k)  j. Intrel(j within k)  TT(x+y, j)\nc. If x+y+z is maximally true over any interval then x+y, y+z and x+z are all true over that interval.\nx, y, z, j. MT(x+y+z, j)  MT(x+y, j)  MT(x+z, j)  MT(z +y, k)\nIt is appropriate at this point to introduce the  (phi) function which returns a unique interval of incidence, within an interval if indeed there is such an interval, and is not defined if there is no such interval or there is more than one such.\nDefinition 3.7 (The phi () function)\nGiven an eventuality x and interval k, the  function returns the only (possibly improper) subinterval of k, over which x is maximally true. It is undefined either if there is no such interval or there are more than one such interval.\nx, k, j. (x, k) = j !i. MT(x, i)  Intrel(i, sub, k)  j = i\nMaximal truth also forms the basis for defining recurrence. Although Koomen offered no formal definition of recurrence but had an axiom that states that: if x recurs over an interval then either it is maximally true over the interval or it is maximally true over some starting subinterval of the interval, and it recurs over the remaining subinterval of the given interval. However we strengthen that axiom and offer a definition for recurrence thus:\nDefinition 3.8(Recurrence)\nAn eventuality is said to recur over an interval if and only if either it is maximally true over the\ninterval or it is maximally true over some starting subinterval of the interval, and it recurs over the remaining subinterval of the given interval.\nx, k. RT(x, k)  MT(x, k) \n(j, i. Starts(j, k)  Ends(i, k)  Meets(j, i)  MT(x, j)  RT(x, i))\nThe effect of this strengthening is to make maximal truth a special case of recurrence.\nNow we introduce the  function into our formalism. We use the function to refer to the list of intervals over which x is maximally true, within an interval over which x recurs.\nAxiom 3.9(The eta  function)\nGiven that x recurs over an interval j, then, the function  returns a time map of the interval whose cover* is the original interval, and x is maximally true over each time interval returned by the index function.\nx, j. RT(x, j) \ntm. (x, j) = tm  j = cover*(tm)  (p. 1  p  dim(tm)  MT(x, tm[p]))\nThe eta function  is a partial function that takes an eventuality and an interval over which the eventuality is recurrently true, and returns a time map which contains time intervals over which the eventuality is true throughout. To illustrate the usefulness of eta function in our formalization of recurrence, we can express the fact that if x is recurrently true over k, then any subinterval j of\nk over which x is maximally true, is a member of the list returned by (x, k) by writing:\nx, k. RT(x, k)  (j. MT(x, j)  Intrel(j sub k)  n1. (x, k)[n1] = j)\nDefinition 3.10(Double Recurrence) We say that x and y doubly recur over an interval k if and only if both x and y each recur over k\nx, y, k. MRT(x, y, k)  RT(x, k)  RT(y, k)"
    }, {
      "heading" : "So for example, to say x recurs over an interval j in Koomen’s theory, one writes as a logical",
      "text" : "formula RT(x, j). However, there is often the need to represent the recurrence of two different eventualities over the same interval. For example, to state that eventualities x and z recur over the interval j we will write the formula: RT(x, j) and. RT(z, j). We will refer to this as a double recurrence of x and z over j.\nThe following is basically true of components of an eventuality because any two of them cannot be maximally incident on two non-disjoint intervals.\nAxiom 3.11(Mutual exclusion) Any two different components of an eventuality are mutually exclusive in time, i.e. any pair of intervals over which they respectively true, must be disjoint.\n x, p, q, j, k. p q  TT(xp, j)  TT(xq, k)  Intrel(k, disjoint, j)\nWe proceed to define some properties of recurrence and double recurrence, and some basic truths about them.\n3.1 Properties of Recurrence and Double recurrence\nThis section presents basic inferences about the properties of recurrence and double recurrence. The notions of periods of an eventuality and the cycles of a double recurrence are introduced. Their properties are also proved.\nDefinition 3.13 (Period of Eventuality) A period of an eventuality is an interval over which it is maximally true. We assume that the\nfunction  returns the set of all such intervals for any given eventuality.\nx, , k.   (x)  MT(x, )\nThe following theorem follows from the definitions of recurrence (3.8) and double recurrence (3.9). The proof is trivial and is thus omitted.\nTheorem 3.14 If there is a double recurrence of x and y over an interval k, then Either there exists two starting sub intervals of k such that x is maximally true over one and y is maximally true over the other and two ending subintervals of k such that x is maximally true over one and y is maximally true over the other Or either x or y are maximally true over k.\nk, x, y. MRT(x, y, k) \n j1, j2, j3, j4. Intrel(j1, starts k) \n( Intrel(j2, starts, k)  MT(x, j1)  MT(y, j2) \nMT(x, j3) MT(y, j4)  Intrel(j3 ends k)  Intrel(j4, ends k))\n ( MT(x, k)  MT(y, k) ) )\nNow we define the cycle of a double recurrence.\nDefinition 3.15 (Cycle of a double recurrence )\nA cycle  of a double recurrence of two eventualities x and y, is a minimal interval over which x and y are doubly recurrent.\nx, y, .   (x, y) \nMRT(x, y, ) \n j. Intrel(j, within, )  j  (x, y)\nThe following Theorem 3.18 is a direct consequences of our basic assumption i.e. Axiom 3.4 and the Definition 3.13 of periods.\nTheorem 3.16\nAll periods of the same eventualities have the same durations.\nx, 1, 2. 1, 2 (x)  dur(1) = dur(2)\nThe following theorem is a direct consequence of Axiom 3.4 and the Definition 3.15 of a cycle. Thus every period of x have the same duration. In a similar way all cycles of a recurrence of any pair of eventualities have the duration as presented below\nTheorem 3.17 All cycles of double recurrence for the same pairs of eventualities are of the same duration.\nx, y, 1, 2. 1,2  (x, y)  dur(1) = dur(2)\nThe following theorem follows from axiom 3.4, a bit of arithmetic reasoning about the durations of x and y. It states that the duration of a cycle is the longest common multiple of the duration of x and y.\nTheorem 3.19 The duration of a cycle of double recurrence equals the least common multiple of the periods of the two recurrences.\nx, y, , j, k, n1, n2. (x, y)  ( MT(x, j)  dur(k) = n1)  (MT(y, k)  dur(k) = n2) \ndur() = lcm(n1, n2)\nThe following theorem from the literature[1], presents an interesting result about the temporal relations between each incidences of xp and yq within each cycle. It states that in each cycle, the relation between the r th incidence of xp and the s th incidence of yq is always the same in every cycle.\nTheorem 3.20 (Each cycle is exactly like every other)\nFor the double recurrence of two sequences x and y, whatever relation holds between interval of incidence of any two members of the sequences xp and yq , within the r th period of the x-sequence and the s th in period of the y-sequence respectively of any cycle, also holds in all other cycles.\n1,2, x, y. 1, 2  (x, y))  p, q, r, s, rel. 0  p  len(x) -1  0  q  len(y) -1 \nIntrel((xp, (x, 1)[r]) rel (yq, (y, 1)[s]))  Intrel((xp, (x, 2)[r]) rel (yq, (y, 2)[s]))\nThe implication of this theorem is that the existence of a coincidence can be determined by exploring a cycle of a double recurrence because by setting up a projection of a cycle of double recurrence. Our objective in this paper is to present a method of partitions by which coincidence of xp and yq, can be determined by the temporal projection of one period each of x and y. Those periods are shorter than a cycle of the double recurrence of x and y. This represents a significant reduction in the search space for the solution. The subject of partitions is addressed in section 4, while section 5 and 6 presents the algorithms."
    }, {
      "heading" : "3.2 Formal statement of the “coincidence” problem and an initial solution",
      "text" : "We are now better equipped to define the coincidence problem more formally. The problem statement is presented thus:\nGiven two sequences of eventualities seq(x0,..xs-1) and seq(y0..yt-1) recurring over some interval j, which is longer than a cycle. For some p and q within the bounds [1..s] and [1..t] respectively, can we find some subinterval of j over which both xp and yq are true.\nUsing the logical language we have developed our problem is to infer the truth or falsity of the following assertion for some particular sequences x and y, ordinals p and q within the limits of the ordinals in the sequences and interval k:\nIs it the case that MRT(x, y, k)  j. Intrel(j, within, k)  TT(xp + yq, j) ?\nThe solution to this problem based on the notion of gcd partitions is presented in section 5. Our\nimmediate attention now turns to the task of introducing partitions and gcd partitions."
    }, {
      "heading" : "4. Partitions and GCD- partitions",
      "text" : "We begin section by formally introducing the concept of partition for an eventuality, which is central to results presented in this section.\nDefinition 4.1 (Partition of a sequence eventuality) For any eventuality x, we define its partition, as any other eventuality, y which is maximally true over any interval on which x is maximally true, and such that the duration of any interval over which y is true equals the duration of any interval over which x is true.\n x, y. Part(x, y)) \n(k. MT(x, k)  MT(y, k))\nFrom the above definition, the following theorem follows.\nTheorem 4.2 If we define an eventuality w as a partition of another eventuality x, and x is true over some interval j, then for any component eventuality of x, there is a component eventuality of w with which it shares some subinterval of j.\nx, y, j, p. Part(x, w))  MT(x, j )  0  p  len(x) \nk1, k2, r. MT(xp, k1)  MT(wr, k2)  MT(xp + wr, k)  Intrel(k1 within j)  Intrel(k2, within, j)  k = common(k1, k2)\nThe following theorem makes clear the fact that quantitative aspects of the temporal relationships within each period of partitioned eventuality are the same.\nTheorem 4.3 (Partitions preserve qualitative temporal relationships) For any eventuality, x and its partition eventuality z and for any pair of intervals i and j over which x is maximally true, for all appropriate values of p and q, and time interval relation r, if there exists two intervals k and l within i over which xp and zq are respectively, maximally true and the temporal relationship between k and l is r, then there exists similar intervals within j, m and n say, over which xp and zq are maximally true and the relationship between m and n is r.\nx, 1, 2. 1 (x)  2  (x)  Part(x, z) p. q, rel.\n0  p  len(x)-1  0  q  len(w)-1 \n( Intrel((xp, 1) rel (zq, 1))  Intrel((xp 2) rel (zq, 2)) )\nTheorem 4.3 depends on Lemma 4.3a below for which a proof has been omitted here.\nLemma 4.3a For the double recurrence of two sequences x and y, the relation between interval of incidence of any two members of the sequences xp and yq say, within the r th period of the x-sequence and the s th period of the y-sequence respectively, are the same in all cycles.\n1,2, x, y. 1, 2  (x, y))  p, q, n1, n2 rel. 0  p  len(x) -1  0  q  len(y) -1 \n(Intrel((xp, (x, 1)[n1]) rel (yq, (y, 1)[n2]))  Intrel((xp, (x, 2)[n1]) rel (yq, (y, 2)[n2])) )\nTheorem 4.3 follows from Lemma 4.3a when we realize that each period of x is a cycle of the double recurrence of x and z. That is presented as Lemma 4.3b below.\nLemma 4.3b For all eventualities x for which z is a partition, then any period of x is a cycle of the double recurrence of x and y.\nx, z, . Part(x, z)  (x) (x, z).\nIn what follows, we present a theorem that states that what is preserved in the relationships of eventualities and their partition across periods is more than qualitative.\nTheorem 4.4 (Partitions preserve quantitative temporal relationships in periods).\nIf the eventuality z is a partition of the eventuality x, then for any two pair of non-disjoint\nintervals of maximal incidences of any component eventualities xp and zr happening during two different periods 1 and 2 then it is the case that:\n1. For any auxiliary interval for (xp, 1) and (zq, 1), a similar auxiliary interval exists for\n((xp, 2) and (zq, 2) with same duration and similar relations to incidences of xp and zr. 2. The common intervals of the interval pair (xp, 1) and (zq 1) ) and the interval pair\n((xp, 1) and (zq, 1), have the same duration.\nx, 1, 2, p, q. 1, 2  (x)  Part(x, z)  0  p  len(x)-1  0  q  len(w)-1  Intrel(xp disjoint zq)  (k, rel1, rel2. Aux((xp, 1), (zq, 1), k) \nIntrel(k, rel1, (zq, 1)  Intrel(k, rel2, (xp, 1))  (j. Aux((xp, 2), (zq, 2), j)  Intrel(j, rel1, (zq, 2 ))  Intrel(j, rel2, (xp, 2))\n dur(k) = dur(j)) ) ) \ndur(common((xp, 1), (zq, 1)) ) = dur(common((xp, 2), (zq, 2)) )\nThe proof of Theorem 4.4 is contained in the appendix.\nGiven two recurrent eventualities x (of length t) and y (of length u), then the GCD partitions of the sequences is obtained by computing the greatest common divisor (gcd) of the durations of the two eventualities. And thereby creating two partition eventualities: z (of length r) and w (of length s), where the duration of each zp and wq equals to the gcd of the duration of the two eventualities, and the duration of the eventuality z is the duration of the eventuality x (z being a partition for x) while the duration of the eventuality w, equals the duration of y(w being a partition for y). Thus r = duration (x)/gcd and s = duration(y)/gcd. We define gcd partitions formally below:\nDefinition 4.5(gcd-partition) Given two eventualities x and y, we define the eventualities z and w as the gcd partition of the double sequence, if and only if:\n1. The eventualities z of length r and w of length s are partitions respectively of the eventualities x and y. 2. The durations of maximal occurrence of all zp which are components of the eventuality z and that of all wq which are components of the eventuality w are all equal to the greatest\ncommon divisor (gcd) of durations of maximal occurrence of both the z-sequence and the w-sequence.\nx, y, w, z. Gpart(x, y, w, z)  MRT(x, y)  Part(x, w)  Part(y, z) \n( p, q. 0 p len(w)  0 q len(z)  dur(wp) = gcd(dur(x), dur(y))  dur(zq) = dur(wp) )\nBecause a gcd-partition contains two individual partitions, each of those partitions shares the properties of Theorems 4.3 and 4.4 for all partitions. The implication of these is that every partition is exactly like every other in terms of the qualitative and quantitative relationships between occurrences of the same eventualities. As such the any interval of incidence of xp, for any given p, and wr for any r is the same in any period of x. The case is similar for any component of y and its partition z ( i.e. yq and zs, for any q nd s).\nTheorem 4.6 (Properties of gcd partitions) If an eventuality pair (w, z) is a gcd-partition of another eventuality pair (x, y) then every cycle of the double recurrence of x and y, is also a cycle of the double recurrence of w and z.\nx, y, w, z. Gpart(x, y, w, z) (.  (x, y))  (w, z)\nNote that 4.6b follows from Definitions 4.5 and 4.1.\nTheorem 4.7\nIf a pair of eventualities z (of length r) and w (of length s) is a gcd partition of some other eventuality pair x and y, then it is the case that there are exactly s periods of the eventuality z and r periods of the eventuality w, within any cycle of their double recurrence.\nx, y, w, z. Gpart(x, y, w, z)  len(w) = s  len(z) = r \n.   (w, z)  dim((z,)) = s \ndim((w,)) = r  gcd(r, s) =1\nThis follows from basic arithmetic and Theorem 3.19. By Theorem 3.19, the duration of a cycle is the lowest common multiple lcm of the durations of both the z-sequence and w-sequence. Note that the lcm of dur(z) and dur(w) is given by:\nlcm = r.s.g where g is the greatest common divisor of the durations of z and w.\nSince z is of length r thus dur(z) = r.g and as such the number of contiguous z incidences within\nthe cycle is lcm/r.g which is s. Thus dim((z, )) = s. Similarly, dim((w, )) = r. Thus r and s are relatively prime in the sense that their greatest common divisor is 1. Supposing r and s have a common divisor that is more than1, then g cannot be the greatest common divisor of dur(w) and dur(z)."
    }, {
      "heading" : "5. A Solution based on gcd partitions",
      "text" : "In this section we present a solution that is based on temporal projection over two periods of the two eventualities involved in a double recurrence. First we present a fundamental result about gcd partitions that makes this possible. Theorem 5.1 states that for a gcd partition w, z of a double recurrence x, y then an interval exists within any cycle in which any pair of components from w and z are both maximally true.\nTheorem 5.1\nFor any gcd partition z and w of some pair of doubly recurring eventualities x and y, then within\nany cycle of their recurrence, and for any pair p and q, there exists two natural numbers n1 and n2, such that the interval of occurrence of wp within the n1 th period of eventuality w and that of zq within the n2 th period of the eventuality z are the same.\n x, y, w, z. Gpart(x, y, w, z)\n , p, q.  (w, z) \nn1, n2. (wp, (w,)[n1]) = (zq, (z,)[n2])\n(The Proof of Theorem 5.1 is in the Appendix)\nThe implication of Theorem 5.1 is that if we know all the partition elements wr (for all values of r) with which incidence the incidence of xp is non-disjoint in any period of x, and we know all the elements of zs (for all values of s) with which incidence the incidence of yq is non-disjoint, then all we need do is find any pair of values of r and s if they do exist such that the incidences of wr and zs holding over the same interval implies that one would be able to determine through propagation, the fact that xp and yq will eventually happen over two non-disjoint intervals sometime within the cycle of x and y.\nThis is the kind of reasoning a temporal reasoning system is capable of carrying out through constraint propagation as demonstrated by Algorithm 5.2 below. From Theorems 4.3 and 4.4, one only needs to consider one periods each of x and y.\nAlgorithm 5.2\nFunction Coincide(x, y: Eventuality, p, q: Integer) : Boolean begin\n/*Relations between occurrences of xp and wr in every period of x are the same  p, r */ /* Same for yq and zs..According to Theorems 4.3 qnd 4.4 */ /* Thus, it suffices to consider any arbitrary period of x and y */\n/* x and y represent any arbitrary periods of x and y respectively */ if p and q are not with limits of lengths of x and y respectively then\nhalt\nelse;\ncreate interval network for a period x of x and w gcd partition w create interval network for a period y of y and gcd partition z for all r such that (wr, x) is non-disjoint with (xp, x)\nfor all s that (zs y) is non-disjoint with (yq, y) begin\nisolate a network of (xp,x), (wr,x) and their auxiliary and common intervals\nisolate a network of (yq,y), (zs, y) and their auxiliary and common intervals\npropagate constraint: (wr,x) = (zs,y) through isolated interval networks\nif (xp, x) and (yq, y) are non-disjoint after propagation then return true\nend\nreturn false\nend\nLater in section 6, we shall present theorems that illustrate how an algorithm can be constructed for the coincidence problem directly from the isolated network without the use of constraint propagation.\nHowever, in section 5.2 below, we discuss real life double recurrence examples for which the partitioning approach is used.\n5.2 Real-Life Applications\nExample 1\nIn order to illustrate the usefulness of our results we return to the factory management example we glossed over in the introduction:\nA factory uses some machinery, which should be rested adequately on a periodic basis. The machines should be rested for at least three days, within which some routine maintenance should\ntake place. However, the maintenance engineers will not be available throughout a particular day of the week, say, Wednesday. Is it possible to avoid a situation in which the engineers will not be available on a rest day?\nWe now present the solution to this problem based on gcd partitions.\nEventualities: There are two major recurring eventualities: machine-status and weekday. These eventualities may be regarded as state eventualities. The weekday eventuality which has the following component eventualities: Monday, Tuesday, Wednesday, Thursday, Friday, Saturday, Sunday. Each of these should be regarded as states. (e.g. the state of being Monday, etc.). The duration of the interval of maximal occurrence for each state is exactly one day or 24 hours.\nThe machine-status eventuality consists of two component eventualities. The machine works for five days, and then goes into a rest state for three days. This sequence recurs over time. Thus the component eventualities are: Working and Rest. The durations of occurrence for the eventualities are 5 and 3 days respectively. It is important to note here that all the eventualities mentioned here are downward hereditary.\nGCD-Partition: The greatest common divisor of the total durations of states in the two sequences (7 and 8 days respectively) is one. The gcd-partition consists of two partitions respectively for each of the eventualities weekday and machine status. The appropriate partition for the first eventuality is an eventuality w having the following component eventualities: w0, w1, …, w6 each with a duration of occurrence of 1 day, while the second eventuality is z with components z0, z1, …, z7 also with each eventuality having a duration of occurrence of one day.\nThe eventuality Wednesday would always be maximally true over an interval that is equal to the interval of maximal truth of the eventuality w2. The occurrence of Wednesday will always preclude the truth of every other component eventuality of w. Similarly, the intervals of maximal occurrence of z5, z6, z7 would be within the interval of maximal occurrence of the rest state, within any interval of maximal occurrence of the working-rest sequence. The truth of the Rest eventuality would preclude the truth of every other component eventuality of z.\nConclusion: Wednesday is maximally true exactly over any interval on which w2 is maximally true. Similarly the eventuality rest is maximally true over an interval which also covers intervals of maximal occurrence of the eventualities z5, z6, z7 in that order.\nThus, whenever w2 and z5 (or z6 and z7) are both maximally true over some subinterval of any cycle of double recurrence of the eventualities Weekday and Machine-status, then the eventuality Wednesday + Rest would be true over some subinterval of that interval.\nSince by Theorem 5.1, there must exist some subinterval of any cycle of Weekday and Machinestatus over which w2 and z5(or z6 or z7) are both maximally true, it follows that within any such cycle, there exists an interval over which Wednesday + Rest is true.\nComments: We observe here that a rest day within a cycle of recurrence may be any day of the week. One may also wish to tinker with a slightly amended version of the problem in which the machinery works for five days and rests for two days.\nIf the machines started operations on a Monday, then the rest days will always be Saturday and Sunday.\nExample 2\nIn a synchronized factory, there are two production lines running in parallel. The first production line consist of a sequence of three processes P1, P2, P3 while the second production line P4 and P5. The Processes P1 and P5 are process that must not coincide, presumably because some factory safety standard will be compromised. (It may be the case that P5 involves some heating process and P1 involves gasoline flushing.) P1 and P2 take 3 minutes each while P3, P4 and P5 take 2 minutes each. Is it possible for P1 and P5 coincide?\nEventualities: There are two major recurring eventualities. We denote them as PL-1 and PL-2. PL-1 consists of the sequence P1, P2, P3, while PL-2 consists of the sequence P4, P5. The total duration of PL-1 is 8 minutes while the duration of PL-2 is 4 minutes.\nGCD Partition: The gcd of the durations of Pl-1 and PL-2 is 2 minutes. Thus let QL-1 and QL-2 be the gcd partition of PL-1 and PL-2. QL-1 consists of w1,w2,w3and w4, while QL-2 consists of z1and z2, each lasting 2 seconds.\nWithin each period of PL-1 the relationship between the intervals of maximum occurrence of the major eventualities are given thus:\nw1 starts P1 P1 overlaps w2 w2 overlaps P2 w3 ends P2 w4 = P3\nSimilarly, within each period of PL-2:\nP4 = z1 P5 = z2.\nBy Theorem 5.1 there exists an interval within the cycle of the double recurrence of PL-1 and PL-2, in which w2 and z2 are both maximally true.\nConclusion: From the relations outlined above, we can conclude that during any interval in which w2 and z2 coincide, it will be the case that P5 overlaps P2. As such within any cycle of double recurrence of PL-1and PL-2, P2+P5 will be true over some subinterval."
    }, {
      "heading" : "6. The Algorithm",
      "text" : "Instead of understanding this algorithm strictly in terms of constraint propagation as done in section 5.1 above, one can make the assumption that every pair of incidences of wr and zs, for each r and s from the gcd-partition, will both be maximally true over some subinterval of any cycle of double recurrences. Consequently, in order to know whether or not xp and yq ever coincide within any cycle, we can treat the relations between incidences of xp and any wr which are non-disjoint within any period of x and that between incidences of yq and any zs which are non-disjoint within any period of y, as relations between xp and the common interval over which\nwr and zs are both maximally true. If a coincidence happens under these conditions then it will happen in any cycle. Otherwise if we try all possible incidences of wr and zs which are nondisjoint with incidences of xp and yq within any periods of x and y respectively, and assuming wr and zs both be maximally true on the same interval does not lead to the inference of coincidence, then xp and wr will never coincide.\nAs it turns out, it is possible to exhaust all the conditions under which there is a coincidence between xp and yq and therefore a decision algorithm can be constructed by exploring 15 different conditions (or thereabout) under which the coincidence of xp and wr will happen. Twelve of those possibilities are described in the first six theorems presented in this section and their corollary derived from reversing the pair xp, wr and yq, zs, in the antecedents of the theorems. There are three other theorems. Those Theorems follow from Theorem 5.1 and Allen’s interval logic.\nTheorem 6.1"
    }, {
      "heading" : "If within any cycle  of the double recurrence of x and y with a gcd partition w, z, any occurrence of xp starts or overlaps some occurrence of wr and any incidence yq starts or",
      "text" : "overlaps zs, then there exists a subinterval of  over which an incidence of xp+ yq is true\nx, y, p, q, w, z.\nMRT(x, y, )   (x, y)  Gpart(x, y, w, z) \n(r, x. Intrel(x, within, )  (Intrel((wr, x) overlaps ( xp, x)) \nIntrel((xp, x) overlaps ( wr, x))) ) \n(s, y. Intrel(x, within, )  (Intrel((yq, y) starts ( zs, y)) \nIntrel((yq, y) finishes (zs, y))  Intrel((yq, y) overlaps (zs, y)) \nIntrel((yq, y) overlapped-by (zs, y)) )  k. Intrel(k, subs, )  MT(xp + yq, k)\nTheorem 6.2"
    }, {
      "heading" : "If within any cycle  of the double recurrence of x and y with a gcd partition w, z, any occurrence of xp finishes some occurrence of wr and any incidence of yq starts zs, and the sum of the durations of the incidences of xp and yq is greater than the gcd of incidences of x and y,",
      "text" : "then there exists a subinterval of  over which an incidence of xp+ yq is true.\n x, y, p, q, w, z.\nMRT(x, y, )   (x, y)  Intrel( subs j)  Gpart(x, y, w, z) \n(r, x. Intrel(x, within, )  ( Intrel((xp, x) finishes ( wr, x))  s, y. Intrel(y, within, )  ( Intrel((yq, y), starts, ( zs, y)) \ndur((xp, x)) + dur((yq, y) > gcd(dur(x), dur(y)) )\n\nk. Intrel(k, subs, )  MT(xp + yq, k)\nTheorem 6.3 If within any cycle  of the double recurrence of x and y which happens within an interval j with a gcd partition w, z, if an incidence of xp starts an incidence of wr and an incidence of yq is contained in an incidence of zs and the incidences of yq and zs have an auxiliary interval\nthat meets the incidence of yq that is shorter than the incidence of xp then there is a coincidence between xp and yq within the cycle .\n x, y, p, q, w, z.\nMRT(x, y, )   (x, y)  Gpart(x, y, w, z) \nr, x. Intrel(x, within, )  Intrel((xp, x), starts, ( wr, x))  s, y. Intrel(y, within, )  Intrel((zs, y), contains, ( yq, y))  j. Aux((zs, y), ( yq, y), j)  Intrel(j, meets, ( yq, y))  dur( j) < dur((xp, x)) \nk. Intrel(k, subs, )  MT(xp + yq, k)\nTheorem 6.4 If within any cycle  of the double recurrence of x and y with a gcd partition w, z, if an incidence of xp finishes an incidence of wr and an incidence of yq is contained in an incidence of zs and the incidences of yq and zs have an auxiliary interval that is met by the incidence of yq that is shorter than the incidence of xp then there is a coincidence between xp and yq within the cycle.\n x, y, p, q, w, z.\nMRT(x, y, )   (x, y)  Gpart(x, y, w, z) \nr, x. Intrel(x, within, )  Intrel((xp, x), finishes, ( wr, x))  s, y. Intrel(y, within, )  Intrel((zs, y), contains, ( yq, y))  j. Aux((zs, y), ( yq, y), j)  Intrel((yq, y), meets, j)  dur( j) < dur((xp, x)) \nk. Intrel(k, subs, )  MT(xp + yq, k)\nTheorem 6.5 If within any cycle  of the double recurrence of x and y with a gcd partition w, z, if an incidence of xp overlaps an incidence of wr and an incidence of yq is contained in an incidence of zs and the incidences of yq and zs have an auxiliary interval that meets the incidence of yq that is shorter than the common interval of the incidences of xp and wr, then there is a coincidence between xp and yq within the cycle.\n x, y, p, q, w, z.\nMRT(x, y, j)   (x, y)  Gpart(x, y, w, z) \nr, x. Intrel(x, within, )  Intrel((xp, x), overlaps, ( wr, x))  s, y. Intrel(y, within, )  Intrel((zs, y), contains, ( yq, y))  j. Aux((zs, y), ( yq, y), j)  Intrel( j , meets, ( yq, y) )  dur( j) < dur(common ((xp, x), ( wr, x))  k. Intrel(k, subs, j)  MT(xp + yq, k)\nTheorem 6.6"
    }, {
      "heading" : "If within any cycle  of the double recurrence of x and y, with a gcd partition w, z, if an incidence of wr overlaps an incidence of xp and an incidence of yq is contained in an incidence",
      "text" : "of zs and the incidences of yq and zs have an auxiliary interval that the incidence of yq meets\nand is shorter than the common interval of the incidences of xp and wr, then there is a coincidence between xp and yq within the cycle.\n x, y, p, q, w, z.\nMRT(x, y, )   (x, y)  Intrel( subs j)  Gpart(x, y, w, z) \nr, x. Intrel(x, within, )  Intrel((wr, x), overlaps, ( xp, x))  s, y. Intrel(y, within, )  ( Intrel((zs, y), contains, ( yq, y))  j. Aux((zs, y), ( yq, y), j)  Intrel((yq, y), meets, j )  dur( j) < dur(common((xp, x), (wr, x)) \nk. Intrel(k, subs, )  MT(xp + yq, k)\nIt is important to note that for Theorems 6.1 to 6.6 above, we can create corollaries in which the\npair xp and yq, the pair wr and zs, as well as the pair x and y are all exchanged in the antecedent part of the implication operator, . In every single case, the consequent part remains the same. This suggests that all these theorems have some sort of commutative properties.\nOn the other hand, for all the following Theorems 6.7 to 6.9, the preconditions were simple enough to enable the inclusion of commutative conditions in the antecedents.\nTheorem 6.7"
    }, {
      "heading" : "If within any cycle  of the double recurrence of x and y with a gcd partition w, z, if an incidence of xp starts an incidence of wr and an incidence of yq starts an incidence of zs, OR if an incidence of xp finishes an incidence of wr and an incidence of yq finishes an incidence of",
      "text" : "zs, then there is a coincidence between xp and yq within the cycle.\n x, y, p, q, w, z.\nMRT(x, y, )   (x, y)  Gpart(x, y, w, z) \nr, s, x, y. Intrel(x, within, )  Intrel(y, within, )  ( Intrel((xp, x), starts, ( wr, x)) \nIntrel((yq, y), starts, (zs, y)) ) \n(Intrel((xp, x), finishes, ( wr, x)) \nIntrel((yq, y), finishes, (zs, y)) )\n\nk. Intrel(k, subs, )  MT(xp + yq, k)\nTheorem 6.8 If within any cycle  of the double recurrence of x and y with a gcd partition w, z, if an incidence of xp is contained an incidence of wr and an incidence of yq is contained in an incidence of zs, and the incidences of xp and wr have an auxiliary interval that meets the incidence of xp and similarly, and the incidences of yq and zs have an auxiliary interval that meets the incidence of yq. Let j and k be auxiliary intervals such that j is an auxiliary of the incidences of xp and wr that meets the incidence of xp and k is an auxiliary interval of the incidences of yq and zs which meets the incidence of yq. Then the only condition left for the incidences of xp and yq to coincide under these circumstances is if either duration of j is between that of k and the sum of the durations of k and that of yq, or the duration of k is between that of j and the sum of the durations of j and that of xp.\n x, y, p, q, w, z.\nMRT(x, y, )   (x, y)  Gpart(x, y, w, z) \nr, x. Intrel(x, within, )  Intrel((wr, x) contains ( xp, x)) \ns, y. Intrel(y, within, )  Intrel((zs, y), contains, ( yq, y)) \nj, k . Aux((wr, x), ( xp, x), j)  Intrel( j, meets, ( xp, x) ) \nAux((zs, y), ( yq, x), k)  Intrel( k, meets, ( yq, y))) \n( dur(k)  dur( j) < dur( k) + dur((yq, y)) \ndur(j)  dur( k) < dur( j) + dur((xp, x) ) \nm. Intrel(m, subs, )  MT(xp + yq, m) )\nTheorem 6.9 If within any cycle  of the double recurrence of x and y which happens within an interval j with a gcd partition w, z, any incidence of xp is a super-interval of some incidence of wr and any incidence of yq is a super-interval by zs, then there exists a subinterval of j over which an incidence of xp+ yq is true.\n x, y, p, q, w, z, .\nMRT(x, y, )   (x, y)  Gpart(x, y, w, z) \nr, x, y. Intrel(x, within, )  Intrel(y, within, ) \n(Intrel((wr, x), subs, ( xp, x) ) \ns, n2.Intrel((zs, y), subs, ( yq, y) ) ) \nk. Intrel(k, subs, )  MT(xp + yq, k)\nFrom the antecedents of all these theorems we now construct a different rendition of the algorithm that detects coincidence which carries out an optimization. In the algorithm, A6.1-6.6 denotes the disjunction of the antecedents of Theorems 6.1 to 6.6, while Commutative(A6.1-6.6) denotes the disjunction of the commutative versions of Theorem 6-1 to 6.6. A similar interpretation should be given to A6.7-6.8.\nThe optimized version of the Coincide function presented earlier as Algorithm 5.2 is now presented as Algorithm 6.1 below.\nAlgorithm 6.10\nbegin\ngcd = greatest_common_division(dur(x), dur(y)) if p or q are not with limits of lengths of x and y respectively then halt /* create interval network for an incidence of yq and incidences of elements of the gcd-partition w within a period y that are non-disjoint, returning true if some zs is found to be a subinterval of yq */ reset the coincidence_flag\n/*coincidence_flag is a global variable*/ Create_network(y, z, q) if coincidence_flag then return true /* create interval network for an incidence of xp and incidences of elements of the gcd-partition z within a period x that are non-disjoint, returning true if some wr is found to be a subinterval of xp */ reset the coincidence_flag Create_network(x, w, p) If coincidence_flag then return true\nfor all r such that (wr, x) is non-disjoint with (xp,x)\nfor all s that (zs y) is non-disjoint with (yq,y) if A6.1- 6.6 or Commutative(A6.1-6.6) or A6.7-6.8 then\nreturn true\nreturn false\nend\nThis algorithm starts by creating an interval network around an incidence of yq in any arbitrary period of y, and the incidences of components of its gcd partition z with which it is non-disjoint. In addition, this network creation procedure looks out to know if the incidence of yq is a superinterval of a component of z, and if it is sets a coincidence flag which helps conclude the occurrence of a coincidence of the incidences of xp and yq in the main procedure (according to Theorem 6.9). A similar network is built for xp. The algorithm for the network creation task is in Appendix B.\nThe second part of the algorithm focuses on applying Theorems 6.1 to 6.8. In the double for loop, each of the incidences of components of w and z in the networks of xp and yq respectively are examined in the light of Theorems 6.1 to 6.8, in order to determine coincidence. Once any of the antecedents of any of these theorems is found to be true, then coincidence is determined. By checking Theorem looking out for the antecedent of 6.9 while creating the network, we simplify the time complexity of the embedded loops. Thus the number of iterations for each loop is not more than 2, because we have first taken care of the case in which xp’s incidence shares common intervals with more than two intervals of the gcd-partition entity’s intervals by first addressing a situation in which the interval of occurrence of xp or yq is a super-interval of a gcd-partition’s entity. Thus the running time of the loops has a constant upper bound.\n6.1 Algorithm Analysis\nWe start with a result on the asymptotic running time of Algorithm 6.1 presented as Lemma 6.1.1.\nLemma 6.1.1 The worst case running time of Algorithm 6.1 runs in a time that is linear in the maximum of the\ndurations of x and y i.e. O(max(dur(x), dur(y))).\nThere are three basic tasks involved in the algorithm. The first task is finding the greatest common divisor of the durations of x and y. The running time of typical gcd algorithms is O((lg(max(dur(x), dur(y)))) 2 ).\nThe second task is that of setting up the temporal networks for incidences of xp and yq within respective cycles of x and y as done by the create-network algorithm in Appendix B. The two\ncalls to create networks run in times O(len(x) + dur(x)). Therefore the two calls to createnetwork have a worst case running time of:\nO(max(len(x), len(y)) + max(dur(x), dur(y)))\nRealizing that the length of any eventuality is usually smaller than its duration, ( i.e. len(x) \ndur(x)) . then it is clear that the running time is O(max(dur(x), dur(y))). That time is more asymptotically significant than the time it takes to find the gcd of the durations of x and y.\nFinally the task of determining coincidence from the networks set up for xp and yq is constant as argued by section 5. Hence the running time of this algorithm is linear in the maximum of the duration of x and y.\nOn the other hand an algorithm based on temporal projection over a cycle of double recurrence has a worst case running time that is quadratic as stated in this lemma.\nLemma 6.1.2 A coincidence algorithm based on a temporal projection over a cycle of double recurrence has a worst case running time that is quadratic in the durations of x and y.\nIn the worst case, the length of every eventuality is equal to its duration, and the gcd of the durations of x and y is 1. In that case the running time of an algorithm that does such a projection\nwill be O(dur(x)* dur(y)), because the duration of a cycle of x and y is the product of the duration of the periods of x and y."
    }, {
      "heading" : "7. Summary and Conclusions",
      "text" : "We have presented, a logical formalization for reasoning about double recurrence, and thereby presented a solution to the coincidence problem. The importance of the coincidence problem has been discussed. An algorithm that detects coincidence based on the property of gcd-partitions of double recurrences presented as Theorem 5.1 has been presented as algorithm 6.1. Theorem 5.1 states that every pair of components from the gcd-partition (w and z respectively), will maximally coincide within any cycle. The algorithm 6.1 then determines coincidence of xp and yq within a cycle, by finding a pair of the components of the gcd partition of x and y whose maximal coincidence imply that the incidences of xp and yq will coincide. The solution presented here is shown to be more efficient than the one presented in [2] in the worst case.\nIt is important to re-emphasize here that the eventualities considered here have definite as opposed to variable or fuzzy durations. A fuzzy domain will lead to a problem that is nondeterministic. Thus an average solution will be a reasonable approximation to the solution. In that case, the average durations of all eventualities are taken to be the definite durations.\nFinally, this paper has addressed the coincidence problem within double recurrences for the case where the number of recurring eventualities is just two. A natural extension to this problem is when there are more than two sequences where one needs to find out the coincidence of more than two eventualities. This is an interesting direction for future work. It only remains to be seen how often such double recurrence problems may arise in practice.\nReferences\n1. B.O. Akinkunmi, A.O. Osofisan, Temporal properties of repetitive entities, Artificial Intelligence Review 22(4), 297–338, December 2004\n2. B.O. Akinkunmi The Problem of Coincidence in a Theory of Temporal Double recurrence. Journal of Applied Logic, 15:46-68, May 2016.\n3. J. F. Allen. Maintaining knowledge about temporal intervals. Communications of the ACM. 26(11): 832-843, 1983\n4. J. F. Allen. Towards a general theory of action and time. Artificial Intelligence, 23(2) : 123-154, 1984.\n5. T.L. Dean and D.V. McDermott. Temporal Database Management. Artificial Intelligence 32(2):1-55, 1987\n6. A. Galton Eventualities In M. Fisher, D. Gabbay and L Vila (eds) Handbook of Temporal Reasoning in Artificial Intelligence, pp 25-58, Elsevier (2005)\n7. A. Galton. Operators vs Arguments: The Ins and Outs of Reification. Synthese, 150(3): 415-441, 2006.\n8. Johannes A.G.M..Koomen. Reasoning about Recurrence. Ph.D. thesis, Department of Computer Science, University of Rochester, 1989.\n9. Johannes A. G. M. Koomen, Reasoning about recurrence, International Journal of Intelligent Systems 6(5): 461-496 (1991)\n10. D.H. Lehmer. Mathematical methods in Large-scale Computing Units. Harvard University Computation Laboratory Annals, 26:.141-146, 1951.\n11. D. McDermott, A temporal logic for reasoning about processes and plans. Cognitive Science, 6 pp. 101-155, 1982.\nAppendix A (Proofs) Proof of Theorem 4.4\nThe Proof of Theorem 4.4 depends on two lemma 4.4a and lemma 4.4b below.\nLemma 4.4a For any complex eventuality sequence x, the durations of incidence of any incidence of its subsequence within any two different periods of incidence of x are equal.\n1, 2, x. p, r. 1, 2  (x)  len(x) = p  r  p \ndur(cover*([(xu, 1)]u= 1 u=r )) = dur(cover*([(xu, 2)]u= 1 u=r ))\nA proof of this can easily be constructed by induction on the length of the sub-sequence which is the value of r going by the fact that all incidences of any eventuality are of the same duration (Axiom 3.4).\nLemma 4.4b If there are intervals i, j k and m such that i and j have the same beginning and i meets k while j meets m. Assume there are corresponding intervals i1, j1, k1, m1 such that i1 and j1 have the same beginning i1 meets k1 while j1 meets m1. If the durations of each pair of corresponding intervals are equal then the following are true:\n1. For any auxiliary intervals l for the interval pair (k, m), there is a similar auxiliary interval l1 for the pair (k1, m1) whose relations to k1 and m1 are exactly the same as\nthose of l to k and m respectively and the durations of l and l1 are the same.\n2. If there is a common interval between k and m, then there is a common interval between k1 and m1 such that both have the same duration.\ni, j, k, m, i1, j1, k1,m1.\ndur(i) = dur(i1)  dur(j) = dur(j1)  dur(m) = dur(m1)  dur(k) =dur(k1)  Samebegin(i, j)  Samebegin(i1, j1)  Intrel(i meets k)  Intrel(i1 meets k1)  Intrel(j meets m)  Intrel(j1 meets m1) \n(l, l1, rel1, rel2 . Aux(k, m, l)  Intrel(l, rel1,k)  Intrel(l rel2 m) \nl11. Aux(k1, m1, l1)  Intrel(l1, rel1,k1)  Intrel(l1 rel2 m1) ) \ndur(common(k, m)) = dur(common(k1, m1))\nWe believe there is no need to offer a proof for this lemma because by the fact that each both interval pairs (x, y) and (x1, y1) have the “same beginning” relation, and the fact that each of the pairs of intervals (z, z1) and (w, w1) are equal, the relations network {x. y. w. z} is a carbon copy of {x1, y1, z1, w1}. Thus all auxiliary and common intervals in the first relations network have exact carbon-copies in the second with the same durations.\nMain Proof of Theorem 4.4\n1. Let 1, 2  (x) and Part(x, z) and for some p and q let 0  p  len(x)-1 and\n0  q  len(w)-1 and Intrel(xp disjoint zq)\n2. dur(cover*([(xu, 1)]u= 1 u=p-1 )) = dur(cover*([(xu, 2)]u= 1 u=p-1 )) Lemma 4.4a 3. dur(cover*([(zu, 1)]u= 1 u=q-1 )) = dur(cover*([(zu, 2)]u= 1 u=q-1 )) Lemma 4.4a 4. Samebegin( (x1, 1), (z1, 1)) and Samebegin( (x1, 2), (z1, 2)) (Definition of Partition and MT) 5. Intrel((x1, 1), starts, cover*([(xu, 1)]u= 1 u=p-1 )) \nIntrel((z1, 2), starts, cover*([(zu, 1)]u= 1 u=p-1 )) (Definition of MT)\n6. Samebegin(cover*([(xu, 1)]u= 1 u=p-1 ), cover*([(zu, 1)]u= 1 u=p-1 )) ( 4 and 5) 7. Samebegin(cover*([(xu, 2)]u= 1 u=p-1 ), cover*([(zu, 2)]u= 1 u=p-1 )) (4 and 5) 8. Intrel(cover* ([(xu, 1)]u= 1 u=p-1 ), meets, (xp, 1) ) \nIntrel( cover*([(xu, 2)]u= 1 u=p-1 ) , meets, (xp, 2) ) (Definitions of cover* and  )\n9. Intrel( cover *([(zu, 1)]u= 1 u=q-1 ), meets, (zq, 1) ) \nIntrel[(cover* ((zu, 2)]u= 1 u=q-1 )], meets, (zq, 2) ) (Definitions of cover* and  )\n10. dur((xp, 1)) = dur((xp, 2)) dur( (zq, 1) )= dur( (zq, 2)) 11. Steps 2,3,6,7, 8,9 and Lemma 4.4b lead to the conclusions:\na. dur(common((xp, 1, (zq, 1)) = dur(common(((xp, 2), (zq, 2)) b. (l, l1, rel1, rel2 . Aux((xp, 1), (zq, 1) , l)  Intrel(l, rel1, (xp, 1) )  Intrel(l\nrel2 (zq, 1)) \nl11. Aux((xp, 2), (zq, 2), l)  Intrel(l1, rel1, (xp, 2)) \nIntrel(l1 rel2 (zq, 2)) )\nThe proof is concluded.\nProof of Theorem 5.1 First let us assume that r < s, so that a single period of the eventuality w is shorter than that of the eventuality z. From Theorem 4.7, there are exactly s periods of z and r periods of the w.\nBy Allen’s interval logic and for any given cycle,  of the double recurrence of the eventualities\nz and w, i.e.  (w, z) it is the case that:\n(w1, (w1, )[ 1]) = (z1, (z, )[1]), (w2, (w2, )[1]) = (z2, (z, )[1]),… (ws, (wr, )[1]) = (zr, (z, )[1]) (w1, (w1, )[2]) = (zr+1, (z, )[1]),…\nFrom that pattern above one concludes for any interval k1 and integer n1 within the bounds [1..r] that if k1 = (wp, (w, )[n1]) then there exists n2 within the bounds [1..s] such that (zf(n1,p), (w, )[n2]) = k1, where f(n1, p) is given by:\nf(n1, p) = p if n1 = 1 f(n1, p) = f(n1-1, p) + r mod s otherwise\nThese two equations refer to a Linear Congruential Generator, belonging to a class of random number generators, which is a generalization of Lehmer’s class of generators [10]. Thus, by the following criteria:\n1. The gcd of r and s is 1 (by Theorem 4.7) 2. Let a be the coefficient f(n1, p) then a-1 = 0 and it is divisible by all integers.\nIt is the case that yp has the maximum period of s. In other words f(n1, p) generates different numbers within the bounds [1..s] given the sequence of n1 values 1..r.\nBecause there are r periods of the eventuality z within the cycle , then for any p there exists an\ninterval over which xp is true and zq is also true for all possible q. "
    }, {
      "heading" : "Appendix B (The Create Algorithms)",
      "text" : "Create_network( x, w, p)\nbegin\nk = 1 j = 1 cumdurx = 0 cumdury = gcd /*This loop moves forward to xp, the eventuality of interest */ while j < p do\nif cumdurx + x.dur[j] = k*gcd then begin\ninc j, inc k, cumdurx = cumdurx + x.dur[j] end\nelse if cumdurx + x.dur[j] > k*gcd then\ninc k\nelse begin\ninc j cumdurx = cumdurx +x.dur[j], end\n/* Setting a network of non-disjoint intervals around (xp, x) */ while j = p and not coincidence-flag do\nif (k-1)*gcd < cumdurx then\nif k *gcd < cumdurx +x.dur[p] then begin\nassert Intrel((wk,x), overlaps,(xp, x))\n/* Storing information about auxiliary intervals and the common interval for these two intervals above*/\nnew = make label\nassert Intrel(new, starts, (wk,x))  Intrel( new, meets, (xp,x))\n dur(new) = comdurx - k*gcd\nnew = make label\nassert intrel(new, ends, (xp, x))  Intrel((wk, x), meets new) \ndur(new) = cumdurx +x.dur[p] – (k+1)*gcd \ndur(common((xp, x), (wk, x) ) ) = (k+1)*gcd - comdurx\ninc k end\nelse if k * gcd = cumdurx + x.dur[p] then begin\nassert intrel((xp,x), finishes, (wk,x))\n/* Storing information about the only auxiliary intervals for these two intervals above */\nnew = make label\nassert Intrel(new, starts, (wk,x)) \nIntrel(new, meets, (xp,x)  dur(new) = comdurx – k*gcd,\ninc j end\nelse begin\nassert Intrel((wk,x), contains, (xp, x))\n/* Storing information about the two auxiliary intervals for the two intervals above*/\nnew = make label\nassert Intrel(new, starts (wk,x)) \nIntrel(new, meets, (xp,x)  dur(new) = comdurx – k*gcd\nnew = make label\nassert Intrel((xp,x), meets new) \nIntrel(new finishes (wk,x))  dur(new) (k+1)*gcd\ninc j end\nelse /* if (k-1)*gcd = cumdurx then */\nif k*gcd = cumdurx +x.dur[p] then begin\nInrel((wk, x), equals, (xp, x)),\n/* There are no auxiliary intervals here. More importantly, we do not need them */\nset coincidence_flag inc j end\nelse if k*gcd < cumdurx + x.dur[p]then begin\nassert Intrel((wk, x), starts, (xp, x))\n/*There is an auxiliary interval here, but we do not need it. There is coincidence*/\nset coincidence_flag inc k end\nelse begin assert Intrel((xp,x), starts, (wk, x))\n/* Storing information about the one auxiliary interval for these two intervals above*/\nnew = make label\nassert Intrel(new, finishes, (wk,x)) \nIntrel((xp,x), meets new)  dur(new) = (k+1)*gcd - cumdurx\ninc j end\nreturn end"
    } ],
    "references" : [ {
      "title" : "Osofisan, Temporal properties of repetitive entities",
      "author" : [ "A.O.B.O. Akinkunmi" ],
      "venue" : "Artificial Intelligence Review",
      "citeRegEx" : "1",
      "shortCiteRegEx" : "1",
      "year" : 2004
    }, {
      "title" : "Problem of Coincidence in a Theory of Temporal Double recurrence",
      "author" : [ "B.O. Akinkunmi Th" ],
      "venue" : "Journal of Applied Logic, 15:46-68, May",
      "citeRegEx" : "2",
      "shortCiteRegEx" : null,
      "year" : 2016
    }, {
      "title" : "Maintaining knowledge about temporal intervals",
      "author" : [ "J.F. Allen" ],
      "venue" : "Communications of the ACM",
      "citeRegEx" : "3",
      "shortCiteRegEx" : "3",
      "year" : 1983
    }, {
      "title" : "Towards a general theory of action and time",
      "author" : [ "J.F. Allen" ],
      "venue" : "Artificial Intelligence, 23(2) : 123-154,",
      "citeRegEx" : "4",
      "shortCiteRegEx" : null,
      "year" : 1984
    }, {
      "title" : "Temporal Database Management",
      "author" : [ "T.L. Dean", "D.V. McDermott" ],
      "venue" : "Artificial Intelligence",
      "citeRegEx" : "5",
      "shortCiteRegEx" : "5",
      "year" : 1987
    }, {
      "title" : "Operators vs Arguments: The Ins and Outs of Reification",
      "author" : [ "A. Galton" ],
      "venue" : "Synthese, 150(3): 415-441,",
      "citeRegEx" : "7",
      "shortCiteRegEx" : null,
      "year" : 2006
    }, {
      "title" : "Reasoning about Recurrence",
      "author" : [ "Johannes A.G.M..Koomen" ],
      "venue" : "Ph.D. thesis, Department of Computer Science, University of Rochester,",
      "citeRegEx" : "8",
      "shortCiteRegEx" : "8",
      "year" : 1989
    }, {
      "title" : "Reasoning about recurrence, International Journal of Intelligent Systems",
      "author" : [ "Johannes A.G.M. Koomen" ],
      "venue" : null,
      "citeRegEx" : "9",
      "shortCiteRegEx" : "9",
      "year" : 1991
    }, {
      "title" : "Mathematical methods in Large-scale Computing Units",
      "author" : [ "D.H. Lehmer" ],
      "venue" : "Harvard University Computation Laboratory Annals, 26:.141-146,",
      "citeRegEx" : "10",
      "shortCiteRegEx" : null,
      "year" : 1951
    }, {
      "title" : "A temporal logic for reasoning about processes and plans",
      "author" : [ "D. McDermott" ],
      "venue" : "Cognitive Science, 6 pp. 101-155,",
      "citeRegEx" : "11",
      "shortCiteRegEx" : null,
      "year" : 1982
    } ],
    "referenceMentions" : [ {
      "referenceID" : 0,
      "context" : "The problem of temporal recurrence is known in knowledge representation [1, 8, 9].",
      "startOffset" : 72,
      "endOffset" : 81
    }, {
      "referenceID" : 6,
      "context" : "The problem of temporal recurrence is known in knowledge representation [1, 8, 9].",
      "startOffset" : 72,
      "endOffset" : 81
    }, {
      "referenceID" : 7,
      "context" : "The problem of temporal recurrence is known in knowledge representation [1, 8, 9].",
      "startOffset" : 72,
      "endOffset" : 81
    }, {
      "referenceID" : 1,
      "context" : "The problem of coincidence in double and regular temporal recurrence was introduced in [2].",
      "startOffset" : 87,
      "endOffset" : 90
    }, {
      "referenceID" : 6,
      "context" : "Our interest in this problem has been motivated by the need to enable a planner/scheduler cope with reasoning about the possible occurrence of the preconditions of an action in the context of double recurrence as opposed to a single recurrence addressed in [8].",
      "startOffset" : 257,
      "endOffset" : 260
    }, {
      "referenceID" : 1,
      "context" : "In that regard, the main result of [2] is that if a coincidence for those eventualities would exist at all, one must happen within every cycle of double recurrence.",
      "startOffset" : 35,
      "endOffset" : 38
    }, {
      "referenceID" : 6,
      "context" : "4 The problems described above are examples of the coincidence problem which arises in contexts described by an extension of Koomen’s parlance [8, 9] as “double recurrence”.",
      "startOffset" : 143,
      "endOffset" : 149
    }, {
      "referenceID" : 7,
      "context" : "4 The problems described above are examples of the coincidence problem which arises in contexts described by an extension of Koomen’s parlance [8, 9] as “double recurrence”.",
      "startOffset" : 143,
      "endOffset" : 149
    }, {
      "referenceID" : 1,
      "context" : "As such it has been shown that any search for coincidence within an interval over which double recurrence take place can be narrowed down to any arbitrary cycle[2].",
      "startOffset" : 160,
      "endOffset" : 163
    }, {
      "referenceID" : 1,
      "context" : "This paper uses the same language of the reified first order logic used in [2] which notation is briefly presented in section 2.",
      "startOffset" : 75,
      "endOffset" : 78
    }, {
      "referenceID" : 1,
      "context" : "The paper ends with an algorithmic analysis of the two main algorithms involved in the proposed solution and compares their performance with the simple temporal projection algorithm proposed in [2].",
      "startOffset" : 194,
      "endOffset" : 197
    }, {
      "referenceID" : 1,
      "context" : "It is exactly the same language used in [2].",
      "startOffset" : 40,
      "endOffset" : 43
    }, {
      "referenceID" : 2,
      "context" : "A time interval is time unit over which a proposition may be regarded as being either true or false[3, 4].",
      "startOffset" : 99,
      "endOffset" : 105
    }, {
      "referenceID" : 3,
      "context" : "A time interval is time unit over which a proposition may be regarded as being either true or false[3, 4].",
      "startOffset" : 99,
      "endOffset" : 105
    }, {
      "referenceID" : 4,
      "context" : "In some literature a time interval is regarded as a pair of time points[5].",
      "startOffset" : 71,
      "endOffset" : 74
    }, {
      "referenceID" : 5,
      "context" : "[7].",
      "startOffset" : 0,
      "endOffset" : 3
    }, {
      "referenceID" : 6,
      "context" : "We use the predicates here as used in [8] i.",
      "startOffset" : 38,
      "endOffset" : 41
    }, {
      "referenceID" : 2,
      "context" : "2 Interval Calculus Allen [3] formulated the interval calculus, as a means of representing time, along with a computationally efficient reasoning algorithm based on constraint propagation.",
      "startOffset" : 26,
      "endOffset" : 29
    }, {
      "referenceID" : 9,
      "context" : "Allen had argued that time points proposed earlier by McDermott [11], was inadequate.",
      "startOffset" : 64,
      "endOffset" : 68
    }, {
      "referenceID" : 6,
      "context" : "This concept is referred to in this paper as in [8], as the cover of the two intervals.",
      "startOffset" : 48,
      "endOffset" : 51
    }, {
      "referenceID" : 0,
      "context" : "cover*(tm) = m  (dim(tm) = 1  m = tm[1])  (dim(tm) > 1  Intrel(tm[1] starts m)  Intrel(tm[dim(tm)] ends m)",
      "startOffset" : 38,
      "endOffset" : 41
    }, {
      "referenceID" : 0,
      "context" : "cover*(tm) = m  (dim(tm) = 1  m = tm[1])  (dim(tm) > 1  Intrel(tm[1] starts m)  Intrel(tm[dim(tm)] ends m)",
      "startOffset" : 69,
      "endOffset" : 72
    }, {
      "referenceID" : 0,
      "context" : "The following theorem from the literature[1], presents an interesting result about the temporal relations between each incidences of xp and yq within each cycle.",
      "startOffset" : 41,
      "endOffset" : 44
    }, {
      "referenceID" : 1,
      "context" : "The solution presented here is shown to be more efficient than the one presented in [2] in the worst case.",
      "startOffset" : 84,
      "endOffset" : 87
    } ],
    "year" : 2017,
    "abstractText" : "A logical theory of regular double (or multiple) recurrence of eventualities (which are regular patterns of occurrences that are repeated) in time, has been developed within the context of temporal reasoning that enabled reasoning about the problem of coincidence. i.e. if two complex eventualities (or eventuality sequences) consisting respectively of component eventualities x0, x1,....,xr and y0, y1, ..,ys both recur over an interval k and all eventualities are of fixed durations, is there a subinterval of k over which the occurrence xp and yq for 1 p  r and 1 q  s coincide. We present the ideas behind a new algorithm for detecting the coincidence of eventualities xp and yq within a cycle of the double recurrence of x and y. The algorithm is based on the novel concept of gcd-partitions that requires the partitioning of each of the incidences of both x and y into eventuality sequences each of which components have a duration that is equal to the greatest common divisor of the durations of x and y. The main idea behind the algorithm is the fact that there exists a subinterval of the cycle of double recurrence over which any pair of component eventualities from the gcd-partitions of x and y, are fully incident. Thus we only need determine whether or not a coincidence happens during one of those intervals when such a pair from the gcd-partition, with which xp and yq are non-disjoint for each of the incidences of x and y, fully coincide. The gcd-partitioning of a double recurrence significantly reduces the search space that one needs to explore while looking for the coincidence of xp and yq from a cycle of multiple recurrence to two periods of x and y. The worst-case running time of the partitioning algorithm is linear in the maximum of the durations of x and y, while the worst case running time of an algorithm exploring a complete cycle is quadratic in the durations of x and y. Hence the partitioning algorithm works faster than the cyclical exploration in the worst case.",
    "creator" : "Microsoft® Office Word 2007"
  }
}