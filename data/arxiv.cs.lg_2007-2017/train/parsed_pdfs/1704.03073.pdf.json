{
  "name" : "1704.03073.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : "Data-efficient Deep Reinforcement Learning for Dexterous Manipulation",
    "authors" : [ "Ivaylo Popov", "Nicolas Heess", "Timothy Lillicrap", "Roland Hafner", "Gabriel Barth-Maron", "Matej Vecerik", "Thomas Lampe", "Yuval Tassa", "Tom Erez", "Martin Riedmiller" ],
    "emails" : [ ],
    "sections" : [ {
      "heading" : null,
      "text" : "I. INTRODUCTION\nDexterous manipulation is a fundamental challenge in robotics. Researchers have long been seeking a way to enable robots to robustly and flexibly interact with fixed and free objects of different shapes, materials, and surface properties in the context of a broad range of tasks and environmental conditions. Such flexibility is very difficult to achieve with manually designed controllers. The recent resurgence of neural networks and “deep learning” has inspired hope that these methods will be as effective in the control domain as they are for perception. And indeed, in simulation, recent work has used neural networks to learn solutions to a variety of control problems from scratch (e.g. [7, 20, 32, 31, 11, 17]).\nWhile the flexibility and generality of learning approaches is promising for robotics, these methods typically require a large amount of data that grows with the complexity of the task. What is feasible on a simulated system, where hundreds of millions of control steps are possible [23], does not necessarily transfer to real robot applications due to unrealistic learning times. One solution to this problem is to restrict the generality of the controller by incorporating task specific knowledge, e.g. in the form of dynamic movement primitives [30], or in the form of strong teaching signals, e.g. kinesthetic teaching of trajectories [24]. Recent works have had some success learning flexible neural network policies directly on real robots (e.g. [18, 5, 39]), but tasks as complex as grasping-and-stacking remain daunting.\nAn important issue for the application of learning methods in robotics is to understand how to make the best use of collected data, which can be expensive to obtain, both in terms of time and money. To keep learning times reasonably low even in complex scenarios, it is crucial to find a practical compromise between the generality of the controller and the necessary restrictions of the task setup. This is the gap that we aim to fill in this paper: exploring the potential of a learning approach that keeps prior assumptions low while keeping data consumption in reasonable bounds. Simultaneously, we are interested in approaches that are broadly applicable, robust, and practical.\nIn this paper we provide a simulation study that investigates the possibility of learning complex manipulation skills endto-end with a general purpose model-free deep reinforcement learning algorithm. The express goal of this work is to assess the feasibility of performing analogous end-to-end learning experiments on real robotics hardware and to provide guidance with respect to the choice of learning algorithm and experimental setup and the performance that we can hope to achieve.\nThe task which we consider to this end is that of picking up a Lego brick from the table and stacking it onto a second nearby brick using a robotic arm with 9 degrees of freedom (DoF), six in the arm and three for the fingers in the gripper. In addition to having a high-dimensional state and action space, the task exemplifies several of the challenges that are encountered in real-world manipulation problems. Firstly, it involves contact-rich interactions between the robotic arm and two freely moving objects. Secondly it requires mastering several sub-skills (reaching, grasping, and stacking). Each of these sub-skills is challenging in its own right as they require both precision (for instance, successful stacking requires accurate alignment of the two bricks) and as well as robust generalization over a large state space (e.g. different initial positions of the bricks and the initial configuration of the arm). Finally, there exist non-trivial and long-ranging dependencies between the solutions for different subtasks: for instance, the ability to successfully stack the brick in the later part of the task depends critically on having picked up the brick in a sensible way beforehand.\nOn the algorithm side we build on the Deep Deterministic Policy Gradient (DDPG; [20]), a general purpose model-free reinforcement learning algorithm for continuous action spaces, and extend it in two ways (section V): firstly, we improve the the data efficiency of the algorithm by scheduling updates\nof the network parameters independently of interactions with the environment. Secondly, we overcome the computational and experimental bottlenecks of single-machine single-robot learning by introducing a distributed version of DDPG which allows data collection and network training to be spread out over multiple computers and robots.\nWe further propose two broadly applicable strategies that allow us to inject prior knowledge into the learning process in order to help reliably find solutions to complex tasks and further reduce the amount of environmental interaction. The first of these strategies is a recipe for designing effective shaping rewards for compositional tasks (section VI), while the second (section VII) uses a suitable bias in the distribution of initial states to achieve an effect akin to a curriculum or a form of apprenticeship learning.\nIn combination these contributions allow us to reliably learn robust policies for the full task from scratch in less than 10 million environment transitions. This corresponds to less than 10 hours of interaction time on 16 robots, thus entering a regime that no longer seems unrealistic with modern experimental setups. In addition, when states from successful trajectories are used as the start states for learning trials the full task can be learned with 1 million transitions (i.e. less than 1 hour of interaction on 16 robots). To our knowledge our results provide the first demonstration of solving complex manipulation problems involving multiple freely moving objects. They are also encouraging as a sensible lower bound for real-world experiments suggesting that it may indeed be possible to learn such non-trivial manipulation skills directly on real robots."
    }, {
      "heading" : "II. RELATED WORK",
      "text" : "Reinforcement learning approaches solve tasks through repeated interactions with the environment guided by a reward signal that indicates the success or failure of a trial. A wide variety of techniques have been developed that exploit this idea [34], with a broad distinction often made between valuebased and policy search methods. While the former estimate and improve a value function, policy search methods directly optimize the parameters of a policy to maximize cumulative\nreward. The latter have been routinely applied in robotics, in part because they straightforwardly handle continuous and high-dimensional action spaces [3] and applications include manipulation [26, 13, 25, 37, 18, 5, 39, 8], locomotion e.g. [16, 21], and a range of other challenges such as helicopter flight [1].\nOne limitation that has hampered policy search methods is that they can scale poorly with the number of parameters that need to be estimated. This limitation, and other constraints when working with real robotics hardware has led research to focus on the use of manually engineered and restrictive features and movement representations, particularly trajectorybased ones such as spline based dynamic movement primitives. Simplifying the policy space can make learning on real hardware tractable, but it also limits the kinds of problems that can be solved. In order to solve a problem such as picking up and manipulating an object, more expressive function classes are likely to be needed.\nThe use of rich and flexible function approximators such as neural networks in RL dates back many years, e.g. [38, 35, 12, 10]. In the last few years there has been a resurgence of interest in end-to-end training of neural networks for challenging control problems, and several algorithms, both value and policy focused have been developed and applied to challenging problems including continuous control, e.g. [22, 23, 6, 7, 20, 32, 31, 11, 17]. These methods work well with large neural networks and can learn directly from raw visual input streams. With few exceptions, e.g. [10, 5, 18, 39], they have been considered too data-inefficient for robotics applications.\nOne exception are guided policy search methods (GPS) [18, 39]. These have recently been applied to several manipulation problems and employ a teacher algorithm to locally optimize trajectories which are then summarized by a neural network policy. GPS algorithms gain data-efficiency by employing aggressive local policy updates and by performing extensive training of their neural network policy before collecting more real-world data. The teacher can use model-based [18] or model-free [39] trajectory optimization. The former can struggle in situations with strong discontinuities in the\ndynamics, and both rely on access to a well defined and fully observed state space.\nModel-free value function approaches offer an alternative way to handle to the issue of data-efficiency in robotics. Such approaches enable effective reuse of data and do not require full access to the state space or to a model of the environment. One recent work [5], closely related to the ideas followed in this paper, provides a proof of concept demonstration that value-based methods using neural network approximators can be used for robotic manipulation in the real world . This work applied a Q-learning approach [7] to a door opening task in which a robotic arm fitted with an unactuated hook needed to reach to a handle and pull a door to a given angle. The starting state of the arm and door were fixed across trials and the reward structure was smooth and structured, with one term expressing the distance from the hook to the handle and a second term expressing the distance of the door to the desired angle. This task was learned in approximately 2 hours across 2 robots pooling their experience into a shared replay buffer.\nThis work thus made use of a complementary solution to the need for large amounts of interaction data: the use of experimental rigs that allow large scale data collection, e.g. [27], including the use of several robots from which experience are gathered in parallel [19, 5, 39]. This can be combined with single machine or distributed training depending on whether the bottleneck is primarily one of data collection or also one of network training [23].\nFinally, the use of demonstration data has played an important role in robot learning, both as a means to obtain suitable cost functions [2, 14, 4, 8] but also to bootstrap and thus speed up learning. For the latter, kinesthetic teaching is widely used [26, 13, 25, 39]. It integrates naturally with trajectory-based movement representations but the need for a human operator to be able to guide the robot through the full movement can be limiting. Furthermore, when the policy representation is not trajectory based (e.g. direct torque control with neural networks) the use of human demonstration trajectories may be less straightforward (e.g. since the associated controls are not available)."
    }, {
      "heading" : "III. BACKGROUND",
      "text" : "In this section we briefly formalize the learning problem, summarize the DDPG algorithm, and explain its relationship to several other Q-function based reinforcement learning (RL) algorithms.\nThe RL problem consists of an agent interacting with an environment in a sequential manner to maximize the expected sum of rewards. At time t the agent observes the state xt of the system and produces a control ut = π(xt; θ) according to policy π with parameters θ. This leads the environment to transition to a new state xt+1 according to the dynamics xt+1 ∼ p(·|xt, ut), and the agent receives a reward rt = r(xt, ut). The goal is to maximize the expected sum of discounted rewards J(θ) = Eτ∼ρθ [∑ t γ t−1r(xt, ut) ] , where ρ(θ) is the distribution over trajectories τ = (x0, u0, x1, u1, . . . ) induced by the current policy: ρθ(τ) = p(x0) ∏ t>0 p(xt|xt−1, π(xt−1; θ)).\nDPG [33] is a policy gradient algorithm for continuous action spaces that improves the deterministic policy function π via backpropagation of the action-value gradient from a learned approximation to the Q-function. Specifically, DPG maintains a parametric approximation Q(xt, ut;φ) to the action value function Qπ(xt, ut) associated with π and φ is chosen to minimize\nE(xt,ut,xt+1)∼ρ̄ [ (Q(xt, ut;φ)− yt)2 ] (1)\nwhere yt = r(xt, ut) + γQ(xt+1, π(xt+1)). ρ̄ is usually close to the marginal transition distribution induced by π but often not identical. For instance, during learning ut may be chosen to be a noisy version of π(xt; θ), e.g. ut = π(xt; θ) + where ∼ N (0, σ2) and ρ̄ is then the transition distribution induced by this noisy policy.\nThe policy parameters θ are then updated according to ∆θ ∝ E(x,u)∼ρ̄ [ ∂\n∂u Q(x, u;φ)\n∂\n∂θ π(x; θ)\n] . (2)\nDDPG [20] is an improvement of the original DPG algorithm adding experience replay and target networks: Experience is collected into a buffer and updates to θ and φ (eqs. 1, 2) are computed using mini-batch updates with random samples from this buffer. Furthermore, a second set of ”targetnetworks” is maintained with parameters θ′ and φ′. These are used to compute yt in eqn. (1) and their parameters are slowly updated towards the current parameters θ, φ. Both measures significantly improve the stability of DDPG.\nDDPG bears a relation to several other recent model free RL algorithms: The NAF algorithm [7] which has recently been applied to a real-world robotics problem [5] can be viewed as a DDPG variant where the Q-function is quadratic in the action so that the optimal action can be easily recovered directly from the Q-function, making a separate representation of the policy unnecessary. DDPG and especially NAF are the continuous action counterparts of DQN [22], a Q-learning algorithm that recently re-popularized the use of experience replay and target networks to stabilize learning with powerful function approximators such as neural networks. DDPG, NAF, and DQN all interleave mini-batch updates of the Q-function (and the policy for DDPG) with data collection via interaction with the environment. These mini-batch based updates set DDPG and DQN apart from the otherwise closely related NFQ and NFQCA algorithms for discrete and continuous actions respectively. NFQ [29] and NFQCA [9] employ the same basic update as DDPG and DQN, however, they are batch algorithms that perform updates less frequently and fully re-fit the Q-function and the policy network after every episode with several hundred iterations of gradient descent with Rprop [28] and using full-batch updates with the entire replay buffer. The aggressive training makes NFQCA data efficient, but the full batch updates can become impractical with large networks, large observation spaces, or when the number of training episodes is large. Finally, DPG can be seen as the deterministic limit of a particular instance of the stochastic value gradients (SVG) family [11], which\nalso computes policy gradient via back-propagation of value gradients, but optimizes stochastic policies.\nDiscrete Continuous Mini-batch learning\nTarget networks DQN DDPG, NAF Full-batch learning with Rprop\nParameter resetting NFQ NFQCA\nOne appealing property of the above family of algorithms is that the use of a Q-function facilitates off-policy learning. This allows decoupling the collection of experience data from the updates of the policy and value networks, a desirable property given that experience is expensive to collect in a robotics setup. In this context, because neural network training is often slow, decoupling allows us to make many parameter update steps per step in the environment, ensuring that the networks are well fit to the data that is currently available."
    }, {
      "heading" : "IV. TASK AND EXPERIMENTAL SETUP",
      "text" : "The full task that we consider in this paper is to use the arm to pick up one Lego Duplo brick from the table and stack it onto the remaining brick. This ”composite” task can be decomposed into several subtasks, including grasping and stacking. In our experiments we consider the full task as well as the two sub-tasks in isolation as shown in the table below:\nStarting state Reward Grasp Both bricks on table Brick 1 above table\nStackInHand Brick 1 in gripper Bricks stacked Stack Both bricks on table Bricks stacked\nIn every episode the arm starts in a random configuration with the positioning of gripper and brick appropriate for the task of interest. We implement the experiments in a physically plausible simulation in MuJoCo [36] with the simulated arm being closely matched to a real-world Jaco arm1 setup in our lab. Episodes are terminated after 150 steps, with each step corresponding to 50ms of physical simulation time. This means that the agent has 7.5 seconds to perform the task. Unless otherwise noted we give a reward of one upon successful completion of the task and zero otherwise.\nThe observation vector provided to the agent contains information about the angles and angular velocities of the 6 joints of the arm and 3 fingers of the gripper. In addition, we provide information about the position and orientation of the two bricks and relative distances of the two bricks to the pinch position of the gripper, i.e. roughly the position where the fingertips would meet if the fingers are closed. The 9-dimensional continuous action directly sets the velocities of the arm and finger joints. In experiments not reported in this paper we have tried using an observation vector containing only the raw state of the brick in addition to the arm configuration (i.e. without the vector between the end-effector and brick) and found that\n1Jaco is a robotics arm developed by Kinova Robotics\nthis increased the number of environment interactions needed roughly by a factor of two to three.\nThe only hyper-parameter that we optimize for each experimental condition is the learning rate. For each condition we train and measure the performance of 10 agents with different random initial network parameters. After every 30 training episodes the agent is evaluated for 10 episodes. We used the mean performance at each evaluation phase as the performance measure presented in all plots. We found empirically that 10 episodes of evaluation gave a reasonable proxy for performance in the studied tasks. In the plots the line shows the mean performance for the set and the shaded regions correspond to the range between the worst and best performing agent in the set. In all plots the x-axis represents the number of environment transitions seen so far at an evaluation point (in millions) and the y-axis represent episode return.\nA video of the full setup and examples of policies solving the component and full tasks can be found here: https://www.youtube.com/watch?v=8QnD8ZM0YCo."
    }, {
      "heading" : "V. ASYNCHRONOUS DPG WITH VARIABLE REPLAY STEPS",
      "text" : "In this section we study two methods for extending the DDPG algorithm and find that they can have significant effect on data and computation efficiency, in some cases making the difference between finding a solution to a task or not.\na) Multiple mini-batch replay steps: Deep neural networks can require many steps of gradient descent to converge. In a supervised learning setting this affects purely computation time. In reinforcement learning, however, neural network training is interleaved with the acquisition of interaction experience, and the nature of the latter is affected by the state of the former – and vice versa – so the situation is more complicated. To gain a better understanding of this interaction we modified the original DDPG algorithm as described in [20] to perform a fixed but configurable number of mini-batch updates per step in the environment. In [20] one update was performed after each new interaction step.\nWe refer to DDPG with a configurable number of update steps as DPG-R and tested the impact of this modification on the two primitive tasks Grasp and StackInHand. The results are shown in Fig. 2. It is evident that the number of update steps has a dramatic effect on the amount of experience data required for learning successful policies. After one million interactions the original version of DDPG with a single update step (blue traces) appears to have made no progress towards a successful policy for stacking, and only a small number of controllers have learned to grasp. Increasing the number of updates per interaction to 5 greatly improves the results (green traces), and with 40 updates (purple) the first successful policies for stacking and grasping are obtained after 200,000 and 300,000 interactions respectively (corresponding to 1,300 and 2,000 episodes). It is notable that although the improvement is task dependent and the dependence between update steps and convergence is clearly not linear, in both cases we continue to see a reduction in total environment interaction up to 40 update steps, the maximum used in the experiment.\nOne may speculate as to why changing the number of updates per environment step has such a pronounced effect. One hypothesis is that, loosely speaking and drawing an analogy to supervised learning, insufficient training leads to underfitting of the policy and value network with respect to the already collected training data. Unlike in supervised learning, however, where the dataset is typically fixed, the quality of the policy directly feeds back into the data acquisition process since the policy network is used for exploration, thus affecting the quality the data used in future iterations of network training.\nWe have observed in various experiments (not listed here) that other aspects of the network architecture and training process can have a similar effect on the extent of underfitting. Some examples include the type of non-linearities used in the network layers, the size of layers and the learning rate. It is important to note that one cannot replicate the effect of multiple replay steps simply by increasing the learning rate. In practice we find that attempts to do so make training unstable.\nb) Asynchronous DPG: While increasing the number of update steps relative to the number of environment interactions greatly improves the data efficiency of the algorithm it can also strongly increase the computation time. In the extreme case, in simulation, when the overall run time is dominated by the network updates it may scale linearly with the number of replay steps. In this setting it is desirable to be able to parallelize the update computations.\nIn a real robotics setup the overall run time is typically dominated by the collection of robot interactions. In this case it is desirable to be able to collect experience from multiple robots simultaneously (e.g. as in [39, 5]).\nWe therefore develop an asynchronous version of DPG that allows parallelization of training and environment interaction by combining multiple instances of an DPG-R actor and critic that each share their network parameters and can be configured to either share or have independent experience replay buffers. This is inspired by the A3C algorithm proposed in [23], and also analogous to [5, 39]. We found that this strategy is also an effective way to share parameters for DPG. That is, we employ asynchronous updates whereby each worker has its own copy\nof the parameters and uses it for computing gradients which are then applied to a shared parameter instance without any synchronization. We use the Adam optimizer [15] with local non-shared first-order statistics and a single shared instance of second-order statistics. The pseudo code of the asynchronous DPG-R is shown in algorithm box 1.\nAlgorithm 1 (A)DPG-R algorithm Initialize global shared critic and actor network parameters: θQ ′′ and θµ ′′\nPseudo code for each learner thread: Initialize critic network Q(s, a|θQ) and actor µ(s|θµ) with weights θQ and θµ. Initialize target network Q′ and µ′ with weights: θQ\n′ ← θQ, θµ′ ← θµ Initialize replay buffer R for episode = 1, M do\nReceive initial observation state s1 for t = 1, T do\nSelect action at = µ(st|θµ) + Nt according to the current policy and exploration noise Perform action at, observe reward rt and new state st+1 Store transition (st, at, rt, st+1) in R for update = 1, R do\nSample a random minibatch of N transitions (si, ai, ri, si+1) from R Set yi = ri + γQ′(si+1, µ′(si+1|θµ ′ )|θQ′) Perform asynchronous update of the shared parameters of the critic by minimizing the loss: L = 1N ∑ i(yi −Q(si, ai|θQ)2) Perform asynchronous update of shared parameters of actor policy using the sampled gradient:\n∇θµ′′µ|si ≈ 1\nN ∑ i ∇aQ(s, a|θQ)|∇θµµ(s|θµ)|si\nCopy the shared parameters to the local ones: θQ ← θQ′′ , θµ ← θµ′′ Every S update steps, update the target networks: θQ\n′ ← θQ, θµ′ ← θµ end for\nend for end for\nFigure 3 compares the performance of ADPG-R for different number of update steps and 16 workers (all workers performing both data collection and computing updates). Similar to Fig. 2 we find that increasing the ratio of update steps per environment steps improves data efficiency, although the effect appears to be somewhat less pronounced than for DPG-R.\nFigure 4 (top row) directly compares the single-worker and asynchronous version of DPG-R. In both cases we choose the best performing number of replay steps and learning rate. As we can see, the use of multiple workers does not affect overall\ndata efficiency for StackInHand but it reduced roughly in half for Grasp, with the note that the single worker still hasn’t quite converged.\nFigure 4 (bottom row) plots the same data but as a function of environment steps per worker. This measure corresponds to the optimal wall clock efficiency that we can achieve, under the assumption that communication time between workers is negligible compared to environment interaction and gradient computation (this usually holds up to a certain degree of parallelization). This theoretical wall clock time for running an experiment with 16 workers is about 16x lower for StackInHand and roughly 8x lower for Grasp.\nOverall these results show that distributing neural network training and data collection across multiple computers and robots can be an extremely effective way of reducing the overall run time of experiments and thus making it feasible to run more challenging experiments. We make extensive use of asynchronous DPG for remaining the experiments."
    }, {
      "heading" : "VI. COMPOSITE SHAPING REWARDS",
      "text" : "In the previous section we discussed how the ability of DDPG to exploit information that is available in the acquired interaction data affects learning speed. One important factor that determines what information is available from this data is the nature of the reward function. The reward function in the previous section was ”sparse” or ”pure” reward where a reward of 1 was given for states that correspond to successful task completion (brick lifted above 3cm for grasp; for stack) and 0 otherwise. For this reward to be useful for learning it is of course necessary that the agent is able to enter this goal region in state space with whatever exploration strategy is chosen. This was indeed the case for the two subtasks in isolation, but it is highly unlikely for the full task: without further guidance naı̈ve random exploration is very unlikely to lead to a successful grasp and stack as we also experimentally verify in Fig. 5.\nOne commonly used solution to this problem is to provide informative shaping rewards that allow a learning signal to be obtained even with simple exploration strategies, e.g. by embedding information about the value function in the reward function for every transition acquired from the environment. For instance, for a simple reaching problem with a robotic arm we could define a shaping reward that takes into account the distance between the end-effector and the target.\nWhile this a convenient way of embedding prior knowledge about the solution and is a widely and successfully used approach for simple problems it comes with several caveats, especially for complex sequential or compositional tasks such as the one we are interested in here.\nFirstly, while a suitable shaping reward may be easy to construct for simple problems for more complex composite tasks, such as the one considered in this paper, a suitable reward function is often non-obvious and may require considerable effort and experimentation. Secondly, and related to the previous point, the use of a shaping reward typically alters the solution to the optimization problem.\nThe effect of this can be benign but especially when it comes to complex tasks a small mistake may lead to complete failure of learning as we will demonstrate below. Thirdly, in a robotics setup not all information that would be desirable to define a good shaping reward may be easily available. For instance, in the manipulation problem considered in this paper determining the position of the Lego bricks requires extra instrumentation of the experimental setup.\nIn this section we propose and analyze several possible reward functions for our full Stack task, aiming to provide a recipe that can be applied to other tasks with similar compositional structure. Shaping rewards are typically defined based on some notion of distance from or progress towards a goal state. We attempt to transfer this idea to our compositional setup via, what we call, composite (shaping) rewards. These reward functions return an increasing reward as the agent completes components of the full task. They are either piecewise constant or smoothly varying across different regions of the\nstate space that correspond to completed subtasks. In the case of Stack we use the reward components described in table I.\nThese reward components can be combined in different ways. We consider three different composite rewards in additional to the original sparse task reward: Grasp shaping: Grasp brick 1 and Stack brick 1, i.e. the agent receives a reward of 0.25 when the brick 1 has been grasped and a reward of 1.0 after completion of the full task. Reach and grasp shaping: Reach brick 1, Grasp brick 1 and Stack brick 1, i.e. the agent receives a reward of 0.125 when being close to brick 1, a reward of 0.25 when brick 1 has been grasped, and a reward of 1.0 after completion of the full task. Full composite shaping: the sparse reward components as before in combination with the distance-based smoothly varying components.\nFigure 5 shows the results of learning with the above reward functions (blue traces). The figure makes clear that learning with the sparse reward only does not succeed for the full task. Introducing an intermediate reward for grasping allows the agent to learn to grasp but learning is very slow. The time to successful grasping can be substantially reduced by giving a distance based reward component for reaching to the first brick, but learning does not progress beyond grasping. Only with an additional intermediate reward component as in continuous reach, grasp, stack the full task can be solved.\nAlthough the above reward functions are specific to the particular task, we expect that the idea of a composite reward function can be applied to many other tasks thus allowing learning for to succeed even for challenging problems. Nevertheless, great care must be taken when defining the reward function. We encountered several unexpected failure cases while designing the reward function components: e.g. reach and grasp components leading to a grasp unsuitable for stacking, agent not stacking the bricks because it will stop receiving the grasping reward before it receives reward for stacking and the agent flips the brick because it gets a grasping reward calculated with the wrong reference point on the brick. We show examples of these in the video: https://www.youtube.com/watch?v=8QnD8ZM0YCo."
    }, {
      "heading" : "VII. LEARNING FROM INSTRUCTIVE STATES",
      "text" : "In the previous section we have described a strategy for designing effective reward functions for complex compositional tasks which alleviate the burden of exploration. We have also pointed out, however, that designing shaping rewards can be error prone and may rely on privileged information. In this section we describe a different strategy for embedding prior knowledge into the training process and improving exploration that reduces the reliance on carefully designed reward functions.\nSpecifically we propose to let the distribution of states at which the learning agent is initialized at the beginning of an episode reflect the compositional nature of the task: In our case, instead of initializing the agent always at the beginning of the full task with both bricks on the table we can, for instance, choose to initialize the agent occasionally with the brick already in its hand and thus prepared for stacking in the same way as when learning the subtask StackInHand in section V. Trajectories of policies solving the task will have to visit this region of space before stacking the bricks and we can thus think of this initialization strategy as initializing the agent closer to the goal.\nMore generally, we can choose to initialize episodes with states taken from anywhere along or close to successful trajectories. Suitable states can be either manually defined (as in section V), or they can be obtained from a human demonstrator or a previously trained agent that can partially solve the task. This can be seen as a form of apprenticeship learning in which we provide teacher information by influencing the state visitation distribution.\nWe perform experiments with two alternative methods for generating the starting states. The first one uses manually defined initial states and amounts to the possibility discussed above: we initialize the learning agent in either the original starting states with both bricks located on the table or in states where the first brick is already in the gripper as if the agent just performed a successful grasp and lifted the brick. These two sets of start states correspond to those used in section V.\nThe second method for generating instructive starting states can also be used on a real robot provided a human demonstrator or a pre-trained policy are available. It aims at initializing the learning agent along solution trajectory states in a more fine-grained fashion. We sample a random number of steps for each episode between one and the expected number of steps required to solve the task from the original starting states and then run the demonstrator for this number of steps. The final state of this process is then used as a starting state initialization for the learning agent which then acts in the environment for the remainder of the episode.\nThe results of these experiments are shown in Figure 5. It shows results for the four reward functions considered in the previous section when combined with the simple augmented start state distribution. While there is still no learning for the basic sparse reward case, results obtained with all other reward functions are improved. In particular, even for the second\nsimplest reward function (Grasp shaping) we now obtain some controllers that can solve the full task. Learning with the full composite shaping reward is faster and more robust than without the use of instructive states.\nThe top left plot of Figure 5 (red trace) shows results for the case where the episode is initialized anywhere along trajectories from a pre-trained controller. We use this start state distribution in combination with the basic sparse reward for the overall case (Stack without shaping). Episodes were configured to be 50 steps, shorter than in the previous experiments, to be better suited to this setup with assisted exploration. During testing we still used episodes with 150 steps as before (so the traces are comparable). We can see a large improvement in performance in comparison to the two-state method variant even in the absence of any shaping rewards. We can learn a robust policy for all seeds within a total of 1 million environment transitions. This corresponds to less than 1 hour of interaction time on 16 simulated robots.\nOverall these results suggest that an appropriate start state distribution does not only greatly speed up learning, it also allows simpler reward function to be used. In our final experiment the simplest reward function, only indicating overall experimental success, was sufficient to solve the task. Considering the difficulties that can be associated with designing good shaping rewards this is an encouraging results.\nThe robustness of the policies that we can train to the starting state variation are also quite encouraging. Table II lists the success rate by task from 1000 trials. You can find a video\nwith trained policies performing the Grasp, StackInHand and Stack tasks from different initial states in the supplementary material."
    }, {
      "heading" : "VIII. CONCLUSION",
      "text" : "We have introduced two extensions to the DDPG algorithm which make it a powerful method for learning robust policies for complex continuous control tasks. Specifically, we have shown that by decoupling the frequency of network updates from the environment interaction we can substantially improve data-efficiency, to a level that in some cases makes the difference between finding a solution or not. The asynchronous version of DDPG which allows data collection and network training to be distributed over several computers and (simulated) robots has provided us with a close to linear speed up in wall-clock time for 16 parallel workers.\nIn addition, we presented two methods that help to guide the learning process towards good solutions and thus reduce the pressure on exploration strategies and speed up learning. The first, composite rewards, is a recipe for constructing effective reward functions for tasks that consist of a sequence of subtasks. The second, instructive starting states, can be seen as a lightweight form of apprenticeship learning that facilitates learning of long horizon tasks even with sparse rewards, a property of many real-world problems. Taken together, the algorithmic changes and exploration shaping strategies have allowed us to learn robust policies for the Stack task within a number of transitions that is feasible to collect in a realrobot system within a few days, or in significantly less time if multiple robots were used for training.\nIt is of course a challenge to judge the transfer of results in simulation to the real world. We have taken care to design a physically realistic simulation, and in initial experiments, which we have performed both in simulation and on the physical robot, we generally find a good correspondence of performance and learning speed between simulation and real world. This makes us optimistic that our performance numbers also hold when going to the real world. A second caveat of our simulated setup is that it currently uses information about the state of the environment, which although not impossible to obtain on a real robot, may require additional instrumentation of the experimental setup, e.g. to determine the position of the two bricks in the work space. To address this second issue we are currently focusing on end-to-end learning directly from raw visual information. Here, we have some first results showing the feasibility of learning policies for grasping with a success rate of about 80% across different starting conditions.\nWe view the algorithms and techniques presented here as an important step towards applying versatile deep reinforcement\nlearning methods for real-robot dexterous manipulation with perception."
    }, {
      "heading" : "A. Reward function",
      "text" : "In this section we provide further details regarding the reward functions described in section VI. For our experiments we derived these from the state vector of the simulation, but they could also be obtained through instrumentation in hardware. The reward functions are defined in terms of the following quantities:\n• b (1) z : height of brick 1 above table • sB1{x,y,z}: x,y,z positions of site located roughly in the center of brick 1 • sB2{x,y,z}: x,y,z positions of site located just above brick 2, at the position where s\nB1 will be located when brick 1 is stacked on top of brick 2. • sP{x,y,z}: x,y,z positions of the pinch site of the hand – roughly the position where the fingertips would meet if the fingers are closed..\n1) Sparse reward components: Using the above we can define the following conditions for the successful completion of subtasks:\na) Reach Brick 1: The pinch site of the fingers is within a virtual box around the first brick position.\nreach =(|sB1x − sPx | < ∆reachx ) ∧ (|sB1y − sPy | < ∆reachy ) ∧ (|sB1z − sPz | < ∆reachz ),\nwhere ∆reach{x,y,z} denote the half-lengths of the sides of the virtual box for reaching.\nb) Grasp Brick 1: Brick 1 is located above the table surface by a threshold, θ, that is possible only if the arm is the brick has been lifted.\ngrasp =b(1)z > θ\nc) Stack: Brick 1 is stacked on brick 2. This is expressed as a box constraint on the displacement between brick 1 and brick 2 measured in the coordinate system of brick 2.\nstack =(|C(2)x (sB1 − sB2)| < ∆stackx ) ∧ (|C(2)y (sB1 − sB2)| < ∆stacky ) ∧ (|C(2)z (sB1 − sB2)| < ∆stackz ),\nwhere ∆stack{x,y,z} denote the half-lengths of the sides of the virtual box for stacking, and C (2) is the rotation matrix that projects a vector into the coordinate system of brick 2. This projection into the coordinate system of brick 2 is necessary since brick 2 is allowed to move freely. It ensures that the box constraint is considered relative to the pose of brick 2. While this criterion for a successful stack is quite complicated to express in terms of sites, it could be easily implemented in hardware e.g. via a contact sensor attached to brick 2.\n2) Shaping components: The full composite reward also includes two distance based shaping components that guide the hand to the brick 1 and then brick 1 to brick 2. These could be approximate and would be relatively simple to implement with a hardware visual system that can only roughly identify the centroid of an object. The shaping components of the reward are given as follows:\na) Reaching to brick 1: :\nrS1(s B1, sP ) = 1− tanh2(w1‖sB1 − sP ‖2)\nb) Reaching to brick 2 for stacking:\nrS2(s B1, sB2) = 1− tanh2(w2‖sB1 − sB2‖2).\n3) Full reward: Using the above components the reward functions from section VI: Stack, Grasp shaping, Reach and grasp shaping, and Full composite shaping can be expressed as in equations (3, 4, 5, 6) below. These make use of the predicates\nabove to determine whether which subtasks have been completed and return a reward accordingly.\nr(b(1)z , s P , sB1, sB2) = { 1 if stack(b(1)z , sP , sB1, sB2) 0 otherwise\n(3)\nr(b(1)z , s P , sB1, sB2) =  1 if stack(b(1)z , sP , sB1, sB2) 0.25 if ¬stack(b(1)z , sP , sB1, sB2) ∧ grasp(b(1)z , sP , sB1, sB2) 0 otherwise\n(4)\nr(b(1)z , s P , sB1, sB2) =  1 if stack(b(1)z , sP , sB1, sB2) 0.25 if ¬stack(b(1)z , sP , sB1, sB2) ∧ grasp(b(1)z , sP , sB1, sB2) 0.125 if ¬(stack(b(1)z , sP , sB1, sB2) ∨ grasp(b(1)z , sP , sB1, sB2)) ∧ reach(b(1)z , sP , sB1, sB2) 0 otherwise\n(5)\nr(b(1)z , s P , sB1, sB2) =  1 if stack(b(1)z , sP , sB1, sB2) 0.25 + 0.25rS2(s\nB1, sP ) if ¬stack(b(1)z , sP , sB1, sB2) ∧ grasp(b(1)z , sP , sB1, sB2) 0.125 if ¬(stack(b(1)z , sP , sB1, sB2) ∨ grasp(b(1)z , sP , sB1, sB2)) ∧ reach(b(1)z , sP , sB1, sB2) 0 + 0.125rS1(s\nB1, sP ) otherwise (6)"
    } ],
    "references" : [ {
      "title" : "Autonomous helicopter control using reinforcement learning policy search methods",
      "author" : [ "J Andrew Bagnell", "Jeff G Schneider" ],
      "venue" : "In Robotics and Automation,",
      "citeRegEx" : "1",
      "shortCiteRegEx" : "1",
      "year" : 2001
    }, {
      "title" : "Relative entropy inverse reinforcement learning",
      "author" : [ "A. Boularias", "J. Kober", "J. Peters" ],
      "venue" : "In JMLR Workshop and Conference Proceedings Volume",
      "citeRegEx" : "2",
      "shortCiteRegEx" : "2",
      "year" : 2011
    }, {
      "title" : "A survey on policy search for robotics",
      "author" : [ "Marc Peter Deisenroth", "Gerhard Neumann", "Jan Peters" ],
      "venue" : "Foundations and Trends in Robotics,",
      "citeRegEx" : "3",
      "shortCiteRegEx" : "3",
      "year" : 2013
    }, {
      "title" : "Guided cost learning: Deep inverse optimal control via policy optimization",
      "author" : [ "Chelsea Finn", "Sergey Levine", "Pieter Abbeel" ],
      "venue" : "In Proceedings of the 33nd International Conference on Machine Learning,",
      "citeRegEx" : "4",
      "shortCiteRegEx" : "4",
      "year" : 2016
    }, {
      "title" : "Deep reinforcement learning for robotic manipulation",
      "author" : [ "Shixiang Gu", "Ethan Holly", "Timothy Lillicrap", "Sergey Levine" ],
      "venue" : "arXiv preprint arXiv:1610.00633,",
      "citeRegEx" : "5",
      "shortCiteRegEx" : "5",
      "year" : 2016
    }, {
      "title" : "Muprop: Unbiased backpropagation for stochastic neural networks",
      "author" : [ "Shixiang Gu", "Sergey Levine", "Ilya Sutskever", "Andriy Mnih" ],
      "venue" : "International Conference on Learning Representations (ICLR),",
      "citeRegEx" : "6",
      "shortCiteRegEx" : "6",
      "year" : 2016
    }, {
      "title" : "Continuous deep q-learning with model-based acceleration",
      "author" : [ "Shixiang Gu", "Tim Lillicrap", "Ilya Sutskever", "Sergey Levine" ],
      "venue" : "In International Conference on Machine Learning (ICML),",
      "citeRegEx" : "7",
      "shortCiteRegEx" : "7",
      "year" : 2016
    }, {
      "title" : "Learning dexterous manipulation for a soft robotic hand from human demonstrations",
      "author" : [ "Abhishek Gupta", "Clemens Eppner", "Sergey Levine", "Pieter Abbeel" ],
      "venue" : "In 2016 IEEE/RSJ International Conference on Intelligent Robots and Systems,",
      "citeRegEx" : "8",
      "shortCiteRegEx" : "8",
      "year" : 2016
    }, {
      "title" : "Reinforcement learning in feedback control",
      "author" : [ "Roland Hafner", "Martin Riedmiller" ],
      "venue" : "Machine learning,",
      "citeRegEx" : "9",
      "shortCiteRegEx" : "9",
      "year" : 2011
    }, {
      "title" : "Neural reinforcement learning controllers for a real robot application",
      "author" : [ "Roland Hafner", "Martin A. Riedmiller" ],
      "venue" : "IEEE International Conference on Robotics and Automation,",
      "citeRegEx" : "10",
      "shortCiteRegEx" : "10",
      "year" : 2007
    }, {
      "title" : "Learning continuous control policies by stochastic value gradients",
      "author" : [ "Nicolas Heess", "Gregory Wayne", "David Silver", "Tim Lillicrap", "Tom Erez", "Yuval Tassa" ],
      "venue" : "In Advances in Neural Information Processing Systems (NIPS),",
      "citeRegEx" : "11",
      "shortCiteRegEx" : "11",
      "year" : 2015
    }, {
      "title" : "Neural networks for control systems: A  survey",
      "author" : [ "K.J. Hunt", "D. Sbarbaro", "R. Żbikowski", "P.J. Gawthrop" ],
      "venue" : null,
      "citeRegEx" : "12",
      "shortCiteRegEx" : "12",
      "year" : 1992
    }, {
      "title" : "Learning force control policies for compliant manipulation",
      "author" : [ "M. Kalakrishnan", "L. Righetti", "P. Pastor", "S. Schaal" ],
      "venue" : "In IEEE/RSJ International Conference on Intelligent Robots and Systems (IROS",
      "citeRegEx" : "13",
      "shortCiteRegEx" : "13",
      "year" : 2011
    }, {
      "title" : "Learning objective functions for manipulation",
      "author" : [ "M. Kalakrishnan", "P. Pastor", "L. Righetti", "S. Schaal" ],
      "venue" : "In IEEE International Conference on Robotics and Automation,",
      "citeRegEx" : "14",
      "shortCiteRegEx" : "14",
      "year" : 2013
    }, {
      "title" : "Adam: A method for stochastic optimization",
      "author" : [ "Diederik Kingma", "Jimmy Ba" ],
      "venue" : "arXiv preprint arXiv:1412.6980,",
      "citeRegEx" : "15",
      "shortCiteRegEx" : "15",
      "year" : 2014
    }, {
      "title" : "Policy gradient reinforcement learning for fast quadrupedal locomotion",
      "author" : [ "Nate Kohl", "Peter Stone" ],
      "venue" : "In Proceedings of the IEEE International Conference on Robotics and Automation,",
      "citeRegEx" : "16",
      "shortCiteRegEx" : "16",
      "year" : 2004
    }, {
      "title" : "Learning neural network policies with guided policy search under unknown dynamics",
      "author" : [ "Sergey Levine", "Pieter Abbeel" ],
      "venue" : "In Advances in Neural Information Processing Systems (NIPS),",
      "citeRegEx" : "17",
      "shortCiteRegEx" : "17",
      "year" : 2014
    }, {
      "title" : "End-to-end training of deep visuomotor policies",
      "author" : [ "Sergey Levine", "Chelsea Finn", "Trevor Darrell", "Pieter Abbeel" ],
      "venue" : "arXiv preprint arXiv:1504.00702,",
      "citeRegEx" : "18",
      "shortCiteRegEx" : "18",
      "year" : 2015
    }, {
      "title" : "Learning hand-eye coordination for robotic grasping with deep learning and large-scale data collection",
      "author" : [ "Sergey Levine", "Peter Pastor", "Alex Krizhevsky", "Deirdre Quillen" ],
      "venue" : null,
      "citeRegEx" : "19",
      "shortCiteRegEx" : "19",
      "year" : 2016
    }, {
      "title" : "Continuous control with deep reinforcement learning",
      "author" : [ "Timothy P Lillicrap", "Jonathan J Hunt", "Alexander Pritzel", "Nicolas Heess", "Tom Erez", "Yuval Tassa", "David Silver", "Daan Wierstra" ],
      "venue" : "International Conference on Learning Representations (ICLR),",
      "citeRegEx" : "20",
      "shortCiteRegEx" : "20",
      "year" : 2016
    }, {
      "title" : "Learning cpgbased biped locomotion with a policy gradient method",
      "author" : [ "Takamitsu Matsubara", "Jun Morimoto", "Jun Nakanishi", "Masa-aki Sato", "Kenji Doya" ],
      "venue" : "Robotics and Autonomous Systems,",
      "citeRegEx" : "21",
      "shortCiteRegEx" : "21",
      "year" : 2006
    }, {
      "title" : "Human-level control through deep reinforcement learning",
      "author" : [ "Volodymyr Mnih", "Koray Kavukcuoglu", "David Silver", "Andrei A Rusu", "Joel Veness", "Marc G Bellemare", "Alex Graves", "Martin Riedmiller", "Andreas K Fidjeland", "Georg Ostrovski" ],
      "venue" : "Nature, 518(7540):529–533,",
      "citeRegEx" : "22",
      "shortCiteRegEx" : "22",
      "year" : 2015
    }, {
      "title" : "Asynchronous methods for deep reinforcement learning",
      "author" : [ "Volodymyr Mnih", "Adria Puigdomenech Badia", "Mehdi Mirza", "Alex Graves", "Timothy P Lillicrap", "Tim Harley", "David Silver", "Koray Kavukcuoglu" ],
      "venue" : "In International Conference on Machine Learning (ICML),",
      "citeRegEx" : "23",
      "shortCiteRegEx" : "23",
      "year" : 2016
    }, {
      "title" : "Learning to select and generalize striking movements in robot table tennis",
      "author" : [ "K. Muelling", "J. Kober", "O. Kroemer", "J. Peters" ],
      "venue" : null,
      "citeRegEx" : "24",
      "shortCiteRegEx" : "24",
      "year" : 2013
    }, {
      "title" : "Skill learning and task outcome prediction for manipulation",
      "author" : [ "P. Pastor", "M. Kalakrishnan", "S. Chitta", "E. Theodorou", "S. Schaal" ],
      "venue" : "In IEEE International Conference on Robotics and Automation (ICRA), Shanghai,",
      "citeRegEx" : "25",
      "shortCiteRegEx" : "25",
      "year" : 2011
    }, {
      "title" : "Policy gradient methods for robotics",
      "author" : [ "Jan Peters", "Stefan Schaal" ],
      "venue" : "In International Conference on Intelligent Robots and Systems (IROS),",
      "citeRegEx" : "26",
      "shortCiteRegEx" : "26",
      "year" : 2006
    }, {
      "title" : "Supersizing selfsupervision: Learning to grasp from 50k tries and 700 robot",
      "author" : [ "Lerrel Pinto", "Abhinav Gupta" ],
      "venue" : "hours. CoRR,",
      "citeRegEx" : "27",
      "shortCiteRegEx" : "27",
      "year" : 2015
    }, {
      "title" : "A direct adaptive method for faster backpropagation learning: The RPROP algorithm",
      "author" : [ "M. Riedmiller", "H. Braun" ],
      "venue" : "Proceedings of the IEEE International Conference on Neural Networks (ICNN),",
      "citeRegEx" : "28",
      "shortCiteRegEx" : "28",
      "year" : 1993
    }, {
      "title" : "Neural fitted Q iteration - first experiences with a data efficient neural reinforcement learning method",
      "author" : [ "Martin A. Riedmiller" ],
      "venue" : "In Machine Learning: ECML 2005, 16th European Conference on Machine Learning,",
      "citeRegEx" : "29",
      "shortCiteRegEx" : "29",
      "year" : 2005
    }, {
      "title" : "Dynamic Movement Primitives -A Framework for Motor Control in Humans and Humanoid Robotics, pages 261–280",
      "author" : [ "Stefan Schaal" ],
      "venue" : "ISBN 978-4-431-31381-6",
      "citeRegEx" : "30",
      "shortCiteRegEx" : "30",
      "year" : 2006
    }, {
      "title" : "Trust region policy optimization",
      "author" : [ "John Schulman", "Sergey Levine", "Pieter Abbeel", "Michael I. Jordan", "Philipp Moritz" ],
      "venue" : "In International Conference on Machine Learning (ICML),",
      "citeRegEx" : "31",
      "shortCiteRegEx" : "31",
      "year" : 2015
    }, {
      "title" : "High-dimensional continuous control using generalized advantage estimation",
      "author" : [ "John Schulman", "Philipp Moritz", "Sergey Levine", "Michael Jordan", "Pieter Abbeel" ],
      "venue" : "International Conference on Learning Representations (ICLR),",
      "citeRegEx" : "32",
      "shortCiteRegEx" : "32",
      "year" : 2016
    }, {
      "title" : "Deterministic policy gradient algorithms",
      "author" : [ "David Silver", "Guy Lever", "Nicolas Heess", "Thomas Degris", "Daan Wierstra", "Martin Riedmiller" ],
      "venue" : "In International Conference on Machine Learning (ICML),",
      "citeRegEx" : "33",
      "shortCiteRegEx" : "33",
      "year" : 2014
    }, {
      "title" : "Reinforcement learning: An introduction, volume 1",
      "author" : [ "Richard S Sutton", "Andrew G Barto" ],
      "venue" : "MIT press Cambridge,",
      "citeRegEx" : "34",
      "shortCiteRegEx" : "34",
      "year" : 1998
    }, {
      "title" : "Temporal difference learning and tdgammon",
      "author" : [ "Gerald Tesauro" ],
      "venue" : "Commun. ACM,",
      "citeRegEx" : "35",
      "shortCiteRegEx" : "35",
      "year" : 1995
    }, {
      "title" : "Mujoco: A physics engine for model-based control",
      "author" : [ "Emanuel Todorov", "Tom Erez", "Yuval Tassa" ],
      "venue" : "In 2012 IEEE/RSJ International Conference on Intelligent Robots and Systems,",
      "citeRegEx" : "36",
      "shortCiteRegEx" : "36",
      "year" : 2012
    }, {
      "title" : "Learning robot in-hand manipulation with tactile features",
      "author" : [ "Herke van Hoof", "Tucker Hermans", "Gerhard Neumann", "Jan Peters" ],
      "venue" : "In 15th IEEE-RAS International Conference on Humanoid Robots, Humanoids",
      "citeRegEx" : "37",
      "shortCiteRegEx" : "37",
      "year" : 2015
    }, {
      "title" : "Neural networks for control. chapter A  Menu of Designs for Reinforcement Learning over Time, pages 67–95",
      "author" : [ "Paul J. Webros" ],
      "venue" : null,
      "citeRegEx" : "38",
      "shortCiteRegEx" : "38",
      "year" : 1990
    }, {
      "title" : "Collective robot reinforcement learning with distributed asynchronous guided policy",
      "author" : [ "Ali Yahya", "Adrian Li", "Mrinal Kalakrishnan", "Yevgen Chebotar", "Sergey Levine" ],
      "venue" : "search. CoRR,",
      "citeRegEx" : "39",
      "shortCiteRegEx" : "39",
      "year" : 2016
    } ],
    "referenceMentions" : [ {
      "referenceID" : 6,
      "context" : "[7, 20, 32, 31, 11, 17]).",
      "startOffset" : 0,
      "endOffset" : 23
    }, {
      "referenceID" : 19,
      "context" : "[7, 20, 32, 31, 11, 17]).",
      "startOffset" : 0,
      "endOffset" : 23
    }, {
      "referenceID" : 31,
      "context" : "[7, 20, 32, 31, 11, 17]).",
      "startOffset" : 0,
      "endOffset" : 23
    }, {
      "referenceID" : 30,
      "context" : "[7, 20, 32, 31, 11, 17]).",
      "startOffset" : 0,
      "endOffset" : 23
    }, {
      "referenceID" : 10,
      "context" : "[7, 20, 32, 31, 11, 17]).",
      "startOffset" : 0,
      "endOffset" : 23
    }, {
      "referenceID" : 16,
      "context" : "[7, 20, 32, 31, 11, 17]).",
      "startOffset" : 0,
      "endOffset" : 23
    }, {
      "referenceID" : 22,
      "context" : "What is feasible on a simulated system, where hundreds of millions of control steps are possible [23], does not necessarily transfer to real robot applications due to unrealistic learning times.",
      "startOffset" : 97,
      "endOffset" : 101
    }, {
      "referenceID" : 29,
      "context" : "in the form of dynamic movement primitives [30], or in the form of strong teaching signals, e.",
      "startOffset" : 43,
      "endOffset" : 47
    }, {
      "referenceID" : 23,
      "context" : "kinesthetic teaching of trajectories [24].",
      "startOffset" : 37,
      "endOffset" : 41
    }, {
      "referenceID" : 17,
      "context" : "[18, 5, 39]), but tasks as complex as grasping-and-stacking",
      "startOffset" : 0,
      "endOffset" : 11
    }, {
      "referenceID" : 4,
      "context" : "[18, 5, 39]), but tasks as complex as grasping-and-stacking",
      "startOffset" : 0,
      "endOffset" : 11
    }, {
      "referenceID" : 38,
      "context" : "[18, 5, 39]), but tasks as complex as grasping-and-stacking",
      "startOffset" : 0,
      "endOffset" : 11
    }, {
      "referenceID" : 19,
      "context" : "On the algorithm side we build on the Deep Deterministic Policy Gradient (DDPG; [20]), a general purpose model-free",
      "startOffset" : 80,
      "endOffset" : 84
    }, {
      "referenceID" : 33,
      "context" : "A wide variety of techniques have been developed that exploit this idea [34], with a broad distinction often made between valuebased and policy search methods.",
      "startOffset" : 72,
      "endOffset" : 76
    }, {
      "referenceID" : 2,
      "context" : "The latter have been routinely applied in robotics, in part because they straightforwardly handle continuous and high-dimensional action spaces [3] and applications include manipulation [26, 13, 25, 37, 18, 5, 39, 8], locomotion e.",
      "startOffset" : 144,
      "endOffset" : 147
    }, {
      "referenceID" : 25,
      "context" : "The latter have been routinely applied in robotics, in part because they straightforwardly handle continuous and high-dimensional action spaces [3] and applications include manipulation [26, 13, 25, 37, 18, 5, 39, 8], locomotion e.",
      "startOffset" : 186,
      "endOffset" : 216
    }, {
      "referenceID" : 12,
      "context" : "The latter have been routinely applied in robotics, in part because they straightforwardly handle continuous and high-dimensional action spaces [3] and applications include manipulation [26, 13, 25, 37, 18, 5, 39, 8], locomotion e.",
      "startOffset" : 186,
      "endOffset" : 216
    }, {
      "referenceID" : 24,
      "context" : "The latter have been routinely applied in robotics, in part because they straightforwardly handle continuous and high-dimensional action spaces [3] and applications include manipulation [26, 13, 25, 37, 18, 5, 39, 8], locomotion e.",
      "startOffset" : 186,
      "endOffset" : 216
    }, {
      "referenceID" : 36,
      "context" : "The latter have been routinely applied in robotics, in part because they straightforwardly handle continuous and high-dimensional action spaces [3] and applications include manipulation [26, 13, 25, 37, 18, 5, 39, 8], locomotion e.",
      "startOffset" : 186,
      "endOffset" : 216
    }, {
      "referenceID" : 17,
      "context" : "The latter have been routinely applied in robotics, in part because they straightforwardly handle continuous and high-dimensional action spaces [3] and applications include manipulation [26, 13, 25, 37, 18, 5, 39, 8], locomotion e.",
      "startOffset" : 186,
      "endOffset" : 216
    }, {
      "referenceID" : 4,
      "context" : "The latter have been routinely applied in robotics, in part because they straightforwardly handle continuous and high-dimensional action spaces [3] and applications include manipulation [26, 13, 25, 37, 18, 5, 39, 8], locomotion e.",
      "startOffset" : 186,
      "endOffset" : 216
    }, {
      "referenceID" : 38,
      "context" : "The latter have been routinely applied in robotics, in part because they straightforwardly handle continuous and high-dimensional action spaces [3] and applications include manipulation [26, 13, 25, 37, 18, 5, 39, 8], locomotion e.",
      "startOffset" : 186,
      "endOffset" : 216
    }, {
      "referenceID" : 7,
      "context" : "The latter have been routinely applied in robotics, in part because they straightforwardly handle continuous and high-dimensional action spaces [3] and applications include manipulation [26, 13, 25, 37, 18, 5, 39, 8], locomotion e.",
      "startOffset" : 186,
      "endOffset" : 216
    }, {
      "referenceID" : 15,
      "context" : "[16, 21], and a range of other challenges such as helicopter flight [1].",
      "startOffset" : 0,
      "endOffset" : 8
    }, {
      "referenceID" : 20,
      "context" : "[16, 21], and a range of other challenges such as helicopter flight [1].",
      "startOffset" : 0,
      "endOffset" : 8
    }, {
      "referenceID" : 0,
      "context" : "[16, 21], and a range of other challenges such as helicopter flight [1].",
      "startOffset" : 68,
      "endOffset" : 71
    }, {
      "referenceID" : 37,
      "context" : "[38, 35, 12, 10].",
      "startOffset" : 0,
      "endOffset" : 16
    }, {
      "referenceID" : 34,
      "context" : "[38, 35, 12, 10].",
      "startOffset" : 0,
      "endOffset" : 16
    }, {
      "referenceID" : 11,
      "context" : "[38, 35, 12, 10].",
      "startOffset" : 0,
      "endOffset" : 16
    }, {
      "referenceID" : 9,
      "context" : "[38, 35, 12, 10].",
      "startOffset" : 0,
      "endOffset" : 16
    }, {
      "referenceID" : 21,
      "context" : "[22, 23, 6, 7, 20, 32, 31, 11, 17].",
      "startOffset" : 0,
      "endOffset" : 34
    }, {
      "referenceID" : 22,
      "context" : "[22, 23, 6, 7, 20, 32, 31, 11, 17].",
      "startOffset" : 0,
      "endOffset" : 34
    }, {
      "referenceID" : 5,
      "context" : "[22, 23, 6, 7, 20, 32, 31, 11, 17].",
      "startOffset" : 0,
      "endOffset" : 34
    }, {
      "referenceID" : 6,
      "context" : "[22, 23, 6, 7, 20, 32, 31, 11, 17].",
      "startOffset" : 0,
      "endOffset" : 34
    }, {
      "referenceID" : 19,
      "context" : "[22, 23, 6, 7, 20, 32, 31, 11, 17].",
      "startOffset" : 0,
      "endOffset" : 34
    }, {
      "referenceID" : 31,
      "context" : "[22, 23, 6, 7, 20, 32, 31, 11, 17].",
      "startOffset" : 0,
      "endOffset" : 34
    }, {
      "referenceID" : 30,
      "context" : "[22, 23, 6, 7, 20, 32, 31, 11, 17].",
      "startOffset" : 0,
      "endOffset" : 34
    }, {
      "referenceID" : 10,
      "context" : "[22, 23, 6, 7, 20, 32, 31, 11, 17].",
      "startOffset" : 0,
      "endOffset" : 34
    }, {
      "referenceID" : 16,
      "context" : "[22, 23, 6, 7, 20, 32, 31, 11, 17].",
      "startOffset" : 0,
      "endOffset" : 34
    }, {
      "referenceID" : 9,
      "context" : "[10, 5, 18, 39],",
      "startOffset" : 0,
      "endOffset" : 15
    }, {
      "referenceID" : 4,
      "context" : "[10, 5, 18, 39],",
      "startOffset" : 0,
      "endOffset" : 15
    }, {
      "referenceID" : 17,
      "context" : "[10, 5, 18, 39],",
      "startOffset" : 0,
      "endOffset" : 15
    }, {
      "referenceID" : 38,
      "context" : "[10, 5, 18, 39],",
      "startOffset" : 0,
      "endOffset" : 15
    }, {
      "referenceID" : 17,
      "context" : "One exception are guided policy search methods (GPS) [18, 39].",
      "startOffset" : 53,
      "endOffset" : 61
    }, {
      "referenceID" : 38,
      "context" : "One exception are guided policy search methods (GPS) [18, 39].",
      "startOffset" : 53,
      "endOffset" : 61
    }, {
      "referenceID" : 17,
      "context" : "[18] or model-free [39] trajectory optimization.",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 38,
      "context" : "[18] or model-free [39] trajectory optimization.",
      "startOffset" : 19,
      "endOffset" : 23
    }, {
      "referenceID" : 4,
      "context" : "One recent work [5], closely related to the ideas followed in this paper, provides a proof of concept demonstration that value-based methods using neural network approximators can be used for robotic manipulation in the real world .",
      "startOffset" : 16,
      "endOffset" : 19
    }, {
      "referenceID" : 6,
      "context" : "This work applied a Q-learning approach [7] to a door opening task in which a robotic arm fitted with an unactuated hook needed to reach to a handle and pull a door to a given angle.",
      "startOffset" : 40,
      "endOffset" : 43
    }, {
      "referenceID" : 26,
      "context" : "[27], including the use of several robots from which experience are gathered in parallel [19, 5, 39].",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 18,
      "context" : "[27], including the use of several robots from which experience are gathered in parallel [19, 5, 39].",
      "startOffset" : 89,
      "endOffset" : 100
    }, {
      "referenceID" : 4,
      "context" : "[27], including the use of several robots from which experience are gathered in parallel [19, 5, 39].",
      "startOffset" : 89,
      "endOffset" : 100
    }, {
      "referenceID" : 38,
      "context" : "[27], including the use of several robots from which experience are gathered in parallel [19, 5, 39].",
      "startOffset" : 89,
      "endOffset" : 100
    }, {
      "referenceID" : 22,
      "context" : "This can be combined with single machine or distributed training depending on whether the bottleneck is primarily one of data collection or also one of network training [23].",
      "startOffset" : 169,
      "endOffset" : 173
    }, {
      "referenceID" : 1,
      "context" : "Finally, the use of demonstration data has played an important role in robot learning, both as a means to obtain suitable cost functions [2, 14, 4, 8] but also to bootstrap and thus speed up learning.",
      "startOffset" : 137,
      "endOffset" : 150
    }, {
      "referenceID" : 13,
      "context" : "Finally, the use of demonstration data has played an important role in robot learning, both as a means to obtain suitable cost functions [2, 14, 4, 8] but also to bootstrap and thus speed up learning.",
      "startOffset" : 137,
      "endOffset" : 150
    }, {
      "referenceID" : 3,
      "context" : "Finally, the use of demonstration data has played an important role in robot learning, both as a means to obtain suitable cost functions [2, 14, 4, 8] but also to bootstrap and thus speed up learning.",
      "startOffset" : 137,
      "endOffset" : 150
    }, {
      "referenceID" : 7,
      "context" : "Finally, the use of demonstration data has played an important role in robot learning, both as a means to obtain suitable cost functions [2, 14, 4, 8] but also to bootstrap and thus speed up learning.",
      "startOffset" : 137,
      "endOffset" : 150
    }, {
      "referenceID" : 25,
      "context" : "For the latter, kinesthetic teaching is widely used [26, 13, 25, 39].",
      "startOffset" : 52,
      "endOffset" : 68
    }, {
      "referenceID" : 12,
      "context" : "For the latter, kinesthetic teaching is widely used [26, 13, 25, 39].",
      "startOffset" : 52,
      "endOffset" : 68
    }, {
      "referenceID" : 24,
      "context" : "For the latter, kinesthetic teaching is widely used [26, 13, 25, 39].",
      "startOffset" : 52,
      "endOffset" : 68
    }, {
      "referenceID" : 38,
      "context" : "For the latter, kinesthetic teaching is widely used [26, 13, 25, 39].",
      "startOffset" : 52,
      "endOffset" : 68
    }, {
      "referenceID" : 32,
      "context" : "DPG [33] is a policy gradient algorithm for continuous action spaces that improves the deterministic policy function π via backpropagation of the action-value gradient from a learned approximation to the Q-function.",
      "startOffset" : 4,
      "endOffset" : 8
    }, {
      "referenceID" : 19,
      "context" : "DDPG [20] is an improvement of the original DPG algorithm adding experience replay and target networks: Experience is collected into a buffer and updates to θ and φ (eqs.",
      "startOffset" : 5,
      "endOffset" : 9
    }, {
      "referenceID" : 6,
      "context" : "DDPG bears a relation to several other recent model free RL algorithms: The NAF algorithm [7] which has recently been applied to a real-world robotics problem [5] can be viewed as a DDPG variant where the Q-function is quadratic in the action so that the optimal action can be easily recovered directly from the Q-function, making a separate representation of the policy unnecessary.",
      "startOffset" : 90,
      "endOffset" : 93
    }, {
      "referenceID" : 4,
      "context" : "DDPG bears a relation to several other recent model free RL algorithms: The NAF algorithm [7] which has recently been applied to a real-world robotics problem [5] can be viewed as a DDPG variant where the Q-function is quadratic in the action so that the optimal action can be easily recovered directly from the Q-function, making a separate representation of the policy unnecessary.",
      "startOffset" : 159,
      "endOffset" : 162
    }, {
      "referenceID" : 21,
      "context" : "DDPG and especially NAF are the continuous action counterparts of DQN [22], a Q-learning algorithm that recently re-popularized the use of experience replay and target networks to stabilize learning with powerful function approximators such as neural networks.",
      "startOffset" : 70,
      "endOffset" : 74
    }, {
      "referenceID" : 28,
      "context" : "NFQ [29] and NFQCA [9] employ the same basic update as DDPG and DQN, however, they are batch algorithms that perform updates less frequently and fully re-fit the Q-function and the policy network after every episode with several hundred iterations of gradient descent",
      "startOffset" : 4,
      "endOffset" : 8
    }, {
      "referenceID" : 8,
      "context" : "NFQ [29] and NFQCA [9] employ the same basic update as DDPG and DQN, however, they are batch algorithms that perform updates less frequently and fully re-fit the Q-function and the policy network after every episode with several hundred iterations of gradient descent",
      "startOffset" : 19,
      "endOffset" : 22
    }, {
      "referenceID" : 27,
      "context" : "with Rprop [28] and using full-batch updates with the entire replay buffer.",
      "startOffset" : 11,
      "endOffset" : 15
    }, {
      "referenceID" : 10,
      "context" : "the stochastic value gradients (SVG) family [11], which",
      "startOffset" : 44,
      "endOffset" : 48
    }, {
      "referenceID" : 35,
      "context" : "We implement the experiments in a physically plausible simulation in MuJoCo [36] with the simulated arm being closely matched to a real-world Jaco arm1 setup in our lab.",
      "startOffset" : 76,
      "endOffset" : 80
    }, {
      "referenceID" : 19,
      "context" : "To gain a better understanding of this interaction we modified the original DDPG algorithm as described in [20] to perform a fixed but configurable number of mini-batch updates per step in the environment.",
      "startOffset" : 107,
      "endOffset" : 111
    }, {
      "referenceID" : 19,
      "context" : "In [20] one update was performed after each new interaction step.",
      "startOffset" : 3,
      "endOffset" : 7
    }, {
      "referenceID" : 38,
      "context" : "as in [39, 5]).",
      "startOffset" : 6,
      "endOffset" : 13
    }, {
      "referenceID" : 4,
      "context" : "as in [39, 5]).",
      "startOffset" : 6,
      "endOffset" : 13
    }, {
      "referenceID" : 22,
      "context" : "This is inspired by the A3C algorithm proposed in [23], and also analogous to [5, 39].",
      "startOffset" : 50,
      "endOffset" : 54
    }, {
      "referenceID" : 4,
      "context" : "This is inspired by the A3C algorithm proposed in [23], and also analogous to [5, 39].",
      "startOffset" : 78,
      "endOffset" : 85
    }, {
      "referenceID" : 38,
      "context" : "This is inspired by the A3C algorithm proposed in [23], and also analogous to [5, 39].",
      "startOffset" : 78,
      "endOffset" : 85
    }, {
      "referenceID" : 14,
      "context" : "We use the Adam optimizer [15] with local non-shared first-order statistics and a single shared instance of second-order statistics.",
      "startOffset" : 26,
      "endOffset" : 30
    } ],
    "year" : 2017,
    "abstractText" : "Deep learning and reinforcement learning methods have recently been used to solve a variety of problems in continuous control domains. An obvious application of these techniques is dexterous manipulation tasks in robotics which are difficult to solve using traditional control theory or hand-engineered approaches. One example of such a task is to grasp an object and precisely stack it on another. Solving this difficult and practically relevant problem in the real world is an important long-term goal for the field of robotics. Here we take a step towards this goal by examining the problem in simulation and providing models and techniques aimed at solving it. We introduce two extensions to the Deep Deterministic Policy Gradient algorithm (DDPG), a model-free Q-learning based method, which make it significantly more data-efficient and scalable. Our results show that by making extensive use of off-policy data and replay, it is possible to find control policies that robustly grasp objects and stack them. Further, our results hint that it may soon be feasible to train successful stacking policies by collecting interactions on real robots.",
    "creator" : "LaTeX with hyperref package"
  }
}