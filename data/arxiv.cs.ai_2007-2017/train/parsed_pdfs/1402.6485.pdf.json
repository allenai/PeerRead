{
  "name" : "1402.6485.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : "Solving MaxSAT and #SAT on structured CNF formulas",
    "authors" : [ "Sigve Hortemo Sæther", "Jan Arne Telle", "Martin Vatshelle" ],
    "emails" : [ ],
    "sections" : [ {
      "heading" : "1 Introduction",
      "text" : "Given a CNF formula, propositional model counting (#SAT) is the problem of computing the number of satisfying assignments, and maximum satisfiability (MaxSAT) is the problem of determining the maximum number of clauses that can be satisfied by some assignment. Both problems are significantly harder than simply deciding if a satisfying assignment exists. #SAT is #P-hard [9] even when restricted to Horn 2-CNF formulas, and to monotone 2-CNF formulas [19]. MaxSAT is NP-hard even when restricted to Horn 2-CNF formulas [13], and to 2-CNF formulas where each variable appears at most 3 times [17]. Both problems become tractable under certain structural restrictions obtained by\nar X\niv :1\n40 2.\n64 85\nv1 [\ncs .D\nS] 2\n6 Fe\nbounding width parameters of graphs associated with formulas, see for example [7, 8, 20, 22]. The work we present here is inspired by the recent results of Paulusma et al [15] and Slivovsky and Szeider [21] showing that #SAT is solvable in polynomial time when the incidence graph I(F ) of the input formula F has bounded modular treewidth, and more strongly, bounded symmetric clique-width.\nWe extend these results in several ways. We give algorithms for both #SAT and MaxSAT, and also weighted MaxSAT, finding the maximum weight of satisfiable clauses, given a set of weighted clauses. We introduce the parameter ps-width, and express the runtime of our algorithms as a function of ps-width.\nTheorem 3. Given a formula F over n variables and m clauses and of size s, and a decomposition of F of ps-width k, we solve #SAT, and weighted MaxSAT in time O(k3s(m+ n)).\nThus, given a decomposition having a ps-width k that is polynomially-bounded in the number of variables n and clauses m of the formula, we get polynomialtime algorithms. These are dynamic programming algorithms similar to the one given for #SAT in [21], but we believe that the ps-width parameter is a better measure of its ’inherent runtime bottleneck’. The essential combinatorial result enabling this improvement is Lemma 5 of this paper. The algorithm of [21] solves #SAT in time (n+m)O(w) for w being the symmetric clique-width of the decomposition, and is thus a polynomial-time algorithm if given a decomposition with constantly bounded w. The result of Theorem 3 encompasses this, since we show via the concept of MIM-width [23], that any formula with constantly bounded symmetric clique-width also has polynomially bounded ps-width.\nWe show that a relatively rich class of formulas, including classes of unbounded clique-width, have polynomially bounded ps-width. This is shown using the concept of MIM-width of graphs, introduced in the thesis of Vatshelle [23]. See Figure 1. In particular, this holds for classes of formulas having incidence graphs that can be represented as intersection graphs of certain objects, like interval graphs [1]. We prove this also for bigraph bipartizations of these graphs, which are obtained by imposing a bipartition on the vertex set and keeping only edges between the partition classes. Some such bigraph bipartizations have been studied previously, in particular the interval bigraphs. The interval bigraphs contain all bipartite permutation graphs, and these latter graphs have been shown to have unbounded clique-width [3].\nBy combining an alternative definition of interval bigraphs [11] with a fast recognition algorithm [14, 16] we arrive at the following. Say that a CNF formula F has an interval ordering if there exists a linear ordering of variables and clauses such that for any variable x occurring in clause C, if x appears before C then any variable between them also occurs in C, and if C appears before x then x occurs also in any clause between them.\nTheorem 10. Given a CNF formula F over n variables and m clauses and of size s, we can in time O((m+ n)s) decide if F has an interval ordering (yes iff I(F ) is an interval bigraph), and if yes we solve #SAT and weighted MaxSAT with a runtime of O(m2(m+ n)s).\nThe algorithms of Theorem 10 may be of interest for practical applications, as there are no big hidden constants in the runtimes.\nOur paper is organized as follows. In Section 2 we give formal definitions. We will be using a type of decomposition that originates in the theory of graphs and matroids where it is known as branch decomposition, see [10, 18]. The standard approach is to apply this type of decomposition to the incidence graph of a formula, and evaluate its width using as cut function a graph parameter, as done in [21]. The cut function we will use is not a graph parameter, but rather the ps-value of a formula, being the number of distinct subsets of clauses that are satisfied by some complete assignment. We thus prefer to apply the decomposition directly to the formula and not to its incidence graph, although the translation between the two will be straightforward. We define cuts of formulas and ps-width of a formula. Note that a formula can have ps-value exponential and ps-width polynomial. In Section 3 we present dynamic programming algorithms that given a formula and a decomposition solves #SAT and weighted MaxSAT, proving Theorem 3. In Section 4 we investigate classes of formulas having decompositions of low ps-width, basically proving the correctness of the hierarchy presented in Figure 1. In Section 5 we consider formulas having an interval ordering and prove Theorem 10. We end in Section 5 with some open problems."
    }, {
      "heading" : "2 Framework",
      "text" : "A literal is a propositional variable or a negated variable, x or ¬x, a clause is a set of literals, and a formula is a multiset of clauses. For a formula F , cla(F ) denotes the clauses in F . For a clause C, lit(C) denotes the set of literals in C and var(C) denotes the variables of the literals in lit(C). For a set S of variables and clauses, var(S) denotes the variables of S and cla(S) denotes the clauses. For a formula F , var(F ) denotes the union ⋃ C∈cla(F ) var(C). For a set X of variables, an assignment of X is a function τ : X → {0, 1}. For a literal `, we define τ(`) to be 1− τ(var(`)) if ` is a negated variable (` = ¬x for some variable x) and to be τ(var) otherwise (` = x for some variable x). A clause C is said to be satisfied by an assignment τ if there exists at least one literal ` ∈ lit(C) so that τ(`) = 1. All clauses an assignment τ do not satisfy are said to be unsatisfied by τ . We notice that this means an empty clause will be unsatisfied by all assignments. A formula is satisfied by an assignment τ if τ satisfies all clauses in cla(F ).\nThe problem #SAT, given a formula F , asks how many distinct assignments of var(F ) satisfy F . The optimization problem weighted MaxSAT, given a formula F and weight function w : cla(F ) → N, asks what assignment τ of var(F ) maximizes ∑ C w(C) for all C ∈ cla(F ) satisfied by τ . The problem MaxSAT is weighted MaxSAT where all clauses have weight one. When given a CNF formula F , we use s to denote the size of F . More precisely, the size of F is s = |cla(F )|+ ∑C∈cla(F ) |lit(C)|. For weighted MaxSAT, we assume the\nsum of all the weights are at most 2O(claF ), and thus we can do summation on the weights in time linear in claF .\nFor a set A, with elements from a universe U we denote by A the elements in U \\A, as the universe is usually given by the context."
    }, {
      "heading" : "2.1 Cut of a formula",
      "text" : "In this paper, we will solve MaxSAT and #SAT by the use of dynamic programming. We will be using a divide and conquer technique where we solve the problem on smaller subformulas of the original formula F and then combine the solutions to each of these smaller formulas to form a solution to the entire formula F . Note however, that the solutions found for a subformula will depend on the interaction between the subformula and the remainder of the formula. We use the following notation for subformulas.\nFor a clause C and set X of variables, by C|X we denote the clause {` ∈ C : var(`) ∈ X}. We say C|X is the clause C induced by X. For a formula F and subsets C ⊆ cla(F ) and X ⊆ var(F ), we say the subformula FC,X of F induced by C and X is the formula consisting of the clauses {Ci|X : Ci ∈ C}.\nThat is, FC,X is the formula we get by removing all clauses not in C followed by removing each literal that consists of a variable not in X. As with a clause, for an assignment τ over a set X of variables, we say the assignment τ induced by X ′ ⊆ X is the assignment τ |X′ where the domain is restricted to X ′.\nFor a formula F and sets C ⊆ cla(F ), X ⊆ var(F ), and S = C ∪X, we call S a cut of F and note that it breaks F into four subformulas FC,X , FC,X , FC,X , and FC,X . See Figure 2. One important fact we may observe from this definition is that a clause C in F is satisfied by an assignment τ of var(F ), if and only if C (induced by X or X) is satisfied by τ in at least one of the formulas of any cut of F .\n2.2 Precisely satisfiable sets and ps-value of a formula\nFor a formula F and assignment τ of all the variables in var(F ), we denote by sat(F, τ) the set C ⊆ cla(F ) so that each clause in C is satisfied by τ , and each clause not in C is unsatisfied by τ . If for a set C ⊆ cla(F ) we have sat(F, τ) = C for some τ over var(F ), we say C is precisely satisfiable in F . We denote by PS(F ) the family of all precisely satisfiable sets in F . That is,\nPS(F ) = {sat(F, τ) : τ is an assignment of var(F )}.\nThe cardinality of this set, PS(F ), is referred to as the ps-value of F .\n2.3 The ps-width of a formula\nWe define a branch decomposition of a formula F to be a pair (T, δ) where T is a rooted binary tree and δ is a bijective function from the leaves of T to the clauses and variables of F . If all the non-leaf nodes (also referred to as internal nodes) of T induce a path, we say that (T, δ) is a linear branch decomposition. For a non-leaf node v of T , we denote by δ(v) the set {δ(l) : l is a leaf in the subtree rooted in v}. Based on this, we say that the decomposition (T, δ) of formula F induces certain cuts of F , namely the cuts defined by δ(v) for each node v in T .\nFor a formula F and branch decomposition (T, δ), for each node v in T , by Fv we denote the formula induced by the clauses in cla(F ) \\ δ(v) and the variables in δ(v), and by Fv we denote the formula on the complement sets; i.e. the clauses in δ(v) and the variables in var(F ) \\ δ(v). In other words, if δ(v) = C ∪X with C ⊆ cla(F ) and X ⊆ var(F ) then Fv = FC,X and Fv = FC,X . We define the ps-value of the cut δ(v) to be\nps(δ(v)) = max{|PS(Fv)|, |PS(Fv)|}\nWe define the ps-width of a branch decomposition to be\npsw(T, δ) = max{ps(δ(v)) : v is a node of T}\nWe define the ps-width of a formula F to be\npsw(F ) = min{psw(T, δ) : (T, δ) is a branch decompositions of F}\nNote that the ps-value of a cut is a symmetric function. That is, the ps-value of cut S equals the ps-value of the cut S. See Figure 2 for an example.\n3 Dynamic programming for MaxSAT and #SAT\nGiven a branch decomposition (T, δ) of a CNF formula F over n variables and m clauses and of size s, we will give algorithms that solve MaxSAT and #SAT on F in time O(psw(T, δ)3s(m+ n)).\nIn a pre-processing step we will need the following which, for each node v in T computes the sets PS(Fv) and PS(Fv).\nTheorem 1. Given a CNF formula F of n variables and m clauses with a branch decomposition (T, δ) of ps-width k, we can in time O(k2 log(k)m(m+n)) compute the sets PS(Fv) and PS(Fv) for each v in T .\nProof. We notice that for a node v in T with children c1 and c2, we can express PS(Fv) as\nPS(Fv) = {(C1 ∪ C2) ∩ cla(Fv) : C1 ∈ PS(Fc1), C2 ∈ PS(Fc2)} .\nSimilarly, for sibling s and parent p of v in T , the set PS(Fv) can be expressed as\nPS(Fv) = {(Cp ∪ Cs) ∩ cla(Fv) : Cp ∈ PS(Fp), Cs ∈ PS(Fs)} .\nBy transforming these recursive expressions into a dynamic programming algorithm, as done in Procedure 1 and Procedure 2 below, we are able to calculate all the desired sets as long as we can compute the sets for the base cases PS(Fl) when l is a leaf of T , and PS(Fr) for the root r of T . However, these formulas contain at most one variable, and thus we can easily construct their set of specific satisfied clauses in linear amount of time for each of the formulas. For the rest of the formulas, we construct the formulas using Procedure 1 and Procedure 2. As there are at most twice as many nodes in T as there are clauses and variables in F , the procedures will run at most O(|cla(F )|+ |var(F )|) times. In each run of the algorithms, we iterate through at most k2 pairs of precisely satisfiable sets, and do a constant number of set operations that might take O(|cla(F )|) time each. Then we sort the list of at most k2 sets of clauses. When we sort, we can expect the runtime of comparing two elements to spend time linear in |cla(F )|, so the total runtime for sorting L and deleting duplicates takes at most O(k2 log(k)|cla(F )|) time. This results in a total runtime of O(k2 log(k)|cla(F )|(|cla(F )|+ |var(F )|)) for all the nodes of T combined.\nProcedure 1: Generating PS(Fv)\ninput: PS(Fc1) and PS(Fc2) for children c1 and c2 of v in branch decomposition output: PS(Fv) L← empty list of precisely satisfiable clause-sets for each (C1, C2) ∈ PS(Fc1)× PS(Fc2) do\nadd (C1 ∪ C2) \\ cla(δ(v)) to L sort L lexicographically by what clauses each element contains remove duplicates in L by looking only at consecutive elements return L\nWe first give the algorithm for MaxSAT and then briefly describe the changes necessary for solving weighted MaxSAT and #SAT.\nOur algorithm relies on the following binary relation, ≤, on assignments τ and τ ′ related to a cut S = C ∪X with C ⊆ cla(F ), X ⊆ var(F ). For C′ ∈ PS(FC,X) we define τ ′ ≤C′S τ if it holds that |sat(F, τ ′) \\ C′| ≤ |sat(F, τ) \\ C′|. Note that for each cut S = C ∪ X and each C′ ∈ PS(FC,X) this gives a total preorder (transitive, reflexive and total) on assignments. The largest elements of this total preorder will be important for our algorithm, as they satisfy the maximum number of clauses under the given restrictions.\nProcedure 2: Generating PS(Fv)\ninput: PS(Fs) and PS(Fp) for sibling s and parent p of v in branch decomposition output: PS(Fv) L← empty list of precisely satisfiable clause-sets for each (Cs, Cp) ∈ PS(Fs)× PS(Fp) do\nadd (Cs ∪ Cp) \\ cla(δ(v)) to L sort L lexicographically by what clauses each element contains remove duplicates in L by looking only at consecutive elements return L\nGiven (T, δ) of a formula F our dynamic programming algorithm for MaxSAT will generate, for each node v in T , a table Tabv indexed by pairs of PS(Fv)× PS(Fv). For precisely satisfiable sets Cv ∈ PS(Fv) and Cv ∈ PS(Fv) the contents of the table at this index Tabv(Cv, Cv) should be an assignment τ : var(δ(v))→ {0, 1} satisfying the following constraint:\nTabv(Cv, Cv) = τ such that sat(Fv, τ) = Cv and τ ′ ≤Cvδ(v) τ for any\nτ ′ : var(δ(v))→ {0, 1} having sat(Fv, τ ′) = Cv (1)\nLet us give some intuition for this constraint. Our algorithm uses the technique of ’expectation from the outside’ introduced in [4, 5]. The partial assignment τ to variables in var(δ(v)) stored at Tabv(Cv, Cv) will be combined with partial assignments to variables in var(F )\\var(δ(v)) satisfying Cv. These latter partial assignments constitute ’the expectation from the outside’. Constraint (1) implies that τ , being a largest element of the total preorder, will be a best combination with this expectation from the outside since it satisfies the maximum number of remaining clauses.\nBy bottom-up dynamic programming along the tree T we compute the tables of each node of T . For a leaf l in T , generating Tabl can be done easily in linear time since the formula Fv contains at most one variable. For an internal node v of T , with children c1, c2, we compute Tabv by the algorithm described in Procedure 3. There are 3 tables involved in this update, one at each child and one at the parent. A pair of entries, one from each child table, may lead to an update of an entry in the parent table. Each table entry is indexed by a pair, thus there are 6 indices involved in a single potential update. A clever trick first introduced in [5] allows us to loop over triples of indices and for each triple compute the remaining 3 indices forming the 6-tuple involved in the update, thereby reducing the runtime.\nProcedure 3: Computing Tabv for inner node v with children c1, c2\ninput: Tabc1 , Tabc2 output: Tabv 1. initialize Tabv : PS(Fv)× PS(Fv)→ {unassigned} // dummy entries 2. for each (Cc1 , Cc2 , Cv) ∈ PS(Fc1)× PS(Fc2)× PS(Fv) do 3. Cc1 ← (Cc2 ∪ Cv) ∩ δ(c1) 4. Cc2 ← (Cc1 ∪ Cv) ∩ δ(c2) 5. Cv ← (Cc1 ∪ Cc2) \\ δ(v) 6. τ ← Tabc1(Cc1 , Cc1) ] Tabc2(Cc2 , Cc2) 7. τ ′ ← Tabv(Cv, Cv) 8. if τ ′ = unassigned or τ ≥Cvδ(v) τ ′ then Tabv(Cv, Cv)← τ 9. return Tabv\nLemma 2. For a CNF formula F of size s and an inner node v, of a branch decomposition (T, δ) of ps-width k, Procedure 3 computes Tabv satisfying Constraint (1) in time O(k3s). Proof. We assume Tabc1 and Tabc2 satisfy Constraint (1). Procedure 3 loops over all triples (Cc1 , Cc2 , Cv) ∈ PS(Fc1)× PS(Fc2)× PS(Fv). From the definition of ps-width of (T, δ) there are at most k3 such triples. Each operation inside an iteration of the loop take O(s) time and there is a constant number of such operations. Thus the runtime is O(k3s).\nTo show that the output Tabv of Procedure 3 satisfies Constraint (1), we will prove that for any C ∈ PS(Fv) and C ′ ∈ PS(Fv) the value of Tabv(C,C ′) satisfies Constraint (1). That is, we will assure that the content of Tabv(C,C\n′) is an assignment τ so that sat(Fv, τ) = C and for all other assignments τ\n′ over var(δ(v)) so that sat(Fv, τ\n′) = C, we have τ ′ ≤C′δ(v) τ . Let us assume for contradiction, that Tabv(C,C\n′) contains an assignment τ but there exists an assignment τ ′ over var(δ(v)) so that sat(Fv, τ ′) = C, and we do not have τ ′ ≤C′δ(v) τ . As τ is put into Tabv(C,C ′) only if it is an assignment over var(δ(v)) and sat(Fv, τ) = C. So, what we need to show to prove that Tabv is correct is that in fact τ\n′ ≤C′δ(v) τ : First, we notice that τ ′ consist of assignments τ ′1 = τ\n′|var(δ(c1)) and τ ′2 = τ ′|var(δ(c2)) where τ ′1 is over the variables in var(δ(c1)) and τ ′2 is over var(δ(c2)). Let C1 = sat(Fc1 , τ ′ 1) and C2 = sat(Fc2 , τ ′ 2) and let C ′ 1 = (C2 ∪C ′) ∩ δ(c1) and C ′2 = (C1 ∪ C ′) ∩ δ(c2). By how Tabc1 and Tabc2 is defined, we know for the assignment τ1 in Tabc1(C1, C ′ 1) and τ2 in Tabc2(C2, C ′ 2), we have τ ′ 1 ≤ C′1 δ(c1) τ1 and τ ′2 ≤ C′2 δ(c2)\nτ2. From our definition of the total preorder ≤ for assignments, we can deduce that τ ′1 ] τ ′2 ≤C ′ δ(v) τ1 ] τ2;\n|sat(Fv, τ ′1 ] τ ′2) \\ C ′| = |sat(Fc1 , τ ′1) \\ C ′1| − |C1 ∩ C ′2|+ |sat(Fc2 , τ ′2) \\ C ′2| − |C2 ∩ C ′1| ≤ |sat(Fc1 , τ1) \\ C ′1| − |C1 ∩ C ′2|+ |sat(Fc2 , τ2) \\ C ′2| − |C2 ∩ C ′1| = |sat(Fv, τ1 ] τ2) \\ C ′| .\nHowever, since τ1]τ2 at the iteration of the triple (C1, C2, C ′) in fact is considered by the algorithm to be set as Tabv(C,C ′), it must be the case that τ1]τ2 ≤C ′\nδ(v) τ .\nAs ≤C′δ(v) clearly is a transitive relation, we conclude that τ ′ ≤C ′ δ(v) τ .\nTheorem 3. Given a formula F over n variables and m clauses and of size s, and a branch decomposition (T, δ) of F of ps-width k, we solve MaxSAT, #SAT, and weighted MaxSAT in time O(k3s(m+ n)). Proof. To solve MaxSAT, we first compute Tabr for the root node r of T . This requires that we first compute PS(Fv) and PS(Fv) for all nodes v of T , and then, in a bottom up manner, compute Tabv for each of the O(m + n) nodes in T . The former part we can do in O(k3s(m+ n)) time by Theorem 1, and the latter part we do in the same amount of time by Lemma 2.\nAt the root r of T we have δ(r) = var(F ) ∪ cla(F ). Thus Fr = ∅ and Fr contains only empty clauses, so that PS(Fr)× PS(Fr) contains only (∅, ∅). By Constraint (1) and the definition of the ≤ total preorder on assignments, the assignment τ stored in Tabr(∅, ∅) is an assignment of var(F ) maximizing |sat(F, τ)|, the number of clauses satisfied, and hence is a solution to MaxSAT.\nFor a weight function w : cla(F ) → N, by redefining τ1 ≤BA τ2 to mean w(sat(F, τ1) \\ B) ≤ w(sat(F, τ2) \\ B) both for the definition of Tab and for Procedure 3, we are able to solve the more general problem weighted MaxSAT in the same way.\nFor the problem #SAT, we care only about assignments satisfying all the clauses of F , and we want to decide the number of distinct assignments doing so. This requires a few alterations. Firstly, alter the definition of the contents of Tabv(C,C\n′) in Constraint (1) to be the number of assignments τ over var(δ(v)) where sat(Fv, τ) = C and cla(δ(v))\\C ′ ⊆ sat(F, τ). Secondly, when computing Tabl for the leaves l of T , we set each of the entries of Tabl to either zero, one, or two, according to the definition. Thirdly, we alter the algorithm to compute Tabv (Procedure 3) for inner nodes. We initialize Tabv(C,C\n′) to be zero at the start of the algorithm, and substitute lines 6, 7 and 8 of Procedure 3 by the following line which increases the table value by the product of the table values at the children\nTabv(Cv, Cv)← Tabv(Cv, Cv) + Tabc1(Cc1 , Cc1) · Tabc2(Cc2 , Cc2)\nThis will satisfy our new constraint of Tabv for internal nodes v of T . The value of Tabr(∅, ∅) at the root r of T will be exactly the number of distinct assignments satisfying all clauses of F .\nThe bottleneck giving the cubic factor k3 in the runtime of Theorem 3 is the number triples in PS(Fv)× PS(Fc1)× PS(Fc2) for any node v with children c1 and c2. When (T, δ) is a linear branch decomposition, it is always the case that either c1 or c2 is a leaf of T . In this case either |PS(Fc1)| or |PS(Fc2)| is a constant. Therefore, for linear branch decompositions PS(Fv)×PS(Fc1)×PS(Fc2) will contain no more than O(k2) triples. Thus we can reduce the runtime of the algorithm by a factor of k.\nTheorem 4. Given a formula F over n variables and m clauses and of size s, and a linear branch decomposition (T, δ) of F of ps-width k, we solve #SAT, MaxSAT, and weighted MaxSAT in time O(k2s(m+ n)).\n4 CNF formulas of polynomial ps-width\nIn this section we investigate classes of CNF formulas having decompositions with ps-width polynomially bounded in formula size s. In particular, we show that this holds whenever the incidence graph of the formula has constant MIM-width (maximum induced matching-width). We also show that a large class of bipartite graphs, using what we call bigraph bipartizations, have constant MIM-width.\nLet us start by defining bigraph bipartizations. For a graph G and subset of vertices A ⊆ V (G) the bipartite graph G[A,A] is the subgraph of G containing all edges of G with exactly one endpoint in A. We call G[A,A] a bigraph bipartization of G, note that G has a bigraph bipartization for each subset of vertices. For a graph class X define the class of X bigraphs as the bipartite graphs H for which there exists G ∈ X such that H is isomorphic to a bigraph bipartization of G. For example, H is an interval bigraph if there is some interval graph G and some A ⊆ V (G) with H isomorphic to G[A,A].\nTo establish the connection to MIM-width we need to look at induced matchings in the incidence graph of a formula. The incidence graph of a formula F is the bipartite graph I(F ) having a vertex for each clause and variable, with variable x adjacent to any clause C in which it occurs. An induced matching in a graph is a subset M of edges with the property that any edge of the graph is incident to at most one edge in M . In other words, for any 3 vertices a, b, c, if ab is an edge in M and bc is an edge then there does not exist an edge cd in M . The number of edges in M is called the size of the induced matching. The following result provides an upper bound on the ps-value of a formula in terms of the maximum size of an induced matching of its incidence graph.\nLemma 5. Let F be a CNF formula and let k be the maximum size of an induced matching in I(F ). We then have |PS(F )| ≤ |cla(F )|k.\nProof. Let C ∈ PS(F ) and Cf = cla(F ) \\ C. Thus, there exists a complete assignment τ such that the clauses not satisfied by τ are Cf = cla(F )\\sat(F, τ). Since every variable in var(F ) appears in some clause of F this means that τ |var(Cf ) is the unique assignment of the variables in var(Cf ) which do not satisfy any clause of Cf . Let C ′\nf ⊆ Cf be an inclusion minimal set such that var(Cf ) = var(C ′\nf ), hence τ |var(Cf ) is also the unique assignment of the variables in var(Cf ) which do not satisfy any clause of C ′ f . An upper bound on the number of different such minimal C′f , over all C ∈ PS(F ), will give an upper bound on |PS(F )|. For every C ∈ C′f there is a variable vC appearing in C and no other clause of C′f , otherwise C ′\nf would not be minimal. Note that we have an induced matching M of I(F ) containing all such edges vC , C. By assumption,\nthe induced matching M can have at most k edges and hence |C′f | ≤ k. There are at most |cla(F )|k sets of at most k clauses and the lemma follows.\nIn order to lift this result on the ps-value of F , i.e |PS(F )|, to the ps-width of F , we use MIM-width of the incidence graph I(F ), which is defined using branch decompositions of graphs. A branch decomposition of the formula F , as defined in Section 2, can also be seen as a branch decomposition of the incidence graph I(F ). Nevertheless, for completeness, we formally define branch decompositions of graphs and MIM-width.\nA branch decomposition of a graph G is a pair (T, δ) where T is a rooted binary tree and δ a bijection between the leaf set of T and the vertex set of G. For a node w of T let the subset of V (G) in bijection δ with the leaves of the subtree of T rooted at w be denoted by Vw. We say the decomposition defines the cut (Vw, Vw). The MIM-value of a cut (Vw, Vw) is the size of a maximum induced matching of G[Vw, Vw]. The MIM-width of (T, δ) is the maximum MIM-value over all cuts (Vw, Vw) defined by a node w of T . The MIM-width of graph G, denoted mimw(G), is the minimum MIM-width over all branch decompositions (T, δ) of G. As before a linear branch decomposition is a branch decomposition where inner nodes of the underlying tree induces a path.\nWe now give an upper bound on the ps-value of a formula in terms of the MIM-width of any graph G such that the incidence graph of the formula is a bigraph bipartization of G.\nTheorem 6. Let F be a CNF formula of m clauses, G a graph, and (T, δG) a (linear) branch decomposition of G of MIM-width k. If for a subset A ⊆ V (G) the graph G[A,A] is isomorphic to I(F ), then we can in linear time produce a (linear) branch decomposition (T, δF ) of F having ps-width at most m k.\nProof. Since each variable and clause in F has a corresponding node in I(F ), and each node in I(F ) has a corresponding node in G, by defining δF to be the function mapping each leaf l of T to the variable or clause in F corresponding to the node δG(l), (T, δT ) is going to be a branch decomposition of F . For any cut (A,A) induced by a node of (T, δF ), let C ⊆ cla(F ) be the clauses corresponding to vertices in A and X ⊆ var(F ) the variables corresponding to vertices in A. The cut S = C ∪X of F defines the two formulas FC,X and FC,X , and it holds that I(FC,X) and I(FC,X) are induced subgraphs of G[A,A] and hence by Lemma 5, we have |PS(FC,X)| ≤ |cla(F )|mim(A), and likewise we have |PS(FC,X)| ≤ |cla(F )|mim(A). Since the ps-width of the decomposition is the maximum ps-value of each cut, the theorem follows.\nNote that by taking G = I(F ) and A = cla(F ) and letting (T, δG) be a branch decomposition of G of minimum MIM-width, we get the following weaker result.\nCorollary 7. For any CNF formula F over m clauses, the ps-width of F is no larger than mmimw(I(F )).\nIn his thesis, Vatshelle [23] shows that MIM-width of any graph G is at most the clique-width of G. Furthermore, the clique-width has been shown by Courcelle [6] to be at most twice the symmetric clique-width. Thus, we can conclude that MIM-width is bounded on any graph class with a bound on the symmetric clique-width, in accordance with Figure 1.\nMany classes of graphs have intersection models, meaning that they can be represented as intersection graphs of certain objects, i.e. each vertex is associated with an object and two vertices are adjacent iff their objects intersect. The objects used to define intersection graphs usually consist of geometrical objects such as lines, circles or polygons. Many well known classes of intersection graphs have constant MIM-width, as in the following which lists only a subset of the classes proven to have such bounds in [1, 23].\nTheorem 8 ([1, 23]). Let G be a graph. If G is a: interval graph then mimw(G) ≤ 1. circular arc graph then mimw(G) ≤ 2. k-trapezoid graph then mimw(G) ≤ k. Moreover there exist linear decompositions satisfying the bound.\nLet us briefly mention the definition of these graph classes. A graph is an interval graph if it has an intersection model consisting of intervals of the real line. A graph is a circular arc graph if it has an intersection model consisting of arcs of a circle. To build a k-trapezoid we start with k parallel line segments (s1, e1), (s2, e2), ..., (sk, ek) and add two non-intersecting paths s and e by joining si to si+1 and ei to ei+1 respectively by straight lines for each i ∈ {1, ..., k − 1}. The polygon defined by s and e and the two line segments (s1, e1), (sk, ek) forms a k-trapezoid. A graph is a k-trapezoid graph if it has an intersection model consisting of k-trapezoids. See [2] for information about graph classes and their containment relations. Combining Theorems 6 and 8 we get the following.\nCorollary 9. Let F be a CNF formula containing m clauses. If I(F ) is a: interval bigraph then psw(F ) ≤ m. circular arc bigraph then psw(F ) ≤ m2. k-trapezoid bigraph then psw(F ) ≤ mk. Moreover there exist linear decompositions satisfying the bound."
    }, {
      "heading" : "5 Interval bigraphs and formulas having interval",
      "text" : "orders\nWe will in this section show one class of formulas where we can find linear branch decompositions having ps-width O(|cla(F )|). Let us recall the definition of interval ordering. A CNF formula F has an interval ordering if there exists a linear ordering of variables and clauses such that for any variable x occurring in clause C, if x appears before C then any variable between them also occurs in C, and if C appears before x then x occurs also in any clause between them.\nBy a result of Hell and Huang [11] it follows that a formula F has an interval ordering if and only if I(F ) is a interval bigraph.\nTheorem 10. Given a CNF formula F over n variables and m clauses and of size s, we can in time O((m+ n)s) decide if F has an interval ordering (yes iff I(F ) is an interval bigraph), and if yes we solve #SAT and weighted MaxSAT with a runtime of O(m2(m+ n)s).\nProof. Using the characterization of [11] and the algorithm of [16] we can in time O((m+ n)s) decide if F has an interval ordering and if yes, then we find it. From this interval ordering we build an interval graph G such that I(F ) is a bigraph bipartization of G, and construct a linear branch decomposition of G having MIM-width 1 [1]. From such a linear branch decomposition we get from Theorem 6 that we can construct another linear branch decomposition of F having ps-width O(m). We then run the algorithm of Theorem 4."
    }, {
      "heading" : "6 Conclusion",
      "text" : "In this paper we have proposed a structural parameter of CNF formulas, called ps-width or perfectly-satisfiable-width. We showed that weighted MaxSAT and #SAT can be solved in polynomial time on formulas given with a decomposition of polynomially bounded ps-width. Using the concept of interval bigraphs we also showed a polynomial time algorithm that actually finds such a decomposition, for formulas having an interval ordering.\nCould one devise such an algorithm also for the larger class of circular arc bigraphs, or maybe even for the even larger class of k-trapezoid bigraphs? In other words, is the problem of recognizing if a bipartite input graph is a circular arc bigraph, or a k-trapezoid bigraph, polynomial-time solvable?\nIt could be interesting to give an algorithm solving MaxSAT and/or #SAT directly on the interval ordering of a formula, rather than using the more general notion of ps-width as in this paper. Maybe such an algorithm could be of practical use?\nAlso of practical interest would be to design a heuristic algorithm which given a formula finds a decomposition of relatively low ps-width, as has been done for boolean-width in [12].\nFinally, we hope the essential combinatorial result enabling the improvements in this paper, Lemma 5, may have other uses as well."
    } ],
    "references" : [ {
      "title" : "Graph classes with structured neighborhoods and algorithmic applications",
      "author" : [ "Rémy Belmonte", "Martin Vatshelle" ],
      "venue" : "Theor. Comput. Sci.,",
      "citeRegEx" : "1",
      "shortCiteRegEx" : "1",
      "year" : 2013
    }, {
      "title" : "Graph Classes: A Survey, volume 3 of Monographs on Discrete Mathematics and Applications",
      "author" : [ "A. Brandstädt", "V. Bang Le", "J.P. Spinrad" ],
      "venue" : "SIAM Society for Industrial and Applied Mathematics, Philadelphia,",
      "citeRegEx" : "2",
      "shortCiteRegEx" : "2",
      "year" : 1999
    }, {
      "title" : "On the linear structure and clique-width of bipartite permutation graphs",
      "author" : [ "Andreas Brandstädt", "Vadim V. Lozin" ],
      "venue" : "Ars Comb.,",
      "citeRegEx" : "3",
      "shortCiteRegEx" : "3",
      "year" : 2003
    }, {
      "title" : "H-join decomposable graphs and algorithms with runtime single exponential in rankwidth",
      "author" : [ "Binh-Minh Bui-Xuan", "Jan Arne Telle", "Martin Vatshelle" ],
      "venue" : "Discrete Applied Mathematics,",
      "citeRegEx" : "4",
      "shortCiteRegEx" : "4",
      "year" : 2010
    }, {
      "title" : "Boolean-width of graphs",
      "author" : [ "Binh-Minh Bui-Xuan", "Jan Arne Telle", "Martin Vatshelle" ],
      "venue" : "Theoretical Computer Science,",
      "citeRegEx" : "5",
      "shortCiteRegEx" : "5",
      "year" : 2011
    }, {
      "title" : "Clique-width of countable graphs: a compactness property",
      "author" : [ "Bruno Courcelle" ],
      "venue" : "Discrete Mathematics,",
      "citeRegEx" : "6",
      "shortCiteRegEx" : "6",
      "year" : 2004
    }, {
      "title" : "Counting truth assignments of formulas of bounded tree-width or clique-width",
      "author" : [ "Eldar Fischer", "Johann A. Makowsky", "Elena V. Ravve" ],
      "venue" : "Discrete Applied Mathematics,",
      "citeRegEx" : "7",
      "shortCiteRegEx" : "7",
      "year" : 2008
    }, {
      "title" : "Better algorithms for satisfiability problems for formulas of bounded rank-width",
      "author" : [ "Robert Ganian", "Petr Hlinený", "Jan Obdrzálek" ],
      "venue" : "Fundam. Inform.,",
      "citeRegEx" : "8",
      "shortCiteRegEx" : "8",
      "year" : 2013
    }, {
      "title" : "Computers and Intractability: A Guide to the Theory of NP-Completeness",
      "author" : [ "M.R. Garey", "David S. Johnson" ],
      "venue" : null,
      "citeRegEx" : "9",
      "shortCiteRegEx" : "9",
      "year" : 1979
    }, {
      "title" : "Branch-width and well-quasi-ordering in matroids and graphs",
      "author" : [ "James F. Geelen", "Bert Gerards", "Geoff Whittle" ],
      "venue" : "J. COMBIN. THEORY SER. B,",
      "citeRegEx" : "10",
      "shortCiteRegEx" : "10",
      "year" : 2002
    }, {
      "title" : "Interval bigraphs and circular arc graphs",
      "author" : [ "Pavol Hell", "Jing Huang" ],
      "venue" : "Journal of Graph Theory,",
      "citeRegEx" : "11",
      "shortCiteRegEx" : "11",
      "year" : 2004
    }, {
      "title" : "Finding good decompositions for dynamic programming on dense graphs",
      "author" : [ "Eivind Magnus Hvidevold", "Sadia Sharmin", "Jan Arne Telle", "Martin Vatshelle" ],
      "venue" : null,
      "citeRegEx" : "12",
      "shortCiteRegEx" : "12",
      "year" : 2011
    }, {
      "title" : "On the complexity of the maximum satisfiability problem for horn formulas",
      "author" : [ "Brigitte Jaumard", "Bruno Simeone" ],
      "venue" : "Inf. Process. Lett.,",
      "citeRegEx" : "13",
      "shortCiteRegEx" : "13",
      "year" : 1987
    }, {
      "title" : "Recognizing interval digraphs and interval bigraphs in polynomial time",
      "author" : [ "Haiko Müller" ],
      "venue" : "Discrete Applied Mathematics,",
      "citeRegEx" : "14",
      "shortCiteRegEx" : "14",
      "year" : 1997
    }, {
      "title" : "Model counting for CNF formulas of bounded modular treewidth",
      "author" : [ "Daniël Paulusma", "Friedrich Slivovsky", "Stefan Szeider" ],
      "venue" : "STACS, volume 20 of LIPIcs,",
      "citeRegEx" : "15",
      "shortCiteRegEx" : "15",
      "year" : 2013
    }, {
      "title" : "Recognizing interval bigraphs by forbidden patterns",
      "author" : [ "Arash Rafiey" ],
      "venue" : "CoRR, abs/1211.2662,",
      "citeRegEx" : "16",
      "shortCiteRegEx" : "16",
      "year" : 2012
    }, {
      "title" : "A simplified NP-complete MAXSAT problem",
      "author" : [ "Venkatesh Raman", "Bala Ravikumar", "S. Srinivasa Rao" ],
      "venue" : "Inf. Process. Lett.,",
      "citeRegEx" : "17",
      "shortCiteRegEx" : "17",
      "year" : 1998
    }, {
      "title" : "Graph minors X. obstructions to tree-decomposition",
      "author" : [ "Neil Robertson", "Paul D. Seymour" ],
      "venue" : "J. COMBIN. THEORY SER. B,",
      "citeRegEx" : "18",
      "shortCiteRegEx" : "18",
      "year" : 1991
    }, {
      "title" : "A connectionist framework for reasoning: Reasoning with examples",
      "author" : [ "Dan Roth" ],
      "venue" : "editors, AAAI/IAAI,",
      "citeRegEx" : "19",
      "shortCiteRegEx" : "19",
      "year" : 1996
    }, {
      "title" : "Algorithms for propositional model counting",
      "author" : [ "Marko Samer", "Stefan Szeider" ],
      "venue" : "J. Discrete Algorithms,",
      "citeRegEx" : "20",
      "shortCiteRegEx" : "20",
      "year" : 2010
    }, {
      "title" : "Model counting for formulas of bounded clique-width",
      "author" : [ "Friedrich Slivovsky", "Stefan Szeider" ],
      "venue" : "editors, ISAAC,",
      "citeRegEx" : "21",
      "shortCiteRegEx" : "21",
      "year" : 2013
    }, {
      "title" : "On fixed-parameter tractable parameterizations of SAT",
      "author" : [ "Stefan Szeider" ],
      "venue" : "editors, SAT,",
      "citeRegEx" : "22",
      "shortCiteRegEx" : "22",
      "year" : 2003
    }, {
      "title" : "New width parameters of graphs",
      "author" : [ "Martin Vatshelle" ],
      "venue" : "PhD thesis, The University of Bergen,",
      "citeRegEx" : "23",
      "shortCiteRegEx" : "23",
      "year" : 2012
    } ],
    "referenceMentions" : [ {
      "referenceID" : 8,
      "context" : "#SAT is #P-hard [9] even when restricted to Horn 2-CNF formulas, and to monotone 2-CNF formulas [19].",
      "startOffset" : 16,
      "endOffset" : 19
    }, {
      "referenceID" : 18,
      "context" : "#SAT is #P-hard [9] even when restricted to Horn 2-CNF formulas, and to monotone 2-CNF formulas [19].",
      "startOffset" : 96,
      "endOffset" : 100
    }, {
      "referenceID" : 12,
      "context" : "MaxSAT is NP-hard even when restricted to Horn 2-CNF formulas [13], and to 2-CNF formulas where each variable appears at most 3 times [17].",
      "startOffset" : 62,
      "endOffset" : 66
    }, {
      "referenceID" : 16,
      "context" : "MaxSAT is NP-hard even when restricted to Horn 2-CNF formulas [13], and to 2-CNF formulas where each variable appears at most 3 times [17].",
      "startOffset" : 134,
      "endOffset" : 138
    }, {
      "referenceID" : 6,
      "context" : "bounding width parameters of graphs associated with formulas, see for example [7, 8, 20, 22].",
      "startOffset" : 78,
      "endOffset" : 92
    }, {
      "referenceID" : 7,
      "context" : "bounding width parameters of graphs associated with formulas, see for example [7, 8, 20, 22].",
      "startOffset" : 78,
      "endOffset" : 92
    }, {
      "referenceID" : 19,
      "context" : "bounding width parameters of graphs associated with formulas, see for example [7, 8, 20, 22].",
      "startOffset" : 78,
      "endOffset" : 92
    }, {
      "referenceID" : 21,
      "context" : "bounding width parameters of graphs associated with formulas, see for example [7, 8, 20, 22].",
      "startOffset" : 78,
      "endOffset" : 92
    }, {
      "referenceID" : 14,
      "context" : "The work we present here is inspired by the recent results of Paulusma et al [15] and Slivovsky and Szeider [21] showing that #SAT is solvable in polynomial time when the incidence graph I(F ) of the input formula F has bounded modular treewidth, and more strongly, bounded symmetric clique-width.",
      "startOffset" : 77,
      "endOffset" : 81
    }, {
      "referenceID" : 20,
      "context" : "The work we present here is inspired by the recent results of Paulusma et al [15] and Slivovsky and Szeider [21] showing that #SAT is solvable in polynomial time when the incidence graph I(F ) of the input formula F has bounded modular treewidth, and more strongly, bounded symmetric clique-width.",
      "startOffset" : 108,
      "endOffset" : 112
    }, {
      "referenceID" : 20,
      "context" : "These are dynamic programming algorithms similar to the one given for #SAT in [21], but we believe that the ps-width parameter is a better measure of its ’inherent runtime bottleneck’.",
      "startOffset" : 78,
      "endOffset" : 82
    }, {
      "referenceID" : 20,
      "context" : "The algorithm of [21] solves #SAT in time (n+m)O(w) for w being the symmetric clique-width of the decomposition, and is thus a polynomial-time algorithm if given a decomposition with constantly bounded w.",
      "startOffset" : 17,
      "endOffset" : 21
    }, {
      "referenceID" : 22,
      "context" : "The result of Theorem 3 encompasses this, since we show via the concept of MIM-width [23], that any formula with constantly bounded symmetric clique-width also has polynomially bounded ps-width.",
      "startOffset" : 85,
      "endOffset" : 89
    }, {
      "referenceID" : 22,
      "context" : "This is shown using the concept of MIM-width of graphs, introduced in the thesis of Vatshelle [23].",
      "startOffset" : 94,
      "endOffset" : 98
    }, {
      "referenceID" : 0,
      "context" : "In particular, this holds for classes of formulas having incidence graphs that can be represented as intersection graphs of certain objects, like interval graphs [1].",
      "startOffset" : 162,
      "endOffset" : 165
    }, {
      "referenceID" : 2,
      "context" : "The interval bigraphs contain all bipartite permutation graphs, and these latter graphs have been shown to have unbounded clique-width [3].",
      "startOffset" : 135,
      "endOffset" : 138
    }, {
      "referenceID" : 10,
      "context" : "By combining an alternative definition of interval bigraphs [11] with a fast recognition algorithm [14, 16] we arrive at the following.",
      "startOffset" : 60,
      "endOffset" : 64
    }, {
      "referenceID" : 13,
      "context" : "By combining an alternative definition of interval bigraphs [11] with a fast recognition algorithm [14, 16] we arrive at the following.",
      "startOffset" : 99,
      "endOffset" : 107
    }, {
      "referenceID" : 15,
      "context" : "By combining an alternative definition of interval bigraphs [11] with a fast recognition algorithm [14, 16] we arrive at the following.",
      "startOffset" : 99,
      "endOffset" : 107
    }, {
      "referenceID" : 9,
      "context" : "We will be using a type of decomposition that originates in the theory of graphs and matroids where it is known as branch decomposition, see [10, 18].",
      "startOffset" : 141,
      "endOffset" : 149
    }, {
      "referenceID" : 17,
      "context" : "We will be using a type of decomposition that originates in the theory of graphs and matroids where it is known as branch decomposition, see [10, 18].",
      "startOffset" : 141,
      "endOffset" : 149
    }, {
      "referenceID" : 20,
      "context" : "The standard approach is to apply this type of decomposition to the incidence graph of a formula, and evaluate its width using as cut function a graph parameter, as done in [21].",
      "startOffset" : 173,
      "endOffset" : 177
    }, {
      "referenceID" : 3,
      "context" : "Our algorithm uses the technique of ’expectation from the outside’ introduced in [4, 5].",
      "startOffset" : 81,
      "endOffset" : 87
    }, {
      "referenceID" : 4,
      "context" : "Our algorithm uses the technique of ’expectation from the outside’ introduced in [4, 5].",
      "startOffset" : 81,
      "endOffset" : 87
    }, {
      "referenceID" : 4,
      "context" : "A clever trick first introduced in [5] allows us to loop over triples of indices and for each triple compute the remaining 3 indices forming the 6-tuple involved in the update, thereby reducing the runtime.",
      "startOffset" : 35,
      "endOffset" : 38
    }, {
      "referenceID" : 22,
      "context" : "In his thesis, Vatshelle [23] shows that MIM-width of any graph G is at most the clique-width of G.",
      "startOffset" : 25,
      "endOffset" : 29
    }, {
      "referenceID" : 5,
      "context" : "Furthermore, the clique-width has been shown by Courcelle [6] to be at most twice the symmetric clique-width.",
      "startOffset" : 58,
      "endOffset" : 61
    }, {
      "referenceID" : 0,
      "context" : "Many well known classes of intersection graphs have constant MIM-width, as in the following which lists only a subset of the classes proven to have such bounds in [1, 23].",
      "startOffset" : 163,
      "endOffset" : 170
    }, {
      "referenceID" : 22,
      "context" : "Many well known classes of intersection graphs have constant MIM-width, as in the following which lists only a subset of the classes proven to have such bounds in [1, 23].",
      "startOffset" : 163,
      "endOffset" : 170
    }, {
      "referenceID" : 0,
      "context" : "Theorem 8 ([1, 23]).",
      "startOffset" : 11,
      "endOffset" : 18
    }, {
      "referenceID" : 22,
      "context" : "Theorem 8 ([1, 23]).",
      "startOffset" : 11,
      "endOffset" : 18
    }, {
      "referenceID" : 1,
      "context" : "See [2] for information about graph classes and their containment relations.",
      "startOffset" : 4,
      "endOffset" : 7
    }, {
      "referenceID" : 10,
      "context" : "By a result of Hell and Huang [11] it follows that a formula F has an interval ordering if and only if I(F ) is a interval bigraph.",
      "startOffset" : 30,
      "endOffset" : 34
    }, {
      "referenceID" : 10,
      "context" : "Using the characterization of [11] and the algorithm of [16] we can in time O((m+ n)s) decide if F has an interval ordering and if yes, then we find it.",
      "startOffset" : 30,
      "endOffset" : 34
    }, {
      "referenceID" : 15,
      "context" : "Using the characterization of [11] and the algorithm of [16] we can in time O((m+ n)s) decide if F has an interval ordering and if yes, then we find it.",
      "startOffset" : 56,
      "endOffset" : 60
    }, {
      "referenceID" : 0,
      "context" : "From this interval ordering we build an interval graph G such that I(F ) is a bigraph bipartization of G, and construct a linear branch decomposition of G having MIM-width 1 [1].",
      "startOffset" : 174,
      "endOffset" : 177
    }, {
      "referenceID" : 11,
      "context" : "Maybe such an algorithm could be of practical use? Also of practical interest would be to design a heuristic algorithm which given a formula finds a decomposition of relatively low ps-width, as has been done for boolean-width in [12].",
      "startOffset" : 229,
      "endOffset" : 233
    } ],
    "year" : 2014,
    "abstractText" : "In this paper we propose a structural parameter of CNF formulas and use it to identify instances of weighted MaxSAT and #SAT that can be solved in polynomial time. Given a CNF formula we say that a set of clauses is precisely satisfiable if there is some complete assignment satisfying these clauses only. Let the ps-value of the formula be the number of precisely satisfiable sets of clauses. Applying the notion of branch decompositions to CNF formulas and using ps-value as cut function, we define the ps-width of a formula. For a formula given with a decomposition of polynomial ps-width we show dynamic programming algorithms solving weighted MaxSAT and #SAT in polynomial time. Combining with results of ’Belmonte and Vatshelle, Graph classes with structured neighborhoods and algorithmic applications, Theor. Comput. Sci. 511: 54-65 (2013)’ we get polynomial-time algorithms solving weighted MaxSAT and #SAT for some classes of structured CNF formulas. For example, we get O(m(m + n)s) algorithms for formulas F of m clauses and n variables and size s, if F has a linear ordering of the variables and clauses such that for any variable x occurring in clause C, if x appears before C then any variable between them also occurs in C, and if C appears before x then x occurs also in any clause between them. Note that the class of incidence graphs of such formulas do not have bounded clique-width.",
    "creator" : "LaTeX with hyperref package"
  }
}