{
  "name" : "1606.00930.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : "Comparison of 14 different families of classification algorithms on 115 binary datasets",
    "authors" : [ "Jacques Wainer" ],
    "emails" : [ "wainer@ic.unicamp.br" ],
    "sections" : [ {
      "heading" : null,
      "text" : "keywords: Classification algorithms; comparison; binary problems; Demsar procedure; Bayesian analysis"
    }, {
      "heading" : "1 Introduction",
      "text" : "Fernández-Delgado et al. (2014) evaluated 179 different implementations of classification algorithms (from 17 different families of algoritms) on 121 public datasets. We believe that such highly empirical research are very important both for researchers in machine learning and specially for practitioners.\nar X\niv :1\n60 6.\n00 93\n0v 1\n[ cs\n.L G\nFor researchers, this form of research allows them to focus their efforts on more likely useful endeavors. For example, if a researcher is interested in developing algorithms for very large classification problems, it is probably more useful to develop a big-data random forest (which is the family of classification algoritms with best performance according to Fernández-Delgado et al. (2014)) than to do it for Bayesian networks (mainly naive Bayes) or even Nearest Neighbors methods, which perform worse than random forests.\nFor practitioners, this form of research is even more important. Practitioners in machine learning will have limited resources, time, and expertise to test many different classification algorithms on their problem, and this form of research will allow them to focus on the most likely useful algorithms.\nDespite its importance and breath, we believe that Fernández-Delgado et al. (2014) had some “imperfections” which we address in this research. The “imperfections” are discussed below as the extensions we carried in this paper:\n• We used the same set of datasets, but we transform them so that the problems are all binary. Many classification algorithms are defined only to binary problems, for example the SVM family, logistic regression, among others. Of course there are meta-extensions of such algorithms to multi-class problems, for example, one-vs-one, one-vs-all, error correcting output coding (ECOC) (Dietterich and Bakiri, 1995), stacked generalization (Wolpert, 1992), pairwise coupling (Hastie et al., 1998), among others. Also, there are alternative formulations for specific binary classifiers to deal with multiclass, for example, Franc et al. (2002) for SVM, Engel (1988) for logistic regression, and so on.\nFor the algorithms that are intrinsically binary, the application to multiclass problems poses two problems. The first is that one has to decide on which meta-extension to use, or if one should use the specific multiclass formulation of the algorithm. In some cases, one meta-extension is implemented by default, and the user must be aware that this decision was already made for him/her. For example, the libSVM default approach is one-vs-one. But a second, more subtle problem is the search for hyperparameters: it is very common that each combination of hyperparameters are tested only once for all classifiers in the one-vs-one solution. That is, all n(n−1)/2 classifiers in a one-vsone solution has the same set of hyperparameters, and that may cause a decrease in accuracy in comparison to the case in which classifier is allow to choose its one set of hyperparameter. Thus, on multiclass\nproblems, those intrinsically binary algorithms could be facing many disadvantages.\nOn the issue of binary classifiers, Fernández-Delgado et al. (2014) did not include in their comparisons the gradient boosting machine (gbm) algorithm, considered a very competitive algorithm for classification problems because, as reported in Zajac (2016), the implementation did not work in multiclass problems. We included gbm in our comparison.\n• We reduced the number of classifiers to only a few classes/algorithms and not different implementations of the same algorithm. FernándezDelgado et al. (2014) compared an impressing 179 different classification programs, but it was unclear how many were just different implementations of the same algorithm, and how many were variations within the same “family” of algorithms. We believe that for practitioner and research communities, it is more useful to have an understanding of how different families of algorithms rank in relation to each other. For the practitioner, which should have more limited access to the different algorithms, this knowledge allow them to order which algorithms should be applied first to their particular problem.\nIn fact, Fernández-Delgado et al. (2014) also perform an analysis of their results based on the algorithm’s “family”, but they have difficulty of extracting useful information from this analysis, since in most cases, different “implementations” in the same family have widely different results. In one analysis, they rank the families by the worse performing member, which does not provide useful information. But in the end, their conclusions are mainly centered on the families of classifiers, because that is the most useful level of knowledge. From the abstract of the paper:\nA few models are clearly better than the remaining ones: random forest, SVM with Gaussian and polynomial kernels, extreme learning machine with Gaussian kernel, C5.0 and avNNet (a committee of multi-layer perceptrons implemented in R with the caret package). The random forest is clearly the best family of classifiers (3 out of 5 bests classifiers are RF), followed by SVM (4 classifiers in the top-10), neural networks and boosting ensembles (5 and 3 members in the top-20, respectively).\n• We performed a more careful search for hyperparameters for each clas-\nsification algorithm. Given Fernández-Delgado et al. (2014) daunting task of testing 179 programs, they had to rely on default values for the hyperparameters which may lead to suboptimal results. Since we are working with significantly fewer algorithms, we could spend more time selecting reasonable ranges of values for the hyperparameters. In particular we tried to limit the number of training steps for the hyperparameter search in 24 so that no algorithm would have an advantage of having more degrees of freedom to adjust to the data (but in section 2.4 we discuss that some algorithms may allow testing many values of the hyperparameter with just one training and testing step).\n• Besides computing when two algorithms are significantly different in their error rates, in the standard null-hypothesis significance tests (NHST), we also use a Bayesian analysis to discover when the differences of two algorithms has no “practical consequences.” As far as we know, this is the first time a Bayesian ANOVA is used to compare classifiers, which we believe is an important direction in analysis of results in empirical machine learning. But more significantly is the use of “limits of practical significance”, that is, the definition of thresholds below which the differences are irrelevant from practical purposes, which goes beyond an more standard “significance test” analysis currently used in the machine learning literature.\nFernández-Delgado et al. (2014) follow the standard null hypothesis significant test in analyzing their result, but even within this framework, their analysis is not as rigorous as it should have been. The NIST standard for comparing many classifiers across different datasets was proposed by Demsar (2006) and it is discussed in section 3.1. In particular, when testing the different algorithms for statistical significant differences, the Demsar procedure requires one to use the Nemenyi test, which is a nonparametric test that performs the appropriate multiple comparison p-value correction. But Fernández-Delgado et al. (2014) used a paired t-test (a parametric test) between the first ranked and the following 9 top ranked algorithms, apparently without multiple comparions corrections. Very likely, given the large number of comparisons need to contrast all 179 algorithms, very few, if any of the pairwise comparisons would have been flagged as significant by the Nemenyi test.\nIn this paper we followed the full Demsar procedure to analyse the results, but we also used the Bayesian ANOVA to verify when the\ndifferences between the algoritms is not only “statistically significant”, but also “of practical significance”.\nFernández-Delgado et al. (2014) first two ranked programs are two different implementation of the same algorithm - parallel implementation of random forest (first ranked) and a non-parallel implementation (second ranked). The authors state that in some sense, the difference between the two results should not be “important” (they use the term “significant”) and indeed the statistical significance analysis shows that the difference was not statistically significant, but neither was the next 6 ranked algorithms (in comparison to the top performing).\n• We studied the computational costs of running a “standard” implementation of the different algorithms. With information regarding the computational cost a practitioner may want to balance execution time and expected accuracy. Furthermore, this information may encourage the practitioner choose other implementations that the ones tested, and researcher to develop faster implementations of the best ranked algorithms."
    }, {
      "heading" : "2 Data and Methods",
      "text" : ""
    }, {
      "heading" : "2.1 Experimental procedure",
      "text" : "In general terms the experimental procedure followed by this research is the following.\nEach dataset Di (the datasets are discussed in section 2.2) is divided in half into two subsets S1i and S2i, each with the same proportion of classes. For each subset Sji, we used a a 5-fold cross validation procedure to select the best set of hyperparameters for the procedure a, (θ̂a). Then we trained the whole subset Sji using the procedure a with hyperparameters θ̂j and computed the error rate on the subset Ŝi, (where 1̂ = 2 and 2̂ = 1). We call the error rate of algorithm a when learning on the subset Sji, with hyperparameters θ̂a, when testing on the subset Ŝi as (i, ̂|a, θ̂, j). The expected for procedure a error on (whole) dataset i is (i|a) and it is computed as the average\n(i|a) = (i, 1|a, θ̂, i, 2) + (i, 2|a, θ̂, i, 1) 2\n(1)\nWe then performed the analyses described in sections 3.1 and 3.2 on the sets { (i|a)} for all datasets i (described in section 2.2 and for all classification algorithms a (section 2.3)."
    }, {
      "heading" : "2.2 Datasets",
      "text" : "We started with the 121 datasets collected from the UCI site, processed, and converted by the authors of Fernández-Delgado et al. (2014) into a unified format. The datasets is derived from the 165 available at UCI website in March 2013, where 56 were excluded by the authors of Fernández-Delgado et al. (2014). For the remaining 121, Fernández-Delgado et al. (2014) converted all categorical variables to numerical data, and each feature was standardized to zero mean and standard deviation equal to 1.\nWe downloaded the datasets preprocessed by the authors of FernándezDelgado et al. (2014) in November 2014. We performed the following transformations:\n• 65 of the datasets were multiclass problems. We converted them to a binary classification problem by ordering the classes by their names, and alternatively assigning the original class to the positive and negative classes. The datasets have different proportions between the positive and negative classes, approximately normally distributed with mean 0.6 and standard deviation of 0.17.\n• 19 of the datasets were separated into different training and test sets and on the November 2014 data, the test set was not standardized. We standardized the test set (separately from the train set) and joined both sets to create a single dataset.\n• we removed the 6 datasets with less than 100 datapoints,\n• the 9 datasets with more than 10.000 datapoints (more data points for subset) we searched the hyperparameters on a subset of 5000 datapoints. The final training was done with the whole subset, and the testing with the other full subset.\nThus, in this research we tested the algorithms in 121 - 6 (very small datasets removed) = 115 datasets.\nDetails of each dataset are described in A."
    }, {
      "heading" : "2.3 Classification algorithms",
      "text" : "We used 14 classification algorithms from very different families. As discussed in the Introduction, we argued that one of the possible criticisms to the Fernández-Delgado et al. (2014) paper is that the authors do not distinguish different algorithms from different implementations of that algorithm.\nAlthough we do not have a clear or formal definition of what are “families of algorithms” we believe that we have a sufficiently diverse collection of algorithms.\nWe chose not to use algorithms that do not require hyperparameters, such as Linear Discriminant Analysis (LDA) and logistic regression. Hyperparameters allow the algorithm to better adjust to the data details, and so we believe LDA and logistic regressions would be in disadvantages to the other algorithm. We added regularized versions of these algorithms, which contain at least one hyperparameters.\nThus, glmnet (L1 and L2 regularized logistic regression (Zou and Hastie, 2005)) and sda a L1-regularized LDA are two mainly linear algorithms. We would also add bst a boosting of linear models.\nAmong the distance based classifiers, knn is the usual k-nearest neighbor, and rknn is a bagging of knn, where each base learner is a knn on a random sample of the original features. lvq, or learning vector quantization (Kohonen, 1995) is a cluster plus distance, or dictionary based classification: a set of “prototypes,” or clusters, or “codebook” is discovered in the data, many for each class, and new data is classified based on the distance to these prototypes.\nNeural network based classifiers include nnet a common 1-hidden layer logistic network, and elm or extreme learning machines (Huang et al., 2006). Extreme learning machines are a 1-hidden layer neural network, where the weights from the input to the hidden layer are set at random, and only the second set of weights are learned (usually via least square optimization).\nWe only tested the naive Bayes nb as a Bayesian network based algorithm.\nWe divided the SVM family into the linear SVM (svmLinear), the polynomial SVM (svmPoly) and the RBF SVM (svmRadial).\nFinally we included one implementation of random forests (rf) and one implementation of gradient boosting machine classifiers (gbm) (Friedman, 2001).\nThe implementation information of the algorithms are listed below.\nbst Boosting of linear classifiers. We used the R implementation in the package bst (Wang, 2014)\nelm Extreme learning machines Implementation: package elmNN (Gosso, 2012))\ngbm Gradient boosting machines. Implementation: package gbm (Ridgeway, 2013)\nglmnet Elastic net logistic regression classifier. Implementation : package glmnet (Friedman et al., 2010))\nknn k-nearest neighbors classifier. Implementation: package class (Venables and Ripley, 2002).\nlvq Learning vector quantization. Implementation: package class (Venables and Ripley, 2002))\nnb Naive Bayes classifier: package klaR (Weihs et al., 2005)\nnnet A 1-hidden layer neural network with sigmoid transfer function. Implementation: package nnet (Venables and Ripley, 2002)\nrf Random forest. Implementation: package randomForest (Liaw and Wiener, 2002)\nrknn A bagging of knn classifiers on a random subset of the original features. Implementation: package rknn (Li, 2015)\nsda A L1 regularized linear discriminant classifier. Implementation: package sparseLDA (Clemmensen, 2012)\nsvmLinear A SVM with linear kernel. package e1071 (Meyer et al., 2014))\nsvmPoly A SVM with polynomial kernel. package e1071 (Meyer et al., 2014))\nsvmRadial A SVM with RBF kernel. package e1071 (Meyer et al., 2014))"
    }, {
      "heading" : "2.4 Hyperparameters ranges",
      "text" : "The RandomForest classifier is a particularly convenient algorithm to discuss the grid search on hyperparameters. Most implementation of rf use two or three hyperparameters: the mtry, the number of trees, and possible some limit of complexity of the trees, either the minimum size of a terminal node, or the maximum profundity, or a maximum number of terminal nodes. We did not set a range of possible values for the hyperparameters that limit the\ncomplexity of the trees. Mtry is the number of random features that will be used to construct a particular tree. There is a general suggestion (we do not know the source or other papers that tested this suggestion) that this number should be the square root of the number of features of the dataset. If nfeat is the number of features of the dataset, we set the possible values to {0.5× √ nfeat, 1× √ nfeat, 2× √ nfeat, 3× √ nfeat, 4× √ nfeat, 5× √ nfeat}. Also, the range is limited to at most nfeat−1. The number of trees is what we will call a free hyperparameter, that is, an hyper-parameter can be tested for many values but it only need one training step. One can train a random forest with n trees, but at testing time, some implementations can return the classification of each tree on the test data. Thus one can test the accuracy of a random forest with m < n trees, just by computing the more frequent classification of the first m trees (or any random sample of m trees). Thus, to select this hyperparameter, it is not necessary to create a grid with multiple training or testing. So, for the random forest, ntree is a free hyperparameter, that will be tested from 500 to 3000 by 500. But we also put another limit on the number of trees, half of the number data points in the subset.\nThe number of repetitions or boosts in a boosting procedure is also a free parameter. The last class of free hyperparameter refer to an implementation of classification algorithms that calculate all the possible values of a parameter that causes changes in the learned function. The only relevant algorithm for this research is the elastic-net regularized logistic regression implemented by the package glmnet (Friedman et al., 2010)), which computes all the values (or the path as it is called) of the regularization parameter λ. Hastie et al. (2004) discuss a complete path algorithm for SVM (for the C hyperparameter) but we did not use this implementation in this paper.\nWe list the range of hyperparameters for each of the algorithms tested, where nfeat is the number of features in the data and ndat is the number of data points.\nbst Hyperparameters: shrinkage = {0.05, 0.1}. Free hyperparameter, number of boosts, from 100 to 3000 by 200, at most ndat.\nelm Hyperparameter: number of hidden units = at most 24 values equally spaced between 20 and ndat/2\ngbm Hyperparameters: interaction-depth = 1..5, shrinkage={0.05, 0.1}. number of boosts is a free hyperparameter, tested from 50 to 500 with increments of 20 to at most ndat.\nglmnet Hyperparameters α, 8 values equally spaced between 0 and 1. Free hyperparameter λ, 20 values geometrically spaced between 10−5 to 103.\nknn Hyperparameter k:= 1, and at most 23 random values from 3 to ndat/4.\nlvq Hyperparameter: size of the codebook = at most 8 values equally spaced between 2 and 2× nfeat\nnb Hyperparameters: usekernel = { true, false }, fL = {0, 0.1, 1, 2}\nnnet Hyperparameter: number of hidden units = at most 8 values equally spaced between 3 and nfeat/2, decay = {0, 0.01, 0.1}. rf Hyperparameter mtry = {0.5, 1, 2, 3, 4, 5} √ nfeat up to a value of nfeat/2.\nNumber of trees is a free hyperparameters, tested from 500 to 3000 by 500 up to ndat/2.\nrknn Hyperparameters: mtry = 4 values equally spaced between 2 and nfeat−2, k= 1, and at most 23 random values from 3 to ndat/4. The number of classifiers is a free hyperparameter from 5 to 100, in steps of 20.\nsda Hyperparameter: λ = 8 values geometrically spaced from 10−8 to 103\nsvmLinear . Hyperparameter: C = 2−5, 20, 25, 210, 215.\nsvmPoly Hyperparameter C as in the linear kernel and degree from 2 to 5.\nsvmRadial Hyperparameters C as in the linear SVM and γ = 2−15, 2−10.5, 2−6, 2−1.5, 23."
    }, {
      "heading" : "2.5 Reproducibility",
      "text" : "The data described above, the R programs that tested the 14 algorithms, the results of running there algorithms, the R programs used to analyse these results and generate the tables and figures in this paper, and the saved interactions of the MCMC algorithm are available at https://figshare. com/s/d0b30e4ee58b3c9323fb."
    }, {
      "heading" : "3 Statistical procedures",
      "text" : ""
    }, {
      "heading" : "3.1 Demsar procedure",
      "text" : "We will follow the procedure proposed by Demsar (2006). The procedure suggests one should first apply a Friedman test (which can be seen as a\nnon-parametric version of the repeated measure ANOVA test) to determine if there is sufficient evidence that the error rate measures for each procedure are not samples from the same distribution. If the p-value is below 0.05 (for a 95% confidence) than one can claim that it is unlikely that the error rates are all “the same” and one can proceed to compare each algorithm to the others. When comparing all algorithms among themselves, which is the case here, Demsar proposed the Nemenyi test, which will compute the p-value of all pairwise comparisons. Again, a p-value below 0.05 indicates that that comparison is statistically significant, that is, it is unlikely that two sets fo error rates are samples from the same distribution."
    }, {
      "heading" : "3.2 Bayesian comparison of multiple groups",
      "text" : "A standard null hypothesis significant test assumes the null hypothesis, usually that the two samples came form the same population and computes the probability (p-value) of two samples from the same population having as large a difference in mean (or median) as the one encountered in the data. If the p-value is not low, one cannot claim that the null hypothesis is true and that the two data sets came from the same population ( and thus all observed differences are due to “luck”). Failing to disprove the null hypothesis because the p-value is too high is not the same as proving the null hypothesis.\nEquivalence tests are a form of “proving” a weaker version of the usual null hypothesis. Equivalence tests assume as the null hypothesis that the difference between the mean (or median) of the two sets is above a certain threshold, and if the p-value is low enough, one can claim that this null hypothesis is false, and thus that the difference between the means is smaller than the threshold. Equivalence tests are useful when that threshold is a limit of practical irrelevance, that is, a limit below which changes in the mean of two groups are of no practical consequence. Of course, this limit of irrelevance is very problem dependent. Section 3.3 will discuss our proposal for such a limit.\nA different approach to prove that the differences are not important is to use Bayesian methods. Bayesian methods will compute the (posterior) distribution of probability for some set of measures, given the prior hypothesis on those measures. Thus a Bayesian method can compute the posterior distribution of the difference of two means. The area of the distribution of the difference that falls within the limits of irrelevance is the probability that the difference is of no practical importance. In Bayesian statistics, the limit of irrelevance is called Region of Practical Equivalence (ROPE).\nThe standard Bayesian ANOVA, as described in Kruschke (2014) is based on normal distributions. We are interested in a 2-factor ANOVA, where one of the factors is the classification algorithm , and the other factor is the dataset. We assume that there is no interaction component, that is, we are not interested in determining particularities of each algorithm on each dataset - we are making a claim that the datasets used in this research are a sample of real world problems, and we would like to make general statements about the algorithms.\nLet us denote yad as the error rate for the algorithm a on dataset d, then the usual hierarchical model is (Kruschke, 2014):\nyad ∼N(νad, σ0) (2a) νad =β + αa + δd (2b)\nσ0 ∼U(ySD/100, ySD ∗ 10) (2c) β ∼N(yMean, ySD ∗ 5) (2d) αa ∼N(0, σa) (2e) δd ∼N(0, σd) (2f) σa ∼Gamma(ySD/2, ySD ∗ 2) (2g) σd ∼Gamma(ySD/2, ySD ∗ 2) (2h)\nwhere U(L,H) is the uniform distribution with L and H as the low and high limits; N(µ, σ) is the normal distribution with mean µ and standard deviation σ; and Gamma(m,σ) is the Gamma distribution with mode m and standard deviation σ - note that this is not the usual parametrization of the Gamma distribution. ySD is the standard deviation of the yad data, and yMean, the mean of that data.\nWe are interested in the joint posterior probability P (α1, α2, . . . , αA|{yad}). From that one can compute the relevant pairwise differences P (αi−αj |{yad}) and in particular, how much of the probability mass fall within the region of irrelevant differences. More specifically, if ~α = 〈α1, α2, . . . , αA〉, then the simulation approach we will follow generates a set {~αj |~αj ∼ P (~α|{yad})} for j = 1 . . . N where N is the number of chains in the MCMC simulation. We compute characteristics of distribution of P (αi − αj |{yad}) from the ~αj .\nFinally, one commonly used robust variation of the model above is to substitute the normal distribution in Equation 2a for a student-t distribution, with low degree of freedom, that is:\nyad ∼t(νad, σ0, df) df ∼Exp(1/30)\nwhere Exp(λ) is the exponential distribution with rate λ. We also run the robust version of the model, as discussed in E."
    }, {
      "heading" : "3.3 Threshold of irrelevance",
      "text" : "We propose two different forms of defining the threshold of irrelevance for differences in error rates. We will compute the two thresholds and use the lowest of the two measures as the threshold of irrelevance.\nThe first proposal is to compare the two measures of error for each dataset and for each classification algorithm. In Equation 1 they were the two terms (i, 1|a, θ̂1, i, 1) and (i, 2|a, θ̂2, i, 2), that is, the error of classifier a when learning on training subset S2i and tested on the subset S1i, and the dual of that. The difference\nδai = | (i, 2|a, θ̂1, i, 1)− (i, 1|a, θ̂2, i, 2)| (3)\ncan be seen as the change on the error rate that one would expect from applying the classifier a on two different samples (S1i and S2i) from the same population (Di). We will then compute the median of δai for all datasets i and for all classification algorithms a that are among the three best (as calculated by (i|a)) for each dataset. That is, we are considering as a threshold of irrelevance, the median of the change one should expect from using a good classifier (among the top three for that dataset) on two different samples of the same dataset.\nThe second proposal compares the estimate of the error (i, 2|a, θ̂, i, 1) computed from the 5-fold CV procedure on the subset S1i which selects the best hyperparameters with the measure of the error itself. We have not made explicit the steps in the 5-fold CV, but intuitively, for each combination of hyperparameters values θ, it computes the average of the error of training in 4 folds and testing on the remaining one. Let us call it cv(i, 1|a, θ, i, 1) - that is the CV error computed within the S1i subset itself. We select the combination of hyperparameters that have the lowest cv(i, 1|a, θ, i, 1) . But this CV error is an estimate of the future error of the classifier (trained with that combination of hyperparameters). On the other hand (i, 2|a, θ̂, i, 1) is a “future” error of the classifier - the training set is slightly different from the 5-fold CV since it includes the whole subset S1i while for each fold it included only 4/5 of S1i, and the testing set S2i is totally new. The difference\nδcvai = | (i, 2|a, θ̂, i, 1)− cv(i, 1|a, θ, i, 1)| (4)\ncan be seen as the change in error one would expect from applying the classifier a on a slightly larger training set and testing it on completely\nnew data. We will compute the median of δcvai for all datasets i and for all classification algorithms a that are among the three best (as calculated by (i|a)) for each dataset.\nIn both these proposals, we are defining the threshold of irrelevance based on a “futility” point of view, and not based on theoretical considerations. One knows that given a different sample from the same distribution or given new data to test, all algorithms will have different error rates."
    }, {
      "heading" : "3.4 Computational costs",
      "text" : "We compute to measures of computational costs to run the algorithms. The first one is the 1-train-test, which measures the total time to train the algorithm a on a subset Sji and to test it in the subset Ŝi. Thus, that is the time to train the algorithm and to run it on two equally sized data.\nBut all algorithms must search for the appropriate hyperparameters. Thus also compute the total time to search for the correct hyperparameter (using, as discusses above a 5-fold CV). But different algorithms may have a different gird size of tentative hyperparameters (since as discussed for some algorithms some of range of hyperparameter may depend on characteristics of the dataset). Thus we divide the total time to search for the best hyperparameter by the number of hyperparameter combinations tested. We call it the per hyperparameter time.\nSince the execution time varies greatly on different datasets, we will use the mean rank of each execution time to rank the algorithms, and use the Demsar procedure to determine which execution times are significantly different than the others (from a statistical sense). We have no intuition on what could be considered an irrelevant change in either execution times, so we will not perform the Bayesian ANOVA analysis.\nThe program ran on different cores of a cluster of different machines, so there is no guarantee that the machines have the same hardware specification. But we ran all the 14 algorithms for a particular subset on the same program. Thus the unit of distribution is all the 14 algorithms searching for the best combination of hyperparameters on a 5-fold CV of half of a dataset, then training on the full half dataset with the best selection of the hyperparameters and finally testing the classifier on the other half of the dataset.\nTherefore, for the timing analysis we do not average the two measures from the subsets to obtain the measure per dataset. Instead we perform the Demsar statistical analysis using the subsets as subject indicator."
    }, {
      "heading" : "4 Results",
      "text" : ""
    }, {
      "heading" : "4.1 Error rates of the different algorithms",
      "text" : "Table 1 list the mean ranking of all algorithms, the number of times each algorithm was among the top for a dataset. The best performing algorithm, in terms of mean rank across all subsets was the random forest, followed by SVM with Gaussian kernels, followed by gradient boosting machines. The three worst performing algorithms in terms of mean rank were boosting of linear classifiers naive Bayes and L1-regularized LDA. We make no claim that these three algorithms are intrinsically “bad”. It is possible that our choice of hyperparameters was outside the range of more useful values, or the implementation used was particularly not robust. In particular both nb and sda did not run at all for 20 subsets, which may explain partially their poor performance.\nThe ranking of the algorithm is dense, that is, all best performing algorithm receive rank 1, all second best algorithms receive rank 2, and so on. Also for the ranking, we rounded the error rates to 3 significant digits, so two algorithms have the same rank if their error rates have a difference of less than 0.0005. We do not use the rounding for the calculations of the irrelevance threshold.\nFigure 1 displays the heat map of the rank distribution."
    }, {
      "heading" : "4.2 Demsar procedure",
      "text" : "Table 2 lists the p-value of the pairwise comparisons for all classifiers. The p-values below 0.05 indicate that the differences between the corresponding classifiers is statistically significant.\nThe Demsar analysis shows that there is no statistical significance differ-\nence between the top 3 classification algorithms – the p-values of the pairwise comparisons among rf, svmRadial, and gbm are all well above 0.05. nnet, the next algorithm in the rank, is statistically significantly different from each of the first three. As discussed, the failure to prove that the three top algorithms are not statistically different, does not prove that they are equivalent. We will need the Bayesian ANOVA for that."
    }, {
      "heading" : "4.3 Irrelevance thresholds",
      "text" : "The median δia and δ cv ia for all datasets, and for the three best algorithms for each dataset are:\nmedian(δia) =0.0112 median(δcvia ) =0.0134\nThus, the two measures are comparable, a little over 1%, and we will use the lower among the two as out threshold of irrelevance (0.0112). The fact that the median of δia is smaller than the other is somewhat surprising, since δia measures the error of learning (and testing) with two different samples of the data population, while δcvia is the difference of learning on basically the same subset, but testing in two different samples of different sizes from the same data population."
    }, {
      "heading" : "4.4 Bayesian ANOVA analysis",
      "text" : "Table 3 displays the pairwise probability that the differences of the classifiers’ error rates is within our limits of irrelevance (from -0.0112 o 0.0112).\nThe comparison between the top three algorithms shows that the differences are with high probability (0.83 to 0.64) within our range of irrelevance,\nthat is, there is no “practical difference” in the error rates of the three algorithms. In particular there is a stronger argument to be made that the best algorithm, rf is equivalent for practical purposed to the svmRadial. The claim of equivalence between gbm and the other two is less strong, in particular, to our surprise, in relation to the second best svmRadial."
    }, {
      "heading" : "4.5 Computational costs of the algorithms",
      "text" : "Table 4 shows the mean rank for the 1-train-test and per hyperparameter\ntimes. The top 6 algorithms in term of accuracy are indeed computationally costly in terms of training and testing, and they correspond to the 7 worse 1-train-test times. The result for the nb is surprising. Also surprising, to the author at least, is how more costly is rf in comparison to the two other “equivalent” classifiers, svmRadial and gbm. Table 5 is the Demsar procedure p-values for the pairwise comparisons of the 1-train-test cost of the top 6 algorithms (B contains the full p-value table). Notice that the difference between svmRadial and gbm is not significant; the difference between rf and svmRadial and gbm are significant.\nTable 6 lists the p-values of the pairwise comparisons of the top 6 algorithms. B contains the full p-value table. svmRadial is significantly faster than all other algorithm in the per hyperparameter measure.\nThe per hyperparameter cost is surprising low for the svmRadial, which is a welcome result since the hyperparameter grid for the svmRadial does not depend on characteristics of the dataset, and therefore one will need to test many combinations, regardless of the dataset.\nOn the other hand the large per hyperparameter cost of rf could be a problem if one cannot use the free hyperparameter “trick” we described.\nNot all implementations of rf allow access to each tree decision1, and if one has to explicitly train for different number of trees, the total number of hyperparameters tested times the high per hyperparameter cost may make the random forest solution less viable."
    }, {
      "heading" : "5 Discussion",
      "text" : "An important part of these results is the definition of an irrelevance threshold, a difference in error rates between to algorithms which is likely to be irrelevant from practical purposes. We claim that 0.0112 is median change of error rate one should expect when a classifier is trained and tested on a fully different set of data from the same population. This is a very strong claim, for which we have no theoretical backing, but which is empirically derived from the 115 datasets used in this research. And if one agrees that these datasets are a random sample of real life datasets that a practitioner will “find in the wild” (more on this issue below), that one must accept that this conclusion is likely generalizable for all data.\nIn general terms, one should not loose too much sleep trying to improve a classifier by less than 1% since it is likely that one will loose (or gain) that much when new data is used.\nWe can provide some independent evidence that the change in error rate with new data is around 1%. Kaggle competitions are evaluated against two hold out test sets, the public and the private. Usually the public dataset is around 25 to 30% of the private dataset (so the private dataset is not totally new data, but 70 to 75% new data. Thus the difference of private and public accuracy scores are an independent lower bound estimate of the change in accuracy for new data. Unfortunately very few of the Kaggle competitions are measured using accuracy, but one of them the “cats and dogs2” did. The median of the difference between the public and private test scores, for the top 50 entries on the public score is 0.0068, which is 60% of our threshold of irrelevance.\nIf one is reluctant to accept our 1% as a limit of irrelevance when comparing classifiers, Table 8 shows the probability that the difference between the accuracy rate is below 0.0056, that is half of our irrelevance threshold, for the six best algorithms. Even with this extremely rigorous limit of irrelevance, there is a some probability that rf, svmRadial, and gbm would\n1The predict method of random forest in sklearn, for example, does not allow access to each three individual decision.\n2https://www.kaggle.com/c/dogs-vs-cats\nperform at similar levels. In particular, there is still a 50% probability that rf and svmRadial will be equivalent for practical purposes. .\nAnother important point of discussion is the Bayesian analysis itself. We followed a more traditional modeling of the Bayesian ANOVA, where the priors for the means follow a Gaussian distribution (Equations 2e and 2f). But error rates does not follow a Gaussian distribution, first because they are limited to a 0-1 range. Second, the whole point of the Demsar procedure to compare classifiers on different datasets is to use a non-parametric test, one that does not rely on the assumption of normality of the data. We are not making an assumption that error rates are normally distributed, but we are making an assumption that the priors for the coefficients of the dependency on the dataset (given an algorithm) and on the algorithm (given a dataset) are drawn from a Gaussian distribution. C discusses that those assumptions are somewhat reasonable, but in the future, the community should probably define a better model for the Bayesian analysis of error rates. D shows that there was convergence for the Monte Carlo simulations that generated the results in Table 3. Finally, we also ran the robust form of the model. Table 8 shows the probability that the differences between the top six algorithms are within the limit of practical relevance. Notice that one can be 100% sure of the equivalence of the top three algorithms using the robust model. Also notice that even nnet which was significantly different from the top three, is with high probability equivalent to at least svmRadial and gbm. There is no contradiction in both statements: the NHST claims that the difference is “real” while the Bayesian ANOVA claims that that difference (although real) it is not important. But nevertheless, the robust model seems to make much stronger claims of equivalence than the non-robust model, and as a precaution, we preferred the latter model. The stronger results of the robust model can be explained by shrinkage (Kruschke, 2014); since it allows more outliers, the mean of each distribution of the algorithms’ coefficient would\nbe “free” to move closer together, and thus the higher probabilities that the differences are below the threshold of irrelevance.\nE displays the full table for the pairwise probabilities that the differences between the algorithms are within the limit of irrelevance, and also discusses the convergency and model checking of the robust model.\nOur results are in general compatible with those in Fernández-Delgado et al. (2014). Random forest is the best ranking algorithm in both experiments; gradient boosting machines which was not included in FernándezDelgado et al. (2014) performs well, as reported in various blogs, RBF SVM also performs well. The divergence starts with the next best classifications algorithms: Fernández-Delgado et al. (2014) lists polynomial kernel SVM svmPoly and extreme learning machines elm as the next best families, but in our case svmPoly was equivalent to 1-hidden layer neural nets nnet, and a bagging of knn rknn. The differences between these algorithms was also below our practical limit of relevance. elm did perform worse than nnet and rknn."
    }, {
      "heading" : "5.1 Limits on this research",
      "text" : "One limit of this research is that its conclusions should only be generalized to datasets “similar” to the ones used. In particular, our datasets did not include very large, or very sparse, or datasets with much more features than datapoints (as it is common in some bioinformatics applications). Furthermore, our experiments were performed on binary classification tasks. Given these restrictions on the data, if one can assume that the datasets in UCI repository are samples of “real life” problems, our results should be generalizable.\nA second limit of this research is based on our decisions regarding the hyperparameter search for each algorithm. There is very little research on the range of possible or useful values of hyperparameters for any of the\nalgorithms discussed, so our decisions are debatable. And if our choices were particularly bad, an algorithm may have been unfairly ranked in the comparisons.\nThe reader should be aware of the limited usefulness for the timing results. We used “standard” implementations of the algorithms in R. All three implementations were written in some compiled language and linked to R, but it may be that only libSvm, which is the base of the SVM R implementation, has been under current development, and the execution time of the SVM may be due to that. There has been more recent implementations of random forest (Wright and Ziegler, 2015) and gradient boosting machines (Distributed (Deep) Machine Learning Community, 2016) which claim both a faster execution time and shorter memory footprint. On the other hand, incremental and online solvers for SVM (Bordes et al., 2005; Shalev-Shwartz et al., 2011) may further tip the scale in favor of SVM."
    }, {
      "heading" : "5.2 Future research",
      "text" : "Given the result that rf, svmRadial, and gbm are likely the best performing algorithms, it is interesting to explore further variations and different implementations of these algorithms. We discussed that more modern implementations the algorithms may alter the timing results. But variations of the algorithms may also alter the ranking and the apparent equivalence of the three algorithms. Variations of Random Forest, such as Rotation Forest (Rodriguez et al., 2006), Extremely Randomized Forest (Geurts et al., 2006), random forest of conditional inference trees (Hothorn et al., 2006; Strobl et al., 2007), should be compared with the standard algorithm. Least square SVM (Suykens and Vandewalle, 1999) should be compared with the standard SVM, and different models of boosting such as AdaBoost, LogiBoost, BrownBoost, should be compared with gbm.\nThere has been a large number of published research on different methods and algorithms for hyperparameter selection in RBF SVM, but almost no research in hyperparameter selection for Random Forests and Gradient Boosting Machines. Hyperparameter selection is a very important and computationally expensive step in selecting an algorithm for a particular problem, and further understanding of how to improve this process is needed, specially for those two algorithms."
    }, {
      "heading" : "6 Conclusion",
      "text" : "We have shown that random forests, RBF SVM, and gradient boosting machines are classification algorithm that most likely will result in the highest accuracy and that it is likely that there will be no important difference in error rate among these three algorithms, specially between random forest and RBF SVM. In terms of training and testing execution times, SVM with a RBF kernel is faster then the two other competitors.\nWe believe that this paper also makes important methodological contributions for machine learning research, mainly in the definition of a threshold of irrelevance, below which, changes in error rate should be considered as of no practical significance. We argued that this threshold should be 0.0112. Another important methodological contribution is the use of a Bayesian Analysis of Variance method to verify that the differences among the three top performing algorithms, was very likely smaller than the 0.0112 threshold of practical irrelevance, and we showed that the Bayesian model used is appropriate to be used in comparisons of error rates among different algorithms."
    }, {
      "heading" : "A Datasets",
      "text" : "The table below list the characteristics of all datasets, ordered by size. The name of the dataset is the same as the ones used in Fernández-Delgado et al. (2014). The size refers to one half of the dataset. The nfeat column is the number of features of the datasets; ndat the number of data; prop the proportion of data of the positive class. Notes has the following values:\n• m the dataset was multivalued, and so was converted to a binary problem using the procedure discussed in section 2\n• l large dataset. Only 5000 of the data was used to search fror the hyperparameters (see section 2).\nTable 9: The datasets\ndataset nfeat ndat prop note fertility 10 50 0.96 zoo 17 50 0.62 m pittsburg-bridges-REL-L 8 51 0.82 m pittsburg-bridges-T-OR-D 8 51 0.86 pittsburg-bridges-TYPE 8 52 0.62 m continued in the next page\nTable 9: The datasets\ndataset nfeat ndat prop note breast-tissue 10 53 0.53 m molec-biol-promoter 58 53 0.49 pittsburg-bridges-MATERIAL 8 53 0.94 m acute-inflammation 7 60 0.52 acute-nephritis 7 60 0.67 heart-switzerland 13 61 0.38 m echocardiogram 11 65 0.74 lymphography 19 74 0.46 m iris 5 75 0.72 m teaching 6 75 0.64 m hepatitis 20 77 0.22 hayes-roth 4 80 0.57 m wine 14 89 0.60 m planning 13 91 0.74 flags 29 97 0.47 m parkinsons 23 97 0.25 audiology-std 60 98 0.64 m breast-cancer-wisc-prog 34 99 0.77 heart-va 13 100 0.52 m conn-bench-sonar-mines-rocks 61 104 0.54 seeds 8 105 0.64 m glass 10 107 0.40 m spect 23 132 0.67 m spectf 45 133 0.19 statlog-heart 14 135 0.53 breast-cancer 10 143 0.69 heart-hungarian 13 147 0.63 heart-cleveland 14 151 0.75 m haberman-survival 4 153 0.75 vertebral-column-2clases 7 155 0.68 vertebral-column-3clases 7 155 0.67 m primary-tumor 18 165 0.68 m ecoli 8 168 0.64 m ionosphere 34 175 0.30 libras 91 180 0.51 m dermatology 35 183 0.64 m continued in the next page\nTable 9: The datasets\ndataset nfeat ndat prop note horse-colic 26 184 0.64 congressional-voting 17 217 0.59 arrhythmia 263 226 0.67 m musk-1 167 238 0.58 cylinder-bands 36 256 0.38 low-res-spect 101 265 0.25 m monks-3 7 277 0.48 monks-1 7 278 0.51 breast-cancer-wisc-diag 31 284 0.63 ilpd-indian-liver 10 291 0.72 monks-2 7 300 0.64 synthetic-control 61 300 0.51 m balance-scale 5 312 0.53 m soybean 36 341 0.42 m credit-approval 16 345 0.43 statlog-australian-credit 15 345 0.32 breast-cancer-wisc 10 349 0.66 blood 5 374 0.76 energy-y1 9 384 0.80 m energy-y2 9 384 0.75 m pima 9 384 0.66 statlog-vehicle 19 423 0.52 m annealing 32 449 0.81 m oocytes trisopterus nucleus 2f 26 456 0.41 oocytes trisopterus states 5b 33 456 0.98 m tic-tac-toe 10 479 0.34 mammographic 6 480 0.56 conn-bench-vowel-deterding 12 495 0.53 m led-display 8 500 0.51 m statlog-german-credit 25 500 0.72 oocytes merluccius nucleus 4d 42 511 0.31 oocytes merluccius states 2f 26 511 0.93 m hill-valley 101 606 0.49 contrac 10 736 0.79 m yeast 9 742 0.55 m semeion 257 796 0.50 m continued in the next page\nTable 9: The datasets\ndataset nfeat ndat prop note plant-texture 65 799 0.50 m wine-quality-red 12 799 0.56 m plant-margin 65 800 0.52 m plant-shape 65 800 0.52 m car 7 864 0.28 m steel-plates 28 970 0.66 m cardiotocography-10clases 22 1063 0.39 m cardiotocography-3clases 22 1063 0.86 m titanic 4 1100 0.66 image-segmentation 19 1155 0.58 m statlog-image 19 1155 0.55 m ozone 73 1268 0.97 molec-biol-splice 61 1595 0.75 m chess-krvkp 37 1598 0.48 abalone 9 2088 0.68 m bank 17 2260 0.88 spambase 58 2300 0.61 wine-quality-white 12 2449 0.48 m waveform-noise 41 2500 0.66 m waveform 22 2500 0.68 m wall-following 25 2728 0.78 m page-blocks 11 2736 0.92 m optical 63 2810 0.51 m statlog-landsat 37 3217 0.56 musk-2 167 3299 0.85 m thyroid 22 3600 0.94 m ringnorm 21 3700 0.49 twonorm 21 3700 0.49 mushroom 22 4062 0.51 pendigits 17 5496 0.51 ml nursery 9 6480 0.68 ml magic 11 9510 0.65 l letter 17 10000 0.50 ml chess-krvk 7 14028 0.53 ml adult 15 24421 0.76 l statlog-shuttle 10 29000 0.84 ml continued in the next page"
    }, {
      "heading" : "B Full p-value tables for the pairwise compari-",
      "text" : ""
    }, {
      "heading" : "C Bayesian model verification",
      "text" : "Figure 2 plots the histogram of the error rates across the 115 datasets for the different algoritms, superimposed with the best fit Gaussian. One can\nargue that the distribution of error rates can reasonably be considered as normal, which would match the assumptions of the equation 2e. Similarly, Figure 3 is the distribution of error rates for 20 random datasets, and again one argue that the assumption in equation 2f is reasonable.\nA more formal model verification is the procedure of posterior predictive check proposed by Gelman et al. (1996). The procedure calculates how unlikely is the true data when compared to data generated by the model, given the posterior distribution of the hyperparameters of the model. The data (true and generated) are summarized by the χ2 discrepancy (Gelman et al., 1996).\nFigure 4 shows the relation between the discrepancies of the true data and that of the generated data, for 1667 of the points generated by the MCMC algorithm, following the posterior of the parameters of the model. The probability of that the real data (or data with even more extreme discrepancies) were generated by the model is the proportion of the points above the x = y line. As one can see, that probability is around 0.5, and\nthe real data is clearly among the most likely of the data generated by the model. Thus, under this criterion, the model is appropriate. But we must also point out that 3% of the data generated was negative, which is at least esthetically unpleasant."
    }, {
      "heading" : "D Convergence of the MCMC",
      "text" : "There was no attempts to optimize the number of simulations of the MCMC algorithm. We used JAGS, with 5000 burnin steps and 5000 adaptative steps. Finally we ran 100000 total interactions on 4 separated chains.\nBelow is the Gelman and Rubin diagnostic (Brooks and Gelman, 1998) which compares the variance within and between chains, as reported by the function gelman.diag from the R package coda, where the variables saved are the ones in Equation 2b: b0 is α and b1[a] are the βa for each algorithm, b2[d] are the δd for each dataset and ySigma is σ0 from Equation 2a, a1SD and a2SD are σa and σd from 2g and 2h. Not all lines that refer to the b2[d]\nvariables are shown, but they all have the same values.\nPotential scale reduction factors:\nPoint est. Upper C.I.\nb0 1 1 b1[1] 1 1 b1[2] 1 1 b1[3] 1 1 b1[4] 1 1 b1[5] 1 1 b1[6] 1 1 b1[7] 1 1 b1[8] 1 1 b1[9] 1 1 b1[10] 1 1\nb1[11] 1 1 b1[12] 1 1 b1[13] 1 1 b1[14] 1 1 b2[1] 1 1 b2[2] 1 1 b2[3] 1 1 ... b2[113] 1 1 b2[114] 1 1 b2[115] 1 1 ySigma 1 1 a1SD 1 1 a2SD 1 1\nMultivariate psrf\n1\nValues between 1 and 1.1 suggest convergence of the interactions. The effective sizes of the interactions shows that there is no problem of high autocorrelation. Again not all values for the b2[d] variables are shown.\nb0 b1[1] b1[2] b1[3] b1[4] b1[5] b1[6] b1[7]\n100000.00 101017.13 98356.57 99052.19 99172.48 99820.25 99350.88 100262.05\nb1[8] b1[9] b1[10] b1[11] b1[12] b1[13] b1[14] b2[1]"
    }, {
      "heading" : "100541.69 98992.43 98427.81 100000.00 97006.48 97467.65 94816.02 100000.00",
      "text" : "b2[2] b2[3] b2[4] b2[5] b2[6] b2[7] b2[8] b2[9] 99043.72 97966.91 99380.08 100000.00 99530.18 101053.74 100087.01 100000.00 ...\nb2[114] b2[115] ySigma a1SD a2SD"
    }, {
      "heading" : "100204.87 100216.75 55353.48 16108.44 51977.11",
      "text" : ""
    }, {
      "heading" : "E Results with the robust Bayesian model",
      "text" : "This section displays the results of the Bayesian analysis based on the robust model. Table 12 is the full probability table from the Bayesian ANOVA.\nWe cannot perform the verification of the model using posterior predictive check because the χ2 discrepancy needs the variance of the data. Under the robust model, the variance of the data depends also on the degrees of\nfreedom of the student-t distribution, and in the case of the robust simulations is 1.12, and the variance of the student-t distribution is not defined for degrees of freedom below 2."
    } ],
    "references" : [ {
      "title" : "Fast kernel classifiers with online and active learning",
      "author" : [ "A. Bordes", "S. Ertekin", "J. Weston", "L. Bottou" ],
      "venue" : "The Journal of Machine Learning Research",
      "citeRegEx" : "Bordes et al\\.,? \\Q2005\\E",
      "shortCiteRegEx" : "Bordes et al\\.",
      "year" : 2005
    }, {
      "title" : "General methods for monitoring convergence of iterative simulations",
      "author" : [ "S. Brooks", "A. Gelman" ],
      "venue" : "Journal of Computational and Graphical Statistics",
      "citeRegEx" : "Brooks and Gelman,? \\Q1998\\E",
      "shortCiteRegEx" : "Brooks and Gelman",
      "year" : 1998
    }, {
      "title" : "sparseLDA: Sparse Discriminant Analysis. R package version 0.1-6",
      "author" : [ "L. Clemmensen" ],
      "venue" : "URL http://CRAN.R-project.org/package=sparseLDA",
      "citeRegEx" : "Clemmensen,? \\Q2012\\E",
      "shortCiteRegEx" : "Clemmensen",
      "year" : 2012
    }, {
      "title" : "Statistical comparisons of classifiers over multiple data sets",
      "author" : [ "J. Demsar" ],
      "venue" : "The Journal of Machine Learning Research",
      "citeRegEx" : "Demsar,? \\Q2006\\E",
      "shortCiteRegEx" : "Demsar",
      "year" : 2006
    }, {
      "title" : "Solving multiclass learning problems via error-correcting output codes",
      "author" : [ "T. Dietterich", "G. Bakiri" ],
      "venue" : "Journal of Artificial Intelligence Research,",
      "citeRegEx" : "Dietterich and Bakiri,? \\Q1995\\E",
      "shortCiteRegEx" : "Dietterich and Bakiri",
      "year" : 1995
    }, {
      "title" : "Polytomous logistic regression",
      "author" : [ "J. Engel" ],
      "venue" : "Statistica Neerlandica",
      "citeRegEx" : "Engel,? \\Q1988\\E",
      "shortCiteRegEx" : "Engel",
      "year" : 1988
    }, {
      "title" : "Do we need hundreds of classifiers to solve real world classification problems",
      "author" : [ "M. Fernández-Delgado", "E. Cernadas", "S. Barro", "D. Amorim" ],
      "venue" : "Journal of Machine Learning Research",
      "citeRegEx" : "Fernández.Delgado et al\\.,? \\Q2014\\E",
      "shortCiteRegEx" : "Fernández.Delgado et al\\.",
      "year" : 2014
    }, {
      "title" : "Multi-class support vector machine",
      "author" : [ "V Franc" ],
      "venue" : "International Conference on Pattern Recognition",
      "citeRegEx" : "Franc,? \\Q2002\\E",
      "shortCiteRegEx" : "Franc",
      "year" : 2002
    }, {
      "title" : "Regularization paths for generalized linear models via coordinate descent",
      "author" : [ "J. Friedman", "T. Hastie", "R. Tibshirani" ],
      "venue" : "Journal of statistical software",
      "citeRegEx" : "Friedman et al\\.,? \\Q2010\\E",
      "shortCiteRegEx" : "Friedman et al\\.",
      "year" : 2010
    }, {
      "title" : "Greedy function approximation: a gradient boosting machine",
      "author" : [ "J.H. Friedman" ],
      "venue" : "Annals of Statistics,",
      "citeRegEx" : "Friedman,? \\Q2001\\E",
      "shortCiteRegEx" : "Friedman",
      "year" : 2001
    }, {
      "title" : "Posterior predictive assessment of model fitness via realized discrepancies",
      "author" : [ "A. Gelman", "Meng", "X.-L", "H. Stern" ],
      "venue" : "Statistica Sinica,",
      "citeRegEx" : "Gelman et al\\.,? \\Q1996\\E",
      "shortCiteRegEx" : "Gelman et al\\.",
      "year" : 1996
    }, {
      "title" : "Extremely randomized trees",
      "author" : [ "P. Geurts", "D. Ernst", "L. Wehenkel" ],
      "venue" : "Machine Learning",
      "citeRegEx" : "Geurts et al\\.,? \\Q2006\\E",
      "shortCiteRegEx" : "Geurts et al\\.",
      "year" : 2006
    }, {
      "title" : "elmNN: Implementation of ELM (Extreme Learning Machine) algorithm for SLFN (Single Hidden Layer Feedforward Neural Networks). R package version 1.0",
      "author" : [ "A. Gosso" ],
      "venue" : null,
      "citeRegEx" : "Gosso,? \\Q2012\\E",
      "shortCiteRegEx" : "Gosso",
      "year" : 2012
    }, {
      "title" : "The entire regularization path for the support vector machine",
      "author" : [ "T. Hastie", "S. Rosset", "R. Tibshirani", "J. Zhu" ],
      "venue" : "The Journal of Machine Learning Research",
      "citeRegEx" : "Hastie et al\\.,? \\Q2004\\E",
      "shortCiteRegEx" : "Hastie et al\\.",
      "year" : 2004
    }, {
      "title" : "Classification by pairwise coupling",
      "author" : [ "T. Hastie", "R Tibshirani" ],
      "venue" : "The Annals of Statistics",
      "citeRegEx" : "Hastie and Tibshirani,? \\Q1998\\E",
      "shortCiteRegEx" : "Hastie and Tibshirani",
      "year" : 1998
    }, {
      "title" : "Unbiased recursive partitioning: A conditional inference framework",
      "author" : [ "T. Hothorn", "K. Hornik", "A. Zeileis" ],
      "venue" : "Journal of Computational and Graphical Statistics",
      "citeRegEx" : "Hothorn et al\\.,? \\Q2006\\E",
      "shortCiteRegEx" : "Hothorn et al\\.",
      "year" : 2006
    }, {
      "title" : "Extreme learning machine: theory and applications",
      "author" : [ "Huang", "G.-B", "Zhu", "Q.-Y", "Siew", "C.-K" ],
      "venue" : "Neurocomputing",
      "citeRegEx" : "Huang et al\\.,? \\Q2006\\E",
      "shortCiteRegEx" : "Huang et al\\.",
      "year" : 2006
    }, {
      "title" : "Learning Vector Quantization",
      "author" : [ "T. Kohonen" ],
      "venue" : null,
      "citeRegEx" : "Kohonen,? \\Q1995\\E",
      "shortCiteRegEx" : "Kohonen",
      "year" : 1995
    }, {
      "title" : "Doing Bayesian data analysis: A tutorial with R, JAGS, and Stan",
      "author" : [ "J. Kruschke" ],
      "venue" : null,
      "citeRegEx" : "Kruschke,? \\Q2014\\E",
      "shortCiteRegEx" : "Kruschke",
      "year" : 2014
    }, {
      "title" : "rknn: Random KNN Classification and Regression. R package version 1.2-1",
      "author" : [ "S. Li" ],
      "venue" : "URL https://cran.r-project.org/web/packages/rknn/index.html",
      "citeRegEx" : "Li,? \\Q2015\\E",
      "shortCiteRegEx" : "Li",
      "year" : 2015
    }, {
      "title" : "Classification and regression by randomforest",
      "author" : [ "A. Liaw", "M. Wiener" ],
      "venue" : "R News",
      "citeRegEx" : "Liaw and Wiener,? \\Q2002\\E",
      "shortCiteRegEx" : "Liaw and Wiener",
      "year" : 2002
    }, {
      "title" : "e1071: Misc Functions of the Department of Statistics (e1071), TU Wien. R package version 1.6-4",
      "author" : [ "D. Meyer", "E. Dimitriadou", "K. Hornik", "A. Weingessel", "F. Leisch" ],
      "venue" : null,
      "citeRegEx" : "Meyer et al\\.,? \\Q2014\\E",
      "shortCiteRegEx" : "Meyer et al\\.",
      "year" : 2014
    }, {
      "title" : "gbm: Generalized Boosted Regression Models. R package version 2.1. URL http://CRAN.R-project.org/package=gbm",
      "author" : [ "G. Ridgeway" ],
      "venue" : null,
      "citeRegEx" : "Ridgeway,? \\Q2013\\E",
      "shortCiteRegEx" : "Ridgeway",
      "year" : 2013
    }, {
      "title" : "Rotation forest: A new classifier ensemble method",
      "author" : [ "J.J. Rodriguez", "L.I. Kuncheva", "C.J. Alonso" ],
      "venue" : "IEEE Transactions on Pattern Analysis and Machine Intelligence",
      "citeRegEx" : "Rodriguez et al\\.,? \\Q2006\\E",
      "shortCiteRegEx" : "Rodriguez et al\\.",
      "year" : 2006
    }, {
      "title" : "Pegasos: Primal estimated sub-gradient solver for SVM",
      "author" : [ "S. Shalev-Shwartz", "Y. Singer", "N. Srebro", "A. Cotter" ],
      "venue" : "Mathematical Programming",
      "citeRegEx" : "Shalev.Shwartz et al\\.,? \\Q2011\\E",
      "shortCiteRegEx" : "Shalev.Shwartz et al\\.",
      "year" : 2011
    }, {
      "title" : "Bias in random forest variable importance measures: Illustrations, sources and a solution",
      "author" : [ "C. Strobl", "Boulesteix", "A.-L", "A. Zeileis", "T. Hothorn" ],
      "venue" : "BMC Bioinformatics",
      "citeRegEx" : "Strobl et al\\.,? \\Q2007\\E",
      "shortCiteRegEx" : "Strobl et al\\.",
      "year" : 2007
    }, {
      "title" : "Least squares support vector machine classifiers",
      "author" : [ "J.A. Suykens", "J. Vandewalle" ],
      "venue" : "Neural Processing Letters",
      "citeRegEx" : "Suykens and Vandewalle,? \\Q1999\\E",
      "shortCiteRegEx" : "Suykens and Vandewalle",
      "year" : 1999
    }, {
      "title" : "Modern Applied Statistics with S, 4th Edition",
      "author" : [ "W.N. Venables", "B.D. Ripley" ],
      "venue" : null,
      "citeRegEx" : "Venables and Ripley,? \\Q2002\\E",
      "shortCiteRegEx" : "Venables and Ripley",
      "year" : 2002
    }, {
      "title" : "bst: Gradient Boosting. R package version 0.3-4",
      "author" : [ "Z. Wang" ],
      "venue" : "URL http://CRAN.R-project.org/package=bst",
      "citeRegEx" : "Wang,? \\Q2014\\E",
      "shortCiteRegEx" : "Wang",
      "year" : 2014
    }, {
      "title" : "klar analyzing german business cycles",
      "author" : [ "C. Weihs", "U. Ligges", "K. Luebke", "N. Raabe" ],
      "venue" : null,
      "citeRegEx" : "Weihs et al\\.,? \\Q2005\\E",
      "shortCiteRegEx" : "Weihs et al\\.",
      "year" : 2005
    }, {
      "title" : "Stacked generalization",
      "author" : [ "D.H. Wolpert" ],
      "venue" : "Neural Networks",
      "citeRegEx" : "Wolpert,? \\Q1992\\E",
      "shortCiteRegEx" : "Wolpert",
      "year" : 1992
    }, {
      "title" : "ranger: A fast implementation of random forests for high dimensional data in C++ and R. arXiv:1508.04409",
      "author" : [ "M.N. Wright", "A. Ziegler" ],
      "venue" : null,
      "citeRegEx" : "Wright and Ziegler,? \\Q2015\\E",
      "shortCiteRegEx" : "Wright and Ziegler",
      "year" : 2015
    }, {
      "title" : "What is better: gradient-boosted trees, or a random forest",
      "author" : [ "Z. Zajac" ],
      "venue" : null,
      "citeRegEx" : "Zajac,? \\Q2016\\E",
      "shortCiteRegEx" : "Zajac",
      "year" : 2016
    }, {
      "title" : "Regularization and variable selection via the elas",
      "author" : [ "T. Hastie" ],
      "venue" : null,
      "citeRegEx" : "Zou and Hastie,? \\Q2005\\E",
      "shortCiteRegEx" : "Zou and Hastie",
      "year" : 2005
    }, {
      "title" : "The procedure calculates how unlikely is the true data when compared to data generated by the model, given the posterior distribution of the hyperparameters of the model",
      "author" : [ "A more formal model verification is the procedure of posterior predictive check proposed by Gelman" ],
      "venue" : "The data (true and generated) are summarized by the χ2 discrepancy (Gelman",
      "citeRegEx" : "Gelman,? 1996",
      "shortCiteRegEx" : "Gelman",
      "year" : 1996
    } ],
    "referenceMentions" : [ {
      "referenceID" : 6,
      "context" : "1 Introduction Fernández-Delgado et al. (2014) evaluated 179 different implementations of classification algorithms (from 17 different families of algoritms) on 121 public datasets.",
      "startOffset" : 15,
      "endOffset" : 47
    }, {
      "referenceID" : 4,
      "context" : "Of course there are meta-extensions of such algorithms to multi-class problems, for example, one-vs-one, one-vs-all, error correcting output coding (ECOC) (Dietterich and Bakiri, 1995), stacked generalization (Wolpert, 1992), pairwise coupling (Hastie et al.",
      "startOffset" : 155,
      "endOffset" : 184
    }, {
      "referenceID" : 30,
      "context" : "Of course there are meta-extensions of such algorithms to multi-class problems, for example, one-vs-one, one-vs-all, error correcting output coding (ECOC) (Dietterich and Bakiri, 1995), stacked generalization (Wolpert, 1992), pairwise coupling (Hastie et al.",
      "startOffset" : 209,
      "endOffset" : 224
    }, {
      "referenceID" : 4,
      "context" : "For example, if a researcher is interested in developing algorithms for very large classification problems, it is probably more useful to develop a big-data random forest (which is the family of classification algoritms with best performance according to Fernández-Delgado et al. (2014)) than to do it for Bayesian networks (mainly naive Bayes) or even Nearest Neighbors methods, which perform worse than random forests.",
      "startOffset" : 255,
      "endOffset" : 287
    }, {
      "referenceID" : 4,
      "context" : "For example, if a researcher is interested in developing algorithms for very large classification problems, it is probably more useful to develop a big-data random forest (which is the family of classification algoritms with best performance according to Fernández-Delgado et al. (2014)) than to do it for Bayesian networks (mainly naive Bayes) or even Nearest Neighbors methods, which perform worse than random forests. For practitioners, this form of research is even more important. Practitioners in machine learning will have limited resources, time, and expertise to test many different classification algorithms on their problem, and this form of research will allow them to focus on the most likely useful algorithms. Despite its importance and breath, we believe that Fernández-Delgado et al. (2014) had some “imperfections” which we address in this research.",
      "startOffset" : 255,
      "endOffset" : 808
    }, {
      "referenceID" : 4,
      "context" : "Of course there are meta-extensions of such algorithms to multi-class problems, for example, one-vs-one, one-vs-all, error correcting output coding (ECOC) (Dietterich and Bakiri, 1995), stacked generalization (Wolpert, 1992), pairwise coupling (Hastie et al., 1998), among others. Also, there are alternative formulations for specific binary classifiers to deal with multiclass, for example, Franc et al. (2002) for SVM, Engel (1988) for logistic regression, and so on.",
      "startOffset" : 156,
      "endOffset" : 412
    }, {
      "referenceID" : 4,
      "context" : "Of course there are meta-extensions of such algorithms to multi-class problems, for example, one-vs-one, one-vs-all, error correcting output coding (ECOC) (Dietterich and Bakiri, 1995), stacked generalization (Wolpert, 1992), pairwise coupling (Hastie et al., 1998), among others. Also, there are alternative formulations for specific binary classifiers to deal with multiclass, for example, Franc et al. (2002) for SVM, Engel (1988) for logistic regression, and so on.",
      "startOffset" : 156,
      "endOffset" : 434
    }, {
      "referenceID" : 6,
      "context" : "On the issue of binary classifiers, Fernández-Delgado et al. (2014) did not include in their comparisons the gradient boosting machine (gbm) algorithm, considered a very competitive algorithm for classification problems because, as reported in Zajac (2016), the implementation did not work in multiclass problems.",
      "startOffset" : 36,
      "endOffset" : 68
    }, {
      "referenceID" : 6,
      "context" : "On the issue of binary classifiers, Fernández-Delgado et al. (2014) did not include in their comparisons the gradient boosting machine (gbm) algorithm, considered a very competitive algorithm for classification problems because, as reported in Zajac (2016), the implementation did not work in multiclass problems.",
      "startOffset" : 36,
      "endOffset" : 257
    }, {
      "referenceID" : 6,
      "context" : "On the issue of binary classifiers, Fernández-Delgado et al. (2014) did not include in their comparisons the gradient boosting machine (gbm) algorithm, considered a very competitive algorithm for classification problems because, as reported in Zajac (2016), the implementation did not work in multiclass problems. We included gbm in our comparison. • We reduced the number of classifiers to only a few classes/algorithms and not different implementations of the same algorithm. FernándezDelgado et al. (2014) compared an impressing 179 different classification programs, but it was unclear how many were just different implementations of the same algorithm, and how many were variations within the same “family” of algorithms.",
      "startOffset" : 36,
      "endOffset" : 509
    }, {
      "referenceID" : 6,
      "context" : "On the issue of binary classifiers, Fernández-Delgado et al. (2014) did not include in their comparisons the gradient boosting machine (gbm) algorithm, considered a very competitive algorithm for classification problems because, as reported in Zajac (2016), the implementation did not work in multiclass problems. We included gbm in our comparison. • We reduced the number of classifiers to only a few classes/algorithms and not different implementations of the same algorithm. FernándezDelgado et al. (2014) compared an impressing 179 different classification programs, but it was unclear how many were just different implementations of the same algorithm, and how many were variations within the same “family” of algorithms. We believe that for practitioner and research communities, it is more useful to have an understanding of how different families of algorithms rank in relation to each other. For the practitioner, which should have more limited access to the different algorithms, this knowledge allow them to order which algorithms should be applied first to their particular problem. In fact, Fernández-Delgado et al. (2014) also perform an analysis of their results based on the algorithm’s “family”, but they have difficulty of extracting useful information from this analysis, since in most cases, different “implementations” in the same family have widely different results.",
      "startOffset" : 36,
      "endOffset" : 1136
    }, {
      "referenceID" : 6,
      "context" : "Given Fernández-Delgado et al. (2014) daunting task of testing 179 programs, they had to rely on default values for the hyperparameters which may lead to suboptimal results.",
      "startOffset" : 6,
      "endOffset" : 38
    }, {
      "referenceID" : 5,
      "context" : "Fernández-Delgado et al. (2014) follow the standard null hypothesis significant test in analyzing their result, but even within this framework, their analysis is not as rigorous as it should have been.",
      "startOffset" : 0,
      "endOffset" : 32
    }, {
      "referenceID" : 3,
      "context" : "The NIST standard for comparing many classifiers across different datasets was proposed by Demsar (2006) and it is discussed in section 3.",
      "startOffset" : 91,
      "endOffset" : 105
    }, {
      "referenceID" : 3,
      "context" : "The NIST standard for comparing many classifiers across different datasets was proposed by Demsar (2006) and it is discussed in section 3.1. In particular, when testing the different algorithms for statistical significant differences, the Demsar procedure requires one to use the Nemenyi test, which is a nonparametric test that performs the appropriate multiple comparison p-value correction. But Fernández-Delgado et al. (2014) used a paired t-test (a parametric test) between the first ranked and the following 9 top ranked algorithms, apparently without multiple comparions corrections.",
      "startOffset" : 91,
      "endOffset" : 430
    }, {
      "referenceID" : 6,
      "context" : "Fernández-Delgado et al. (2014) first two ranked programs are two different implementation of the same algorithm - parallel implementation of random forest (first ranked) and a non-parallel implementation (second ranked).",
      "startOffset" : 0,
      "endOffset" : 32
    }, {
      "referenceID" : 6,
      "context" : "2 Datasets We started with the 121 datasets collected from the UCI site, processed, and converted by the authors of Fernández-Delgado et al. (2014) into a unified format.",
      "startOffset" : 116,
      "endOffset" : 148
    }, {
      "referenceID" : 6,
      "context" : "2 Datasets We started with the 121 datasets collected from the UCI site, processed, and converted by the authors of Fernández-Delgado et al. (2014) into a unified format. The datasets is derived from the 165 available at UCI website in March 2013, where 56 were excluded by the authors of Fernández-Delgado et al. (2014). For the remaining 121, Fernández-Delgado et al.",
      "startOffset" : 116,
      "endOffset" : 321
    }, {
      "referenceID" : 6,
      "context" : "2 Datasets We started with the 121 datasets collected from the UCI site, processed, and converted by the authors of Fernández-Delgado et al. (2014) into a unified format. The datasets is derived from the 165 available at UCI website in March 2013, where 56 were excluded by the authors of Fernández-Delgado et al. (2014). For the remaining 121, Fernández-Delgado et al. (2014) converted all categorical variables to numerical data, and each feature was standardized to zero mean and standard deviation equal to 1.",
      "startOffset" : 116,
      "endOffset" : 377
    }, {
      "referenceID" : 6,
      "context" : "2 Datasets We started with the 121 datasets collected from the UCI site, processed, and converted by the authors of Fernández-Delgado et al. (2014) into a unified format. The datasets is derived from the 165 available at UCI website in March 2013, where 56 were excluded by the authors of Fernández-Delgado et al. (2014). For the remaining 121, Fernández-Delgado et al. (2014) converted all categorical variables to numerical data, and each feature was standardized to zero mean and standard deviation equal to 1. We downloaded the datasets preprocessed by the authors of FernándezDelgado et al. (2014) in November 2014.",
      "startOffset" : 116,
      "endOffset" : 603
    }, {
      "referenceID" : 33,
      "context" : "Thus, glmnet (L1 and L2 regularized logistic regression (Zou and Hastie, 2005)) and sda a L1-regularized LDA are two mainly linear algorithms.",
      "startOffset" : 56,
      "endOffset" : 78
    }, {
      "referenceID" : 17,
      "context" : "lvq, or learning vector quantization (Kohonen, 1995) is a cluster plus distance, or dictionary based classification: a set of “prototypes,” or clusters, or “codebook” is discovered in the data, many for each class, and new data is classified based on the distance to these prototypes.",
      "startOffset" : 37,
      "endOffset" : 52
    }, {
      "referenceID" : 16,
      "context" : "Neural network based classifiers include nnet a common 1-hidden layer logistic network, and elm or extreme learning machines (Huang et al., 2006).",
      "startOffset" : 125,
      "endOffset" : 145
    }, {
      "referenceID" : 9,
      "context" : "Finally we included one implementation of random forests (rf) and one implementation of gradient boosting machine classifiers (gbm) (Friedman, 2001).",
      "startOffset" : 132,
      "endOffset" : 148
    }, {
      "referenceID" : 28,
      "context" : "We used the R implementation in the package bst (Wang, 2014)",
      "startOffset" : 48,
      "endOffset" : 60
    }, {
      "referenceID" : 6,
      "context" : "As discussed in the Introduction, we argued that one of the possible criticisms to the Fernández-Delgado et al. (2014) paper is that the authors do not distinguish different algorithms from different implementations of that algorithm.",
      "startOffset" : 87,
      "endOffset" : 119
    }, {
      "referenceID" : 12,
      "context" : "elm Extreme learning machines Implementation: package elmNN (Gosso, 2012)) gbm Gradient boosting machines.",
      "startOffset" : 60,
      "endOffset" : 73
    }, {
      "referenceID" : 22,
      "context" : "Implementation: package gbm (Ridgeway, 2013) glmnet Elastic net logistic regression classifier.",
      "startOffset" : 28,
      "endOffset" : 44
    }, {
      "referenceID" : 8,
      "context" : "Implementation : package glmnet (Friedman et al., 2010)) knn k-nearest neighbors classifier.",
      "startOffset" : 32,
      "endOffset" : 55
    }, {
      "referenceID" : 27,
      "context" : "Implementation: package class (Venables and Ripley, 2002).",
      "startOffset" : 30,
      "endOffset" : 57
    }, {
      "referenceID" : 27,
      "context" : "Implementation: package class (Venables and Ripley, 2002)) nb Naive Bayes classifier: package klaR (Weihs et al.",
      "startOffset" : 30,
      "endOffset" : 57
    }, {
      "referenceID" : 29,
      "context" : "Implementation: package class (Venables and Ripley, 2002)) nb Naive Bayes classifier: package klaR (Weihs et al., 2005) nnet A 1-hidden layer neural network with sigmoid transfer function.",
      "startOffset" : 99,
      "endOffset" : 119
    }, {
      "referenceID" : 27,
      "context" : "Implementation: package nnet (Venables and Ripley, 2002) rf Random forest.",
      "startOffset" : 29,
      "endOffset" : 56
    }, {
      "referenceID" : 20,
      "context" : "Implementation: package randomForest (Liaw and Wiener, 2002) rknn A bagging of knn classifiers on a random subset of the original features.",
      "startOffset" : 37,
      "endOffset" : 60
    }, {
      "referenceID" : 19,
      "context" : "Implementation: package rknn (Li, 2015) sda A L1 regularized linear discriminant classifier.",
      "startOffset" : 29,
      "endOffset" : 39
    }, {
      "referenceID" : 2,
      "context" : "Implementation: package sparseLDA (Clemmensen, 2012) svmLinear A SVM with linear kernel.",
      "startOffset" : 34,
      "endOffset" : 52
    }, {
      "referenceID" : 21,
      "context" : "package e1071 (Meyer et al., 2014)) svmPoly A SVM with polynomial kernel.",
      "startOffset" : 14,
      "endOffset" : 34
    }, {
      "referenceID" : 21,
      "context" : "package e1071 (Meyer et al., 2014)) svmRadial A SVM with RBF kernel.",
      "startOffset" : 14,
      "endOffset" : 34
    }, {
      "referenceID" : 21,
      "context" : "package e1071 (Meyer et al., 2014))",
      "startOffset" : 14,
      "endOffset" : 34
    }, {
      "referenceID" : 8,
      "context" : "The only relevant algorithm for this research is the elastic-net regularized logistic regression implemented by the package glmnet (Friedman et al., 2010)), which computes all the values (or the path as it is called) of the regularization parameter λ.",
      "startOffset" : 131,
      "endOffset" : 154
    }, {
      "referenceID" : 8,
      "context" : "The only relevant algorithm for this research is the elastic-net regularized logistic regression implemented by the package glmnet (Friedman et al., 2010)), which computes all the values (or the path as it is called) of the regularization parameter λ. Hastie et al. (2004) discuss a complete path algorithm for SVM (for the C hyperparameter) but we did not use this implementation in this paper.",
      "startOffset" : 132,
      "endOffset" : 273
    }, {
      "referenceID" : 3,
      "context" : "1 Demsar procedure We will follow the procedure proposed by Demsar (2006). The procedure suggests one should first apply a Friedman test (which can be seen as a",
      "startOffset" : 2,
      "endOffset" : 74
    }, {
      "referenceID" : 18,
      "context" : "Let us denote yad as the error rate for the algorithm a on dataset d, then the usual hierarchical model is (Kruschke, 2014): yad ∼N(νad, σ0) (2a) νad =β + αa + δd (2b) σ0 ∼U(ySD/100, ySD ∗ 10) (2c) β ∼N(yMean, ySD ∗ 5) (2d) αa ∼N(0, σa) (2e) δd ∼N(0, σd) (2f) σa ∼Gamma(ySD/2, ySD ∗ 2) (2g) σd ∼Gamma(ySD/2, ySD ∗ 2) (2h) where U(L,H) is the uniform distribution with L and H as the low and high limits; N(μ, σ) is the normal distribution with mean μ and standard deviation σ; and Gamma(m,σ) is the Gamma distribution with mode m and standard deviation σ - note that this is not the usual parametrization of the Gamma distribution.",
      "startOffset" : 107,
      "endOffset" : 123
    }, {
      "referenceID" : 18,
      "context" : "The standard Bayesian ANOVA, as described in Kruschke (2014) is based on normal distributions.",
      "startOffset" : 45,
      "endOffset" : 61
    }, {
      "referenceID" : 18,
      "context" : "The stronger results of the robust model can be explained by shrinkage (Kruschke, 2014); since it allows more outliers, the mean of each distribution of the algorithms’ coefficient would",
      "startOffset" : 71,
      "endOffset" : 87
    }, {
      "referenceID" : 6,
      "context" : "Our results are in general compatible with those in Fernández-Delgado et al. (2014). Random forest is the best ranking algorithm in both experiments; gradient boosting machines which was not included in FernándezDelgado et al.",
      "startOffset" : 52,
      "endOffset" : 84
    }, {
      "referenceID" : 6,
      "context" : "Our results are in general compatible with those in Fernández-Delgado et al. (2014). Random forest is the best ranking algorithm in both experiments; gradient boosting machines which was not included in FernándezDelgado et al. (2014) performs well, as reported in various blogs, RBF SVM also performs well.",
      "startOffset" : 52,
      "endOffset" : 234
    }, {
      "referenceID" : 6,
      "context" : "Our results are in general compatible with those in Fernández-Delgado et al. (2014). Random forest is the best ranking algorithm in both experiments; gradient boosting machines which was not included in FernándezDelgado et al. (2014) performs well, as reported in various blogs, RBF SVM also performs well. The divergence starts with the next best classifications algorithms: Fernández-Delgado et al. (2014) lists polynomial kernel SVM svmPoly and extreme learning machines elm as the next best families, but in our case svmPoly was equivalent to 1-hidden layer neural nets nnet, and a bagging of knn rknn.",
      "startOffset" : 52,
      "endOffset" : 408
    }, {
      "referenceID" : 31,
      "context" : "There has been more recent implementations of random forest (Wright and Ziegler, 2015) and gradient boosting machines (Distributed (Deep) Machine Learning Community, 2016) which claim both a faster execution time and shorter memory footprint.",
      "startOffset" : 60,
      "endOffset" : 86
    }, {
      "referenceID" : 0,
      "context" : "On the other hand, incremental and online solvers for SVM (Bordes et al., 2005; Shalev-Shwartz et al., 2011) may further tip the scale in favor of SVM.",
      "startOffset" : 58,
      "endOffset" : 108
    }, {
      "referenceID" : 24,
      "context" : "On the other hand, incremental and online solvers for SVM (Bordes et al., 2005; Shalev-Shwartz et al., 2011) may further tip the scale in favor of SVM.",
      "startOffset" : 58,
      "endOffset" : 108
    }, {
      "referenceID" : 23,
      "context" : "Variations of Random Forest, such as Rotation Forest (Rodriguez et al., 2006), Extremely Randomized Forest (Geurts et al.",
      "startOffset" : 53,
      "endOffset" : 77
    }, {
      "referenceID" : 11,
      "context" : ", 2006), Extremely Randomized Forest (Geurts et al., 2006), random forest of conditional inference trees (Hothorn et al.",
      "startOffset" : 37,
      "endOffset" : 58
    }, {
      "referenceID" : 15,
      "context" : ", 2006), random forest of conditional inference trees (Hothorn et al., 2006; Strobl et al., 2007), should be compared with the standard algorithm.",
      "startOffset" : 54,
      "endOffset" : 97
    }, {
      "referenceID" : 25,
      "context" : ", 2006), random forest of conditional inference trees (Hothorn et al., 2006; Strobl et al., 2007), should be compared with the standard algorithm.",
      "startOffset" : 54,
      "endOffset" : 97
    }, {
      "referenceID" : 26,
      "context" : "Least square SVM (Suykens and Vandewalle, 1999) should be compared with the standard SVM, and different models of boosting such as AdaBoost, LogiBoost, BrownBoost, should be compared with gbm.",
      "startOffset" : 17,
      "endOffset" : 47
    } ],
    "year" : 2016,
    "abstractText" : "We tested 14 very different classification algorithms (random forest, gradient boosting machines, SVM linear, polynomial, and RBF 1-hidden-layer neural nets, extreme learning machines, k-nearest neighbors and a bagging of knn, naive Bayes, learning vector quantization, elastic net logistic regression, sparse linear discriminant analysis, and a boosting of linear classifiers) on 115 real life binary datasets. We followed the Demsar analysis and found that the three best classifiers (random forest, gbm and RBF SVM) are not significantly different from each other. We also discuss that a change of less then 0.0112 in the error rate should be considered as an irrelevant change, and used a Bayesian ANOVA analysis to conclude that with high probability the differences between these three classifiers is not of practical consequence. We also verified the execution time of “standard implementations” of these algorithms and concluded that RBF SVM is the fastest (significantly so) both in training time and in training plus testing time. keywords: Classification algorithms; comparison; binary problems; Demsar procedure; Bayesian analysis",
    "creator" : "LaTeX with hyperref package"
  }
}