{
  "name" : "1405.3367.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : "Bound Founded Answer Set Programming",
    "authors" : [ "Rehan Abdul Aziz" ],
    "emails" : [ "raziz@student.unimelb.edu.au" ],
    "sections" : [ {
      "heading" : null,
      "text" : "ar X\niv :1\n40 5.\n33 67\nv1 [\ncs .A"
    }, {
      "heading" : "1 Motivation",
      "text" : "Answer Set Programming (Baral 2003) is a useful modelling paradigm to solve search and planning problems. Modern ASP solving (Gebser et al. 2007; Gebser et al. 2012) builds on propositional satisfiability (SAT) solving (Mitchell 2005). However, ASP solvers have a competitive edge over SAT solvers in problems whose model involves some notion of transitive closure, e.g., reachability or connectivity in a graph. This is due to the difference in semantics of both systems; ASP solvers implement stable model semantics (Gelfond and Lifschitz 1988) which minimizes the number of variables that are true in a given logic program while a SAT solver only looks for an assignment that satisfies all the given clauses. In ASP, in order for a variable to be true, it must have some rule as a support that justifies it being true. Furthermore, no set of variables can circularly support one another. E.g. given two rules a ← b and b ← a, the only valid solution in\n∗ NICTA is funded by the Australian Government as represented by the Department of Broadband, Communications and the Digital Economy and the Australian Research Council through the ICT Centre of Excellence program.\nstable model semantics is where a and b are both false, whereas in propositional semantics, both the variables being true is also a valid solution.\nAs ASP systems such as SMODELS and CLASP only deal with Boolean variables, they are inefficient for solving problems that are naturally modelled with integers, especially if they have large domains. These combinatorial problems (e.g. scheduling) are ubiquitous in Computer Science, which makes ASP a poor choice to model and solve them. The most obvious way to model these in ASP is to represent each integer’s domain as a set of Boolean variables and impose constraints on these variables to ensure consistency. This incurs what is commonly known as the grounding bottleneck problem. Naturally, decomposing a large finite domain to Boolean variables blows up the problem size in the size of domains of integer variables. Constraint Programming solvers (Rossi et al. 2006) and Mixed Integer Programming solvers, on the other hand, are excellent candidates for these problems as they support numeric variables natively. Unfortunately, constraint solvers suffer from the same inefficiency as SAT solvers regarding problems like reachability that require inductive definitions. A hybrid system that has the best of both worlds, i.e., inductive rules for Boolean variables from ASP, and native support for integers and constraints over them from CP, addresses both the concerns. However, in this work, we propose that even this hybrid approach is not sufficient, and there exists a type of grounding bottleneck that is still not removed by combining the strengths of CP and ASP solvers. Let us illustrate this by first looking at a benchmark from ASP competitions, and then modifying its problem description.\nConsider the Minimum Connected Dominating Set (MCDS) problem. A dominating set is a set of nodes such that every node in the graph is either in the set or has at least one neighbour in the set. The objective is to find a dominating set of minimum cardinality such that the subgraph induced by dominating nodes is connected. Let us look at the ASP encoding of the problem 1. A vertex X is given in the input as vtx (X), an edge from X to Y as edge(X,Y ) and the edge relation is symmetric.\nR1 {dom(U) : vtx(U)}. R2 in(V ) ← dom(V ). R3 in(V ) ← edge(U, V ) ∧ dom(U). C1 ← vtx(U) ∧ ¬in(U). R4 reach(U) ← dom(U)∧ 6 ∃V <U : dom(V ). R5 reach(V ) ← reach(U) ∧ dom(V ) ∧ edge(U, V ). C2 ← dom(U) ∧ ¬reach(U). O minimize{dom(U) : vtx(U)}.\nR1 introduces a decision variable dom for each vertex specifying whether it is a dominating vertex or not. R1 is a choice rule which means that for a given node U , this rule can be a justification for dom(U) if it is true. R2, R3 and C1 model that every node must either be a dominating node or have a neighbour that is dominating. This is done with the help of an auxiliary predicate in that becomes true when at least one of the conditions is met. C1 says that there can be no node for which in is false. R4 and R5 define the predicate reach that is used to model the connectivity constraint of the induced subgraph by the dominating nodes. R4 encodes the base case for reachability, specifying that the node with the lowest index is reachable by definition.\n1 Based on the model from Potassco group in the second ASP competition: http://dtai.cs.kuleuven.be/events/ASP-competition/encodings.shtml\nThis choice is arbitrary and its purpose can be satisfied by any criterion to select a dominating node.R5 is a recursive case for reachability and it says that a dominating neighbour of a reachable node is also reachable. The constraint C2 says that all dominating nodes must be reachable. The objective, given by O, is to minimize the cardinality of the dominating set.\nLet us modify MCDS such that the edges in the graph also have weights (edge(U, V,W ) means that the edge from U to V has weight W ) and there is an additional constraint that the diameter (maximum distance between any two nodes) of the dominating subgraph is less than a certain given value K . This problem has applications in computer networks (Kim et al. 2009; Buchanan et al. 2013). Let d(X,Y ) represent the distance (shortest path) between two dominating nodes X and Y . In MCDS, it is sufficient to check for reachability of every dominating node from an arbitrary node to ensure connectedness. However, to enforce the new constraint, we need a distance variable for each pair of nodes in the dominating set. We can replace R4, R5 and C2 in the above encoding of MCDS with the following:\nR4 d(U,U) ≤ 0 ← dom(U). R5 d(U, T ) ≤ d(V, T ) +W ← dom(T ) ∧ dom(U) ∧ dom(V ) ∧ edge(U, V,W ). C2 ← dom(U) ∧ dom(V ) ∧ d(U, V ) > K.\nR4 is the base case for d and it says that the distance from a dominating node to itself is at most 0. R5 is a recursive rule that specifies that for two dominating neighbours and a dominating node T , the distance between one end of the node to T is at most the distance between the other end and T , plus the weight of the edge. Finally, the constraint C2 establishes that the distance between any two dominating nodes must be at most K . It is unnecessary to include the previous reachability rules since finite distances between all pairs of dominating nodes implies that the dominating set is connected.\nRules like R4 and R5 on integer variables are clearly not supported by current ASP systems. The semantics that we wish to associate with the distance variables is that firstly, if there are no rules supporting them, then they are equal to ∞. Secondly, any rule for a distance variable justifies a value lower than ∞ and thirdly, the upper bounds of these variables cannot form a circular justification. E.g. if there are two rules: a ≤ b and b ≤ a, then any solution where a and b are equal to a finite value should be rejected, and the only stable solution should be one where both are equal to ∞. The distance variable is essentially an upper-bound founded (ub-founded) variable, for which the upper bound needs to be justified by some rule. We can encode these upper-bound founded distance variables in ASP along with our desired semantics by replacing R4, R5, and C2 as follows:\ndub(U, V,N) ← dom(U) ∧ dom(V ) ∧ dub(U, V,N − 1), N < M. dub(U,U, 0) ← dom(U). dub(U, T,D +W ) ← dom(T ) ∧ dom(U) ∧ dom(V ) ∧ edge(U, V,W ) ∧ d(V, T,D). d(U, V,D) ← dom(U) ∧ dom(V ) ∧ dub(U, V,D) ∧ ¬dub(U, V,D − 1). ← dom(U) ∧ dom(V ) ∧ d(U, V,D) ∧D > K.\nIn the above encoding, M is a sufficiently large integer and dub(U, V,N) specifies that the distance between the dominating nodes U and V is at most N (the subscript ub stands for upperbound). d(U, V,D) is defined as the minimum value for which dub(U, V,D) is true. Unfortunately, an ASP solver on this encoding quickly runs into the grounding bottleneck problem as\nwe increase edge weights and the bound on diameter. This is the motivation of this work, i.e., to support founded numeric variables and rules like R4 and R5 without grounding them.\nThe symmetric analog for a ub-founded variable is a lower-bound founded (lb-founded) variable, which is by default equal to −∞ (false for Boolean) and further rules for it can justify a greater value on its lower bound. In this generalization, ASP variables are simply lb-founded Boolean variables. For simplicity, we only consider lb-founded variables, and refer to them as founded variables. This simplification is possible because we can replace all ub-founded variables, their rules, and their constraints by corresponding lb-founded variables with similar rules and constraints. E.g., for the above problem, let d(U, V ) represent the negative of the distance between U and V , then we can perform this transformation as follows:\nR4 d(U,U) ≥ 0 ← dom(U). R5 d(U, T ) ≥ d(V, T )−W ← dom(T ) ∧ dom(U) ∧ dom(V ) ∧ edge(U, V,W ). C2 ← dom(U) ∧ dom(V ) ∧ d(U, V ) < −K.\nAn important point in the encoding of MCDS is that if we remove the reachability condition from the problem specification, and R4, R5, and C2 from the encoding, then the problem can be solved by a SAT solver just as efficiently as an ASP solver. Recall that the only shortcoming of SAT solvers is related to modelling properties like reachability since the propositional semantics that they are based on does not naturally model recursive definitions. This leads us to the important observation that besides founded variables like reach and d , there can be variables in a problem like the dom variables that are not founded. Let us call them standard variables, owing to the fact that these are the usual variables in CP solvers. Standard variables can be assigned any value as long as all the constraints associated with them are satisfied. Founded variables, on the other hand, need rules to define their values and without them, they are equal to some default value.\nSince there are no rules and founded variables in CP and MIP solvers, MCDS with bounded diameter as defined above cannot be efficiently solved by them. The MIP formulation as given in (Buchanan et al. 2013) encodes each distance variable with K propositional variables, meaning that the problem size increases with K . Our encoding above that uses founded variables does not suffer from this problem. This leads us to distinguish between the two types of grounding bottlenecks. One is caused in a system by the absence of its support for standard integer variables. Let us call this type the standard grounding bottleneck. The other type of grounding bottleneck is caused by the lack of a system’s capabilities to handle founded numeric variables, therefore, let us call it founded grounding bottleneck.\nIn the next section, we formally define the semantics of Bound Founded Answer Set Programming (BFASP), a formalism that generalizes the stable model semantics to bounds over numeric variables, and allows for a richer set of rules for founded variables. 2"
    }, {
      "heading" : "2 Bound Founded Answer Set Programming",
      "text" : "Let V be the set of variables. We consider three types of variables: integer, real, and Boolean. Furthermore, we divide the set of variables in two disjoint sets: standard S and founded variables F . A domain D maps each variable x ∈ V to a set of constant values D(x). A valuation (or\n2 The MINIZINC encoding of MCDS with bounded diameter in BFASP is given Appendix A.\nassignment) θ over variables vars(θ) ⊆ V maps each variable x ∈ vars(θ) to a value θ(x). A constraint c is a set of assignments over the variables vars(c), representing the solutions of the constraint. Given a constraint c, a variable y ∈ vars(c) is monotonically increasing (decreasing) in c if for all solutions θ that satisfy c, increasing (decreasing) the value of y also creates a solution, that is θ′ where θ′(y) > θ(y), and θ′(x) = θ(x), x ∈ vars(c) − {y}, is also a solution of c.\nA positive-CP P is a collection of constraints where each constraint is increasing in exactly one variable and decreasing in the rest. The minimal solution of a positive-CP is an assignment θ that satisfies P s.t. there is no other assignment θ′ that also satisfies P and there exists a variable v for which θ′(v) < θ(v). Note that for Booleans, true > false . A satisfiable positive-CPP always has a unique minimal solution. If we have bounds consistent propagators for all the constraints in the program, then the unique minimal solution can be found simply by performing bounds propagation on all constraints until a fixed point is reached, and then setting all variables to their lowest values.\nA rule r is a pair (c, y) where c is a constraint, y ∈ F is the head of the rule and it is increasing in c. A bound founded answer set program (BFASP) P is a tuple (S,F , C,R) where C and R are sets of constraints and rules respectively. Given a variable y ∈ F , rules(y) is the set of rules with y as their heads.\nThe reduct of a BFASP P w.r.t. an assignment θ, written P θ, is a positive-CP made from each rule r = (c, y) by replacing in c each variable x ∈ vars(c)−{y}, if it is a standard variable or if c is not decreasing in it, by its value θ(x) to create a positive-CP constraint c′. Let rθ denote this constraint. If rθ is not a tautology, it is included in the reduct. An assignment θ is a stable model of P iff i) it satisfies all the constraints in P and ii) it is the minimal model that satisfies P θ.\nExample 1 Consider a BFASP with standard variable s, integer founded variables a, b, Boolean founded variables x and y, and the rules: (a ≥ 0, a), (b ≥ 0, b), (a ≥ b + s, a), (b ≥ 8 ← x, b), (x ← ¬y ∧ (a ≥ 5), x). Consider an assignment θ s.t. θ(x) = true, θ(y) = false , θ(b) = 8, θ(s) = 9 and θ(a) = 17. The reduct of θ is the positive-CP: a ≥ b + 9, b ≥ 8 ← x, x ← a ≥ 5. The minimal model that satisfies the reduct is equal to θ, therefore, θ is a stable model of the program. Consider another assignment θ′ where all values are the same as in θ, but θ′(s) = 3. Then, P θ ′ is the positive-CP: a ≥ 0, b ≥ 0, a ≥ b + 3, b ≥ 8 ← x, x ← a ≥ 5. The minimal solution that satisfies this positive-CP is M where M(a) = 3, M(b) = 0, M(x) = M(y) = false . Therefore, θ′ is not a stable model of the program."
    }, {
      "heading" : "3 Overview of the existing literature",
      "text" : "There are several approaches in the literature that aim at removing the standard grounding bottleneck from ASP systems. A majority of these approaches work as follows: they introduce finite domain integer variables and constraints inside the ASP program. The ASP solver passes these to a CP solver while maintaining a Boolean variable to represent the truth value of each constraint that is in the ASP program. For a constraint c that appears in the program, this is done by reifying the constraint, i.e., introducing a Boolean variable b to represent whether the constraint is true. The ASP and CP solvers communicate using these introduced Boolean variables. E.g., if b is set true by the ASP solver, then the constraint c is enforced by the CP solver. Since the ASP solver treats CP as a blackbox, it cannot directly learn clauses from the propagation\nperformed by the CP solver. Examples of systems that use this approach are the AC SOLVER algorithm (Mellarkod et al. 2008), CLINGCON (Gebser et al. 2009) and EZCSP (Balduccini 2009). Recently, some systems have been introduced that overcome the limited learning by using a single solver that supports both founded Booleans as well as standard integer variables and constraints over them. One way to achieve this is to introduce standard integer variables inside an ASP solver, and extending ASP’s propagation engine to work like a CP solver (de Cat et al. 2013; Drescher and Walsh 2012). The second approach is given in our earlier work (Aziz et al. 2013a), and extends an existing CP solver with founded Boolean variables and normal rules. To implement the stable model semantics over these, it implements the source pointer technique (Simons et al. 2002) to prune unfounded sets (Van Gelder et al. 1988) of variables as a propagator, similar to the ASP solver CLASP (Gebser et al. 2012).\nTranslating in terms of its supported features a specification that is missing in a system is another way to remove standard grounding bottleneck. There are two approaches in the literature to accomplish this. The first approach provides a translation from an ASP program augmented with numeric variables and constraints to a Mixed Integer Program (Liu et al. 2012). As discussed earlier, the non-recursive parts of the program are straight-forward to translate. The non-trivial part is encoding rules that involve positive recursion. This is done using the level ranking mapping as given in (Janhunen 2004). The fundamental idea of the translation is that if there is an unfounded set in the solution of the original program, then the mapping contains an inconsistent set of inequalities. The second approach (Drescher and Walsh 2010) encodes entire CP solving into ASP using the well-known eager CP decompositions to SAT. Unfortunately, this a priori translation of CP to SAT is already known to be highly inefficient in the CP community where it is much more efficient to translate lazily as in lazy clause generation (Ohrimenko et al. 2009).\nCompared to the standard grounding bottleneck, the focus on the founded grounding bottleneck has been relatively weak. The formalism that is closest to BFASP in terms of removing this bottleneck is Fuzzy Answer Set Programming (FASP) (Nieuwenborgh et al. 2006; Blondeel et al. 2013). The fuzzy atoms in FASP correspond to founded real variables in BFASP, and each logical connective in FASP can be expressed as a rule form in BFASP. We have provided the translation in our previous work (Aziz et al. 2013), showing that BFASP subsumes FASP. Most importantly, from the implementation point of view, the MIP based unfounded set detection algorithm (Janssen et al. 2008) given for FASP only detects unfounded sets in a complete solution, which means that it cannot prune partial solutions that contain unfounded sets. Therefore, the algorithm has a similar shortcoming as CMODELS (Lierler and Maratea 2004) has in case of Boolean unfounded sets. Finally, lack of any good implementation for FASP makes it infeasible to carry out an empirical comparison of BFASP and FASP."
    }, {
      "heading" : "4 Goals and current status of the research",
      "text" : "The broader goal of my PhD is to analyze the strengths and implementation techniques of ASP in order to enhance the existing modelling and solving capabilities of constraint solvers. This overall goal can be divided into the following subgoals.\n• To define, study, implement, and evaluate BFASP in order to put it forward as a formalism, with an accompanying implementation, that does not suffer from any kind of grounding bottleneck. This subgoal has been completed, and the most important features of BFASP were published in ICLP 2013 (Aziz et al. 2013). The paper defines the semantics of BFASP\nand presents an unfounded set algorithm that detects circular sets of bounds and prunes them during search. It presents performance comparison of our implementation of BFASP with ASP on three benchmarks, and with CP on one benchmark, and the results demonstrate the need for BFASP. Prior to introducing BFASP, we extended a CP solver with founded Boolean variables and normal rules (Aziz et al. 2013a). We implemented two known algorithms for unfounded set detection from the ASP literature inside the CP solver CHUFFED and compared it with CLINGCON on problems that involve inductive definitions as well as standard integer variables.\n• To define and study the language of BFASP. As compared to ASP languages like GRINGO that follow a very restrictive grammar, the grammar for BFASP is very permissive and a user can write complex expressions as rules. Therefore, the first task in this subgoal is to simplify these rules to a small set of primitive rules. In other words, we want to extend the flattening principles (Stuckey and Tack 2013) used in constraint languages to BFASP. Secondly, ASP grounders use bottom-up grounding that generates as few useless rules as possible. These are rules that can be removed without affecting the stable solutions of the program. The second task is to generalize ASP bottom-up grounding technique for BFASP. Finally, magic set rewriting is a useful technique in logic programming that only instantiates rules that are relevant to a given query. Considering variables appearing in constraints and objective function comprise our query, i.e. the set of variables whose values are of interest, the final task is to generalize the magic set transformation for BFASP.\n• Identify research areas and benchmarks where BFASP can be applied and that cannot be efficiently solved by the current ASP, CP, and Constraint ASP (Gebser et al. 2009) systems. The doctoral programme could prove especially beneficial with regard to this subgoal."
    }, {
      "heading" : "Appendix A MINIZINC Encoding of Minimum Connected Dominating Set with Bounded",
      "text" : "Diameter\nint: N; %number of nodes int: E; %number of edges array[1..E] of 1..N: from; %encodes an edge i (from[i], to[i]) array[1..E] of 1..N: to; array[1..E] of int: weight; %weight of an edge int: K; %bound on diameter\narray[1..N] of var bool: dom; %whether a node is dominating\n% Dominating set constraint constraint forall (n in 1..N) ( dom[n] \\/ exists(e in 1..E where from[e] = n) (dom[to[e]]) );\n% Rules for negative distance array[1..N,1..N] of var int: d :: founded;\nrule forall (n in 1..N) (d[n,n] >= 0 :: head(d[n,n])); rule forall (e in 1..E, n in 1..N) ( d[from[e],n] >= d[to[e],n] - weight[e] <- dom[from[e]] /\\ dom[to[e]] /\\ dom[n] :: head(d[from[e],n]) );\n% Diameter constraint constraint forall (u,v in 1..N where u != v) ( dom[u] /\\ dom[v] -> d[u,v] >= -K );\n% Objective to minimize the cardinality of dominating set solve minimize sum (n in 1..N) (bool2int(dom[n]));\n% A toy instance N=4; E=6; K=35; from =[1, 2, 2, 3, 3, 4]; to =[2, 1, 3, 2, 4, 3]; weight =[20,20,30,30,40,40];"
    } ],
    "references" : [ {
      "title" : "Stable model semantics for founded bounds",
      "author" : [ "R.A. AZIZ", "G. CHU", "P.J. STUCKEY" ],
      "venue" : "Theory and Practice of Logic Programming 13, 4–5, 517–532. Proceedings of the 29th International Conference on Logic Programming.",
      "citeRegEx" : "AZIZ et al\\.,? 2013",
      "shortCiteRegEx" : "AZIZ et al\\.",
      "year" : 2013
    }, {
      "title" : "Inductive definitions in constraint programming",
      "author" : [ "R.A. AZIZ", "P.J. STUCKEY", "Z. SOMOGYI" ],
      "venue" : "Proceedings of the Thirty-Sixth Australasian Computer Science Conference, B. Thomas, Ed. CRPIT, vol. 135. ACS, 41–50.",
      "citeRegEx" : "AZIZ et al\\.,? 2013a",
      "shortCiteRegEx" : "AZIZ et al\\.",
      "year" : 2013
    }, {
      "title" : "Representing constraint satisfaction problems in answer set programming",
      "author" : [ "M. BALDUCCINI" ],
      "venue" : "ICLP09 Workshop on Answer Set Programming and Other Computing Paradigms (ASPOCP09).",
      "citeRegEx" : "BALDUCCINI,? 2009",
      "shortCiteRegEx" : "BALDUCCINI",
      "year" : 2009
    }, {
      "title" : "Knowledge representation, reasoning and declarative problem solving",
      "author" : [ "C. BARAL" ],
      "venue" : "Cambridge University Press.",
      "citeRegEx" : "BARAL,? 2003",
      "shortCiteRegEx" : "BARAL",
      "year" : 2003
    }, {
      "title" : "Fuzzy answer set programming: An introduction",
      "author" : [ "M. BLONDEEL", "S. SCHOCKAERT", "D. VERMEIR", "M. DE COCK" ],
      "venue" : "Soft Computing: State of the Art Theory and Novel Applications. Springer, 209–222.",
      "citeRegEx" : "BLONDEEL et al\\.,? 2013",
      "shortCiteRegEx" : "BLONDEEL et al\\.",
      "year" : 2013
    }, {
      "title" : "On connected dominating sets of restricted diameter",
      "author" : [ "A. BUCHANAN", "J.S. SUNG", "V. BOGINSKI", "S. BUTENKO" ],
      "venue" : "European Journal of Operational Research.",
      "citeRegEx" : "BUCHANAN et al\\.,? 2013",
      "shortCiteRegEx" : "BUCHANAN et al\\.",
      "year" : 2013
    }, {
      "title" : "Model expansion in the presence of function symbols using constraint programming",
      "author" : [ "B. DE CAT", "B. BOGAERTS", "J. DEVRIENDT", "M. DENECKER" ],
      "venue" : "IEEE International Conference on Tools with Artificial Intelligence.",
      "citeRegEx" : "CAT et al\\.,? 2013",
      "shortCiteRegEx" : "CAT et al\\.",
      "year" : 2013
    }, {
      "title" : "A translational approach to constraint answer set solving",
      "author" : [ "C. DRESCHER", "T. WALSH" ],
      "venue" : "Theory and Practice of Logic Programming 10, 4-6, 465–480.",
      "citeRegEx" : "DRESCHER and WALSH,? 2010",
      "shortCiteRegEx" : "DRESCHER and WALSH",
      "year" : 2010
    }, {
      "title" : "Answer set solving with lazy nogood neneration",
      "author" : [ "C. DRESCHER", "T. WALSH" ],
      "venue" : "Technical Communications of the 28th International Conference on Logic Programming. 188–200.",
      "citeRegEx" : "DRESCHER and WALSH,? 2012",
      "shortCiteRegEx" : "DRESCHER and WALSH",
      "year" : 2012
    }, {
      "title" : "Conflict-driven answer set solving",
      "author" : [ "M. GEBSER", "B. KAUFMANN", "A. NEUMANN", "T. SCHAUB" ],
      "venue" : "Proceedings of the 20th International Joint Conference on Artificial Intelligence. MIT Press, 386.",
      "citeRegEx" : "GEBSER et al\\.,? 2007",
      "shortCiteRegEx" : "GEBSER et al\\.",
      "year" : 2007
    }, {
      "title" : "Conflict-driven answer set solving: From theory to practice",
      "author" : [ "M. GEBSER", "B. KAUFMANN", "T. SCHAUB" ],
      "venue" : "Artificial Intelligence 187, 52–89.",
      "citeRegEx" : "GEBSER et al\\.,? 2012",
      "shortCiteRegEx" : "GEBSER et al\\.",
      "year" : 2012
    }, {
      "title" : "Constraint answer set solving",
      "author" : [ "M. GEBSER", "M. OSTROWSKI", "T. SCHAUB" ],
      "venue" : "Proceedings of the 25th International Conference on Logic Programming. Springer, 235–249.",
      "citeRegEx" : "GEBSER et al\\.,? 2009",
      "shortCiteRegEx" : "GEBSER et al\\.",
      "year" : 2009
    }, {
      "title" : "The stable model semantics for logic programming",
      "author" : [ "M. GELFOND", "V. LIFSCHITZ" ],
      "venue" : "Proceedings of the Fifth International Conference on Logic Programming. MIT Press, 1070–1080.",
      "citeRegEx" : "GELFOND and LIFSCHITZ,? 1988",
      "shortCiteRegEx" : "GELFOND and LIFSCHITZ",
      "year" : 1988
    }, {
      "title" : "Representing normal programs with clauses",
      "author" : [ "T. JANHUNEN" ],
      "venue" : "Proceedings of the 16th Eureopean Conference on Artificial Intelligence. 358–362.",
      "citeRegEx" : "JANHUNEN,? 2004",
      "shortCiteRegEx" : "JANHUNEN",
      "year" : 2004
    }, {
      "title" : "Compiling fuzzy answer set programs to fuzzy propositional theories",
      "author" : [ "J. JANSSEN", "S. HEYMANS", "D. VERMEIR", "M.D. COCK" ],
      "venue" : "Proceedings of the 24th International Conference on Logic Programming. Springer Berlin Heidelberg, 362–376.",
      "citeRegEx" : "JANSSEN et al\\.,? 2008",
      "shortCiteRegEx" : "JANSSEN et al\\.",
      "year" : 2008
    }, {
      "title" : "Constructing minimum connected dominating sets with bounded diameters in wireless networks",
      "author" : [ "KIM D.", "WU Y.", "LI Y.", "ZOU F.", "DU", "D.-Z." ],
      "venue" : "IEEE Transactions on Parallel and Distributed Systems, 147–157.",
      "citeRegEx" : "D. et al\\.,? 2009",
      "shortCiteRegEx" : "D. et al\\.",
      "year" : 2009
    }, {
      "title" : "Cmodels-2: Sat-based answer set solver enhanced to non-tight programs",
      "author" : [ "Y. LIERLER", "M. MARATEA" ],
      "venue" : "LPNMR. 346–350.",
      "citeRegEx" : "LIERLER and MARATEA,? 2004",
      "shortCiteRegEx" : "LIERLER and MARATEA",
      "year" : 2004
    }, {
      "title" : "Answer set programming via mixed integer programming",
      "author" : [ "G. LIU", "T. JANHUNEN", "I. NIEMELA" ],
      "venue" : "Proceedings of the 13th International Conference on Principles of Knowledge Representation and Reasoning. AAAI Press, 32–42.",
      "citeRegEx" : "LIU et al\\.,? 2012",
      "shortCiteRegEx" : "LIU et al\\.",
      "year" : 2012
    }, {
      "title" : "Integrating answer set programming and constraint logic programming",
      "author" : [ "V.S. MELLARKOD", "M. GELFOND", "Y. ZHANG" ],
      "venue" : "Annals of Mathematics and Artificial Intelligence 53, 1-4, 251–287.",
      "citeRegEx" : "MELLARKOD et al\\.,? 2008",
      "shortCiteRegEx" : "MELLARKOD et al\\.",
      "year" : 2008
    }, {
      "title" : "A SAT solver primer",
      "author" : [ "D.G. MITCHELL" ],
      "venue" : "Bulletin of the EATCS 85, 112–132.",
      "citeRegEx" : "MITCHELL,? 2005",
      "shortCiteRegEx" : "MITCHELL",
      "year" : 2005
    }, {
      "title" : "Fuzzy answer set programming",
      "author" : [ "D.V. NIEUWENBORGH", "M.D. COCK", "D. VERMEIR" ],
      "venue" : "Proceedings of Logics in Artificial Intelligence, 10th European Conference, JELIA 2006. Springer Berlin Heidelberg, 359–372.",
      "citeRegEx" : "NIEUWENBORGH et al\\.,? 2006",
      "shortCiteRegEx" : "NIEUWENBORGH et al\\.",
      "year" : 2006
    }, {
      "title" : "Propagation via lazy clause generation",
      "author" : [ "O. OHRIMENKO", "P.J. STUCKEY", "M. CODISH" ],
      "venue" : "Constraints 14, 3, 357–391.",
      "citeRegEx" : "OHRIMENKO et al\\.,? 2009",
      "shortCiteRegEx" : "OHRIMENKO et al\\.",
      "year" : 2009
    }, {
      "title" : "Handbook of Constraint Programming (Foundations of Artificial Intelligence)",
      "author" : [ "F. ROSSI", "P.V. BEEK", "T. WALSH" ],
      "venue" : "Elsevier Science, New York, NY.",
      "citeRegEx" : "ROSSI et al\\.,? 2006",
      "shortCiteRegEx" : "ROSSI et al\\.",
      "year" : 2006
    }, {
      "title" : "Extending and implementing the stable model semantics",
      "author" : [ "P. SIMONS", "I. NIEMELÄ", "T. SOININEN" ],
      "venue" : "Artificial Intelligence 138, 1–2, 181–234.",
      "citeRegEx" : "SIMONS et al\\.,? 2002",
      "shortCiteRegEx" : "SIMONS et al\\.",
      "year" : 2002
    }, {
      "title" : "Minizinc with functions",
      "author" : [ "P.J. STUCKEY", "G. TACK" ],
      "venue" : "Proceedings of the 10th International Conference on Integration of Artificial Intelligence (AI) and Operations Research (OR) techniques in Constraint Programming. Number 7874 in LNCS. Springer, 268–283.",
      "citeRegEx" : "STUCKEY and TACK,? 2013",
      "shortCiteRegEx" : "STUCKEY and TACK",
      "year" : 2013
    }, {
      "title" : "Unfounded sets and well-founded semantics for general logic programs",
      "author" : [ "A. VAN GELDER", "K.A. ROSS", "J.S. SCHLIPF" ],
      "venue" : "Proceedings of the ACM Symposium on Principles of Database Systems. ACM, 221–230.",
      "citeRegEx" : "GELDER et al\\.,? 1988",
      "shortCiteRegEx" : "GELDER et al\\.",
      "year" : 1988
    } ],
    "referenceMentions" : [ {
      "referenceID" : 3,
      "context" : "Answer Set Programming (Baral 2003) is a useful modelling paradigm to solve search and planning problems.",
      "startOffset" : 23,
      "endOffset" : 35
    }, {
      "referenceID" : 9,
      "context" : "Modern ASP solving (Gebser et al. 2007; Gebser et al. 2012) builds on propositional satisfiability (SAT) solving (Mitchell 2005).",
      "startOffset" : 19,
      "endOffset" : 59
    }, {
      "referenceID" : 10,
      "context" : "Modern ASP solving (Gebser et al. 2007; Gebser et al. 2012) builds on propositional satisfiability (SAT) solving (Mitchell 2005).",
      "startOffset" : 19,
      "endOffset" : 59
    }, {
      "referenceID" : 19,
      "context" : "2012) builds on propositional satisfiability (SAT) solving (Mitchell 2005).",
      "startOffset" : 59,
      "endOffset" : 74
    }, {
      "referenceID" : 12,
      "context" : "This is due to the difference in semantics of both systems; ASP solvers implement stable model semantics (Gelfond and Lifschitz 1988) which minimizes the number of variables that are true in a given logic program while a SAT solver only looks for an assignment that satisfies all the given clauses.",
      "startOffset" : 105,
      "endOffset" : 133
    }, {
      "referenceID" : 22,
      "context" : "Constraint Programming solvers (Rossi et al. 2006) and Mixed Integer Programming solvers, on the other hand, are excellent candidates for these problems as they support numeric variables natively.",
      "startOffset" : 31,
      "endOffset" : 50
    }, {
      "referenceID" : 5,
      "context" : "This problem has applications in computer networks (Kim et al. 2009; Buchanan et al. 2013).",
      "startOffset" : 51,
      "endOffset" : 90
    }, {
      "referenceID" : 5,
      "context" : "The MIP formulation as given in (Buchanan et al. 2013) encodes each distance variable with K propositional variables, meaning that the problem size increases with K .",
      "startOffset" : 32,
      "endOffset" : 54
    }, {
      "referenceID" : 18,
      "context" : "Examples of systems that use this approach are the AC SOLVER algorithm (Mellarkod et al. 2008), CLINGCON (Gebser et al.",
      "startOffset" : 71,
      "endOffset" : 94
    }, {
      "referenceID" : 11,
      "context" : "2008), CLINGCON (Gebser et al. 2009) and EZCSP (Balduccini 2009).",
      "startOffset" : 16,
      "endOffset" : 36
    }, {
      "referenceID" : 2,
      "context" : "2009) and EZCSP (Balduccini 2009).",
      "startOffset" : 16,
      "endOffset" : 33
    }, {
      "referenceID" : 8,
      "context" : "One way to achieve this is to introduce standard integer variables inside an ASP solver, and extending ASP’s propagation engine to work like a CP solver (de Cat et al. 2013; Drescher and Walsh 2012).",
      "startOffset" : 153,
      "endOffset" : 198
    }, {
      "referenceID" : 1,
      "context" : "The second approach is given in our earlier work (Aziz et al. 2013a), and extends an existing CP solver with founded Boolean variables and normal rules.",
      "startOffset" : 49,
      "endOffset" : 68
    }, {
      "referenceID" : 23,
      "context" : "To implement the stable model semantics over these, it implements the source pointer technique (Simons et al. 2002) to prune unfounded sets (Van Gelder et al.",
      "startOffset" : 95,
      "endOffset" : 115
    }, {
      "referenceID" : 10,
      "context" : "1988) of variables as a propagator, similar to the ASP solver CLASP (Gebser et al. 2012).",
      "startOffset" : 68,
      "endOffset" : 88
    }, {
      "referenceID" : 17,
      "context" : "The first approach provides a translation from an ASP program augmented with numeric variables and constraints to a Mixed Integer Program (Liu et al. 2012).",
      "startOffset" : 138,
      "endOffset" : 155
    }, {
      "referenceID" : 13,
      "context" : "This is done using the level ranking mapping as given in (Janhunen 2004).",
      "startOffset" : 57,
      "endOffset" : 72
    }, {
      "referenceID" : 7,
      "context" : "The second approach (Drescher and Walsh 2010) encodes entire CP solving into ASP using the well-known eager CP decompositions to SAT.",
      "startOffset" : 20,
      "endOffset" : 45
    }, {
      "referenceID" : 21,
      "context" : "Unfortunately, this a priori translation of CP to SAT is already known to be highly inefficient in the CP community where it is much more efficient to translate lazily as in lazy clause generation (Ohrimenko et al. 2009).",
      "startOffset" : 197,
      "endOffset" : 220
    }, {
      "referenceID" : 20,
      "context" : "The formalism that is closest to BFASP in terms of removing this bottleneck is Fuzzy Answer Set Programming (FASP) (Nieuwenborgh et al. 2006; Blondeel et al. 2013).",
      "startOffset" : 115,
      "endOffset" : 163
    }, {
      "referenceID" : 4,
      "context" : "The formalism that is closest to BFASP in terms of removing this bottleneck is Fuzzy Answer Set Programming (FASP) (Nieuwenborgh et al. 2006; Blondeel et al. 2013).",
      "startOffset" : 115,
      "endOffset" : 163
    }, {
      "referenceID" : 0,
      "context" : "We have provided the translation in our previous work (Aziz et al. 2013), showing that BFASP subsumes FASP.",
      "startOffset" : 54,
      "endOffset" : 72
    }, {
      "referenceID" : 14,
      "context" : "Most importantly, from the implementation point of view, the MIP based unfounded set detection algorithm (Janssen et al. 2008) given for FASP only detects unfounded sets in a complete solution, which means that it cannot prune partial solutions that contain unfounded sets.",
      "startOffset" : 105,
      "endOffset" : 126
    }, {
      "referenceID" : 16,
      "context" : "Therefore, the algorithm has a similar shortcoming as CMODELS (Lierler and Maratea 2004) has in case of Boolean unfounded sets.",
      "startOffset" : 62,
      "endOffset" : 88
    }, {
      "referenceID" : 0,
      "context" : "This subgoal has been completed, and the most important features of BFASP were published in ICLP 2013 (Aziz et al. 2013).",
      "startOffset" : 102,
      "endOffset" : 120
    }, {
      "referenceID" : 1,
      "context" : "Prior to introducing BFASP, we extended a CP solver with founded Boolean variables and normal rules (Aziz et al. 2013a).",
      "startOffset" : 100,
      "endOffset" : 119
    }, {
      "referenceID" : 24,
      "context" : "In other words, we want to extend the flattening principles (Stuckey and Tack 2013) used in constraint languages to BFASP.",
      "startOffset" : 60,
      "endOffset" : 83
    }, {
      "referenceID" : 11,
      "context" : "• Identify research areas and benchmarks where BFASP can be applied and that cannot be efficiently solved by the current ASP, CP, and Constraint ASP (Gebser et al. 2009) systems.",
      "startOffset" : 149,
      "endOffset" : 169
    } ],
    "year" : 2014,
    "abstractText" : "Answer Set Programming (ASP) is a powerful modelling formalism that is very efficient in solving combinatorial problems. ASP solvers implement the stable model semantics that eliminates circular derivations between Boolean variables from the solutions of a logic program. Due to this, ASP solvers are better suited than propositional satisfiability (SAT) and Constraint Programming (CP) solvers to solve a certain class of problems whose specification includes inductive definitions such as reachability in a graph. On the other hand, ASP solvers suffer from the grounding bottleneck that occurs due to their inability to model finite domain variables. Furthermore, the existing stable model semantics are not sufficient to disallow circular reasoning on the bounds of numeric variables. An example where this is required is in modelling shortest paths between nodes in a graph. Just as reachability can be encoded as an inductive definition with one or more base cases and recursive rules, shortest paths between nodes can also be modelled with similar base cases and recursive rules for their upper bounds. This deficiency of stable model semantics introduces another type of grounding bottleneck in ASP systems that cannot be removed by naively merging ASP with CP solvers, but requires a theoretical extension of the semantics from Booleans and normal rules to bounds over numeric variables and more general rules. In this work, we propose Bound Founded Answer Set Programming (BFASP) that resolves this issue and consequently, removes all types of grounding bottleneck inherent in ASP systems.",
    "creator" : "LaTeX with hyperref package"
  }
}