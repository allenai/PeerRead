{
  "name" : "1612.06475.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : "Span-Based Constituency Parsing with a Structure-Label System and Provably Optimal Dynamic Oracles",
    "authors" : [ "James Cross", "Liang Huang" ],
    "emails" : [ "liang.huang.sh}@gmail.com" ],
    "sections" : [ {
      "heading" : "1 Introduction",
      "text" : "Parsing is an important problem in natural language processing which has been studied extensively for decades. Between the two basic paradigms of parsing, constituency parsing, the subject of this paper, has in general proved to be the more difficult than dependency parsing, both in terms of accuracy and the run time of parsing algorithms.\nThere has recently been a huge surge of interest in using neural networks to make parsing decisions, and such models continue to dominate the state of the art in dependency parsing (Andor et al., 2016). In constituency parsing, however, neural approaches are still behind the state-of-the-art (Carreras et al., 2008; Shindo et al., 2012; Thang et al., 2015); see more details in Section 5.\nTo remedy this, we design a new parsing framework that is more suitable for constituency parsing, and that can be accurately modeled by neural networks. Observing that constituency parsing is primarily focused on sentence spans (rather than individual words, as is dependency parsing), we propose\na novel adaptation of the shift-reduce system which reflects this focus. In this system, the stack consists of sentence spans rather than partial trees. It is also factored into two types of parser actions, structural and label actions, which alternate during a parse. The structural actions are a simplified analogue of shift-reduce actions, omitting the directionality of reduce actions, while the label actions directly assign nonterminal symbols to sentence spans.\nOur neural model processes the sentence once for each parse with a recurrent network. We represent parser configurations with a very small number of span features (4 for structural actions and 3 for label actions). Extending Wang and Chang (2016), each span is represented as the difference of recurrent output from multiple layers in each direction. No pretrained embeddings are required.\nWe also extend the idea of dynamic oracles from dependency to constituency parsing. The latter is significantly more difficult than the former due to F1 being a combination of precision and recall (Huang, 2008), and yet we propose a simple and extremely efficient oracle (amortizedO(1) time). This oracle is proved optimal for F1 as well as both of its components, precision and recall. Trained with this oracle, our parser achieves what we believe to be the best results for any parser without reranking which was trained only on the Penn Treebank and the French Treebank, despite the fact that it is not only lineartime, but also strictly greedy.\nWe make the following main contributions:\n• A novel factored transition parsing system where the stack elements are sentence spans rather than partial trees (Section 2).\n• A neural model where sentence spans are represented as differences of output from a multilayer bi-directional LSTM (Section 3).\n• The first provably optimal dynamic oracle for\nar X\niv :1\n61 2.\n06 47\n5v 1\n[ cs\n.C L\n] 2\n0 D\nec 2\n01 6\nconstituency parsing which is also extremely efficient (amortized O(1) time) (Section 4).\n• The best F1 scores of any single-model, closed training set, parser for English and French.\nWe are also publicly releasing the source code for one implementation of our parser.1"
    }, {
      "heading" : "2 Parsing System",
      "text" : "We present a new transition-based system for constituency parsing whose fundamental unit of computation is the sentence span. It uses a stack in a similar manner to other transition systems, except that the stack contains sentence spans with no requirement that each one correspond to a partial tree structure during a parse.\nThe parser alternates between two types of actions, structural and label, where the structural actions follow a path to make the stack spans correspond to sentence phrases in a bottom-up manner, while the label actions optionally create tree brackets for the top span on the stack. There are only two structural actions: shift is the same as other transition systems, while combine merges the top two sentence spans. The latter is analogous to a reduce action, but it does not immediately create a tree structure and is non-directional. Label actions do create a partial tree on top of the stack by assigning one or more non-terminals to the topmost span.\nExcept for the use of spans, this factored approach is similar to the odd-even parser from Mi and Huang (2015). The fact that stack elements do not have to be tree-structured, however, means that we can create productions with arbitrary arity, and no binarization is required either for training or parsing. This also allows us to remove the directionality inherent in the shift-reduce system, which is at best an imperfect fit for constituency parsing. We do follow the practice in that system of labeling unary chains of non-terminals with a single action, which means our parser uses a fixed number of steps, (4n− 2) for a sentence of n words.\nFigure 1 shows the formal deductive system for this parser. The stack σ is modeled as a list of strictly increasing integers whose first element is always\n1code: https://github.com/jhcross/span-parser\nzero. These numbers are word boundaries which define the spans on the stack. In a slight abuse of notation, however, we sometimes think of it as a list of pairs (i, j), which are the actual sentence spans, i.e., every consecutive pair of indices on the stack, initially empty. We represent stack spans by trapezoids (iSome text and the symbol or scaled\n1\nj) in th figures to emphasize that they may or not have tree stucture.\nThe parser alternates between structural actions and label actions according to the parity of the parser step z. In even steps, it takes a structural action, either combining the top two stack spans, which requires at least two spans on the stack, or introducing a new span of unit length, as long as the entire sentence is not already represented on the stack\nIn odd steps, the parser takes a label action. One possibility is labeling the top span on the stack, (i, j) with either a nonterminal label or an ordered unary chain (since the parser has only one opportunity to label any given span). Taking no action, designated nolabel, is also a possibility. This is essentially a null operation except that it returns the parser to an even step, and this action reflects the decision that (i, j) is not a (complete) labeled phrase in the tree. In the final step, (4n − 2), nolabel is not allowed\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\nsince the parser must produce a tree. Figure 2 shows a complete example of applying this parsing system to a very short sentence (“I do like eating fish”) that we will use throughout this section and the next. The action in step 2 is labelNP because “I” is a one-word noun phrase (parts of speech are taken as input to our parser, though it could easily be adapted to include POS tagging in label actions). If a single word is not a complete phrase (e.g., “do”), then the action after a shift is nolabel.\nThe ternary branch in this tree (VP→MD VBP S) is produced by our parser in a straightforward manner: after the phrase “do like” is combined in step 7, no label is assigned in step 8, successfully delaying the creation of a bracket until the verb phrase is fully formed on the stack. Note also that the unary production in the tree is created with a single action, label-S-VP, in step 14.\nThe static oracle to train this parser simply consists of taking actions to generate the gold tree with a “short-stack” heuristic, meaning combine first whenever combine and shift are both possible."
    }, {
      "heading" : "3 LSTM Span Features",
      "text" : "Long short-term memory networks (LSTM) are a type of recurrent neural network model proposed by Hochreiter and Schmidhuber (1997) which are very effective for modeling sequences. They are able to capture and generalize from interactions among their sequential inputs even when separated by a long distance, and thus are a natural fit for analyz-\ning natural language. LSTM models have proved to be a powerful tool for many learning tasks in natural language, such as language modeling (Sundermeyer et al., 2012) and translation (Sutskever et al., 2014).\nLSTMs have also been incorporated into parsing in a variety of ways, such as directly encoding an entire sentence (Vinyals et al., 2015), separately modeling the stack, buffer, and action history (Dyer et al., 2015), to encode words based on their character forms (Ballesteros et al., 2015), and as an element in a recursive structure to combine dependency subtrees with their left and right children (Kiperwasser and Goldberg, 2016a).\nFor our parsing system, however, we need a way to model arbitrary sentence spans in the context of the rest of the sentence. We do this by representing each sentence span as the elementwise difference of the vector outputs of the LSTM outputs at different time steps, which correspond to word boundaries. If the sequential output of the recurrent network for the sentence is f0, ..., fn in the forward direction and bn, ..., b0 in the backward direction then the span (i, j) would be represented as the concatenation of the vector differences (fj − fi) and (bi − bj).\nThe spans are represented using output from both backward and forward LSTM components, as can be seen in Figure 3. This is essentially the LSTMMinus feature representation described by Wang and Chang (2016) extended to the bi-directional case. In initial experiments, we found that there was essentially no difference in performance between using the difference features and concatenating all end-\n〈s〉 I do like eating fish 〈/s〉0\nf0\nb0\n1\nf1\nb1\n2\nf2\nb2\n3\nf3\nb3\n4\nf4\nb4\n5\nf5\nb5\nFigure 3: Word spans are modeled by differences in LSTM output. Here the span 3 eating fish 5 is represented by the vector differences (f5 − f3) and (b3 − b5). The forward difference corresponds to LSTM-Minus (Wang and Chang, 2016).\npoint vectors, but our approach is almost twice as fast.\nThis model allows a sentence to be processed once, and then the same recurrent outputs can be used to compute span features throughout the parse. Intuitively, this allows the span differences to learn to represent the sentence spans in the context of the rest of the sentence, not in isolation (especially true for LSTM given the extra hidden recurrent connection, typically described as a “memory cell”). In practice, we use a two-layer bi-directional LSTM, where the input to the second layer combines the forward and backward outputs from the first layer at that time step. For each direction, the components from the first and second layers are concatenated to form the vectors which go into the span features. See Cross and Huang (2016) for more details on this approach.\nFor the particular case of our transition constituency parser, we use only four span features to determine a structural action, and three to determine a label action, in each case partitioning the sentence exactly. The reason for this is straightforward: when considering a structural action, the top two spans on the stack must be considered to determine whether they should be combined, while for a label action, only the top span on the stack is important, since that is the candidate for labeling. In both cases the remaining sentence prefix and suffix are also included. These features are shown in Table 1.\nThe input to the recurrent network at each time step consists of vector embeddings for each word\nAction Stack LSTM Span Features Structural σ | i |k |j 02iSome text and the symbol or scaled\n1\nkSome text and the symbol or scaled\n1\nj2n Label σ | i |j 02iSome text and the symbol or scaled\n1\nj2n\nTable 1: Features used for the parser. No label or tree-structure features are required.\nand its part-of-speech tag. Parts of speech are predicted beforehand and taken as input to the parser, as in much recent work in parsing. In our experiments, the embeddings are randomly initialized and learned from scratch together with all other network weights, and we would expect further performance improvement from incorporating embeddings pretrained from a large external corpus.\nThe network structure after the the span features consists of a separate multilayer perceptron for each type of action (structural and label). For each action we use a single hidden layer with rectified linear (ReLU) activation. The model is trained on a peraction basis using a single correct action for each parser state, with a negative log softmax loss function, as in Chen and Manning (2014)."
    }, {
      "heading" : "4 Dynamic Oracle",
      "text" : "The baseline method of training our parser is what is known as a static oracle: we simply generate the sequence of actions to correctly parse each training sentence, using a short-stack heuristic (i.e., combine first whenever there is a choice of shift and combine). This method suffers from a well-documeted problem, however, namely that it only “prepares” the model for the situation where no mistakes have been made during parsing, an inevitably incorrect assumption in practice. To alleviate this problem, Goldberg and Nivre (2013) define a dynamic oracle to return the best possible action(s) at any arbitrary configuration.\nIn this section, we introduce an easy-to-compute optimal dynamic oracle for our constituency parser. We will first define some concepts upon which the dynamic oracle is built and then show how optimal actions can be very efficiently computed using this framework. In broad strokes, in any arbitrary parser configuration c there is a set of brackets t∗(c) from the gold tree which it is still possible to reach. By following dynamic oracle actions, all of those brackets and only those brackets will be predicted.\nEven though proving the optimality of our dynamic oracle (Sec. 4.3) is involved, computing the oracle actions is extremely simple (Secs. 4.2) and efficient (Sec. 4.4)."
    }, {
      "heading" : "4.1 Preliminaries and Notations",
      "text" : "Before describing the computation of our dynamic oracle, we first need to rigorously establish the desired optimality of dynamic oracle. The structure of this framework follows Goldberg et al. (2014).\nDefinition 1. We denote c `τ c′ iff. c′ is the result of action τ on configuration c, also denoted functionally as c′ = τ(c). We denote ` to be the union of `τ for all actions τ , and `∗ to be the reflexive and transitive closure of `.\nDefinition 2 (descendant/reachable trees). We denote D(c) to be the set of final descendant trees derivable from c, i.e., D(c) = {t | c `∗ 〈z, σ, t〉}. This set is also called “reachable trees” from c.\nDefinition 3 (F1). We define the standard F1 metric of a tree t with respect to gold tree tG as F1(t) = 2rp r+p , where r = |t∩tG| |tG| , p = |t∩tG| |t| .\nThe following two definitions are similar to those for dependency parsing by Goldberg et al. (2014).\nDefinition 4. We extend the F1 function to configurations to define the maximum possible F1 from a given configuration: F1(c) = maxt1∈D(c) F1(t1).\nDefinition 5 (oracle). We can now define the desired dynamic oracle of a configuration c to be the set of actions that retrain the optimal F1:\noracle(c) = {τ | F1(τ(c)) = F1(c)}.\nThis abstract oracle is implemented by dyna(·) in Sec. 4.2, which we prove to be correct in Sec. 4.3.\nDefinition 6 (span encompassing). We say span (i, j) is encompassed by span (p, q), notated (i, j) (p, q), iff. p ≤ i < j ≤ q.\nDefinition 7 (strict encompassing). We say span (i, j) is strictly encompassed by span (p, q), notated (i, j) ≺ (p, q), iff. (i, j) (p, q) and (i, j) 6= (p, q). We then extend this relation from spans to brackets, and notate iXj ≺ pYq iff. (i, j) ≺ (p, q).\n0S5\n1VP5\n3S/VP5\n4NP5\n0Some text and the symbol or scaled\n1\n1Some text and the symbol or scaled\n1\n2Some text and th sym l or scaled\n1\n4 5\nI do like eating fish\nFigure 4: Reachable brackets (w.r.t. gold tree in Fig. 1) for c = 〈10, [0, 1, 2, 4], {0NP1}〉 which mistakenly combines “like eating”. Trapezoids indicate stack spans (the top one in red), and solid triangles denote reachable brackets, with left(c) in blue and right(c) in cyan. The next reachable bracket, next(c) = 1VP5, is in bold. Brackets 3VP5 and 3S5 (in dotted triangle) cross the top span (thus unreachable), and 0NP1 is already recognized (thus not in reach(c) either).\nWe next define a central concept, reachable brackets, which is made up of two parts, the left ones left(c) which encompass (i, j) without crossing any stack spans, and the right ones right(c) which are completely on the queue. See Fig. 4 for examples.\nDefinition 8 (reachable brackets). For any configuration c = 〈z, σ | i |j, t〉, we define the set of reachable gold brackets (with respect to gold tree tG) as\nreach(c) = left(c) ∪ right(c)\nwhere the left- and right-reachable brackets are\nleft(c)={pXq ∈ tG | (i, j) ≺ (p, q), p ∈ σ | i} right(c)={pXq ∈ tG | p ≥ j}\nfor even z, with the ≺ replaced by for odd z. Special case (initial): reach(〈0, [0], ∅〉) = tG. The notation p ∈ σ | i simply means (p, q) does not “cross” any bracket on the stack. Remember our stack is just a list of span boundaries, so if p coincides with one of them, (p, q)’s left boundary is not crossing and its right boundary q is not crossing either since q ≥ j due to (i, j) ≺ (p, q).\nAlso note that reach(c) is strictly disjoint from t, i.e., reach(c) ∩ t = ∅ and reach(c) ⊆ tG − t. See Figure 6 for an illustration.\nDefinition 9 (next bracket). For any configuration c = 〈z, σ | i |j, t〉, the next reachable gold bracket (with respect to gold tree tG) is the smallest reachable bracket (strictly) encompassing (i, j):\nnext(c) = min≺ left(c)."
    }, {
      "heading" : "4.2 Structural and Label Oracles",
      "text" : "For an even-step configuration c = 〈z, σ | i | j, t〉, we denote the next reachable gold bracket next(c) to be pXq, and define the dynamic oracle to be:\ndyna(c) =  {sh} if p = i and q > j {comb} if p < i and q = j {sh, comb} if p < i and q > j (1)\nAs a special case dyna(〈0, [0], ∅〉) = {sh}. Figure 5 shows examples of this policy. The key insight is, if you follow this policy, you will not miss the next reachable bracket, but if you do not follow it, you certainly will. We formalize this fact below (with proof omitted due to space constraints) which will be used to prove the central results later.\nLemma 1. For any configuration c, for any τ ∈ dyna(c), we have reach(τ(c)) = reach(c); for any τ ′ /∈ dyna(c), we have reach(τ(c)) ( reach(c).\nThe label oracles are much easier than structural ones. For an odd-step configuration c = 〈z, σ | i | j, t〉, we simply check if (i, j) is a valid span in the gold tree tG and if so, label it accordingly, otherwise no label. More formally,\ndyna(c) = { {label-X} if some iXj ∈ tG {nolabel} otherwise (2)"
    }, {
      "heading" : "4.3 Correctness",
      "text" : "To show the optimality of our dynamic oracle, we begin by defining a special tree t∗(c) and show that it is optimal among all trees reachable from configuration c. We then show that following our dynamic oracle (Eqs. 1–2) from c will lead to t∗(c).\nDefinition 10 (t∗(c)). For any configuration c = 〈z, σ, t〉, we define the optimal tree t∗(c) to include all reachable gold brackets and nothing else. More formally, t∗(c) = t ∪ reach(c).\nconfiguration oracle\nstatic dynamic 0Some t xt and t e symbol or scaled\n1Some text and the symbol or scaled\n2Some text and the symbol or scaled\n3 comb {comb, sh}\nI do like 1∧52Some text and the symbol or scaled\n1\n3\n0Some text and the symbol or scaled\n1\n1Some text and the sym ol or scaled\n1\n3\nundef.\n{sh}\nI do like t={..., 1VP3} 1∧5Some text and the symbol or scaled\n1\n3\n0Some text and the symbol or scaled\n1\n1Some te t and the symbol or scaled\n1\n2Som t xt and th sym l or scaled\n1\n4 {comb, sh}\nI do like eating 1∧52Some text and the symbol or scaled\n1\n4\n0Some text and the symbol or scaled\n1\n1Some text and the symbol or scaled\n1\n2Some text and the sym ol or scaled\n1\n4Some text and the symbol o scaled\n1\n5 {comb}\nI do like eating fish 1∧54Some text and the symbol or scaled\n1\nFigure 5: Dynamic oracle with respect to the gold parse in Fig. 2. The last three examples are off the gold path with strike out indicating structural or label mistakes. Trapezoids denote stack spans (top one in red) and the blue triangle denotes the next reachable bracket next(c) which is 1VP5 in all cases.\nWe can show by induction that t∗(c) is attainable:\nLemma 2. For any configuration c, the optimal tree is a descendant of c, i.e., t∗(c) ∈ D(c).\nThe following Theorem shows that t∗(c) is indeed the best possible tree:\nTheorem 1 (optimality of t∗). For any configuration c, F1(t∗(c)) = F1(c).\nProof. (SKETCH) Since t∗(c) adds all possible additional gold brackets (the brackets in reach(c)), it is not possible to get higher recall. Since it adds no incorrect brackets, it is not possible to get higher pre-\ncision. Since F1 is the harmonic mean of precision and recall, it also leads to the best possible F1.\nCorollary 1. For any c = 〈z, σ, t〉, for any t′ ∈ D(c) and t′ 6= t∗(c), we have F1(t′) < F1(c).\nWe now need a final lemma about the policy dyna(·) (Eqs. 1–2) before proving the main result. Lemma 3. From any c = 〈z, σ, t〉, for any action τ ∈ dyna(c), we have t∗(τ(c)) = t∗(c). For any action τ ′ /∈ dyna(c), we have t∗(τ ′(c)) 6= t∗(c).\nProof. (SKETCH) By case analysis on even/odd z.\nWe are now able to state and prove the main theoretical result of this paper (using Lemma 3, Theorem 1 and Corollary 1):\nTheorem 2. The function dyna(·) in Eqs. (1–2) satisfies the requirement of a dynamic oracle (Def. 5):\ndyna(c) = oracle(c) for any configuration c."
    }, {
      "heading" : "4.4 Implementation and Complexity",
      "text" : "For any configuration, our dynamic oracle can be computed in amortized constant time since there are only O(n) gold brackets and thus bounding |reach(c)| and the choice of next(c). After each action, next(c) either remains unchanged, or in the case of being crossed by a structural action or mislabeled by a label action, needs to be updated. This update is simply tracing the parent link to the next smallest gold bracket repeatedly until the new bracket encompasses span (i, j). Since there are at most O(n) choices of next(c) and there are O(n) steps, the per-step cost is amortized constant time. Thus our dynamic oracle is much faster than the super-linear time oracle for arc-standard dependency parsing in Goldberg et al. (2014)."
    }, {
      "heading" : "5 Related Work",
      "text" : "Neural networks have been used for constituency parsing in a number of previous instances. For example, Socher et al. (2013) learn a recursive network that combines vectors representing partial trees, Vinyals et al. (2015) adapt a sequence-tosequence model to produce parse trees, Watanabe and Sumita (2015) use a recursive model applying a shift-reduce system to constituency parsing with\nbeam search, and Dyer et al. (2016) adapt the StackLSTM dependency parsing approach to this task. Durrett and Klein (2015) combine both neural and sparse features for a CKY parsing system. Our own previous work (Cross and Huang, 2016) use a recurrent sentence representation in a head-driven transition system which allows for greedy parsing but does not achieve state-of-the-art results.\nThe concept of “oracles” for constituency parsing (as the tree that is most similar to tG among all possible trees) was first defined and solved by Huang (2008) in bottom-up parsing. In transition-based parsing, the dynamic oracle for shift-reduce dependency parsing costs worst-case O(n3) time (Goldberg et al., 2014). On the other hand, after the submission of our paper we became aware of a parallel work (Coavoux and Crabbé, 2016) that also proposed a dynamic oracle for their own incremental constituency parser. However, it is not optimal due to dummy non-terminals from binarization."
    }, {
      "heading" : "6 Experiments",
      "text" : "We present experiments on both the Penn English Treebank (Marcus et al., 1993) and the French Treebank (Abeillé et al., 2003). In both cases, all stateaction training pairs for a given sentence are used at the same time, greatly increasing training speed since all examples for the same sentence share the same forward and backward pass through the recurrent part of the network. Updates are performed in minibatches of 10 sentences, and we shuffle the training sentences before each epoch. The results we report are trained for 10 epochs.\nThe only regularization which we employ during training is dropout (Hinton et al., 2012), which is applied with probability 0.5 to the recurrent outputs. It is applied separately to the input to the second LSTM layer for each sentence, and to the input to the ReLU hidden layer (span features) for each stateaction pair. We use the ADADELTA method (Zeiler, 2012) to schedule learning rates for all weights. All of these design choices are summarized in Table 2.\nIn order to account for unknown words during training, we also adopt the strategy described by Kiperwasser and Goldberg (2016b), where words in the training set are replaced with the unknownword symbol UNK with probability punk = zz+f(w) where f(w) is the number of times the word appears in the training corpus. We choose the parameter z so that the training and validation corpora have approximately the same proportion of unknown words. For the Penn Treebank, for example, we used z = 0.8375 so that both the validation set and the (rest of the) training set contain approximately 2.76% unknown words. This approach was helpful but not critical, improving F1 (on dev) by about 0.1 over training without any unknown words."
    }, {
      "heading" : "6.1 Training with Dynamic Oracle",
      "text" : "The most straightforward use of dynamic oracles to train a neural network model, where we collect all action examples for a given sentence before updating, is “training with exploration” as proposed by Goldberg and Nivre (2013). This involves parsing each sentence according to the current model and using the oracle to determine correct actions for training. We saw very little improvement on the Penn treebank validation set using this method, however. Based on the parsing accuracy on the training sentences, this appears to be due to the model overfitting the training data early during training, thus negating the benefit of training on erroneous paths.\nAccordingly, we also used a method recently proposed by Ballesteros et al. (2016), which specifically addresses this problem. This method introduces stochasticity into the training data parses by randomly taking actions according to the softmax distribution over action scores. This introduces realistic mistakes into the training parses, which we found was also very effective in our case, leading to higher F1 scores, though it noticeably sacrifices\nrecall in favor of precision. This technique can also take a parameter α to flatten or sharpen the raw softmax distribution. The results on the Penn treebank development set for various values of α are presented in Table 3. We were surprised that flattening the distribution seemed to be the least effective, as training accuracy (taking into account sampled actions) lagged somewhat behind validation accuracy. Ultimately, the best results were for α = 1, which we used for final testing."
    }, {
      "heading" : "6.2 Penn Treebank",
      "text" : "Following the literature, we used the Wall Street Journal portion of the Penn Treebank, with standard splits for training (secs 2–21), development (sec 22), and test sets (sec 23). Because our parsing system seamlessly handles non-binary productions, minimal data preprocessing was required. For the part-of-speech tags which are a required input to our parser, we used the Stanford tagger with 10-way jackknifing.\nTable 4 compares test our results on PTB to a range of other leading constituency parsers. Despite being a greedy parser, when trained using dynamic oracles with exploration, it achieves the best F1 score of any closed-set single-model parser."
    }, {
      "heading" : "6.3 French Treebank",
      "text" : "We also report results on the French treebank, with one small change to network structure. Specifically, we also included morphological features for each word as input to the recurrent network, using a small embedding for each such feature, to demonstrate that our parsing model is able to exploit such additional features.\nWe used the predicted morphological features, part-of-speech tags, and lemmas (used in place of word surface forms) supplied with the SPMRL 2014\ndata set (Seddah et al., 2014). It is thus possible that results could be improved further using an integrated or more accurate predictor for those features. Our parsing and evaluation also includes predicting POS tags for multi-word expressions as is the standard practice for the French treebank, though our results are similar whether or not this aspect is included.\nWe compare our parser with other recent work in Table 5. We achieve state-of-the-art results even in comparison to Björkelund et al. (2014), which utilized both external data and reranking in achieving the best results in the SPMRL 2014 shared task."
    }, {
      "heading" : "6.4 Notes on Experiments",
      "text" : "For these experiments, we performed very little hyperparameter tuning, due to time and resource contraints. We have every reason to believe that performance could be improved still further with such techniques as random restarts, larger hidden layers, external embeddings, and hyperparameter grid search, as demonstrated by Weiss et al. (2015).\nWe also note that while our parser is very accurate even with greedy decoding, the model is easily adaptable for beam search, particularly since the parsing system already uses a fixed number of actions. Beam search could also be made considerably more efficient by caching post-hidden-layer feature components for sentence spans, essentially using the precomputation trick described by Chen and Manning (2014), but on a per-sentence basis."
    }, {
      "heading" : "7 Conclusion and Future Work",
      "text" : "We have developed a new transition-based constituency parser which is built around sentence spans. It uses a factored system alternating between structural and label actions. We also describe a fast dynamic oracle for this parser which can determine the optimal set of actions with respect to a gold training tree in an arbitrary state. Using an LSTM model and only a few sentence spans as features, we achieve state-of-the-art accuracy on the Penn Treebank for all parsers without reranking, despite using strictly greedy inference.\nIn the future, we hope to achieve still better results using beam search, which is relatively straightforward given that the parsing system already uses a fixed number of actions. Dynamic programming (Huang and Sagae, 2010) could be especially powerful in this context given the very simple feature representation used by our parser, as noted also by Kiperwasser and Goldberg (2016b)."
    }, {
      "heading" : "Acknowledgments",
      "text" : "We thank the three anonymous reviewers for comments, Kai Zhao, Lemao Liu, Yoav Goldberg, and Slav Petrov for suggestions, Juneki Hong for proofreading, and Maximin Coavoux for sharing their manuscript. This project was supported in part by NSF IIS-1656051, DARPA FA8750-13-2-0041 (DEFT), and a Google Faculty Research Award."
    } ],
    "references" : [ {
      "title" : "Building a treebank for french",
      "author" : [ "Abeillé et al.2003] Anne Abeillé", "Lionel Clément", "François Toussenel" ],
      "venue" : "In Treebanks,",
      "citeRegEx" : "Abeillé et al\\.,? \\Q2003\\E",
      "shortCiteRegEx" : "Abeillé et al\\.",
      "year" : 2003
    }, {
      "title" : "Globally normalized transition-based neural networks",
      "author" : [ "Andor et al.2016] Daniel Andor", "Chris Alberti", "David Weiss", "Aliaksei Severyn", "Alessandro Presta", "Kuzman Ganchev", "Slav Petrov", "Michael Collins" ],
      "venue" : "Proceedings of ACL",
      "citeRegEx" : "Andor et al\\.,? \\Q2016\\E",
      "shortCiteRegEx" : "Andor et al\\.",
      "year" : 2016
    }, {
      "title" : "Improved transition-based parsing by modeling characters instead of words with lstms",
      "author" : [ "Chris Dyer", "Noah A Smith" ],
      "venue" : "arXiv preprint arXiv:1508.00657",
      "citeRegEx" : "Ballesteros et al\\.,? \\Q2015\\E",
      "shortCiteRegEx" : "Ballesteros et al\\.",
      "year" : 2015
    }, {
      "title" : "Training with exploration improves a greedy stack-lstm parser. arXiv preprint arXiv:1603.03793",
      "author" : [ "Yoav Goldberg", "Chris Dyer", "Noah A Smith" ],
      "venue" : null,
      "citeRegEx" : "Ballesteros et al\\.,? \\Q2016\\E",
      "shortCiteRegEx" : "Ballesteros et al\\.",
      "year" : 2016
    }, {
      "title" : "Introducing the ims-wrocław-szeged-cis entry at the spmrl",
      "author" : [ "Ozlem Cetinoglu", "Agnieszka Falenska", "Richárd Farkas", "Thomas Mueller", "Wolfgang Seeker", "Zsolt Szántó" ],
      "venue" : null,
      "citeRegEx" : "Björkelund et al\\.,? \\Q2014\\E",
      "shortCiteRegEx" : "Björkelund et al\\.",
      "year" : 2014
    }, {
      "title" : "Tag, dynamic programming, and the perceptron for efficient, feature-rich parsing",
      "author" : [ "Michael Collins", "Terry Koo" ],
      "venue" : "In Proceedings of the Twelfth Conference on Computational Natural Language Learning,",
      "citeRegEx" : "Carreras et al\\.,? \\Q2008\\E",
      "shortCiteRegEx" : "Carreras et al\\.",
      "year" : 2008
    }, {
      "title" : "A fast and accurate dependency parser using neural networks. In Empirical Methods in Natural Language Processing (EMNLP)",
      "author" : [ "Chen", "Manning2014] Danqi Chen", "Christopher D Manning" ],
      "venue" : null,
      "citeRegEx" : "Chen et al\\.,? \\Q2014\\E",
      "shortCiteRegEx" : "Chen et al\\.",
      "year" : 2014
    }, {
      "title" : "Incremental parsing with minimal features using bi-directional lstm",
      "author" : [ "Cross", "Huang2016] James Cross", "Liang Huang" ],
      "venue" : "Proceedings of ACL",
      "citeRegEx" : "Cross et al\\.,? \\Q2016\\E",
      "shortCiteRegEx" : "Cross et al\\.",
      "year" : 2016
    }, {
      "title" : "Transition-based dependency parsing with stack long short-term memory",
      "author" : [ "Dyer et al.2015] Chris Dyer", "Miguel Ballesteros", "Wang Ling", "Austin Matthews", "Noah A Smith" ],
      "venue" : "Empirical Methods in Natural Language Processing (EMNLP)",
      "citeRegEx" : "Dyer et al\\.,? \\Q2015\\E",
      "shortCiteRegEx" : "Dyer et al\\.",
      "year" : 2015
    }, {
      "title" : "Recurrent neural network grammars",
      "author" : [ "Dyer et al.2016] Chris Dyer", "Adhiguna Kuncoro", "Miguel Ballesteros", "Noah A Smith" ],
      "venue" : "Proceedings of HLT-NAACL",
      "citeRegEx" : "Dyer et al\\.,? \\Q2016\\E",
      "shortCiteRegEx" : "Dyer et al\\.",
      "year" : 2016
    }, {
      "title" : "Training deterministic parsers with nondeterministic oracles. Transactions of the association for Computational Linguistics, 1:403–414",
      "author" : [ "Goldberg", "Nivre2013] Yoav Goldberg", "Joakim Nivre" ],
      "venue" : null,
      "citeRegEx" : "Goldberg et al\\.,? \\Q2013\\E",
      "shortCiteRegEx" : "Goldberg et al\\.",
      "year" : 2013
    }, {
      "title" : "A tabular method for dynamic oracles in transition-based parsing",
      "author" : [ "Francesco Sartorio", "Giorgio Satta" ],
      "venue" : null,
      "citeRegEx" : "Goldberg et al\\.,? \\Q2014\\E",
      "shortCiteRegEx" : "Goldberg et al\\.",
      "year" : 2014
    }, {
      "title" : "Discriminative training of a neural network statistical parser",
      "author" : [ "James Henderson" ],
      "venue" : "In Proceedings of ACL",
      "citeRegEx" : "Henderson.,? \\Q2004\\E",
      "shortCiteRegEx" : "Henderson.",
      "year" : 2004
    }, {
      "title" : "Improving neural networks by preventing co-adaptation of feature detectors. CoRR, abs/1207.0580",
      "author" : [ "Nitish Srivastava", "Alex Krizhevsky", "Ilya Sutskever", "Ruslan Salakhutdinov" ],
      "venue" : null,
      "citeRegEx" : "Hinton et al\\.,? \\Q2012\\E",
      "shortCiteRegEx" : "Hinton et al\\.",
      "year" : 2012
    }, {
      "title" : "Long short-term memory",
      "author" : [ "Hochreiter", "Schmidhuber1997] Sepp Hochreiter", "Jürgen Schmidhuber" ],
      "venue" : "Neural computation,",
      "citeRegEx" : "Hochreiter et al\\.,? \\Q1997\\E",
      "shortCiteRegEx" : "Hochreiter et al\\.",
      "year" : 1997
    }, {
      "title" : "Dynamic programming for linear-time incremental parsing",
      "author" : [ "Huang", "Sagae2010] Liang Huang", "Kenji Sagae" ],
      "venue" : "In Proceedings of ACL",
      "citeRegEx" : "Huang et al\\.,? \\Q2010\\E",
      "shortCiteRegEx" : "Huang et al\\.",
      "year" : 2010
    }, {
      "title" : "Forest reranking: Discriminative parsing with non-local features",
      "author" : [ "Liang Huang" ],
      "venue" : "In Proceedings of the ACL: HLT,",
      "citeRegEx" : "Huang.,? \\Q2008\\E",
      "shortCiteRegEx" : "Huang.",
      "year" : 2008
    }, {
      "title" : "2016a. Easy-first dependency parsing with hierarchical tree lstms",
      "author" : [ "Kiperwasser", "Yoav Goldberg" ],
      "venue" : "arXiv preprint arXiv:1603.00375",
      "citeRegEx" : "Kiperwasser et al\\.,? \\Q2016\\E",
      "shortCiteRegEx" : "Kiperwasser et al\\.",
      "year" : 2016
    }, {
      "title" : "2016b. Simple and accurate dependency parsing using bidirectional LSTM feature representations. CoRR, abs/1603.04351",
      "author" : [ "Kiperwasser", "Yoav Goldberg" ],
      "venue" : null,
      "citeRegEx" : "Kiperwasser et al\\.,? \\Q2016\\E",
      "shortCiteRegEx" : "Kiperwasser et al\\.",
      "year" : 2016
    }, {
      "title" : "Building a large annotated corpus of english: The penn treebank",
      "author" : [ "Mary Ann Marcinkiewicz", "Beatrice Santorini" ],
      "venue" : null,
      "citeRegEx" : "Marcus et al\\.,? \\Q1993\\E",
      "shortCiteRegEx" : "Marcus et al\\.",
      "year" : 1993
    }, {
      "title" : "Reranking and selftraining for parser adaptation",
      "author" : [ "Eugene Charniak", "Mark Johnson" ],
      "venue" : "In Proceedings of the 21st International Conference on Computational Linguistics and the 44th annual meeting of the Associ-",
      "citeRegEx" : "McClosky et al\\.,? \\Q2006\\E",
      "shortCiteRegEx" : "McClosky et al\\.",
      "year" : 2006
    }, {
      "title" : "Shift-reduce constituency parsing with dynamic programming and pos tag lattice",
      "author" : [ "Mi", "Huang2015] Haitao Mi", "Liang Huang" ],
      "venue" : "In Proceedings of the 2015 Conference of the North American Chapter of the Association for Computational Linguistics:",
      "citeRegEx" : "Mi et al\\.,? \\Q2015\\E",
      "shortCiteRegEx" : "Mi et al\\.",
      "year" : 2015
    }, {
      "title" : "Improved inference for unlexicalized parsing",
      "author" : [ "Petrov", "Klein2007] Slav Petrov", "Dan Klein" ],
      "venue" : "In Proceedings of HLT-NAACL",
      "citeRegEx" : "Petrov et al\\.,? \\Q2007\\E",
      "shortCiteRegEx" : "Petrov et al\\.",
      "year" : 2007
    }, {
      "title" : "A best-first probabilistic shift-reduce parser",
      "author" : [ "Sagae", "Lavie2006] Kenji Sagae", "Alon Lavie" ],
      "venue" : "In Proceedings of the COLING/ACL on Main conference poster sessions,",
      "citeRegEx" : "Sagae et al\\.,? \\Q2006\\E",
      "shortCiteRegEx" : "Sagae et al\\.",
      "year" : 2006
    }, {
      "title" : "Introducing the spmrl 2014 shared task on parsing morphologically-rich languages",
      "author" : [ "Seddah et al.2014] Djamé Seddah", "Sandra Kübler", "Reut Tsarfaty" ],
      "venue" : "In Proceedings of the First Joint Workshop on Statistical Parsing of Morphologically Rich Lan-",
      "citeRegEx" : "Seddah et al\\.,? \\Q2014\\E",
      "shortCiteRegEx" : "Seddah et al\\.",
      "year" : 2014
    }, {
      "title" : "Bayesian symbol-refined tree substitution grammars for syntactic parsing",
      "author" : [ "Yusuke Miyao", "Akinori Fujino", "Masaaki Nagata" ],
      "venue" : "In Proceedings of the 50th Annual Meeting of the Association for Computational Linguistics:",
      "citeRegEx" : "Shindo et al\\.,? \\Q2012\\E",
      "shortCiteRegEx" : "Shindo et al\\.",
      "year" : 2012
    }, {
      "title" : "Parsing with compositional vector grammars",
      "author" : [ "John Bauer", "Christopher D Manning", "Andrew Y Ng" ],
      "venue" : "ACL",
      "citeRegEx" : "Socher et al\\.,? \\Q2013\\E",
      "shortCiteRegEx" : "Socher et al\\.",
      "year" : 2013
    }, {
      "title" : "Lstm neural networks for language modeling",
      "author" : [ "Ralf Schlüter", "Hermann Ney" ],
      "venue" : "In INTERSPEECH,",
      "citeRegEx" : "Sundermeyer et al\\.,? \\Q2012\\E",
      "shortCiteRegEx" : "Sundermeyer et al\\.",
      "year" : 2012
    }, {
      "title" : "Sequence to sequence learning with neural networks",
      "author" : [ "Quoc V Le." ],
      "venue" : "Advances in neural information processing systems, pages 3104–3112.",
      "citeRegEx" : "Le.,? 2014",
      "shortCiteRegEx" : "Le.",
      "year" : 2014
    }, {
      "title" : "Optimal shift-reduce constituent parsing with structured perceptron",
      "author" : [ "Thang et al.2015] Le Quang Thang", "Hiroshi Noji", "Yusuke Miyao" ],
      "venue" : null,
      "citeRegEx" : "Thang et al\\.,? \\Q2015\\E",
      "shortCiteRegEx" : "Thang et al\\.",
      "year" : 2015
    }, {
      "title" : "Grammar as a foreign language",
      "author" : [ "Łukasz Kaiser", "Terry Koo", "Slav Petrov", "Ilya Sutskever", "Geoffrey Hinton" ],
      "venue" : "In Advances in Neural Information Processing Systems,",
      "citeRegEx" : "Vinyals et al\\.,? \\Q2015\\E",
      "shortCiteRegEx" : "Vinyals et al\\.",
      "year" : 2015
    }, {
      "title" : "Graph-based dependency parsing with bidirectional lstm",
      "author" : [ "Wang", "Chang2016] Wenhui Wang", "Baobao Chang" ],
      "venue" : "In Proceedings of ACL",
      "citeRegEx" : "Wang et al\\.,? \\Q2016\\E",
      "shortCiteRegEx" : "Wang et al\\.",
      "year" : 2016
    }, {
      "title" : "Transition-based neural constituent parsing",
      "author" : [ "Watanabe", "Sumita2015] Taro Watanabe", "Eiichiro Sumita" ],
      "venue" : "Proceedings of ACL-IJCNLP",
      "citeRegEx" : "Watanabe et al\\.,? \\Q2015\\E",
      "shortCiteRegEx" : "Watanabe et al\\.",
      "year" : 2015
    }, {
      "title" : "Structured training for neural network transition-based parsing",
      "author" : [ "Weiss et al.2015] David Weiss", "Chris Alberti", "Michael Collins", "Slav Petrov" ],
      "venue" : "In Proceedings of ACL",
      "citeRegEx" : "Weiss et al\\.,? \\Q2015\\E",
      "shortCiteRegEx" : "Weiss et al\\.",
      "year" : 2015
    }, {
      "title" : "ADADELTA: an adaptive learning rate method. CoRR, abs/1212.5701",
      "author" : [ "Matthew D. Zeiler" ],
      "venue" : null,
      "citeRegEx" : "Zeiler.,? \\Q2012\\E",
      "shortCiteRegEx" : "Zeiler.",
      "year" : 2012
    }, {
      "title" : "Fast and accurate shift-reduce constituent parsing",
      "author" : [ "Zhu et al.2013] Muhua Zhu", "Yue Zhang", "Wenliang Chen", "Min Zhang", "Jingbo Zhu" ],
      "venue" : "ACL",
      "citeRegEx" : "Zhu et al\\.,? \\Q2013\\E",
      "shortCiteRegEx" : "Zhu et al\\.",
      "year" : 2013
    } ],
    "referenceMentions" : [ {
      "referenceID" : 1,
      "context" : "There has recently been a huge surge of interest in using neural networks to make parsing decisions, and such models continue to dominate the state of the art in dependency parsing (Andor et al., 2016).",
      "startOffset" : 181,
      "endOffset" : 201
    }, {
      "referenceID" : 5,
      "context" : "In constituency parsing, however, neural approaches are still behind the state-of-the-art (Carreras et al., 2008; Shindo et al., 2012; Thang et al., 2015); see more details in Section 5.",
      "startOffset" : 90,
      "endOffset" : 154
    }, {
      "referenceID" : 25,
      "context" : "In constituency parsing, however, neural approaches are still behind the state-of-the-art (Carreras et al., 2008; Shindo et al., 2012; Thang et al., 2015); see more details in Section 5.",
      "startOffset" : 90,
      "endOffset" : 154
    }, {
      "referenceID" : 29,
      "context" : "In constituency parsing, however, neural approaches are still behind the state-of-the-art (Carreras et al., 2008; Shindo et al., 2012; Thang et al., 2015); see more details in Section 5.",
      "startOffset" : 90,
      "endOffset" : 154
    }, {
      "referenceID" : 16,
      "context" : "The latter is significantly more difficult than the former due to F1 being a combination of precision and recall (Huang, 2008), and yet we propose a simple and extremely efficient oracle (amortizedO(1) time).",
      "startOffset" : 113,
      "endOffset" : 126
    }, {
      "referenceID" : 1,
      "context" : "There has recently been a huge surge of interest in using neural networks to make parsing decisions, and such models continue to dominate the state of the art in dependency parsing (Andor et al., 2016). In constituency parsing, however, neural approaches are still behind the state-of-the-art (Carreras et al., 2008; Shindo et al., 2012; Thang et al., 2015); see more details in Section 5. To remedy this, we design a new parsing framework that is more suitable for constituency parsing, and that can be accurately modeled by neural networks. Observing that constituency parsing is primarily focused on sentence spans (rather than individual words, as is dependency parsing), we propose a novel adaptation of the shift-reduce system which reflects this focus. In this system, the stack consists of sentence spans rather than partial trees. It is also factored into two types of parser actions, structural and label actions, which alternate during a parse. The structural actions are a simplified analogue of shift-reduce actions, omitting the directionality of reduce actions, while the label actions directly assign nonterminal symbols to sentence spans. Our neural model processes the sentence once for each parse with a recurrent network. We represent parser configurations with a very small number of span features (4 for structural actions and 3 for label actions). Extending Wang and Chang (2016), each span is represented as the difference of recurrent output from multiple layers in each direction.",
      "startOffset" : 182,
      "endOffset" : 1403
    }, {
      "referenceID" : 16,
      "context" : "Except for the use of spans, this factored approach is similar to the odd-even parser from Mi and Huang (2015). The fact that stack elements do not have to be tree-structured, however, means that we can create productions with arbitrary arity, and no binarization is required either for training or parsing.",
      "startOffset" : 98,
      "endOffset" : 111
    }, {
      "referenceID" : 27,
      "context" : "LSTM models have proved to be a powerful tool for many learning tasks in natural language, such as language modeling (Sundermeyer et al., 2012) and translation (Sutskever et al.",
      "startOffset" : 117,
      "endOffset" : 143
    }, {
      "referenceID" : 30,
      "context" : "LSTMs have also been incorporated into parsing in a variety of ways, such as directly encoding an entire sentence (Vinyals et al., 2015), separately modeling the stack, buffer, and action history (Dyer et al.",
      "startOffset" : 114,
      "endOffset" : 136
    }, {
      "referenceID" : 8,
      "context" : ", 2015), separately modeling the stack, buffer, and action history (Dyer et al., 2015), to encode words based on their character forms (Ballesteros et al.",
      "startOffset" : 67,
      "endOffset" : 86
    }, {
      "referenceID" : 2,
      "context" : ", 2015), to encode words based on their character forms (Ballesteros et al., 2015), and as an element in a recursive structure to combine dependency subtrees with their left and right children (Kiperwasser and Goldberg, 2016a).",
      "startOffset" : 56,
      "endOffset" : 82
    }, {
      "referenceID" : 16,
      "context" : "See Cross and Huang (2016) for more details on this approach.",
      "startOffset" : 14,
      "endOffset" : 27
    }, {
      "referenceID" : 28,
      "context" : "In our experiments, the embeddings are randomly initialized and learned from scratch together with all other network weights, and we would expect further performance improvement from incorporating embeddings pretrained from a large external corpus. The network structure after the the span features consists of a separate multilayer perceptron for each type of action (structural and label). For each action we use a single hidden layer with rectified linear (ReLU) activation. The model is trained on a peraction basis using a single correct action for each parser state, with a negative log softmax loss function, as in Chen and Manning (2014).",
      "startOffset" : 64,
      "endOffset" : 646
    }, {
      "referenceID" : 28,
      "context" : "The baseline method of training our parser is what is known as a static oracle: we simply generate the sequence of actions to correctly parse each training sentence, using a short-stack heuristic (i.e., combine first whenever there is a choice of shift and combine). This method suffers from a well-documeted problem, however, namely that it only “prepares” the model for the situation where no mistakes have been made during parsing, an inevitably incorrect assumption in practice. To alleviate this problem, Goldberg and Nivre (2013) define a dynamic oracle to return the best possible action(s) at any arbitrary configuration.",
      "startOffset" : 76,
      "endOffset" : 536
    }, {
      "referenceID" : 10,
      "context" : "The structure of this framework follows Goldberg et al. (2014).",
      "startOffset" : 40,
      "endOffset" : 63
    }, {
      "referenceID" : 10,
      "context" : "The following two definitions are similar to those for dependency parsing by Goldberg et al. (2014).",
      "startOffset" : 77,
      "endOffset" : 100
    }, {
      "referenceID" : 10,
      "context" : "Thus our dynamic oracle is much faster than the super-linear time oracle for arc-standard dependency parsing in Goldberg et al. (2014).",
      "startOffset" : 112,
      "endOffset" : 135
    }, {
      "referenceID" : 26,
      "context" : "For example, Socher et al. (2013) learn a recursive network that combines vectors representing partial trees, Vinyals et al.",
      "startOffset" : 13,
      "endOffset" : 34
    }, {
      "referenceID" : 26,
      "context" : "For example, Socher et al. (2013) learn a recursive network that combines vectors representing partial trees, Vinyals et al. (2015) adapt a sequence-tosequence model to produce parse trees, Watanabe and Sumita (2015) use a recursive model applying a shift-reduce system to constituency parsing with Network architecture Word embeddings 50 Tag embeddings 20 Morphological embeddings† 10 LSTM layers 2 LSTM units 200 / direction ReLU hidden units 200 / action type",
      "startOffset" : 13,
      "endOffset" : 132
    }, {
      "referenceID" : 26,
      "context" : "For example, Socher et al. (2013) learn a recursive network that combines vectors representing partial trees, Vinyals et al. (2015) adapt a sequence-tosequence model to produce parse trees, Watanabe and Sumita (2015) use a recursive model applying a shift-reduce system to constituency parsing with Network architecture Word embeddings 50 Tag embeddings 20 Morphological embeddings† 10 LSTM layers 2 LSTM units 200 / direction ReLU hidden units 200 / action type",
      "startOffset" : 13,
      "endOffset" : 217
    }, {
      "referenceID" : 11,
      "context" : "In transition-based parsing, the dynamic oracle for shift-reduce dependency parsing costs worst-case O(n3) time (Goldberg et al., 2014).",
      "startOffset" : 112,
      "endOffset" : 135
    }, {
      "referenceID" : 8,
      "context" : "beam search, and Dyer et al. (2016) adapt the StackLSTM dependency parsing approach to this task.",
      "startOffset" : 17,
      "endOffset" : 36
    }, {
      "referenceID" : 8,
      "context" : "beam search, and Dyer et al. (2016) adapt the StackLSTM dependency parsing approach to this task. Durrett and Klein (2015) combine both neural and sparse features for a CKY parsing system.",
      "startOffset" : 17,
      "endOffset" : 123
    }, {
      "referenceID" : 8,
      "context" : "beam search, and Dyer et al. (2016) adapt the StackLSTM dependency parsing approach to this task. Durrett and Klein (2015) combine both neural and sparse features for a CKY parsing system. Our own previous work (Cross and Huang, 2016) use a recurrent sentence representation in a head-driven transition system which allows for greedy parsing but does not achieve state-of-the-art results. The concept of “oracles” for constituency parsing (as the tree that is most similar to tG among all possible trees) was first defined and solved by Huang (2008) in bottom-up parsing.",
      "startOffset" : 17,
      "endOffset" : 550
    }, {
      "referenceID" : 19,
      "context" : "We present experiments on both the Penn English Treebank (Marcus et al., 1993) and the French Treebank (Abeillé et al.",
      "startOffset" : 57,
      "endOffset" : 78
    }, {
      "referenceID" : 0,
      "context" : ", 1993) and the French Treebank (Abeillé et al., 2003).",
      "startOffset" : 32,
      "endOffset" : 54
    }, {
      "referenceID" : 13,
      "context" : "The only regularization which we employ during training is dropout (Hinton et al., 2012), which is applied with probability 0.",
      "startOffset" : 67,
      "endOffset" : 88
    }, {
      "referenceID" : 34,
      "context" : "We use the ADADELTA method (Zeiler, 2012) to schedule learning rates for all weights.",
      "startOffset" : 27,
      "endOffset" : 41
    }, {
      "referenceID" : 13,
      "context" : "The only regularization which we employ during training is dropout (Hinton et al., 2012), which is applied with probability 0.5 to the recurrent outputs. It is applied separately to the input to the second LSTM layer for each sentence, and to the input to the ReLU hidden layer (span features) for each stateaction pair. We use the ADADELTA method (Zeiler, 2012) to schedule learning rates for all weights. All of these design choices are summarized in Table 2. In order to account for unknown words during training, we also adopt the strategy described by Kiperwasser and Goldberg (2016b), where words in the training set are replaced with the unknownword symbol UNK with probability punk = z z+f(w) where f(w) is the number of times the word appears in the training corpus.",
      "startOffset" : 68,
      "endOffset" : 590
    }, {
      "referenceID" : 26,
      "context" : "The most straightforward use of dynamic oracles to train a neural network model, where we collect all action examples for a given sentence before updating, is “training with exploration” as proposed by Goldberg and Nivre (2013). This involves parsing each sentence according to the current model and using the oracle to determine correct actions for training.",
      "startOffset" : 44,
      "endOffset" : 228
    }, {
      "referenceID" : 2,
      "context" : "Accordingly, we also used a method recently proposed by Ballesteros et al. (2016), which specifically addresses this problem.",
      "startOffset" : 56,
      "endOffset" : 82
    }, {
      "referenceID" : 22,
      "context" : "Closed Training & Single Model LR LP F1 Sagae and Lavie (2006) 88.",
      "startOffset" : 22,
      "endOffset" : 63
    }, {
      "referenceID" : 22,
      "context" : "Closed Training & Single Model LR LP F1 Sagae and Lavie (2006) 88.1 87.8 87.9 Petrov and Klein (2007) 90.",
      "startOffset" : 22,
      "endOffset" : 102
    }, {
      "referenceID" : 5,
      "context" : "2 Carreras et al. (2008) 90.",
      "startOffset" : 2,
      "endOffset" : 25
    }, {
      "referenceID" : 5,
      "context" : "2 Carreras et al. (2008) 90.7 91.4 91.1 Shindo et al. (2012) 91.",
      "startOffset" : 2,
      "endOffset" : 61
    }, {
      "referenceID" : 5,
      "context" : "2 Carreras et al. (2008) 90.7 91.4 91.1 Shindo et al. (2012) 91.1 †Socher et al. (2013) 90.",
      "startOffset" : 2,
      "endOffset" : 88
    }, {
      "referenceID" : 5,
      "context" : "2 Carreras et al. (2008) 90.7 91.4 91.1 Shindo et al. (2012) 91.1 †Socher et al. (2013) 90.4 Zhu et al. (2013) 90.",
      "startOffset" : 2,
      "endOffset" : 111
    }, {
      "referenceID" : 5,
      "context" : "2 Carreras et al. (2008) 90.7 91.4 91.1 Shindo et al. (2012) 91.1 †Socher et al. (2013) 90.4 Zhu et al. (2013) 90.2 90.7 90.4 Mi and Huang (2015) 90.",
      "startOffset" : 2,
      "endOffset" : 146
    }, {
      "referenceID" : 5,
      "context" : "2 Carreras et al. (2008) 90.7 91.4 91.1 Shindo et al. (2012) 91.1 †Socher et al. (2013) 90.4 Zhu et al. (2013) 90.2 90.7 90.4 Mi and Huang (2015) 90.7 90.9 90.8 †Watanabe and Sumita (2015) 90.",
      "startOffset" : 2,
      "endOffset" : 189
    }, {
      "referenceID" : 5,
      "context" : "2 Carreras et al. (2008) 90.7 91.4 91.1 Shindo et al. (2012) 91.1 †Socher et al. (2013) 90.4 Zhu et al. (2013) 90.2 90.7 90.4 Mi and Huang (2015) 90.7 90.9 90.8 †Watanabe and Sumita (2015) 90.7 Thang et al. (2015) (A*) 90.",
      "startOffset" : 2,
      "endOffset" : 214
    }, {
      "referenceID" : 5,
      "context" : "2 Carreras et al. (2008) 90.7 91.4 91.1 Shindo et al. (2012) 91.1 †Socher et al. (2013) 90.4 Zhu et al. (2013) 90.2 90.7 90.4 Mi and Huang (2015) 90.7 90.9 90.8 †Watanabe and Sumita (2015) 90.7 Thang et al. (2015) (A*) 90.9 91.2 91.1 †*Dyer et al. (2016) (discrim.",
      "startOffset" : 2,
      "endOffset" : 255
    }, {
      "referenceID" : 5,
      "context" : "2 Carreras et al. (2008) 90.7 91.4 91.1 Shindo et al. (2012) 91.1 †Socher et al. (2013) 90.4 Zhu et al. (2013) 90.2 90.7 90.4 Mi and Huang (2015) 90.7 90.9 90.8 †Watanabe and Sumita (2015) 90.7 Thang et al. (2015) (A*) 90.9 91.2 91.1 †*Dyer et al. (2016) (discrim.) 89.8 †*Cross and Huang (2016) 90.",
      "startOffset" : 2,
      "endOffset" : 296
    }, {
      "referenceID" : 10,
      "context" : "External/Reranking/Combo †Henderson (2004) (rerank) 89.",
      "startOffset" : 26,
      "endOffset" : 43
    }, {
      "referenceID" : 10,
      "context" : "External/Reranking/Combo †Henderson (2004) (rerank) 89.8 90.4 90.1 McClosky et al. (2006) 92.",
      "startOffset" : 26,
      "endOffset" : 90
    }, {
      "referenceID" : 10,
      "context" : "External/Reranking/Combo †Henderson (2004) (rerank) 89.8 90.4 90.1 McClosky et al. (2006) 92.2 92.6 92.4 Zhu et al. (2013) (semi) 91.",
      "startOffset" : 26,
      "endOffset" : 123
    }, {
      "referenceID" : 10,
      "context" : "External/Reranking/Combo †Henderson (2004) (rerank) 89.8 90.4 90.1 McClosky et al. (2006) 92.2 92.6 92.4 Zhu et al. (2013) (semi) 91.1 91.5 91.3 Huang (2008) (forest) 91.",
      "startOffset" : 26,
      "endOffset" : 158
    }, {
      "referenceID" : 10,
      "context" : "External/Reranking/Combo †Henderson (2004) (rerank) 89.8 90.4 90.1 McClosky et al. (2006) 92.2 92.6 92.4 Zhu et al. (2013) (semi) 91.1 91.5 91.3 Huang (2008) (forest) 91.7 †Vinyals et al. (2015) (WSJ)‡ 90.",
      "startOffset" : 26,
      "endOffset" : 195
    }, {
      "referenceID" : 10,
      "context" : "External/Reranking/Combo †Henderson (2004) (rerank) 89.8 90.4 90.1 McClosky et al. (2006) 92.2 92.6 92.4 Zhu et al. (2013) (semi) 91.1 91.5 91.3 Huang (2008) (forest) 91.7 †Vinyals et al. (2015) (WSJ)‡ 90.5 †Vinyals et al. (2015) (semi) 92.",
      "startOffset" : 26,
      "endOffset" : 230
    }, {
      "referenceID" : 10,
      "context" : "External/Reranking/Combo †Henderson (2004) (rerank) 89.8 90.4 90.1 McClosky et al. (2006) 92.2 92.6 92.4 Zhu et al. (2013) (semi) 91.1 91.5 91.3 Huang (2008) (forest) 91.7 †Vinyals et al. (2015) (WSJ)‡ 90.5 †Vinyals et al. (2015) (semi) 92.8 †Durrett and Klein (2015)‡ 91.",
      "startOffset" : 26,
      "endOffset" : 268
    }, {
      "referenceID" : 8,
      "context" : "1 †Dyer et al. (2016) (gen.",
      "startOffset" : 3,
      "endOffset" : 22
    }, {
      "referenceID" : 4,
      "context" : "Parser LR LP F1 Björkelund et al. (2014)∗,‡ 82.",
      "startOffset" : 16,
      "endOffset" : 41
    }, {
      "referenceID" : 4,
      "context" : "Parser LR LP F1 Björkelund et al. (2014)∗,‡ 82.53 Durrett and Klein (2015)‡ 81.",
      "startOffset" : 16,
      "endOffset" : 75
    }, {
      "referenceID" : 4,
      "context" : "Parser LR LP F1 Björkelund et al. (2014)∗,‡ 82.53 Durrett and Klein (2015)‡ 81.25 Coavoux and Crabbé (2016) 80.",
      "startOffset" : 16,
      "endOffset" : 108
    }, {
      "referenceID" : 24,
      "context" : "data set (Seddah et al., 2014).",
      "startOffset" : 9,
      "endOffset" : 30
    }, {
      "referenceID" : 4,
      "context" : "We achieve state-of-the-art results even in comparison to Björkelund et al. (2014), which utilized both external data and reranking in achieving the best results in the SPMRL 2014 shared task.",
      "startOffset" : 58,
      "endOffset" : 83
    }, {
      "referenceID" : 28,
      "context" : "For these experiments, we performed very little hyperparameter tuning, due to time and resource contraints. We have every reason to believe that performance could be improved still further with such techniques as random restarts, larger hidden layers, external embeddings, and hyperparameter grid search, as demonstrated by Weiss et al. (2015). We also note that while our parser is very accurate even with greedy decoding, the model is easily adaptable for beam search, particularly since the parsing system already uses a fixed number of actions.",
      "startOffset" : 45,
      "endOffset" : 344
    }, {
      "referenceID" : 28,
      "context" : "For these experiments, we performed very little hyperparameter tuning, due to time and resource contraints. We have every reason to believe that performance could be improved still further with such techniques as random restarts, larger hidden layers, external embeddings, and hyperparameter grid search, as demonstrated by Weiss et al. (2015). We also note that while our parser is very accurate even with greedy decoding, the model is easily adaptable for beam search, particularly since the parsing system already uses a fixed number of actions. Beam search could also be made considerably more efficient by caching post-hidden-layer feature components for sentence spans, essentially using the precomputation trick described by Chen and Manning (2014), but on a per-sentence basis.",
      "startOffset" : 45,
      "endOffset" : 756
    }, {
      "referenceID" : 16,
      "context" : "Dynamic programming (Huang and Sagae, 2010) could be especially powerful in this context given the very simple feature representation used by our parser, as noted also by Kiperwasser and Goldberg (2016b).",
      "startOffset" : 21,
      "endOffset" : 204
    } ],
    "year" : 2016,
    "abstractText" : "Parsing accuracy using efficient greedy transition systems has improved dramatically in recent years thanks to neural networks. Despite striking results in dependency parsing, however, neural models have not surpassed stateof-the-art approaches in constituency parsing. To remedy this, we introduce a new shiftreduce system whose stack contains merely sentence spans, represented by a bare minimum of LSTM features. We also design the first provably optimal dynamic oracle for constituency parsing, which runs in amortized O(1) time, compared to O(n) oracles for standard dependency parsing. Training with this oracle, we achieve the best F1 scores on both English and French of any parser that does not use reranking or external data.",
    "creator" : "LaTeX with hyperref package"
  }
}