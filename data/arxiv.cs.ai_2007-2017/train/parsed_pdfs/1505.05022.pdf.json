{
  "name" : "1505.05022.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : "Modular Action Language ALM",
    "authors" : [ "DANIELA INCLEZAN", "MICHAEL GELFOND", "Daniela Inclezan" ],
    "emails" : [ "inclezd@MiamiOH.edu)", "michael.gelfond@ttu.edu)" ],
    "sections" : [ {
      "heading" : null,
      "text" : "KEYWORDS: logic programming, reasoning about actions and change, action language"
    }, {
      "heading" : "1 Introduction",
      "text" : "In this paper we introduce a new modular action language, ALM, and illustrate the principles of its use. Our work builds upon the methodology for representing knowledge about discrete dynamic systems introduced by Gelfond and Lifschitz (1993; 1998). In this approach, a system is viewed as a transition diagram whose nodes correspond to possible states of the system and whose arcs are labeled by actions. The diagram is defined by a system description – a collection of statements in a high-level action language expressing the direct and indirect effects of actions as well as their executability conditions (see, for instance, action languages A (Gelfond\nar X\niv :1\n50 5.\n05 02\n2v 2\n[ cs\n.L O\n2 Daniela Inclezan and Michael Gelfond\nand Lifschitz 1993), B (Gelfond and Lifschitz 1998); AL (Turner 1997; Baral and Gelfond 2000); the non-modular extension of AL with multi-valued fluents (Dovier et al. 2007); C (Giunchiglia and Lifschitz 1998); C+ (Giunchiglia et al. 2004); K (Eiter et al. 2004); D (Strass and Thielscher 2012); E (Kakas and Miller 1997); H (Chintabathina et al. 2005; Chintabathina 2012)). Such languages allow concise representations of very large diagrams. In order to reason about the system, its action language description is often translated into a logic program under the answer set semantics (Gelfond and Lifschitz 1988; 1991). This allows for the use of Answer Set Programming (ASP) (Gelfond and Lifschitz 1991; Niemelä 1998; Marek and Truszczynski 1999) to perform complex reasoning tasks such as planning, diagnosis, etc. This methodology was successfully used in a number of interesting medium size applications, but does not seem to be fully adequate for applications requiring a larger body of knowledge about actions and their effects, step-wise design, and multiple use of, possibly previously designed, pieces of knowledge. (The phenomenon is of course well known in Computer Science. Similar considerations led to the early development of notions of subroutine and module in procedural programming. In logic programming, early solutions were based on the concepts of macro and template (Baral et al. 2006; Calimeri and Ianni 2006).) Just a few examples of domains that we consider large enough to benefit from the above-mentioned practices are: the Zoo World and Traffic World examples proposed by Erik Sandewall (Sandewall 1999) and modeled in (Henschel and Thielscher 1999; Akman et al. 2004); the Monkey and Banana Problem by John McCarthy (McCarthy 1963; McCarthy 1968) and formalized in (Erdoǧan and Lifschitz 2006; Erdoǧan 2008); the Missionaries and Cannibals Problem by John McCarthy (McCarthy 1998) represented in (Gustafsson and Kvarnström 2004; Erdoǧan 2008).\nThis inadequacy is due to the fact that most action languages, with some notable exceptions like MAD (Lifschitz and Ren 2006; Erdoǧan and Lifschitz 2006; Desai and Singh 2007) and TAL-C (Gustafsson and Kvarnström 2004), have no built-in features for supporting the description of a domain’s ontology and its objects, and for structuring knowledge and creating knowledge-based libraries. ALM is designed to address these problems. It is based on an earlier action language, AL, introduced in (Gelfond and Inclezan 2009) where it is called ALd , which so far has been the authors’ language of choice (see, for instance, (Gelfond and Kahl 2014)). However, the basic ideas presented in the paper can be used for defining versions of ALM based on other action languages.\nALM has constructs for representing sorts (i.e., classes, kinds, types, categories) of objects relevant to a given domain, their attributes,1 and a subsort relation that can be viewed as a directed acyclic graph (DAG). We refer to this relation as a sort hierarchy. These constructs support a methodology of knowledge representation that starts with determining the sorts of objects in a domain and formulating the domain’s causal laws and other axioms in terms of these sorts. The specialization construct of the language, which corresponds to the links of the sort hierarchy,\n1 Attributes are intrinsic properties of a sort of objects. In ALM they are represented by possibly partial functions defined on elements of that sort.\nModular Action Language ALM 3\nallows to define new sorts (including various sorts of actions) in terms of other, previously defined sorts.\nThe definition of particular objects populating the sorts is usually given only when the domain knowledge is used to solve a particular task, e.g., predicting the effects of some particular sequences of actions, planning, diagnosis, etc.\nIt is worth noting that allowing definitions of actions as special cases of other, previously defined actions was one of the main goals of actions languages like ALM and MAD . Such definitions are not allowed in traditional action languages. ALM’s solution consists in allowing action sorts, which do not exist in MAD . We believe that the ALM solution is simpler than the one in MAD , where special cases of actions are described using import statements (similar to bridge rules in C+). ALM also facilitates the introduction of particular domain objects (including particular actions) that are defined as instances of the corresponding sorts. For example, an action go(bob, london, paris) can be defined as an instance of action sort move with attributes actor , origin, and destination set to bob, london, and paris respectively; action go(bob, paris) is another instance of the same sort in which the origin of the move is absent. Note that, since axioms of the domain are formulated in terms of sorts and their attributes, they are applicable to both of these actions. This is very different from the traditional action language representation of objects as terms, which requires separate axioms for go(bob, london, paris) and go(bob, paris).\nStructuring of knowledge in ALM is supported by the concepts of module, module hierarchy, and library, and by the division of a system description of ALM into two parts: theory and structure. Theories contain declarations of sorts, attributes, and properties of the domain together with axioms describing them, while structures are used to describe the domain’s objects. Rather traditionally, ALM views a module as a formal description of a specific piece of knowledge packaged as a unit. A theory consists of one or more modules with a common theme, possibly organized into a module hierarchy based on a dependency relation. Modules of a theory can be developed and tested independently, which facilitates the reuse of knowledge and stepwise development and refinement (Wirth 1971) of knowledge bases, and increases their elaboration tolerance (McCarthy 1998).\nTheories describing recurrent knowledge may be stored in libraries and used in different applications. The structure part of an ALM system description contains definitions of objects of the domain together with their sorts, values of their attributes, and statics - relations between objects that cannot be changed by actions. If a system description of ALM satisfies some natural consistency requirements and provides complete information about the membership of its objects in the system’s sorts then it describes the unique transition diagram containing all possible trajectories of the system. In this sense ALM is semantically similar to AL. There are also some substantial differences. First, if no complete information about membership of objects in sorts is given, then the system description specifies the collection of transition diagrams corresponding to various possible placements of objects in the system’s sorts. This has no analog in AL. Second, in addition to the semantics of its system descriptions, ALM provides semantics for its theories. Informally,\n4 Daniela Inclezan and Michael Gelfond\na theory of ALM can be viewed as a function taking as an input objects of the domain, their sort membership, and the values of static relations, and returning the corresponding transition diagram – a possible model of the theory. (This definition has some similarity with the notions of module developed for logic programs under the answer set semantics, e.g. (Oikarinen and Janhunen 2006) and (Lierler and Truszczynski 2013). Accurate mathematical analysis of these similarities and their use for automatic reasoning in ALM is a matter for future research.) The availability of a formal semantics clarifies the notion of an ALM theory and allows us to define an entailment relation (T entails q if q is true in every model of T ).\nTo accurately define the semantics of ALM theories, we introduce the notion of a basic action theory (BAT ) — a pair consisting of a specific type of sorted signature (which we call an action signature), and a set of axioms over this signature. An interpretation I of the signature of a BAT theory T defines: objects, their sort membership, and statics; while T can be viewed as a function that takes I as input and returns the transition diagram T (I ) defined by I . In a sense, T (I ) is very similar to system descriptions of AL and other traditional action languages. The difference is in the forms of their signatures and axioms. As in AL, the precise definition of states and transitions of T (I ) is given in terms of its translation into logic programs under the answer set semantics.\nA system description D of ALM can be viewed as a formal definition of a particular BAT theory T , and a class of its interpretations. The latter is given by the structure of D , the former by its theory. If the structure of D is complete, i.e., defines exactly one interpretation I , then D represents T (I ).\nAn earlier version ofALM has been tested in the context of a real-life application, as part of our collaboration on Project Halo. Project Halo is a research effort by Vulcan Inc. aimed towards the development of a Digital Aristotle – “an application containing large volumes of scientific knowledge and capable of applying sophisticated problem-solving methods to answer novel questions” (Gunning et al. 2010). The Digital Aristotle uses the knowledge representation language called SILK (Semantic Inferencing on Large Knowledge) (Grosof et al. 2009), which is based on the well-founded semantics (Van Gelder et al. 1991) and transaction logic with defaults and argumentation theories (Fodor and Kifer 2011). Our first contribution to Project Halo consisted in creating an ALM formalization of an important biological process, cell division (Inclezan and Gelfond 2011). The use of ALM allowed us to create libraries of knowledge and reuse information when representing the cell division domain. As a second step, we created a question answering system capable of answering complex temporal projection questions about this biological process (Inclezan 2010). Our model of cell division represented in the higher level language ALM served as a front end for the question answering system, which was implemented both in ASP and in the language of the Digital Aristotle.\nOur language has evolved since our collaboration on Project Halo. The version of ALM presented here differs from that described in previous papers (Gelfond and Inclezan 2009; Inclezan and Gelfond 2011) in various ways. We simplified and generalized the basic concepts of our language, as well as its syntax and semantics. (We say more about the new features of ALM in the conclusion section of the paper.)\nModular Action Language ALM 5\nThe reasoning in ALM is based on the reduction of temporal projection, planning, diagnosis, etc. to the problem of computing the answer sets of logic programs (for a general description see, for instance, (Baral 2003)) by ASP solvers (see (Niemelä and Simons 1997), (Gebser et al. 2012), or (Leone et al. 2006)).\nThe rest of this paper is organized as follows: we first introduce the concept of basic action theory, which is a fundamental concept in this work. We then describe language ALM and the methodology of ALM’s use. We end with conclusions and future work. There are three appendices containing the grammar of ALM (Appendix A), the description of the use ofALM in Digital Aristotle (Appendix B), and a comparison between ALM and MAD (Appendix C)."
    }, {
      "heading" : "2 Basic Action Theories",
      "text" : "In this section we give the definition of a fundamental concept of ALM called basic action theory (BAT ). A BAT consists of a collection of axioms over a so called action signature — a special type of sorted signature providing suitable vocabulary for representing knowledge about dynamic domains. Sorted signatures needed for our purpose are somewhat atypical. They allow partial functions and contain means for describing a hierarchy of sorts and attributes of their elements. We start with the precise definition of sorted signatures and their interpretations."
    }, {
      "heading" : "2.1 Sorted Signatures and Their Interpretations",
      "text" : "By sorted signature we mean a tuple\nΣ = 〈C,O,H,F〉\nwhere C, O, and F are sets of strings over some fixed alphabet. The strings are used to name sorts, objects, and (possibly partial) functions respectively. Each function symbol f ∈ F is assigned a positive integer n (called f ’s arity), sorts c0, . . . , cn for its parameters, and sort c for its values. We refer to c as the range of f and use the standard mathematical notation f : c0 × . . .× cn → c for this assignment. Finally, H is a sort hierarchy — a directed acyclic graph with two types of nodes: sort nodes labeled by sort names from C, and object nodes labeled by object names from O. Whenever convenient we identify nodes of the hierarchy with their labels. A link from sort c1 to sort c2, denoted by 〈c1, c2〉, indicates that elements of sort c1 are also elements of sort c2. We refer to c2 as a parent of c1. A link from object o to a sort c, denoted by 〈o, c〉, indicates that object o is of sort c. For simplicity, we assume that the graph has exactly one sink node, which corresponds to the sort containing all the elements of the hierarchy. A triple 〈C,O,H〉 will be sometimes referred to as an ontology.\nSorts, object constants, and functions of a sorted signature are normally parti-\ntioned into user-defined, pre-defined, and special.\nThe collection of pre-defined symbols may include names for some commonly used sorts and functions, such as: sorts booleans and integers; a sort [m..n] for every pair of natural numbers m and n such that m < n, denoting the set of\n6 Daniela Inclezan and Michael Gelfond\nnatural numbers in the closed interval [m,n]; standard object constants true, false, 0, 1, 2, etc., denoting elements of these sorts; standard arithmetic functions and relations +, −, ∗, /, mod , <, ≤, etc. (The list is not exhaustive. When needed we may introduce other similar symbols.) All these symbols are pre-interpreted, i.e., come with their usual mathematical interpretations.\nThe collection of special symbols consists of:\n• sorts and function symbols pertinent to sort hierarchies of sorted signatures:\n— Sort nodes denoting the collection of sorts labeling the sort nodes of H. This sort is never used as a label of a node in H.\n— Sort object constants denoting the collection of constants labeling the\nobject nodes of H. This sort is never used as a label of a node in H. — Sort universe denoting the collection of elements of sorts from H. — Function symbol link : nodes × nodes → booleans where link(c1, c2)\nreturns true iff H contains a link from sort c1 to sort c2. — Function symbol is a : universe × nodes → booleans where is a(x , c)\nreturns true if c is a source node of H (i.e., c has no subsorts in H) and object x from the universe is of the sort denoted by c. — Function symbol instance : universe × nodes → booleans denoting the membership relation between objects of the universe and the sorts of\nthe domain. This function will be later defined in terms of function is a. — Function symbols subsort : nodes × nodes → booleans, has child , has parent , sink , source : nodes → booleans describing properties of sorts of H and their members. All these functions (with their self-explanatory meaning) will be later defined in terms\nof function link .\n• Function symbol domf : c0 × . . . × cn → booleans (read as domain of f ) for every user-defined function symbol f : c0 × . . .× cn → c with n > 0.\nTerms of a sorted signature are defined as usual:\n• A variable and an object constant is a term. • If f : c0 × . . . × cn → c is a function symbol and t0, . . . , tn are terms then\nf (t0, . . . , tn) is a term.\nExpressions of the form\nt1 = t2 and t1 6= t2 (1)\nare called literals. Positive literals are also referred to as atoms. (For simplicity of presentation we use standard shorthands and write t and ¬t instead of t = true and t = false, respectively; 3 ≤ 5 instead of ≤ (3, 5); etc.) Terms and literals not containing variables are called ground. Our notion of an interpretation of a sorted signature is slightly different from the traditional one.\nModular Action Language ALM 7\nDefinition 1 (Interpretation) An interpretation I of Σ consists of\n• A non-empty set |I| of strings called the universe of I. • An assignment that maps\n— every user-defined sort c of H into a subset I(c) of |I| and user defined object constant o into an element from |I|; — every user-defined function symbol f : c0 × . . . × cn → c of Σ into a (possibly partial) function I(f ) : I(c0)× . . .× I(cn)→ I(c); — the special function is a into function I(is a) such that: – for every x ∈ |I| and every sort c of H, I(is a)(x , c) is true iff c is\na source node of H and x ∈ I(c) and – for every object o and sort c of H, I(is a)(I(o), c) is true iff 〈o, c〉 ∈ H;\n— the special function link into function I(link) such that for every two sort nodes c1, c2, I(link)(c1, c2) is true iff 〈c1, c2〉 ∈ H; — the special function domf for user-defined function f : c0× . . .× cn → c into function I(domf ) such that for every x̄ ∈ I(c0) × . . . × I(cn), I(domf )(x̄ ) is true iff x̄ belongs to the domain of I(f ).\n• On pre-defined symbols, I is identified with the symbols’ standard interpretations.\nAn interpretation I of Σ can be naturally extended to ground terms: if I is defined on terms t1, . . . , tn and I(f ) is defined on the tuple (I(t1), . . . , I(tn)) then\nI(f (t1, . . . , tn)) =def I(f )(I(t1), . . . , I(tn))·\nOtherwise I(f (t1, . . . , tn)) is undefined.\nFinally, we say that an atom t1 = t2 is\n• true in I if both I(t1) and I(t2) are defined and have the same value; • false in I if both I(t1) and I(t2) are defined and have different values; and • undefined in I otherwise.\nSimilarly, a literal t1 6= t2 is true in I if t1 = t2 is false in I; it is false in I if t1 = t2 is true in I; and undefined otherwise.\nNote that every interpretation I can be uniquely represented by the collection of atoms that are true in this interpretation. For instance, for every sort c of H, I(c) can be represented as the set {instance(o, c) : I(o) ∈ I(c)}; for a unary function f , I(f ) can be viewed as the set {f (x ) = y : I(x ) ∈ I(domf ) and I(f )(I(x )) = I(y)}, etc.\n2.2 Action Signature and Axioms of a BAT\nSince ALM is a language for specifying properties of actions, in what follows we limit ourselves to action signatures — sorted signatures that\n8 Daniela Inclezan and Michael Gelfond\n• contain a special sort actions and • have their user-defined and special function symbols divided into three dis-\njoint categories: attributes, statics, and fluents. Attributes describe intrinsic properties of objects of a given sort; statics and fluents describe relations between objects. Values of attributes and statics are constants – they cannot be changed by actions. The values of fluents can. Both statics and fluents are further divided into basic and defined. The latter are total boolean functions that can be defined in terms of the former. They are used primarily for the brevity of representation.\nA literal (atom) in which f is an attribute is called an attribute literal (atom). Similarly for static and fluent literals that are, in turn, divided into basic and defined. We assume that all special functions of an action signature, except domf , are defined statics; domf is a basic fluent when f is a basic fluent and a defined static otherwise. Since the semantics of ALM will be defined in terms of a version of ASP with function symbols, ASP{f} (Balduccini 2013), which does not allow terms with nested user-defined functions, we limit atoms of an action signature to those constructed from terms with at most one user-defined function symbol. (This is not a serious limitation and can easily be avoided by viewing nested terms as shorthands.)\nWe can now define the syntax and informal semantics of statements of a BAT over a fixed action signature Σ. Variables in these statements are universally quantified.\nDefinition 2 (Statements of a BAT ) • A dynamic causal law is an expression of the form\noccurs(a) causes f (x̄ ) = o if instance(a, c), cond (2)\nwhere a and o are variables or object constants, f is a basic fluent, c is the sort actions or a subsort of it, and cond is a collection of literals. The law says that an occurrence of an action a of the sort c in a state satisfying property cond causes the value of f (x̄ ) to become o in any resulting state.\n• A state constraint is an expression of the form\nf (x̄ ) = o if cond (3)\nwhere o is a variable or an object constant, f is any function except a defined function, and cond is a collection of literals. The law says that the value of f (x̄ ) in any state satisfying condition cond must be o. Additionally, f (x̄ ) = o can also be replaced by the object constant false, in which case the law says that there is no state satisfying condition cond .\n• The definition of a defined function p is an expression of the form\np(t1) if cond1 . . . p(tk ) if condk\n(4)\nwhere ts are sequences of terms, and cond1, . . . , condk are collections of literals. Moreover, if p is a static then cond1, . . . , condk can not contain fluent\nModular Action Language ALM 9\nliterals. Statements of the definition will be often referred to as its clauses. The statement says that, for every Y , p(Y ) is true in a state σ iff there is\n1 ≤ m ≤ k such that statements condm and tm = Y are true in σ. • An executability condition for actions is an expression of the form\nimpossible occurs(a) if instance(a, c), cond (5)\nwhere a is a variable or an object constant, c is the sort actions or a subsort of it, and cond is a collection of literals and expressions of the form occurs(t) or ¬occurs(t) where t is a variable or an object constant of the sort actions. The law says that an occurrence of an action a of the sort c is impossible when condition cond holds.\nDynamic causal laws and constraints will be sometimes referred to as causal laws. We use the term head to refer to l in (2) and (3), and to any of the p(ti), 1 ≤ i ≤ k , in (4). We call body the expression to the right of the keyword if in statements (2), (3), (5), or in any of the statements of (4). Statements not containing variables will be referred to as ground.\nDefinition 3 (Basic Action Theory – BAT ) A Basic Action Theory (BAT ) is a pair consisting of an action signature Σ and a collection T of statements over Σ (called axioms of the theory) such that:\n• If f is a basic fluent then\n— T contains a state constraint:\ndomf (X0, . . . ,Xn) if f (X0, . . . ,Xn) = Y (6)\n— No dynamic causal law of T contains an atom formed by domf in the\nhead.\n• If f is a defined fluent, a static, or an attribute then T contains the definition:\ndomf (X0, . . . ,Xn) if f (X0, . . . ,Xn) = Y (7)\n• T contains definitions of special statics of the hierarchy given in terms of functions is a and link :\ninstance(O ,C ) if is a(O ,C )\ninstance(O ,C2) if instance(O ,C1), link(C1,C2)\nhas child(C2) if link(C1,C2) has parent(C1) if link(C1,C2)\nsource(C ) if ¬has child(C ) sink(C ) if ¬has parent(C )\nsubsort(C1,C2) if link(C1,C2) subsort(C1,C2) if link(C1,C ), subsort(C ,C2)\n(8)\nTo simplify the notation, in what follows we will often identify a theory with the collection of its axioms. Axioms (6)–(8) above are self-explanatory, with the possible exception of the restriction prohibiting the appearance of domf in the head of dynamic causal laws. To understand the latter requirement it is sufficient to notice\n10 Daniela Inclezan and Michael Gelfond\nthat it is not enough to include object O in the domain of basic fluent f — it is also necessary to specify the value of f (O). Otherwise the causal law making domf (O) true would become non-deterministic,2 which is not allowed in the current version of ALM. The presence of a law assigning a value to f (O) makes dynamic causal laws with domf in the head unnecessary. It is however useful to allow dynamic causal laws with ¬domf (O) in the head as a simple way of removing O from the domain of f .\nThe following is an example of a basic action theory.\nExample 1 (A Basic Action Theory T 0) Let us consider an action signature Σ0 with three sorts, c1, c2 and c3, the special sorts universe and actions, and the pre-defined sort booleans, organized in a hierarchy H0 in which universe is the parent of c1, c1 is the parent of c2, c3, actions, and booleans, and object constant o is of sort c3; attributes attr1, attr2 : actions → c3;\nbasic fluents f , g : c2 → c3; and special functions like link , is a, domf , domg . The hierarchy H0 can be seen in Figure 1, but we omitted from the picture the sort universe whose only child is c1. The basic action theory T 0 over Σ0 consists of the causal laws\noccurs(A) causes f (X ) = Y if instance(A, actions),\nattr1(A) = Y , g(X ) = o\noccurs(A) causes ¬domf (X ) if instance(A, actions), attr2(A) = o false if ¬domg(X ), instance(X , c2).\nThe third axiom requires function g to be total.\nIn addition, T 0 contains standard BAT axioms:\n2 To see why, consider, for instance, a basic fluent f declared as f : {0, 1} → {0, 1} and a dynamic causal law “occurs(a) causes domf (1).” Intuitively, the axiom says that after a is executed f (1) must be defined, i.e., f (1) = 0 or f (1) = 1, which is non-deterministic.\nModular Action Language ALM 11\nState constraints for the basic fluents:\ndomf (X ) if f (X ) = Y domg(X ) if g(X ) = Y\nDefinitions for the domains of attributes:\ndomattr1(X ) if attr1(X ) = Y domattr2(X ) if attr2(X ) = Y\nand the collection of axioms from (8).\n2.3 Semantics of BAT s\nIntuitively, a basic action theory T defines the collection of discrete dynamic systems satisfying its axioms. The semantics of T will describe such systems by specifying their transition diagrams, often referred to as models of T . Nodes of a transition diagram represent possible states of the dynamic system; arcs of the diagram are labeled by actions. A transition 〈σ0, a, σ1〉 says that the execution of action a in state σ0 may take the system to state σ1.\nA state of the diagram will be defined by the universe — a collection of objects of the sorts of T , and by a physically possible assignment of values to T ’s functions. Moreover, we assume that the sorted universe and the values of statics and attributes are the same in all states, i.e., states only differ by the values of fluents.\nTo make this precise it is convenient to partition an interpretation I of an action signature Σ into two parts: fluent part consisting of the universe of I and the restriction of I on the sets of fluents, and static part consisting of the same universe and the restriction of I on the remaining elements of the signature. Sometimes we will refer to the latter as a static interpretation of Σ.\nWe also need the following notation: Given an action signature Σ and a collection U of strings in some fixed alphabet, we denote by ΣU the signature obtained from Σ by expanding its set of object constants by elements of U , which we assume to be of sort universe.\nDefinition 4 (Pre-model) Let T be a basic action theory with signature Σ and U be a collection of strings in some fixed alphabet. A static interpretation M of ΣU is called a pre-model of T (with the universe U ) if M(universe) = U and for every object constant o of ΣU that is not an object constant of Σ, M(o) = o.\nGiven a pre-model M with the universe U we will often denote signature ΣU by ΣM.\nTo illustrate this notion let us consider a pre-model of theory T from Example\n1:\nExample 2 (A pre-model of Basic Action Theory T 0) To define a pre-model of basic action theory T 0 from Example 1 let us consider a static interpretation M with the universe UM = {x , y , z , a, b, true, false} such that:\n12 Daniela Inclezan and Michael Gelfond\nM(universe) =M(c1) = {x , y , z , a, b, true, false}; M(c2) = {x}; M(c3) = {y , z}, M(actions) = {a, b}; M(o) = {y}; and M(attr1)(a) =M(attr2)(b) = y .\nIn addition: every symbol from UM is added to Σ 0 U and mapped into itself; domattr1 = {a}, domattr2 = {b}; the interpretation of special function link is determined by the hierarchy from Figure 1; the interpretation of is a is extracted from the interpretation of the hierarchy’s sorts. Clearly, M satisfies the conditions in Definition 4 and hence is a pre-model of T 0.\nA pre-model M of T uniquely defines a model TM of T if such a model exists. The definition of TM will be given in two steps: first we define TM’s states and then its transitions.\nIntuitively, if theory T does not contain definitions, then a state of TM is an interpretation I with static part M that satisfies the state constraints of T . The situation is less simple for theories containing definitions (especially recursive ones). Similar to the case of AL, the definition of a state will be given using logic programs under the answer set semantics; specifically, we will use logic programs with nonHerbrand partial functions in the language ASP{f} (Balduccini 2013).3\nLet M be a pre-model of action theory T .\nProgram SM:\nBy SM we denote a logic program that consists of:\na) rules obtained from the state constraints and definitions of T by replacing\nvariables with properly typed object constants of ΣM, replacing object constants with their corresponding interpretations in M, removing the constant false from the head of state constraints, and replacing the keyword if with\n←, b) the Closed World Assumption:\n¬d(t0, . . . , tn)← not d(t0, . . . , tn)\nfor every defined function d : c0 × . . . × cn → booleans and ti ∈ M(ci), 0 ≤ i ≤ n.\nend of SM:\nFinally, we define a program SI used in the definition of states of the transition\ndiagram defined by M.\nProgram SI :\n3 Other approaches for introducing non-Herbrand functions in ASP can be seen, for instance, in (Cabalar 2011; Lifschitz 2012; Bartholomew and Lee 2013).\nModular Action Language ALM 13\nFor every interpretation I of Σ with static part M, by SI we denote the logic program obtained by adding to SM the set of atoms obtained from I by removing the defined atoms.\nend of SI\nDefinition 5 (State) Let M be a pre-model of a BAT theory T . An interpretation σ with static part M is a state of the transition diagram TM defined by M if σ is the only answer set of Sσ.\nNotice that σ is not a state if Sσ has multiple answer sets, a situation that would only occur when the value of some defined function is not completely determined by the values of basic functions. We will return to this issue later, in Section 4.2.\nExample 3 (States of the diagram) Let M be the pre-model of theory T 0 from Example 2. The program SM for this M looks as follows:\n← ¬domg(x ), instance(x , c2)\ndomf (x )← f (x ) = y domf (x )← f (x ) = z domg(x )← g(x ) = y domg(x )← g(x ) = z\ndomattr1(a)← attr1(a) = y domattr1(a)← attr1(a) = z domattr2(a)← attr2(a) = y domattr2(a)← attr2(a) = z domattr1(b)← attr1(b) = y domattr1(b)← attr1(b) = z domattr2(b)← attr2(b) = y domattr2(b)← attr2(b) = z\nand the Closed World Assumptions for the special functions. Recall that, according to the definition of an interpretation of a sorted signature, for every x ∈ |I|, I(is a)(x , c) is true iff c is a source node of the sort hierarchy and I(x ) ∈ I(c), and for every object o and sort c, I(is a)(I(o), c) is true iff 〈o, c〉 is a link in our hierarchy. This, together with the condition on the interpretation of link guarantees that every state of TM contains atoms is a(x , c2), is a(y , c3), and other atoms formed by is a and link that define our hierarchy. The collection of these atoms together with the closed world assumptions for is a, link and the other defined statics uniquely determine their values. It is easy to check that every state of M contains literals formed by these special fluents. Every state of TM also contains attr1(a) = y , attr2(b) = y , and domg(x ). Overall, TM has the following six states (for each state, we only show non-special fluents):\nσ1 = {f (x ) = y , g(x ) = y} σ2 = {f (x ) = z , g(x ) = y} σ3 = {f (x ) = y , g(x ) = z} σ4 = {f (x ) = z , g(x ) = z} σ5 = {g(x ) = y} σ6 = {g(x ) = z}·\n14 Daniela Inclezan and Michael Gelfond\nIn addition, states σ1, σ2, σ3, and σ4 contain domf (x ) while states σ5 and σ6, in which f is undefined on x , contain ¬domf (x ).\nTo define transitions of the diagram that corresponds to a pre-modelM with the universe U , we construct a logic program PM whose signature is obtained from the signature of program SM defined above by\n• adding a new sort, step, ranging over 0 and 1; • replacing every fluent f : c0 × . . .× cn → c by function\nf : c0 × . . .× cn × step → c; • adding a function symbol occurs : actions × step → booleans.\nProgram PM:\nProgram PM is obtained from a theory T and pre-model M by\na) replacing variables by properly typed object constants of ΣM; b) replacing object constants by their corresponding interpretations in M; c) removing the object constant false from the head of state constraints; d) replacing every occurrence of a fluent term f (t) in the head of a dynamic\ncausal law by f (t , I + 1);\ne) replacing every other occurrence of a fluent term f (t) by f (t , I ); f) removing “occurs(a) causes” from every dynamic causal law and adding\noccurs(a) to the body;\ng) replacing “impossible occurs(a)” in every executability condition by ¬occurs(a); h) replacing occurs(a) by occurs(a, I ) and ¬occurs(a) by ¬occurs(a, I ); i) replacing the keyword if by ←; j) adding the Closed World Assumption:\n¬d(t0, . . . , tn , I )← not d(t0, . . . , tn , I )\nfor every defined fluent d : c0×. . .×cn → booleans and ti ∈M(ci), 0 ≤ i ≤ n; k) adding the rule:\n¬f (t0, . . . , tn)← not f (t0, . . . , tn) for every defined static of the form f : c0×. . .×cn → booleans and ti ∈M(ci), 0 ≤ i ≤ n;\nl) adding the Inertia Axiom:\ndomf (t0, . . . , tn , I + 1) ← domf (t0, . . . , tn , I ), not ¬domf (t0, . . . , tn , I + 1) ¬domf (t0, . . . , tn , I + 1) ← ¬domf (t0, . . . , tn , I ), not domf (t0, . . . , tn , I + 1)\nfor every basic fluent domf : c0 × . . . × cn → booleans, and ti ∈ M(ci), 0 ≤ i ≤ n;\nm) adding the Inertia Axiom:\nf (t0, . . . , tn , I + 1) = t ← domf (t0, . . . , tn , I + 1), f (t0, . . . , tn , I ) = t ,\nnot f (t0, . . . , tn , I + 1) 6= t\nModular Action Language ALM 15\nfor every basic fluent f : c0×. . .×cn → c not formed by dom, and ti ∈M(ci), 0 ≤ i ≤ n, and t ∈M(c).\nend of PM\nNote that the last axiom is a modification of the standard logic programming version of the Inertia Axiom (see, for instance, (Gelfond and Kahl 2014)), which is stated for total (boolean) functions. The main difference is the addition of the domain statements in the body. The inertia axiom for the function domf is of the standard form.\nProgram P(M, σ0, a): Let σ0 be a state of the transition diagram defined by a premodel M, and let a ⊆ M(actions). By P(M, σ0, a) we denote the logic program formed by adding to PM the set of atoms obtained from σ0 by replacing every fluent atom f (t0, . . . , tn) = t by f (t0, . . . , tn , 0) = t and adding the set of atoms {occurs(x , 0) : x ∈ a}. end of P(M, σ0, a)\nDefinition 6 (Transition) Let σ0 and σ1 be states of the transition diagram defined by a pre-model M and let a ⊆M(actions). The triple 〈σ0, a, σ1〉 is a transition of the transition diagram defined by a pre-model M of a BAT theory T if program P(M, σ0, a) has an answer set A such that f (t0, . . . , tn) = t ∈ σ1 iff\n• f is an attribute or a static and f (t0, . . . , tn) = t ∈ A, or • f is a fluent and f (t0, . . . , tn , 1) = t ∈ A.\nDefinition 7 (Model) A transition diagram TM defined by a pre-model M of a basic action theory T is called a model of T if it has a non-empty collection of states.\nThe following example illustrates the definition.\nExample 4 (A Model of Basic Action Theory T 0) To define a model of theory T 0 from Example 1 let us consider the pre-model M from Example 2. States of the diagram defined by this pre-model were given in Example 3. To define the transitions of the model defined by M we use Definition 6. Let us illustrate this by showing that a triple 〈σ1, b, σ5〉 is a transition. To do that we need first to construct a program P(M, σ1, b) (we are only showing rules relevant to our argument):\n[1] f (x , 1) = y ← instance(b, actions), occurs(b, 0),\nattr1(b) = y , g(x , 0) = y .\n[2] ¬domf (x , 1) ← instance(b, actions), occurs(b, 0),\nattr2(b) = y .\n16 Daniela Inclezan and Michael Gelfond\n[3] domf (x , 0)← f (x , 0) = y . domf (x , 1)← f (x , 1) = y . domg(x , 0)← g(x , 0) = y . domg(x , 1)← g(x , 1) = y .\n[4] f (x , 1) = y ← domf (x , 1), f (x , 0) = y ,\nnot f (x , 1) 6= y .\ng(x , 1) = y ← domg(x , 1), g(x , 0) = y ,\nnot g(x , 1) 6= y .\n[5] domf (x , 1) ← domf (x , 0), not ¬domf (x , 1).\ndomg(x , 1) ← domg(x , 0), not ¬domg(x , 1).\n[6] f (x , 0) = y .\ng(x , 0) = y . occurs(b, 0).\nIt is easy to see that the program has a unique answer set, say, S . Since σ5 = {g(x ) = y} we need to show that the only fluent atom with the step parameter 1 belonging to S is g(x , 1) = y . By the second rule from group [5], domg(x , 1) ∈ S . By the second rule of [4] we have that g(x , 1) = y ∈ S . As expected, function g maintains its value by inertia. The situation is different for f . By rule [2] we have that ¬domf (x , 1) ∈ S and hence neither rule [5] nor [4] for f are applicable. Rule [1] is also not applicable since attr1 is not defined for b. Therefore the state defined by S is exactly σ5 = {g(x ) = y}. (Note that the argument would not be possible if we were to use the traditional version of the Inertia Axiom. The modification related to the treatment of dom presented in axioms [4] and [5] is essential.)\nUsing the same method one can easily verify that triples 〈σ2, a, σ1〉, 〈σ5, a, σ1〉, 〈σ5, b, σ5〉, etc. are transitions of the transition diagram defined by M."
    }, {
      "heading" : "2.4 Entailment Relation",
      "text" : "Let us consider a fixed action theory T with action signature Σ, and define an entailment relation between T and statements of Σ.\nLet I be an interpretation of Σ. A ground instance of a statement α of Σ with respect to I is a statement obtained by replacing variables of α by properly typed object constants in ΣI and replacing object constants of α by their interpretations in I.\nNow let us consider a model TM of a basic action theory T defined by a pre-model\nM with the universe U and let σ be a state of TM.\nModular Action Language ALM 17\nDefinition 8 (Satisfiability Relation for Ground Statements of a BAT ) • A state σ of TM satisfies a ground state constraint α if σ contains the head\nof α whenever it contains its body.\n• A state σ of TM satisfies a ground definition α if σ contains the head of a clause in α iff α contains a clause with the same head and the body belonging\nto σ.\n• A transition 〈σ0, a, σ1〉 of TM satisfies a ground dynamic causal law α that starts with the expression “occurs(e) causes” if a contains action e and σ1 contains the head of α whenever σ0 contains its body. • A transition 〈σ0, a, σ1〉 of TM satisfies a ground executability condition α that starts with the expression “impossible e” if either (1) a does not contain e\nor (2) the body of α contains:\n— a ground literal l such that l /∈ σ0, or — an expression “occurs(e1)” such that e1 /∈ a, or — an expression “¬occurs(e2)” such that e2 ∈ a.\nDefinition 9 (Satisfiability Relation for Arbitrary Statements of a BAT ) Let TM be a model of a basic action theory T defined by a pre-modelM with the universe U .\n• TM satisfies a constraint α over signature Σ of T if every state of TM satisfies all ground instances of α with respect to U . Similarly for definitions. • TM satisfies a dynamic causal law α over signature Σ of T if every transition of TM satisfies all ground instances of α with respect to U . Similarly for\nexecutability conditions.\nDefinition 10 (Entailment) A statement α is entailed by a theory T (T |= α) if α is true in every model of T .\nHaving the notion of entailment allows us to investigate the relationship between causal laws. For instance we can show that\n{occurs(A) causes f if p, q ; occurs(A) causes f if ¬p} |= occurs(A) causes f if q\n{occurs(A) causes f if p, q ; q if p} |= occurs(A) causes f if p etc. Our notion of entailment is somewhat similar to the notion of subsumption from (Eiter et al. 2010) – a relation between an action description and a query (including queries having the form of causal laws and executability conditions). Our entailment relation can be viewed as a generalization of subsumption from system descriptions to theories. It allows variables and, unlike that of subsumption, is defined in terms of multiple transition diagrams specified by the theory. There are also related formalisms that allow entailment of causal laws and executability conditions (see, for instance (Turner 1999) and (Giunchiglia et al. 2004)). There are many interesting problems related to the ALM entailment, including that of finding a sound and complete set of inference rules for it. We hope to address these problems in our future work.\n18 Daniela Inclezan and Michael Gelfond\n3 Language ALM\nIn this section we use examples to introduce the syntax of theories and system descriptions ofALM and define their semantics. (The full grammar for the language can be seen in Appendix A.)\nWe begin with describing unimodule system descriptions, i.e. system descriptions\nwhose theories consist of exactly one module."
    }, {
      "heading" : "3.1 Unimodule System Descriptions",
      "text" : "We start with a comparatively simple problem of formalizing the domain described by the following story:\nExample 5 (A Travel Domain) Consider a travel domain in which there are two agents, Bob and John, and three locations, New York, Paris, and Rome. Bob and John can move from one location to another if the locations are connected.\nIf we were to represent this knowledge in AL we would start with identifying objects of the domain including actions such as, say, go(bob, paris, rome) and write AL axioms describing the relationships between these objects. The use of ALM suggests a very different methodology.\nMethodology of Describing Dynamic Domains in ALM:\n1. Determine what sorts of objects are relevant to the domain of discourse and\nhow these sorts can be organized into an inheritance hierarchy.\n2. Use ALM to describe the basic action theory for this type of domains. This should be done in two steps:\n• Describe the action signature of our abstraction by declaring sorts (together with their attributes and the inheritance hierarchy), basic and\ndefined statics and fluents. (Notice that this signature normally will not contain particular objects of our story. It would have no mention of Bob, Paris, etc. However, the signature may include some object constants pertinent to the general domain of the story – see for instance the Monkey and Banana Problem in Section 4.1.)\n• Use this action signature to formulate axioms of the theory.\n3. Populate sorts of your hierarchy with objects relevant to your story and de-\nscribe these objects and their sort membership in ALM.\nAs is the case with other problem solving methodologies, we begin by choosing a proper level of abstraction for our example. Since the example is used for illustrative purposes we opted for using the following simple abstraction:\nOur domains will contain things and discrete points in space. Certain things, called agents, will be able to move from one point to another if the two points are connected. We are interested in the relations between points and the locations of things, including changes of these locations caused by a sequence of given moves.\nModular Action Language ALM 19\n(Note that our abstraction does not allow a location to be a part of another location, e.g., we will not be able to express that Paris is located in France. It ignores the means of transportation, the possibility that locations may have restrictions on the number of things they can contain, etc.)\nAccordingly, our basic action theory containing commonsense knowledge about motion formulated in these terms will include sorts things, agents, points, and move, together with special sorts universe and actions, which belong to every action signature.\nWe call this basic action theory Tbm . The sorts of Tbm will be organized in a\nhierarchy depicted in Figure 2.\nOur next step is to describe Tbm in ALM.\nExample 6 (Motion Theory in ALM) The description of a theory in ALM starts with the keyword theory and is followed by a collection of modules. Our theory, called basic motion, consists of only one module moving\ntheory basic motion\nmodule moving\n〈module body〉\nwhere 〈module body〉 stands for the declarations of sorts, functions, and axioms of the theory. We assume that things, points, and agents have no attributes, while actions from the sort move may come with attribute actor indicating the agent involved in the action, and attributes origin and destination (abbreviated as dest) describing the locations of the actor before and after the execution of the action. Syntactically, all this information is specified as:\nsort declarations\npoints, things :: universe agents :: things\n20 Daniela Inclezan and Michael Gelfond\nmove :: actions\nattributes\nactor : agents origin : points dest : points\nThe construct :: is called specialization and corresponds to the links of the sort hierarchy; for instance, the link from agents to things in Figure 2 is recorded by the statement agents :: things. Multiple links going into the same sort can be recorded by a single statement, as in points, things :: universe. Note that the special sorts universe and actions do not have to be declared. In case of a sort hierarchy with multiple links from c to pc1, . . . , pck we will use a specialization statement of the form c :: pc1, . . . , pck . In describing the attributes of actions of the sort move we use a shorthand. Attributes of move are functions defined on elements of the sort move, which means that the definition of, say, attribute actor should be written as actor : move → agents. After some deliberation however, we decided to allow to write it simply as actor : agents. The same agreement holds for attributes with a larger number of parameters; an attribute of a sort c that has the form attr name : c × c0 × . . . × cn → cn+1 can be written as attr name : c0 × . . . × cn → cn+1. This completes the description of the syntactic representation of our sort hierarchy in ALM.\nThe next step is to syntactically describe functions in the signature. One of the functions mentioned in our informal description specifies whether two points are connected or not. Let us call it connected . In general, the value of connected can be changed by actions (airports can be closed, roads blocked, etc.) and hence we define connected to be a basic fluent. In some scenarios, the property connected will be a symmetric relation but not in others; similarly, it may be a transitive relation or not. To allow for elaboration tolerance, we introduce two basic static functions, symmetric connectivity and transitive connectivity to characterize the property connected . The other function relevant to our domain maps things into points at which they are located. Let us call it loc in. The value of the function can be changed by actions of our domain, hence it is a fluent. It is not defined in terms of other functions, thus it is a basic fluent. It is also a total function, as we assume that the location of every thing is defined in every state. In ALM these functions are syntactically declared as:\nfunction declarations\nstatics\nbasic\nsymmetric connectivity : booleans transitive connectivity : booleans\nfluents\nbasic\nconnected : points × points → booleans total loc in : things → points\nModular Action Language ALM 21\nIn this example the keywords function declarations are followed by the lists of statics and fluents. Elements from each list are divided into basic and defined with each total function in the list preceded by the keyword total. Naturally, the declaration of a sort, static, or fluent in a module should be unique.\nThis concludes our description of action signature of Tbm 4.\nNow we are ready to define the collection of axioms of Tbm . In ALM, we precede this collection by the keyword axioms. Each axiom will be ended by a period (.), as in:\naxioms\noccurs(X ) causes loc in(A) = D if instance(X ,move),\nactor(X ) = A, dest(X ) = D .\nconnected(X ,X ). connected(X ,Y ) if connected(Y ,X ),\nsymmetric connectivity .\n¬connected(X ,Y ) if ¬connected(Y ,X ), symmetric connectivity . connected(X ,Z ) if connected(X ,Y ),\nconnected(Y ,Z ), transitive connectivity .\nimpossible occurs(X ) if instance(X ,move),\nactor(X ) = A,\nloc in(A) 6= origin(X ). impossible occurs(X ) if instance(X ,move),\nactor(X ) = A, loc in(A) = dest(X ).\nimpossible occurs(X ) if instance(X ,move),\nactor(X ) = A, loc in(A) = O , dest(X ) = D ,\n¬connected(O ,D). The keyword total in the declaration of the basic fluent loc in stands for the axiom\nfalse if ¬domloc in(X ).\nthat would otherwise have to be included among the axioms above. In general, the keyword total included in the declaration of a function f : c0× . . .× cn → c stands for the axiom\nfalse if ¬domf (X0, . . . ,Xn).\n4 The description does not mention object constants, which can be declared in ALM by statements o : c and r(c1, . . . , cn ) : c. The first statement defines object constant o of sort c; the second defines the collection of object constants of the form r(x1, . . . , xn ) where x1, . . . , xn are object constants from sorts c1, . . . , cn . Example of the latter can be found in module climbing of Monkey and Banana representation from section 4.1.\n22 Daniela Inclezan and Michael Gelfond\nThis completes our description of the basic action theory Tbm in ALM.\nNote that the semantics of the unimodule ALM theory basic motion is given by the basic action theory Tbm defined by it. In the following sections we will present other examples of basic action theories and their interpretations represented in ALM. (Whenever possible we will make no distinction between these theories and their ALM representations.)\nAs discussed above, a basic action theory T is used to define the collection of its models — transition diagrams representing dynamic domains with shared ontology and properties. Usually, a knowledge engineer is interested in one such domain, characterized by particular objects, sorts, and values of statics. If the engineer’s knowledge about this domain is complete, the domain will be represented by a unique model of T . Otherwise there can be several alternative models.\nThe syntactic construct of ALM used to define such knowledge is called a structure and has the form\nstructure name\n〈structure body〉\nwhere 〈structure body〉 stands for the definition of objects in the hierarchy of Tbm and the values of its statics. Let us illustrate the use of this construct by the following example:\nExample 7 (ALM’s Representation of a Specific Basic Motion Domain.) Let us consider the ALM theory basic motion from Example 6, which encodes the basic action theory Tbm , and use ALM to specify the particular basic motion domain from Example 5.\nThe ALM definition of the structure used to describe this domain starts with the header:\nstructure Bob and John\nfollowed by the definition of agents and points:\ninstances\nbob, john in agents new york , paris, rome in points\nTo specify particular actions of our domain we expand our list of instances by\ngo(X ,P1,P2) in move where P1 6= P2 actor = X\norigin = P1 dest = P2\nNote that the last definition describes several instances simultaneously via the use of variables; we call this type of definition an instance schema. The instance schema defining go(X ,P1,P2) stands for the collection of instance definitions:\nModular Action Language ALM 23\ngo(bob,new york , paris) in move\nactor = bob origin = new york dest = paris\n. . . go(john, paris, rome) in move\nactor = john origin = paris dest = rome\nThe condition where P1 6= P2 ensures that Bob and John do not move to a destination identical to the origin.\nThe following would also be a valid instance schema:\ngo(X ,P) in move\nactor = X dest = P\nif we were interested only in the destinations of Bob and John’s movements, but not in their origins.\nIn our example connectivity between points is both symmetric and transitive: This is captured syntactically by the following: 5\nvalues of statics\nsymmetric connectivity . transitive connectivity .\nThis concludes our definition of Bob and John structure.\nTo syntactically relate a theory with its structure, we use the construct of ALM called system description. In our case it will look as follows:\nsystem description travel\ntheory basic motion\nmodule moving\n〈module body〉 structure Bob and John\n〈structure body〉\nwhere 〈module body〉 and 〈structure body〉 are defined in Examples 6 and 7. The system description travel contains all the information we considered relevant to our particular travel domain. It is not difficult to see that this knowledge is complete and therefore describes exactly one model (i.e., one transition diagram) of basic motion. This is exactly the model we intended for our domain. A part of this model can be seen in Figure 3. We only show fluent loc in and assume that in every state of the\n5 If a theory contains an object constant o then its value, say y, can be declared as:\nobject constants o = y\nIf the structure contains no assignment of value to constant o, we assume that o belongs to the structure’s universe and is mapped into itself.\n24 Daniela Inclezan and Michael Gelfond\npart of the diagram shown in the picture Paris and Rome are connected to each other, but neither of them is connected to New York; we use shorthands b, j , ny , p, and r for bob, john, new york , paris, and rome respectively; and we only show arcs that are labeled by a single action.\nThe model is unique because we specified the membership of our objects in the source nodes of the hierarchy. This information is sufficient to uniquely define the universe and the interpretations of all the sorts.\nThe next example illustrates how incomplete information about a domain can\nlead to multiple models of the system description of this domain:\nExample 8 (System Description with Multiple Models) Consider a system description underspecified hierarchy consisting of a theory professors and a structure alice:\nsystem description underspecified hierarchy\ntheory professors\nmodule professors\nsort declarations\nprofessor :: person assistant , associate, full :: professor\naxioms\nfalse if instance(X ,C1), instance(X ,C2),\nlink(C1, professor), link(C2, professor), C1 6= C2·\nModular Action Language ALM 25\nstructure alice\ninstances\nalice in professor\nThe theory describes a simple hierarchy. The structure populates the hierarchy with one member, Alice (see Figure 4). Unfortunately all we know about Alice is that she is a professor. It is not difficult to check that this system description has three models. In the first one Alice is an assistant professor, in the second she is an associate professor, and in the third one - a full professor.\nWe hope that these examples gave the reader a sufficient insight in the meaning of unimodule ALM theories and system descriptions. In general, the semantics of a syntactically correct unimodule theory T of ALM is given by the unique BAT defined by T . Similarly, the semantics of a system description D of ALM is given by models of the BAT theory defined by T and by the set of interpretation defined by the structure of D ."
    }, {
      "heading" : "3.2 Organizing Knowledge into Modules",
      "text" : "So far we only considered very simple ALM theories consisting of one module. To create theories containing a larger body of knowledge we need multiple modules organized into a module hierarchy. To illustrate this concept let us consider an extension of basic action theory Tbm of motion by an additional sort of things called carriables, which can be carried between connected points by agents that are holding them. Recall from Example 6 that we represented the original Tbm as an ALM theory called basic motion, with a unique module moving . We will use the name motion for the ALM theory that will specify the extension of Tbm . The new theory will contain the moving module developed above as well as a new module called carrying things:\ntheory motion\nmodule moving\n〈module body〉 module carrying things\n〈module body〉 In addition to sorts, fluents, and axioms from module moving , the signature of the new module carrying things will contain two new sorts, carriables and carry ; a new inertial fluent, holding ; and a defined fluent, is held . Informally, holding will be understood as having in one’s hands and carry as moving while holding, which will allow us to define carry as a special case of move.\n26 Daniela Inclezan and Michael Gelfond\nThe dependency of carrying things on moving is expressed in ALM by the syntactic construct depends on called module dependency as follows:\nmodule carrying things\ndepends on moving\nThis says that the sorts and functions explicitly declared in carrying things depend on sorts and functions declared in the module moving . We say that the declarations of moving are implicit in module carrying things. We require all sorts and functions appearing in a module to be either explicitly or implicitly declared in that module. By means of the module dependency construct, a theory of ALM can be structured into a hierarchy of modules. The dependency relation of this hierarchy should form a DAG. Now we define the body of the new module:\nsort declarations\ncarriables :: things\ncarry :: move\nattributes\ncarried object : carriables\nNote that, since carry is defined as a special case of move, it automatically inherits the attributes of move; hence those attributes do not have to be repeated in the declaration of carry . Next, the module contains the declarations of functions:\nfunction declarations\nfluents\nbasic\ntotal holding : agents × things → booleans defined\nis held : things → booleans and the new axioms:\naxioms\nloc in(C ) = P if holding(T ,C ),\nloc in(T ) = P .\nloc in(T ) = P if holding(T ,C ),\nloc in(C ) = P .\nis held(X ) if holding(T ,X ).\nimpossible occurs(X ) if instance(X ,move),\nactor(X ) = A, is held(A).\nimpossible occurs(X ) if instance(X , carry),\nactor(X ) = A, carried object(X ) = C , ¬holding(A,C ).\nThe first two axioms say that an agent and an object he is holding have the same location. The next defines fluent is held(X ) – object X is held by someone or something. The first executability condition states that to move an actor should be\nModular Action Language ALM 27\nfree (i.e., not held). The second states that it is impossible to carry a thing without holding it.\nStructuring a theory of ALM into a hierarchy of modules has several advantages. First, this supports the stepwise development of a knowledge base by allowing parts of its theory to be developed and tested independently from other parts. Second, it increases the readability of ALM theories, due to the more manageable size of their modules.6 And finally, this approach facilitates the creation of knowledge libraries. Theories containing very general information can be stored in a library and imported from there when constructing system descriptions. For instance, imagine that our motion theory is stored in a library called commonsense library . The system description travel could then be re-written by importing this theory as follows:\nsystem description travel\nimport theory motion from commonsense library structure Bob and John\n〈structure body〉\nWe hope that these examples gave the reader some insight into the meaning of theories of ALM that have more than one module. The accurate semantics for such a theory T is given by its flattening, i.e., by translating T into the unimodular theory with the same intuitive meaning.\nFirst, we will give the semantics of theories satisfying the semantic conditions\ngiven in the following definition, theories that we call semantically coherent.\nDefinition 11 (Semantically Coherent Theory) A theory of ALM is semantically coherent if it satisfies the following conditions:\n• All sorts and functions appearing in a module of T are (explicitly or implicitly) declared in that module. • The module hierarchy of T defined by relation “depends on” forms a DAG, G . (The nodes of G correspond to modules of T . An arc 〈M2,M1〉 is in G if and only if module M2 contains the statement “depends on M1”.) • No two modules of a theory contain different declarations of the same sort or the same function name.\nThe last condition in Definition 11 can be weakened to allow the use of the same name for a function and its restriction on a smaller sort. This and other similar features however can somewhat distract from the main ideas of ALM and will not be included in the original version of ALM.\nThe flattening f (T ) of an ALM theory T is constructed by the following algorithm:\n1. Select modules M1 and M2 of T such that M1 contains the statement “depends\non M2”.\n6 For greater readability, we recommend maintaining a balance between a manageable module size and a relatively shallow module dependence hierarchy.\n28 Daniela Inclezan and Michael Gelfond\n2. Replace M1 and M2 by the new module M obtained by uniting depends on\nstatements, sort declarations, object constant declarations, function declara-\ntions, and axioms of M2 with those of M1. 3. Remove the statement “depends on M2” from M . 4. Replace M1 and M2 in all the statements of T of the form “depends on M1”\nand “depends on M2” by M . 5. Repeat until no dependent modules exist. 6. Construct a new module with declarations and axioms defined as unions of\nthe corresponding declarations and axioms of the remaining modules. 7. Return the resulting unimodule theory f (T ).\nThe second condition in Definition 11 guarantees that the algorithm will terminate. The first and second conditions ensure that the result of the algorithm does not contain the depends on statement and that all sorts and functions within module M of step 2 have unique (explicit or implicit) declarations. Thanks to condition three this property is preserved by step 6 of the algorithm and hence f (T ) is indeed a unimodule theory.\nAs expected, the semantics of an ALM theory T with more than one module is given by the semantics of the unimodule theory f (T ).\nFor illustrative purposes we give the result of applying the flattening algorithm\nto the motion theory given above:\ntheory flat motion\nmodule flat motion\nsort declarations\npoints, things :: universe agents, carriables :: things\nmove :: actions\nattributes\nactor : agents origin : points dest : points\ncarry :: move\nattributes\ncarried object : carriables\nfunction declarations\nstatics\nbasic\nsymmetric connectivity : booleans transitive connectivity : booleans\nfluents\nbasic\ntotal loc in : things → points total holding : agents × things → booleans connected : points × points → booleans\nModular Action Language ALM 29\ndefined\nis held : things → booleans\naxioms\noccurs(X ) causes loc in(A) = D if instance(X ,move),\nactor(X ) = A, dest(X ) = D .\nconnected(X ,X ). connected(X ,Y ) if connected(Y ,X ), symmetric connectivity . ¬connected(X ,Y ) if ¬connected(Y ,X ), symmetric connectivity . connected(X ,Z ) if connected(X ,Y ), connected(Y ,Z ),\ntransitive connectivity .\nloc in(C ) = P if holding(T ,C ), loc in(T ) = P . loc in(T ) = P if holding(T ,C ), loc in(C ) = P .\nis held(C ) if holding(T ,C ).\nimpossible occurs(X ) if instance(X ,move), actor(X ) = A, origin(X ) 6= loc in(A). impossible occurs(X ) if instance(X ,move), actor(X ) = A,\ndest(X ) = loc in(A).\nimpossible occurs(X ) if instance(X ,move), actor(X ) = A,\nloc in(A) = O , dest(X ) = D ,\n¬connected(O ,D). impossible occurs(X ) if instance(X ,move),\nactor(X ) = A, is held(A).\nimpossible occurs(X ) if instance(X , carry), actor(X ) = A,\ncarried object(X ) = C , ¬holding(A,C ).\nFor readability, we selected the same names for the theory and its module. This theory will be used in Appendix C, for the purpose of comparing ALM and MAD .\nFinally, the semantics of a system description with a theory T consisting of multiple modules is given by the collection of models of the BAT defined by f (T ) and the collection of interpretations defined by the system’s structure.\nThis concludes our introduction to the syntax and semantics of ALM."
    }, {
      "heading" : "4 Methodology of Language Use",
      "text" : "In this section we further illustrate the methodology of using ALM for knowledge representation and for solving various computational tasks.\n4.1 Representing Knowledge in ALM\nWe exemplify the methodology of representing knowledge in ALM by considering a benchmark commonsense example from the field of reasoning about action and change — the Monkey and Banana Problem (McCarthy 1963; McCarthy 1968). (Another, more realistic, example of the use of ALM can be found in Appendix B.)\n30 Daniela Inclezan and Michael Gelfond\nProblem 1 (Monkey and Banana) A monkey is in a room. Suspended from the ceiling is a bunch of bananas, beyond the monkey’s reach. In the room there is also a box. The ceiling is just the right height so that a monkey standing on the box under the bananas can reach the bananas. The monkey can move around, carry other things around, climb on the box, and grasp the bananas. What is the best sequence of actions for the monkey to get the bananas?\nIn accordance with the basic methodology of declarative programming, we will first represent knowledge about the problem domain and then reduce the problem’s solution to reasoning with this knowledge. Based on our current experience, we recommend to divide the process of representation into the following steps:\nMethodology of Creating Modular Representations in ALM:\n• Build a hierarchy of actions pertinent to the domain. • Starting from the top of the hierarchy gradually build and test modules cap-\nturing properties of its actions. If necessary, add general non-action modules (e.g. a module defining a sequence of actions). Whenever feasible, use existing library modules. • Build a module main containing specific information needed for the problem solution. • Populate the hierarchy with the domain’s objects.\nHere are a few comments about the second step listed above: When deciding how many actions to describe in one module, consider balancing the size of the module with the depth of the (part of the) hierarchy that it captures; also consider the resulting depth of the module dependency hierarchy. For instance, an action and its opposite are normally included in the same module. So are actions that usually occur together and share common fluents and sorts. To facilitate the discovery of relevant library modules, we assume that a dictionary indexed by action classes will be available to knowledge engineers. Action classes will be associated with the library modules in which they are described. The signature and axioms of library modules will be viewable by the knowledge engineer.\nLet us illustrate the methodology by solving the Monkey and Banana problem. The story is clearly about an agent moving around, and grasping and carrying things between various points. The hierarchy of actions pertinent to the story is illustrated in Figure 5.\nNote that, unlike other actions, action release does not explicitly appear in the story. However, it is often advisable to consider actions together with their opposites, so our hierarchy contains release together with grasp.\nTo gradually build a theory monkey and banana containing the knowledge needed to solve the Monkey and Banana problem, we start with selecting a root of the action hierarchy – in our case action move. The inheritance hierarchy pertinent to move appears in Figure 2. We already discussed the module moving describing the properties of move. The theory consisting of this module can be tested on a number\nModular Action Language ALM 31\nof specific domains using ASP-based methods discussed in the next section. Next we select three actions carry, grasp, and release understood as move while holding, take and hold, and stop holding respectively. Since these actions share a fluent holding7 and sorts things and agents, and since a things-carrying agent usually also executes actions grasp and release, knowledge about these actions can be put in the same module. To do that we extend the inheritance hierarchy by a subclass carriables of things and expand module carrying things from section 3.2 by information about another two actions. Sort declarations of carrying things from 3.2 will now also include\ngrasp :: actions\nattributes\ngrasper : agents\ngrasped thing : things and\nrelease :: actions\nattributes\nreleaser : agents released thing : things\nThe section function declarations of the new module will contain the additional function can reach needed as a precondition for the executability of grasp. The function will be defined in terms of locations of things.\ndefined\ncan reach : agents × things → booleans The set of axioms will be expanded as follows. The first two axioms below describe the direct effects of our new actions: action grasp results in the grasper holding the thing he grasped; this is no longer true after the thing is released.\noccurs(A) causes holding(X ,Y ) if instance(A, grasp),\ngrasper(A) = X , grasped thing(A) = Y .\noccurs(A) causes ¬holding(X ,Y ) if instance(A, release), releaser(A) = X ,\nreleased thing(A) = Y .\n7 For simplicity we assume that an agent can only hold one thing at a time. A more general module may allow to grasp a collection of things up to a certain capacity.\n32 Daniela Inclezan and Michael Gelfond\nThe constraint\n¬holding(X ,Y2) if holding(X ,Y1),Y1 6= Y2 ensures that only one thing can be held at a time (and hence to grasp a thing an agent must have his hands free).\nThis is followed by the executability conditions: one cannot grasp a thing he is already holding or a thing that is out of his reach; one cannot release a thing unless he is holding it.\nimpossible occurs(A) if instance(A, grasp),\ngrasper(A) = X , grasped thing(A) = Y , holding(X ,Y ).\nimpossible occurs(A) if instance(A, grasp),\ngrasper(A) = X , grasped thing(A) = Y ,\n¬can reach(X ,Y ). impossible occurs(A) if instance(A, release),\nreleaser(A) = X , released thing(A) = Y ,\n¬holding(X ,Y ). We also need a simple definition of can reach – an agent can always reach an object he shares a location with.\ncan reach(M ,O) if loc in(M ) = loc in(O).\nThis definition will later be expanded to describe the specific geometry of our domain.\nThis completes our construction of the new module carrying things.\nAfter testing the theory consisting of moving and carrying things we proceed to constructing a new module, climbing , which axiomatizes action climb understood as moving from the bottom of a thing to its top. We assume that one can climb only on tops of a special type of things called elevations, which will be added to our hierarchy as a subset of things. The corresponding declarations look as follows:\nmodule climbing\ndepends on moving\nsort declarations\nelevations :: things climb :: move\nattributes\nelevation : elevations\nNow we introduce notation for points associated with the tops of elevations. The points are represented by object constants of the form top(E ) where E is an elevation. In ALM this is expressed by the following: object constants\ntop(elevations) : points\nModular Action Language ALM 33\n(Notice that top here is not a function symbol; if e is an elevation, then top(e) is simply a point.)\nThe module contains axioms saying that top(E ) is the destination of climbing an\nelevation E :\ndest(A) = top(E ) if elevation(A) = E .\nand that a thing cannot be located on its own top:\nfalse if loc in(E ) = top(E ).\nThe last axiom prohibits an attempt by an agent to climb an elevation from a distance:\nimpossible occurs(X ) if instance(X , climb),\nactor(X ) = A, elevation(X ) = O , loc in(O) 6= loc in(A).\nAfter testing the existing modules we concentrate on the specific information\nneeded for the problem solution. It will be presented in a module called main.\nmodule main\ndepends on carrying things, climbing\nThe main goal of the module is to define when the monkey can reach the banana. We start by dividing our sort points into three parts: floor points, ceiling points, and movable points:\nsort declarations\nfloor points, ceiling points,movable points :: points\nwhere the latter correspond to tops of movable objects. We will see the use of these sorts a little later. Now we move to function declarations. The story is about three particular entities: the monkey, the banana, and the box. They will be defined as constants of our module.\nobject constants\nmonkey : agents box : carriables, elevations banana : carriables\nWe will also need a function under, such that under(P ,T ) is true when point P is located under the thing T . Note that, if we consider this function to be defined for arbitrary points, it will be dynamic – under(top(box ), banana) can be true in one state and false in another. This will force us to declare this function as a fluent, causing an unnecessary complication. Instead we define under for floor points only, which is sufficient for our purpose and is substantially simpler.\nfunction declarations\nstatics\nbasic under : floor points × things → booleans To define our function can reach we need the following axiom:\n34 Daniela Inclezan and Michael Gelfond\naxioms\ncan reach(monkey , banana) if loc in(box ) = P ,\nunder(P , banana), loc in(monkey) = top(box ).\nFinally, we need the following axioms for the basic fluent connected :\nconnected(top(box ),P) if loc in(box ) = P ,\ninstance(P ,floor points).\n¬connected(top(box ),P) if loc in(box ) 6= P , instance(P ,floor points).\nconnected(P1,P2) if instance(P1,floor points),\ninstance(P2,floor points).\n¬connected(P1,P2) if instance(P1, ceiling points), instance(P2, points),\nP1 6= P2. This completes the construction of module main as well as theory monkey and banana that we will use to solve the Monkey and Banana problem. It is easy to see that the theory is semantically coherent, as it satisfies the conditions in Definition 11.\nFigure 6 and 7 represent the sort hierarchy and module hierarchy of this theory, respectively.\nTo complete the description of our domain we introduce the structure containing three points located on the floor of the room and one point located on the ceiling, as well as movable points and particular actions mentioned in the story:\nstructure monkey and banana\ninstances\nunder banana, initial monkey , initial box in floor points initial banana in ceiling points top(box ) in movable points\nModular Action Language ALM 35\nmove(P) in move where instance(P , points)\nactor = monkey dest = P\ncarry(box ,P) in carry where instance(P ,floor points)\nactor = monkey carried object = box dest = P\ngrasp(C ) in grasp where instance(C , carriables)\ngrasper = monkey grasped thing = C\nrelease(C ) in release where instance(C , carriables)\nreleaser = monkey released thing = C\nclimb(box ) in climb\nactor = monkey elevation = box\nvalues of statics\nunder(under banana, banana). symmetric connectivity . ¬transitive connectivity .\nThe structure specifies that the relation connected is symmetric, but not transitive. The latter prevents the monkey from moving from its initial location directly on top of the box.\nThe theory and structure described above can be combined into a system de-\nscription monkey and banana as follows:\nsystem description monkey and banana problem\ntheory monkey and banana\nimport motion from commonsense library module main\n〈module body〉\n36 Daniela Inclezan and Michael Gelfond\nstructure monkey and banana\n〈structure body〉\nNote that the import statement above is a directive to import all of the modules of the library theory motion into the theory monkey and banana.\nThe system describes a unique hierarchy and a unique transition diagram, τ . Note that the hierarchy contains properly typed constants monkey , box , and banana declared in our module main; and that some of our functions, e.g. under , are partial.\nIt is not difficult to check that there is a path in τ that starts with the initial state of our problem and is generated by actions move(initial box ), grasp(box ), carry(box , under banana), release(box ), climb(box ), grasp(banana). The final state of this path will contain a fluent holding(monkey , banana). In the next section we discuss how ASP based reasoning can be used to automatically find such sequences."
    }, {
      "heading" : "4.2 ALM’s Use in Solving Computational Tasks",
      "text" : "A system description of ALM describes a collection of transition diagrams that specifies some dynamic system. System descriptions can be used to solve computational tasks such as temporal projection or planning, using a methodology similar to that developed for non-modular action languages like AL (see, for instance, (Gelfond and Kahl 2014)).\n4.2.1 Temporal Projection\nNormally, system descriptions of ALM are used in conjunction with the description of the system’s recorded history — a collection of facts about the values of fluents and the occurrences of actions at different time steps in a trajectory. (Since we are only dealing with discrete systems such steps are represented by non-negative integers). Together, the system description and the history define the collection of possible trajectories of the system up to the current step. In our methodology of solving temporal projection tasks, possible trajectories are obtained by computing the answer sets of a logic program. To formally describe this methodology, we need the following definitions.\nDefinition 12 (History – adapted from (Balduccini and Gelfond 2003a)) By the recorded history Γn of a system description D up to time step n we mean a collection of observations, i.e., facts of the form:\n1. observed(f (t), v , i) – fluent f (t) was observed to have value v at time step i ,\nwhere 0 ≤ i ≤ n. 2. happened(a, i) – action a was observed to happen at time step i , where 0 ≤\ni < n.\n(There are two small differences between this and the definition of a history by Balduccini and Gelfond (2003a): the latter only allows boolean fluents and observations that have the form observed(l , i) where l is a fluent or its negation. Similarly for the next definitions in this subsection.)\nModular Action Language ALM 37\nWe say that the initial situation of Γn is complete if, for every user-defined basic fluent f and any sequence of ground terms t such that observed(domf (t), true, 0) ∈ Γn , Γn also contains a fact of the form observed(f (t), v , 0).\nExample 9 (History)\nA possible recorded history for the system description monkey and banana problem in Section 4.1 may look as follows:\nΓ1 =def {observed(loc in(monkey), initial monkey , 0), observed(loc in(box ), initial box , 0),\nhappened(move(initial box ), 0)}\nwhich says that, initially, the monkey was at point initial monkey and the box was at initial box ; the monkey went to the initial location of the box.\nThe semantics of a history Γn is given by the following definition:\nDefinition 13 (Model of a History – adapted from (Balduccini and Gelfond 2003a))\nLet Γn be a history of a system description D up to time step n.\n(a) A trajectory 〈σ0, a0, σ1, . . . , an−1, σn〉 is a model of Γn if: 1. ai = {a : happened(a, i) ∈ Γn}, for every 0 ≤ i < n. 2. if observed(f (t), v , i) ∈ Γn then f (t) = v ∈ σi , for every 0 ≤ i ≤ n. (b) Γn is consistent if it has a model. (c) An atom f (t) = v holds in a model M of Γn at time 0 ≤ i ≤ n if f (t) = v ∈ σi ; A literal f (t) 6= v holds in a model M of Γn at time 0 ≤ i ≤ n if domf (t) = true ∈ σi and f (t) = v /∈ σi ; Γn entails a literal l at time step 0 ≤ i ≤ n if, for every model M of Γn , l holds in M .\nExample 10 (Model of a History)\nHistory Γ1 from Example 9 is consistent. Its model is the trajectory:\nM = 〈 { loc in(monkey) = initial monkey , loc in(box ) = initial box , . . . }, move(initial box ),\n{ loc in(monkey) = initial box , loc in(box ) = initial box , . . . }〉·\n(We do not show the values of connected since they are unchanged by our actions). Γ1 entails, for example, loc in(monkey) = initial box at time step 1.\nNote that a consistent history may have more than one model if non-deterministic\nactions are involved or the initial situation is not complete.\nNext, we define some useful vocabulary.\n38 Daniela Inclezan and Michael Gelfond\nDefinition 14 (Set of Literals Defining a Sequence – adapted from (Balduccini and Gelfond 2003a))\nLet Γn be a history of D and A be a set of literals over signature Σ. We say that A defines the sequence\n〈σ0, a0, σ1, . . . , an−1, σn〉 if:\n(a) σi = {f (t0, . . . , tn) = t : f (t0, . . . , tn) = t ∈ A and f is a static or attribute} ∪\n{f (t0, . . . , tn) = t : f (t0, . . . , tn , i) = t ∈ A and f is a fluent} for any 0 ≤ i ≤ n, and\n(b) ak = {a : occurs(a, k) ∈ A} for any 0 ≤ k < n.\nDefinition 15 (Program Ωtp – adapted from (Balduccini and Gelfond 2003a)) If Γn is a history of system description D up to time step n, then by Ωtp we denote the ASP{f} program constructed as follows:\n1. For every action a such that happened(a, i) ∈ Γn , Ωtp contains:\noccurs(a, i)← happened(a, i)·\n2. For every expression observed(f (t), v , 0) ∈ Γn , Ωtp contains:\nf (t , 0) = v ← observed(f (t), v , 0)·\n3. For every expression observed(f (t), v , i) ∈ Γn , i > 0, Ωtp contains the reality check axiom:\n← observed(f (t), v , i), domf (t , i),\nf (t , i) 6= v ·\nOur methodology of finding trajectories by computing answer sets of a logic program is designed for system descriptions that match the intuition that defined functions are only shorthands, and their values are fully determined by those of basic statics and fluents. We call such system descriptions well–founded and define them formally as follows.\nDefinition 16 (Well–founded System Description – adapted from (Gelfond and Inclezan 2013))\nLet D be a system description whose theory encodes the BAT theory T , and whose structure defines a collection S of models of T . D is well–founded if, for every model M in S, and every interpretation I with static part M, the program SI (defined as in Section 2.3) has at most one answer set.\nThe system description monkey and banana problem from Section 4.1 is well–\nfounded. An example of a system description that is not well–founded is n w f shown below and adapted from (Gelfond and Inclezan 2013). The two defined fluents of n w f are not defined in terms of basic statics or fluents but rather in terms of one another by mutually recursive axioms.\nModular Action Language ALM 39\nsystem description n w f\ntheory n w f\nmodule main\nsort declarations\nc :: universe\nfluent declarations\ndefined\nf : c → booleans g : c → booleans\naxioms\nf (X ) if ¬g(X ). g(X ) if ¬f (X ).\nstructure n w f\ninstances\nx in c\nIn the case of the non-modular action language AL, there is a known syntactic condition that guarantees that a system description is well–founded (Gelfond and Inclezan 2013). This condition can be easily expanded to ALM due to close connections between ALM and AL.\nTrajectories of a dynamic system specified by a well–founded system description are computed using a logic program Π that consists of the ASP{f} encoding of the system description, the system’s recorded history, and the program Ωtp connecting the recorded history with the system description.\nTo simplify the presentation, in what follows we limit ourselves to well–founded system descriptions that describe domains in which there is complete information about the sort memberships of objects of the domain.8 Let us consider system description D that meets this requirement, and let M be a model of D’s theory. Then, the program PM obtained from the theory of D and M as described in section 2.3 will be used as the ASP{f} encoding of D.\nDefinition 17 (Program Πtp(D)) If Γn is a history of D up to step n, then Πtp(D) is the logic program defined as\nΠtp(D) =def PM ∪ Γn ∪ Ωtp\nsuch that the sort step in the signature of Πtp(D) ranges over the set {0, . . . ,n}.\nProposition 1 If Γn is a consistent history of D such that the initial situation of Γn is complete, then M is a model of Γn iff M is defined by some answer set of program Πtp(D).\n8 This is not a serious restriction; it can be easily lifted by adding to the ASP encoding of the ALM system description rules of the type\nis a(x , c) or ¬is a(x , c)\nfor every object x and every source node c in the hierarchy of sorts.\n40 Daniela Inclezan and Michael Gelfond\nThis proposition can be proven using techniques similar to the ones employed in\nLemma 5 in (Balduccini and Gelfond 2003a).9\nWe used the above methodology of solving temporal projection tasks to create a question answering system in the context of the Digital Aristotle project (Inclezan and Gelfond 2011). Our system was capable of answering complex endof-the-chapter questions on cell division, extracted from a well-known biology textbook.\n4.2.2 Planning\nIn planning problems, in addition to the history of the dynamic system up to the current time point, information about the goal to be achieved is also provided. Given a system description of ALM whose theory describes a basic action theory T , a goal is a collection G of ground user-defined fluent literals over the signature of T . For instance, for the Monkey and Banana problem in Section 4.1, the goal is Gmb = {holding(monkey , banana)}. Goals can be encoded as logic programming rules, as described in the following definition:\nDefinition 18 (Goal Encoding)\nGiven a goal G , we call encoding of G , denoted by lp(G) the rule\ngoal(I ) ← body\nwhere body is defined as follows:\nbody =def {f (t , I ) = v : f (t) = v ∈ G} ∪ {f (t , I ) 6= v : f (t) 6= v ∈ G}·\nIn order to solve planning problems, a slightly different logic programming module will be needed than for solving temporal projection tasks. This module is defined in CR-Prolog (Balduccini and Gelfond 2003b), an extension of ASP designed to handle, among other things, rare events. In addition to regular ASP rules, programs in CR-Prolog may contain consistency restoring rules that have the following syntax:\nh1 or . . . or hk +← l1, . . . , lm ,not lm+1, . . . ,not ln ·\nInformally, this statement says that an intelligent agent who believes l1, . . . , lm and has no reason to believe lm+1, . . . , ln may believe one of hi ’s, 1 ≤ i ≤ k , but only if no consistent set of beliefs can be formed otherwise. For the formal semantics of CR-Prolog, we refer the reader to (Balduccini and Gelfond 2003b). An extension of ASP{f} by consistency restoring rules is defined in (Balduccini and Gelfond 2012). Solvers for CR-Prolog are described in (Balduccini 2007) and (Balai et al. 2012).\nDefinition 19 (Planning Module (Balduccini 2004; Gelfond and Kahl 2014))\n9 The proof and text of Lemma 5 appear on page 29 of the version of (Balduccini and Gelfond 2003a) available at http://arxiv.org/pdf/cs/0312040v1.pdf. Retrieved on August 3, 2014.\nModular Action Language ALM 41\nGiven a goal G , the planning module Ωpl extends module Ωtp from Section 4.2.1 by the following rules:\nsuccess ← goal(I ), I ≤ n ← not success\nr1(A, I ) : occurs(A, I ) +← instance(A, actions)\nsmtg happened(I ) ← occurs(A, I ) ← not smtg happened(I ),\nsmtg happened(I + 1)·\nΩpl computes minimal plans of maximum length n by the use of the consistency restoring rule r1 and the two regular rules that follow it.\nThe actual program for computing plans is constructed similarly as before.\nDefinition 20 (Program Πpl(D)) If Γn is a history of D up to step n and G is a goal over D, then Πpl(D,G) is the logic program defined as\nΠpl(D,G) =def PM ∪ Γn ∪ Ωpl ∪ lp(G)\nsuch that the sort step in the signature of Πpl(D,G) ranges over the set {0, . . . ,n}.\nThe following proposition specifies how answer sets of the logic program defined\nabove can be mapped into plans for achieving given goals.\nProposition 2 If Γn is a consistent history of D such that the initial situation of Γn is complete and G is a goal over D, then the collection of atoms of the form occurs(a, i) from an answer set of Πpl(D,G) defines a minimal plan for achieving goal G , and every such plan is represented by the occurs atoms of some answer set of Πpl(D,G).\nExample 11 (Planning in the Monkey and Banana Problem) If we consider the Monkey and Banana problem with the initial situation\nΓmb = { observed(loc in(monkey), initial monkey , 0), observed(loc in(box ), initial box , 0)\nand the goal\nGmb = {holding(monkey , banana)} defined earlier, then an answer set of program Πpl(monkey and banana problem,Gmb) will contain the following occurs atoms: { occurs(move(initial box ), 0), occurs(grasp(box ), 1),\noccurs(carry(box , under banana), 2), occurs(release(box ), 3),\noccurs(climb(box ), 4), occurs(grasp(banana), 5) } defining a minimal plan 〈 move(initial box ), grasp(box ), carry(box , under banana), release(box ), climb(box ), grasp(banana) 〉 resulting in the monkey holding the banana at time step 6. The program will also find the second minimal plan in which carry(box , under banana) at step 2 is replaced by move(under banana). Since the\n42 Daniela Inclezan and Michael Gelfond\nfirst action is more specific than the second one the first plan seems to be preferable. This can easily be expressed by a slightly modified planning module allowing only most specific actions."
    }, {
      "heading" : "5 Related Work",
      "text" : "Many ideas of ALM, such as the notions of action language, module, sort hierarchy, attribute defined as a partial function, etc., are well-known from the literature on programming languages and knowledge representation. Some of the basic references to these notions were given in the text. In this section we briefly comment on the relationship between ALM and the previously existing modular action languages MAD (Lifschitz and Ren 2006; Erdoǧan and Lifschitz 2006; Desai and Singh 2007), TAL-C (Gustafsson and Kvarnström 2004), and the earlier version of ALM (Gelfond and Inclezan 2009).\nWe start with summarizing the differences between the two versions of ALM. There are a number of changes in the syntax of the language. For instance, theories of the new version of ALM may contain non-boolean fluents10 and constants that substantially simplify ALM’s use for knowledge representation. Axioms of a theory, which in the old version were included in the theory’s declarations, are now put in a separate section of the theory. This removed the problem of deciding which fluent or action declaration should contain an axiom, and improved the readability of the language. There are also substantial improvements in the syntax of axioms, etc. Another collection of changes is related to the semantics of the language. First, the new semantics, based on the notions of basic action theory and its models, clarified and generalized the old definition and allowed the introduction of the entailment relation. Second, the semantics is now defined for structures with possibly underspecified membership relations of its objects in the sort hierarchy, which simplifies reasoning with incomplete information. Third, the semantics was initially given in terms of action language AL (Turner 1997; Baral and Gelfond 2000), where the AL semantics is defined by a translation into ASP; now, we give the semantics of our language directly in ASP – in fact, in an extension of ASP with non-Herbrand functions, ASP{f} (Balduccini 2013). We believe that decoupling ALM from AL will allow us to combine ALM with action languages that correspond to other intuitions.\nAnother modular language is TAL-C (Gustafsson and Kvarnström 2004), which allows definitions of classes of objects that are somewhat similar to those in ALM. TAL-C, however, seems to have more ambitious goals: the language is used to describe and reason about various dynamic scenarios, whereas in ALM the description of a scenario and that of reasoning tasks are not viewed as part of the language. The more rigid structure of ALM supports the separation of concerns design principle and makes it easier to give a formal semantics of the language.\n10 In the field of logic programming, an early discussion on the introduction of functions appears in (Hanus 1994).\nModular Action Language ALM 43\nThese differences led to vastly distinct knowledge representation styles reflected in these languages.\nThere are smaller, but still very substantial, differences betweenALM and MAD . The two languages are based on non-modular action languages with substantially different semantics and underlying assumptions, use very different constructs for creating modules and for defining actions as special cases, etc. A more detailed comparison between the two approaches can be found in Appendix C."
    }, {
      "heading" : "6 Conclusions and Future Work",
      "text" : "In this paper, we have presented a methodology of representing and reasoning about dynamic systems. A knowledge engineer following this methodology starts with finding a proper generalization of a particular dynamic system D , finds the sorts of objects pertinent to this generalization, organizes these sorts into an inheritance hierarchy and uses causal laws, definitions, and executability conditions to specify relevant properties of the sorts elements. The resulting basic action theory, say T , gives the first mathematical model of the system. In the next step of the development, a knowledge engineer refines this model by providing its description in the high level action language ALM. The language has means for precisely representing the signature of T including its sort hierarchy. It is characterized by a modular structure, which improves readability and supports the step-wise development of a knowledge base, reuse of knowledge, and creation of knowledge libraries. ALM’s description of T can be used to specify multiple dynamic systems with different collections of objects and statics. A particular system D can be specified by populating sorts of T by objects of D and defining values of D ’s statics. This step is also supported by ALM, which clearly separates the definition of sorts of objects of the domain (given in T ) from the definition of instances of these sorts (given by an ALM structure). This, together with the means for defining objects of the domain as special cases of previously defined ones, facilitates the stepwise development and testing of the knowledge base and improves its elaboration tolerance.\nA close relationship between ALM and Answer Set Programming allows the use of ALM system descriptions for non-trivial reasoning problems including temporal projection, planning, and diagnosis. This is done by an automatic translation of an ALM system description into logic programs whose answer sets correspond to solutions of the corresponding problems. The existence of efficient answer set solvers that allow to compute these answer sets substantially increases the practical value of this approach.\nThe above methodology has been illustrated by two examples: the well-known benchmark Monkey and Banana problem and a more practical problem of formalization of knowledge and answering questions about biological processes such as the cell division (see Appendix B). It is possible (and even likely) that further experience with ALM will suggest some useful extensions of the language but the authors believe that the version presented in this paper will remain relatively stable and provide a good basis for such extensions.\n44 Daniela Inclezan and Michael Gelfond\nWe conclude by briefly outlining a number of questions about ALM that we believe deserve further investigation:\n• Investigating mathematical properties of ALM and its entailment relation. This includes but is not limited to studying compositional properties of ALM modules, axiomatizing its entailment relation, and establishing a closer rela-\ntionship between ALM and modular logic programming. • Developing more efficient reasoning algorithms exploiting the modular struc-\nture of ALM’s theories and the available information about the sorts of objects in ALM’s system descriptions. Among other things it is worth investigating the possible use of modular logic programming as well as the methods from (Gebser et al. 2011), (Gebser et al. 2011), and (Balai et al. 2012). It may also be interesting to see if the implementation could benefit from hybrid approaches combining description logics with ASP (e.g. (Eiter et al. 2008)) or from typed logic programming (e.g. (Pfenning 1992)). • Designing and implementing a development environment to facilitate the use of ALM in applications, the creation and storage of libraries, and the testing and debugging of theories and modules. • Extending ALM with the capability of representing knowledge about hybrid domains, i.e., domains that allow both discrete and continuous change. In\nparticular, it may be a good idea to combine ALM with action language H (Chintabathina et al. 2005; Chintabathina 2012). • Developing the core of an ALM library of commonsense knowledge. (In particular we would like to create an ALM library module containing a theory of intentions in the style of (Blount et al. 2014).) This work would allow us\nto extend our study on the capabilities of our language, while simultaneously providing a tool for members of our community to use when building their reasoning systems."
    }, {
      "heading" : "Acknowledgments",
      "text" : "We are grateful to Evgenii Balai, Justin Blount, Vinay Chaudhri, Vladimir Lifschitz, Yana Todorova, and the anonymous reviewers for useful comments and discussions. This work was partially supported by NSF grant IIS-1018031.\nModular Action Language ALM 45\nAppendix A Grammar of ALM\n〈boolean〉 :- true | false 〈non zero digit〉 :- 1 | · · · | 9 〈digit〉 :- 0 | 〈non zero digit〉 〈lowercase letter〉 :- a | · · · | z 〈uppercase letter〉 :- A | · · · | Z 〈letter〉 :- 〈lowercase letter〉 | 〈uppercase letter〉 〈identifier〉 :- 〈lowercase letter〉 | 〈identifier〉〈letter〉 | 〈identifier〉〈digit〉 〈variable〉 :- 〈uppercase letter〉 | 〈variable〉〈letter〉 | 〈variable〉〈digit〉 〈positive integer〉 :- 〈non zero digit〉 | 〈positive integer〉〈digit〉 〈integer〉 :- 0 | 〈positive integer〉 | − 〈positive integer〉 〈arithmetic op〉 :- + | − | ∗ | / | mod 〈comparison rel〉 :- > | ≥ | < | ≤ 〈arithmetic rel〉 :- 〈eq〉 | 〈neq〉 | 〈comparison rel〉 〈basic arithmetic term〉 :- 〈variable〉 | 〈identifier〉 | 〈integer〉 〈basic term〉 :- 〈basic arithmetic term〉 | 〈boolean〉 〈function term〉 :- 〈identifier〉〈function args〉 〈function args〉 :- (〈term〉〈remainder function args〉) 〈remainder function args〉 :- | , 〈term〉〈remainder function args〉 〈arithmetic term〉 :- 〈basic arithmetic term〉〈arithmetic op〉〈basic arithmetic term〉 〈term〉 :- 〈basic term〉 | 〈arithmetic term〉 〈positive function literal〉 :- 〈function term〉 | 〈function term〉〈eq〉〈term〉 〈function literal〉 :- 〈positive function literal〉 | ¬〈function term〉 |\n〈function term〉〈neq〉〈term〉 〈literal〉 :- 〈function literal〉 | 〈arithmetic term〉〈arithmetic rel〉〈arithmetic term〉 〈var id〉 :- 〈variable〉 | 〈identifier〉 〈body〉 :- | , 〈literal〉〈body〉 〈dynamic causal law〉 :- occurs(〈var id〉) causes 〈positive function literal〉 if\ninstance(〈var id〉, 〈var id〉)〈body〉· 〈state constraint〉 :- 〈sc head〉 if 〈body〉· 〈sc head〉 :- false | 〈positive function literal〉 〈definition〉 :- 〈function term〉 if 〈body〉· 〈executability condition〉 :- imposible occurs(〈var id〉) if\ninstance(〈var id〉, 〈var id〉)〈extended body〉· 〈extended body〉 :- | , 〈literal〉〈body〉 | , occurs(〈var id〉)〈extended body〉 |\n, ¬occurs(〈var id〉)〈extended body〉 〈system description〉 :- system description 〈identifier〉 〈theory〉〈structure〉 〈theory〉 :- theory 〈identifier〉〈set of modules〉 | import 〈identifier〉 from 〈identifier〉 〈set of modules〉 :- 〈module〉〈remainder modules〉 〈remainder modules〉 :- | 〈module〉〈remainder modules〉 〈module〉 :- module 〈identifier〉〈module body〉 |\nimport 〈identifier〉.〈identifier〉 from 〈identifier〉 〈module body〉 :- 〈sort declarations〉〈constant declarations〉〈function declarations〉〈axioms〉\n46 Daniela Inclezan and Michael Gelfond\n〈sort declarations〉 :- | sort declarations 〈one sort decl〉〈remainder sort declarations〉 〈remainder sort declarations〉 :- | 〈one sort decl〉〈remainder sort declarations〉 〈one sort decl〉 :- 〈identifier〉〈remainder sorts〉 :: 〈sort name〉〈remainder sort names〉〈attributes〉 〈remainder sorts〉 :- | , 〈identifier〉〈remainder sorts〉 〈remainder sort names〉 :- | , 〈sort name〉〈remainder sorts〉 〈sort name〉 :- 〈identifier〉 | [ 〈integer〉..〈integer〉 ] 〈attributes〉 :- | attributes 〈one attribute decl〉〈remainder attribute declarations〉 〈one attribute decl〉 :- 〈identifier〉 : 〈arguments〉〈identifier〉 〈arguments〉 :- | 〈identifier〉〈remainder args〉 → 〈remainder args〉 :- | × 〈identifier〉〈remainder args〉 〈remainder attribute declarations〉 :- | 〈one attribute decl〉〈remainder attribute declarations〉\n〈constant declarations〉 :- | object constants 〈one constant decl〉〈remainder constant declarations〉 〈one constant decl〉 :- 〈identifier〉〈constant params〉 : 〈identifier〉 〈remainder constant declarations〉 :- | 〈one constant decl〉〈remainder constant declarations〉 〈constant params〉 :- ( 〈identifier〉〈remainder constant params〉 ) 〈remainder constant params〉 :- | , 〈identifier〉〈remainder constant params〉\n〈function declarations〉 :- | function declarations 〈static declarations〉〈fluent declarations〉 〈static declarations〉 :- | statics 〈basic function declarations〉〈defined function declarations〉 〈fluent declarations〉 :- | fluents 〈basic function declarations〉〈defined function declarations〉 〈basic function declarations〉 :- | basic 〈one function decl〉〈remainder function declarations〉 〈defined function declarations〉 :- | defined 〈one function decl〉〈remainder function declarations〉 〈one function decl〉 :- 〈total partial〉〈one f decl〉 〈total partial〉 :- | total 〈one f decl〉 :- 〈identifier〉 : 〈identifier〉〈remainder args〉 → 〈identifier〉 〈remainder function declarations〉 :- | 〈one function decl〉〈remainder function declarations〉\n〈axioms〉 :- | axioms 〈one axiom〉〈remainder axioms〉 〈one axiom〉 :- 〈dynamic causal law〉 | 〈state constraint〉 | 〈definition〉 | 〈executability condition〉 〈remainder axioms〉 :- | 〈axiom〉〈remainder axioms〉\n〈structure〉 :- structure 〈identifier〉〈constant defs〉〈instance defs〉〈statics defs〉\n〈constant defs〉 :- | constants 〈one constant def 〉〈remainder constant defs〉 〈one constant def 〉 :- 〈identifier〉 = 〈value〉 〈value〉 :- 〈identifier〉 | 〈boolean〉 | 〈integer〉 〈remainder constant defs〉 :- | 〈one constant def 〉〈remainder constant defs〉\n〈instance defs〉 :- | instances 〈one instance def 〉〈remainder instance defs〉 〈one instance def 〉 :- 〈object name〉〈remainder object names〉 in 〈identifier〉〈cond〉〈attribute defs〉 〈object name〉 :- 〈identifier〉〈object args〉 〈object args〉 :- | (〈basic term〉〈remainder object args〉) 〈remainder object args〉 :- | , 〈basic term〉〈remainder object args〉 〈remainder object names〉 :- | , 〈object name〉〈remainder object names〉 〈cond〉 :- | where 〈literal〉〈remainder cond〉 〈remainder cond〉 :- | , 〈literal〉〈remainder cond〉\nModular Action Language ALM 47\n〈attribute defs〉 :- | 〈one attribute def 〉〈remainder attribute defs〉 〈one attribute def 〉 :- 〈identifier〉〈object args〉 = 〈basic term〉 〈statics defs〉 :- | values of statics 〈one static def 〉〈remainder statics defs〉 〈one static def 〉 :- 〈function literal〉 if 〈body〉· 〈remainder statics defs〉 :- | 〈one static def 〉〈remainder statics defs〉\n48 Daniela Inclezan and Michael Gelfond\nAppendix B ALM and the Digital Aristotle\nThe reader may have noticed that the ALM examples included in the body of the paper are relatively small, which is understandable given that their purpose was to illustrate the syntax and semantics of our language and the methodology of representing knowledge in ALM. In this section, we show how the reuse of knowledge in ALM can potentially lead to the creation of larger practical systems. We present an application of our language to the task of question answering, in which ALM’s conceptual separation between an abstract theory and its structure played an important role in the reuse of knowledge. The signature of the theory and its structure provided the vocabulary for the logic form translation of facts expressed in natural language while the theory axioms contained the background knowledge needed for producing answers. The theory representing the biological domain remained unchanged and was coupled with various structures corresponding to particular questions and representing the domain at different levels of granularity. In addition to demonstrating the reuse of knowledge in ALM, this application also shows the elaboration tolerance of our language, as only minor changes to the structure had to be made when the domain was viewed in more detail, while the theory stayed the same. In what follows, we present the application in more detail.\nAfter designing our language, we tested and confirmed its adequacy for knowledge representation in the context of a practical question answering application: Project Halo (2002-2013) sponsored by Vulcan Inc.11 The goal of Project Halo was the creation of a Digital Aristotle — “an application containing large volumes of scientific knowledge and capable of applying sophisticated problem-solving methods to answer novel questions” (Gunning et al. 2010). Initially, the Digital Aristotle was only able to reason and answer questions about static domains. It lacked a methodology for answering questions about dynamic domains, as it was not clear how to represent and reason about such domains in the language of the Digital Aristotle. Our task within Project Halo was to create a methodology for answering questions about temporal projection in dynamic domains. We had two objectives. First, we wanted to see if the use of ALM for knowledge representation facilitated the task of encoding extensive amounts of scientific knowledge through its means for the reuse of knowledge. Second, we investigated whether provable correct and efficient logic programming algorithms could be developed to use the resulting ALM knowledge base in answering non-trivial questions.\nOur target scientific domain was biology, specifically the biological process of cell division (also called cell cycle). Cell cycle refers to the phases a cell goes through from its “birth” to its division into two daughter cells. Cells consist of a number of parts, which in turn consist of other parts (e.g., eukaryotic cells contain organelles, cytoplasm, and a nucleus; the nucleus contains chromosomes, and the description can continue with more detailed parts). The eukaryotic cell cycle consists of a growth phase (interphase) and a duplication/division phase (mitotic phase), both of which are conventionally described as sequences of sub-phases. Depending on the level\n11 http://www.allenai.org/TemplateGeneric.aspx?contentId=9\nModular Action Language ALM 49\nof detail of the description, these sub-phases may be simple events or sequences of other sub-phases (e.g., the mitotic phase is described in more detail as a sequence of two sub-phases: mitosis and cytokinesis; mitosis, in turn, can be seen as a sequence of five sub-phases, etc.). Certain chemicals, if introduced in the cell, can interfere with the ordered succession of events that is the cell cycle.\nIn order to be useful in answering complex questions, the ALM representation of cell cycle had to capture (1) non-trivial specialized biological knowledge about the structure of the cell at different stages of the cell cycle and (2) the dynamics of naturally evolving process (such as cell cycle), which consist of a series of phases and sub-phases that follow one another in a specific order, unless interrupted. We represented such processes as sequences of actions intended by nature and used a commonsense theory of intentions (Baral and Gelfond 2005) to reason about them.\nOur ALM cell cycle knowledge base consisted of two library modules. One of them was a general commonsense module describing sequences, in particular sequences of actions. The other module was a specialized one formalizing the biological phenomenon of cell division. We begin with the presentation of our commonsense module describing sequences, useful in modeling naturally evolving processes such as cell division. The equality component(S ,N ) = E appearing in the axioms of module sequence is supposed to be read as “the N th component of sequence S is E”. The library module sequence is stored in a general library called commonsense lib.\nmodule sequence\nsort declarations\nsequences :: universe\nattributes\nlength : positive natural numbers component : [0..length]→ universe\naction sequences :: sequences\naxioms\nfalse if component(S ,N ) = E ,\ninstance(S , action sequences), ¬instance(E , actions), ¬instance(E , action sequences).\nThe axiom ensures proper typing for the domain of an attribute component .\nNext, we present our formalization of cell cycle, given in a library module called basic cell cycle stored in a general cell cycle lib library. We started by modeling the eukaryotic cell, consisting of various parts that in turn consist of other parts. Together, they form a “part of ” hierarchy, say Hcell , which can be viewed as a tree. Nodes of this hierarchy were captured by a new sort, types of parts, while links in the hierarchy were represented by an attribute, is part of , defined on elements of the new sort (e.g., is part of (X ) = Y indicates that Y is the father of X in Hcell). We modeled the transitive closure of is part of by introducing a boolean function, part of , where part of (X ,Y ) is true if X is a descendant of Y in Hcell .\nIn the type of questions we addressed, at any given stage of the cell cycle process,\n50 Daniela Inclezan and Michael Gelfond\nall cells in the experimental sample had the same number of nuclei; similarly for the other inner components. As a result, we could assume that, at every stage and for each link from a child X to its parent Y in Hcell , this link was assigned a particular number indicating the number of elements of type X in one element of type Y . The states of our domain were described by a basic fluent, num : types of parts × types of parts → natural numbers, where num(P1,P2) = N holds if the number of elements of type P1 in one element of type P2 is N . For instance, num(nucleus, cell) = 2 indicates that, at the current stage of the cell cycle, each cell in the environment has two nuclei.\nTo describe the cell cycle we needed two action classes: duplicate and split . Duplicate, which acts upon an object that is an element from sort types of parts, doubles the number of every part of this kind present in the environment. Split also acts upon an object ranging over types of parts. An action a of this type with object(a) = c1, where c2 is a child of c1 in Hcell , duplicates the number of elements of type c1 in the environment and cuts in half the number of elements of type c2 in one element of type c1. For example, if the experimental environment consists of one cell with two nuclei, the occurrence of an instance a of action split with object(a) = cell increases the number of cells to two and decreases the number of nuclei per cells to one, thus resulting in an environment consisting of two cells with only one nucleus each. In addition to these two actions we had an exogenous action, prevent duplication, with an attribute object with the range types of parts. The occurrence of an instance action a of prevent duplication with object(a) = c nullifies the effects of duplication and splitting for the type c of parts. We made use of this exogenous action in representing external events that interfere with the normal succession of sub-phases of cell cycle. All this knowledge is represented by the following module:\nmodule basic cell cycle\nsort declarations\ntypes of parts :: universe\nattributes\nis part of : types of parts\nduplicate :: actions\nattributes\nobject : types of parts\nsplit :: duplicate\nprevent duplication :: actions\nattributes\nobject : types of parts\nfunction declarations\nstatics\ndefined\npart of : types of parts × types of parts → booleans\nModular Action Language ALM 51\nfluents\nbasic\ntotal num : types of parts × types of parts → natural numbers prevented dupl : types of parts → booleans\naxioms\noccurs(X ) causes num(P2,P1) = N2 if instance(X , duplicate),\nobject(X ) = P2, is part of (P2) = P1, num(P2,P1) = N1,\nN1 ∗ 2 = N2· occurs(X ) causes num(P2,P1) = N2 if instance(X , split),\nobject(X ) = P1, is part of (P2) = P1, num(P2,P1) = N1,\nN2 ∗ 2 = N1· occurs(X ) causes prevented dupl(P) if instance(X , prevent duplication), object(X ) = P · part of (P1,P2) if is part of (P1) = P2· part of (P1,P2) if is part of (P1) = P3, part of (P3,P2)· num(P ,P) = 0· num(P3,P1) = N if is part of (P3) = P2,\npart of (P2,P1), num(P2,P1) = N1, num(P3,P2) = N2,\nN1 ∗N2 = N · impossible occurs(X ) if instance(X , duplicate),\nobject(X ) = P , prevented dupl(P)·\nAny model of cell cycle consists of a theory importing the two library modules presented above and a structure corresponding to the level of detail of that model. Let us consider a first model, in which we view cell cycle as a sequence consisting of interphase and the mitotic phase. This is represented in the structure by adding the attribute assignments component(1) = interphase and component(2) = mitotic phase to the definition of instance cell cycle. We remind the reader that such attribute assignments are read as “the 1st component of cell cycle is interphase” and “the 2nd component of cell cycle is mitotic phase”. Interphase is considered an elementary action, while the mitotic phase splits the cell into two. We limit our domain to cells contained in an experimental environment, called sample.\nsystem description cell cycle(1)\ntheory\nimport module sequence from commonsense lib import module basic cell cycle from cell cycle lib\n52 Daniela Inclezan and Michael Gelfond\nstructure\ninstances\nsample in types of parts\ncell in types of parts\nis part of = sample\ncell cycle in action sequences\nlength = 2 component(1) = interphase component(2) = mitotic phase\ninterphase in actions\nmitotic phase in split\nobject = cell\nThis initial model of cell division is quite general. It was sufficient to answer a number of the questions targeted by the Digital Aristotle. There were, however, some questions which required a different model.\nConsider, for instance, the following question from (Campbell and Reece 2001):\n12.9. Text : In some organisms mitosis occurs without cytokinesis occurring.\nQuestion : How many cells will there be in the sample at the end of the cell cycle, and how many nuclei will each cell contain?\nTo answer it, the system needed to know more about the structure of the cell and that of the mitotic phase. ALM facilitated the creation of a refinement of our original model of cell division: a new system description, cell cycle(2), was easily created by adding to the previous structure a few new instances:\nnucleus in types of parts\nis part of = cell\nmitosis in duplicate\nis part of = nucleus\ncytokinesis in split\nis part of = cell\nand replacing the old definition of the instance mitotic phase by a new one:\nmitotic phase in action sequences\nlength = 2 component(1) = mitosis component(2) = cytokinesis\nSimilarly, various other refinements of our original model of cell division contained the same theory as the original formalization; only the structure of our original model needed to be modified, in an elaboration tolerant way. Matching questions with models of cell division containing just the right amount of detail is computationally advantageous and, in most cases, the matching can be done automatically.\nOur formalization of cell division illustrates ALM’s capabilities of creating large knowledge bases for practical systems through its mechanisms for reusing knowledge. In our example, the two modules that formed the theory were directly im-\nModular Action Language ALM 53\nported from the library into the system description. This shows that our main goal for ALM – the reuse of knowledge – was successfully achieved. Additionally, the example demonstrates ALM’s suitability for modeling not only commonsense dynamic systems, but also highly specialized, non-trivial domains. It shows the importance of creating and using libraries of knowledge in real-life applications, and it demonstrates the ease of elaborating initial formalizations of dynamic domains into more detailed ones.\nOur second task in Project Halo was to develop a proof-of-concept question answering system that used ALM formalizations of cell cycle in solving complex temporal projection questions like 12.9 above. To do that, we used the methodology described in Section 4.2, expanded by capabilities for reasoning about naturally evolving processes. This latter part was done by incorporating a theory of intentions (Baral and Gelfond 2005) and assuming that naturally evolving processes have the tendency (or the intention) to go through their sequence of phases in order, unless interrupted (e.g., we can say that a cell tends/ intends to go through its cell cycle, which it does unless unexpected events happen).\nIn our question answering methodology, the structure of our ALM system description for the cell cycle domain provided the vocabulary for translating the questions expressed in natural language into a history. The theory of the system description contained the axioms encoding the background knowledge needed to answer questions about the domain.\nAs an example, the information given in the text of 12.9 above would be encoded\nby a history that contains the facts\nobserved(num(cell , sample), 1, 0) observed(num(nucleus, cell), 1, 0) intend(cell cycle, 0) ¬happened(cytokinesis, I )\nfor every step I . Note that, unless otherwise specified, it would be assumed that the experimental sample consists of one cell with one nucleus.\nThe query in 12.9 would be encoded by the ASP{f} rules:\nanswer(X , “cells per sample”) ← last step(I ), num(cell , sample, I ) = X · answer(X , “nuclei per cell”) ← last step(I ), num(nucleus, cell , I ) = X ·\nOur system, ALMAS, would solve the question answering problem by first generating a logic program consisting of the above facts and rules encoding the history and query, respectively; the ASP{f} translation of the ALM system description cell cycle(2); and the temporal projection module described in Section 4.2. Then, the system would compute answer sets of this program, which correspond to answers to the question. For 12.9 there would be a unique answer set, containing:\n54 Daniela Inclezan and Michael Gelfond\nintend(cytokinesis, 2) ¬occurs(cytokinesis, 2) intend(cytokinesis, 3) ¬occurs(cytokinesis, 3) intend(cytokinesis, 4) ¬occurs(cytokinesis, 4) . . .\nThese facts indicate that the unfulfillable intention of executing action cytokinesis persists forever. Additionally, the answer set would include atoms:\nanswer(1, “cells per sample”) holds(val(num(cell , sample), 1), 2) answer(2, “nuclei per cell”) holds(val(num(nucleus, sample), 2), 2) last step(2) holds(val(num(nucleus, cell), 2), 2)\nwhich indicate that at the end of the cell cycle there will be one cell in the sample, with two nuclei. This is in fact the correct answer to question 12.9.\nThis question answering methodology and the methodology of reasoning about naturally evolving processes using intentions was successfully applied to other questions about cell division.\nModular Action Language ALM 55\nAppendix C Comparison between Languages ALM and MAD\nIn this section we give an informal discussion of the relationship between ALM and the modular action language MAD (Lifschitz and Ren 2006; Erdoǧan and Lifschitz 2006). Both languages have similar goals but differ significantly in the proposed ways to achieve these goals. We believe that each language supports its own distinctive style of representing knowledge about actions and change. The difference starts with the non-modular languages that serve as the basis for ALM and MAD . The former is a modular expansion of action language AL. The latter expands action language C (Giunchiglia and Lifschitz 1998). Even though these languages have a lot in common (see (Gelfond and Lifschitz 2012)) they differ significantly in the underlying assumptions incorporated in their semantics. For example, the semantics of AL incorporates the Inertia Axiom, which says that “Things normally stay the same.” Language C is based on a different assumption – the Causality Principle – which says that “Everything true in the world must be caused.” Its underlying logical basis is causal logic (McCain and Turner 1997; Giunchiglia et al. 2004). In C the inertia axiom for a literal l is expressed by a statement\ncaused l if l after l ,\nread as “there is a cause for l to hold after a transition if l holds both before and after the transition”. While AL allows two types of fluents – inertial and defined –, C can be used to define other types of fluents (e.g., default fluents that, unless otherwise stated, take on the fixed default values). The authors of this paper did not find these types of fluents to be particularly useful and, in accordance with their minimalist methodology, did not allow them in either AL or ALM. Of course, the question is not settled and our opinion can change with additional experience. On another hand, AL allows recursive state constraints and definitions, which are severely limited in C. There is a close relationship between ASP and C but, in our judgment, the distance between ASP and AL is smaller than that between ASP and C. There is also a substantial difference between modules of ALM and MAD .\nTo better understand the relationship let us consider the ALM theory motion and the system description travel from Section 3.2 and represent them in MAD .12\nExample 12 (A MAD Version of the System Description travel) The ALM system description travel is formed by the theory motion and the structure Bob and John. The theory consists of two modules, moving and carrying things, organized into a module hierarchy in which the latter module depends on the former. Let us start with the MAD representation of ALM’s module moving . In general, the representation of an ALM module M in MAD consists of two parts: the declaration of sorts of M and their inclusion relation, and the collection of MAD modules corresponding to M . (In our first example a module of ALM will be\n12 Although the “Monkey and Banana” problem presented in Section 4.1 has been encoded in MAD as well (Erdoǧan 2008), we are not considering it here because of the length of its representation and, most importantly, because there are substantial differences in how the problem was addressed in ALM versus MAD from the knowledge representation point of view.\n56 Daniela Inclezan and Michael Gelfond\nmapped into a single module of MAD .) Note that sorts can also be declared within the module but in this case they will be local (i.e., invisible to other modules). Declarations given outside of a module can be viewed as global.\nIn our case, the sorts and inclusions sections of the translation\nM1 = MAD(moving) consist of the following statements (We remind the reader that in MAD variables are identifiers starting with a lower-case letter and constants are identifiers starting with an upper-case letter, the opposite of ALM ): sorts\nUniverse; Points; Things; Agents;\ninclusions\nPoints Universe; Things Universe; Agents Things;\nThe sorts part declares the sort universe (which is pre-defined and does not require declaration in ALM) together with the sorts of moving that are not special cases of actions. The inclusions part describes the specialization relations between these sorts. The definition of a MAD module starts with a title:\nmodule M1\nThe body of a MAD module consists of separate (optional) sections for the declarations of sorts specific to the current module, objects, fluents, actions, and variables, in this order, together with a section dedicated to axioms (Erdoǧan 2008). Our module M1 starts with the declarations of fluents:\nfluents\nSymmetric connectivity : rigid ; Transitive connectivity : rigid ; Connected(Points,Points) : simple; Loc in(Things) : simple(Points);\nRigid fluents of MAD are basic statics of ALM.\nTo declare the action class move of moving we need to model its attributes. To do that we introduce variables with the same names as the associated attributes in moving . This will facilitate referring to those attributes later in axioms. We also order attributes alphabetically as arguments of the action term to ease the translation of special case action classes of move:\nactions\nMove(Agents,Points,Points);\nThe variable declaration and axiom part come next. We will need to add extra axioms (and associated variables) to say that Loc in is an inertial fluent (i.e., basic fluent in ALM terminology) and that Move(Agents,Points,Points) is an exogenous action (i.e., it does not need a cause in order to occur; it may or may not occur at any point in time).\nModular Action Language ALM 57\nvariables\nt , t1, t2 : Things; actor : Agents; origin, dest : Points;\naxioms\ninertial Loc in(t); exogenous Move(actor , dest , origin);\nThe causal law for move can now be expressed in a natural way:\nMove(actor , dest , origin) causes Loc in(actor) = dest ;\nSimilarly for the executability conditions:\nnonexecutable Move(actor , dest , origin) if Loc in(actor) 6= origin; nonexecutable Move(actor , dest , origin) if Loc in(actor) = dest ;\nnonexecutable Move(actor , dest , origin) if Loc in(actor) = origin,\n¬Connected(origin, dest);\nThe situation becomes substantially more difficult for the definition of Connected . The definition used in moving is recursive and therefore cannot be easily emulated by MAD ’s causal laws. The relation can, of course, be explicitly specified later together with the description of particular places, but this causes considerable inconvenience.\nTo represent module carrying things from the theory motion we need a new\n(global) sort:\nsorts\nCarriables;\ninclusions\nCarriables Things;\nThe module M2 that corresponds to carrying things contains declarations of the new action Carry and the corresponding variables.\nmodule M2;\nactions\nCarry(Agents,Carriables,Points,Points);\nvariables\nt : Things; actor : Agents; dest , origin, p : Points; carried object , c : Carriables;\nNext we need to define axioms of the module. Clearly we need to say that the action Carry(actor , carried object , dest , origin) is a special case of the action Move(actor , dest , origin). Since ALM allows action sorts, no new mechanism is required to do that in carrying things. In MAD , while there is a built-in sort action, special case actions are not sorts and the special constructs import and is are\n58 Daniela Inclezan and Michael Gelfond\nintroduced to achieve this goal. Special case actions are declared in MAD by importing the module containing the original action and renaming the original action as the special case action as follows:\nimport M1;\nMove(actor , dest , origin) is Carry(actor , carried object , dest , origin);\nIntuitively, this import statement says that the action Carry(actor , carried object , dest , origin) has all properties that are postulated for the action Move(actor , dest , origin) in the module M1. We also need an additional axiom declaring the action to be exogenous, and state constraints, and executability conditions similar to those in carrying things:\naxioms\nexogenous Carry(actor , carried object , dest , origin);\n% State constraints: Is held(c) if Holding(t , c);\n% Executability conditions: nonexecutable Carry(actor , carried object , dest , origin) if ¬Holding(actor , carried object); nonexecutable Move(actor , dest , origin) if Is held(actor);\nNote, however, that the ALM module carrying things also contained the recursive state constraints below, saying that agents and the objects they are holding have the same location: loc in(C ) = P if holding(T ,C ), loc in(T ) = P · loc in(T ) = P if holding(T ,C ), loc in(C ) = P · Since this is not allowed in MAD , we have to use a less elaboration tolerant representation by adding an explicit causal law saying\nMove(actor , dest , origin) causes Loc in(c) = dest if Holding(actor , c);\nIn MAD additional axioms will be needed to rule out certain initial situations (e.g., “John is holding his suitcase. He is in Paris. His suitcase is in Rome.”) or to represent and reason correctly about more complex scenarios (e.g., “Alice is in the kitchen, holding her baby who is holding a toy. Alice goes to the living room.”).\nThis completes the construction of M2.\nIn general, special case actions are declared in MAD by importing the module containing the original action and renaming the original action as the special case action. That is why we needed to place the MAD representation of carry in a new module that we call M2, in which we import module M1 while renaming Move(actor , dest , origin) as Carry(actor , carried object , dest , origin). In ALM the declarations of move and its specialization carry could be placed in the same module – the decision is up to the user – whereas in MAD they must be placed in separate modules. This potentially leads to a larger number of smaller modules in MAD than in ALM representations.\nFinally, we consider the structure of our ALM system description. It contains two types of actions go(Actor ,Dest) and go(Actor ,Dest ,Origin). Let us expand the\nModular Action Language ALM 59\nstructure by a new object, suitcase, and a new action carry(Actor , suitcase,Dest). For illustrative purposes, let us assume that we would like the MAD representation to preserve these names.\nTo represent this in MAD , we introduce a new module S . It has the local defini-\ntions of objects:\nmodule S ;\nobjects\nJohn,Bob : Agents; New York ,Paris,Rome : Points; Suitcase : Carriables;\nand those of actions. The latter can be defined via the renaming mechanism of MAD . This requires importing the modules in which the action classes were declared. Thus, module S imports modules M1 and M2.\nactions\nGo(Agents,Points); Go(Agents,Points,Points); Carry(Agents,Carriables,Points);\nvariables\nactor : Agents; origin, dest : Points;\nimport M1;\nMove(actor , dest , origin) is Go(actor , dest , origin);\nimport M1;\nMove(actor , dest , origin) is Go(actor , dest);\nimport M2;\nCarry(actor ,Suitcase, dest , origin) is Carry(actor ,Suitcase, dest)\nThis completes the construction of the MAD representation of the system description travel .\nEven this simple example allows to illustrate some important differences between\nALM and MAD . Here is a short summary:\n• Recursive definitions The representation of state constraints of an ALM system description is not straightforward if the set of state constraints defines a cyclic fluent dependency\ngraph (Gelfond and Lifschitz 2012). For instance, the ALM state constraint:\np if p·\nis not equivalent to the same axiom in MAD . The ALM axiom can be eliminated without modifying the meaning of the system description; it says that “in every state in which p holds, p must hold.” Eliminating the same axiom from a MAD action description would not produce an equivalent action description; in MAD , the axiom says that “p holds by default.” This difference\n60 Daniela Inclezan and Michael Gelfond\nbetween ALM and MAD is inherited from the similar difference between AL and C. • Separation of Sorts and Instances One of the most important features of ALM is its support for a clear separation of the definition of sorts of objects of the domain (given in the system’s\ntheory) from the definition of instances of these sorts (given by the system’s structure). Even though it may be tempting to view the first two modules, M1 and M2 above as a MAD counterpart of the ALM theory motion, the analogy does not hold. Unlike ALM where the corresponding theory has a clear semantics independent of that of the structure, no such semantics exists in MAD . Modules M1 and M2 only acquire their meaning after the addition of module S that corresponds to the ALM’s structure. We believe that the existence of the independent semantics of ALM theories facilitates the stepwise development and testing of the knowledge base and improves their elaboration tolerance. • Action Sorts In ALM, the pre-defined sort actions is part of the sort hierarchy, whereas in MAD actions are not considered sorts. Instead, MAD has special constructs\nimport and is (also known as bridge rules), which are used to define actions as special cases of other actions. No such special constructs are needed in ALM. Moreover, in ALM, an action class and its specialization can be part of the same module. This is not the case in MAD where a special case of an action class must be declared in a separate module by importing the module containing the original action class and using renaming clauses. As a consequence, the MAD representation of ALM system descriptions will generally contain more modules that are smaller in size than the ALM counterpart. On the other hand, note that ALM modules are not required to be large; they can be as small as a user desires. ALM allows the definition of fluents on (or ranging over) specific action classes only, and not necessarily the whole pre-defined actions sort, for instance:\nintended : agent actions → booleans\nwhere agent actions is a special case of actions. There is no equivalent concept in MAD , where fluents must be defined on, and range over, either primitive sorts or the built-in sort action, but not specific actions. • Variable Declarations In ALM, we do not define the sorts of variables used in the axioms. This information is evident from the atoms in which they appear. In MAD , vari-\nables need to be defined, which may lead to larger modules and cause errors related to use of variables of wrong types. • Renaming Feature of MAD In MAD , sorts can be renamed by importing the module containing the orig-\ninal declaration of a sort and using a renaming clause. The meaning of such a\nModular Action Language ALM 61\nrenaming clause is that the two sorts are synonyms. There is no straightforward way to define this synonymy in ALM. The closest thing is to use the specialization construct of our language and declare the new sort as a special case of the original one. The reverse (i.e., the original sort being a special case of the renamed sort) cannot be added, as sort hierarchies of ALM are required to be DAGs. This leads to further problems when the renamed sorts appear as attributes in renamed actions of MAD . • Axioms of MAD that have no equivalent in ALM Some axioms, allowed in MAD , are not directly expressible in ALM. For instance, MAD axioms of the type:\nformula may cause formula [ if formula ]\nor\ndefault formula [ if formula ] [ after formula ]\nbelong to this group. The first axiom allows to specify non-deterministic effects of actions, while the second assignes default values to fluents (and more complex formulas). As discussed above, we are not yet convinced that the latter type of axioms needs to be allowed in ALM. Non-determinism, however, is an important feature that one should be able to express in an action formalism. It may be added to ALM (and to AL) in a very natural manner, but it is not allowed in AL and the mathematical properties of “non-deterministic” AL were not yet investigated. Because of this we decided to add this feature in the next version of ALM.\nWe hope that this section gives the reader some useful insight in differences between ALM and MAD . We plan to extend the comparison between ALM and MAD in the future. Formally investigating the relationship between the two languages can facilitate the translation of knowledge modules from one language to another, and can identify situations when one language is preferable to the other. Readers interested in a formal translation of system descriptions of ALM to action descriptions of MAD can consult (Inclezan 2012).\n62 Daniela Inclezan and Michael Gelfond"
    } ],
    "references" : [ {
      "title" : "Representing the zoo world and the traffic world in the language of the Causal Calculator",
      "author" : [ "V. Akman", "S.T. Erdoǧan", "J. Lee", "V. Lifschitz", "H. Turner" ],
      "venue" : "Artificial Intelligence 153, 1–2 (March), 105–140.",
      "citeRegEx" : "Akman et al\\.,? 2004",
      "shortCiteRegEx" : "Akman et al\\.",
      "year" : 2004
    }, {
      "title" : "SPARC – Sorted ASP with Consistency Restoring Rules",
      "author" : [ "E. Balai", "M. Gelfond", "Y. Zhang" ],
      "venue" : "Proceedings of Answer Set Programming and Other Computing Paradigms (ASPOCP 2012), M. Fink and Y. Lierler, Eds. Proceedings published online in arXiv at http://arxiv.org/html/1301.2215v1, 19–33.",
      "citeRegEx" : "Balai et al\\.,? 2012",
      "shortCiteRegEx" : "Balai et al\\.",
      "year" : 2012
    }, {
      "title" : "USA-Smart: Improving the Quality of Plans in Answer Set Planning",
      "author" : [ "M. Balduccini" ],
      "venue" : "PADL’04, B. Jayaraman, Ed. Lecture Notes in Artificial Intelligence (LNCS). Springer, Berlin, 135–147.",
      "citeRegEx" : "Balduccini,? 2004",
      "shortCiteRegEx" : "Balduccini",
      "year" : 2004
    }, {
      "title" : "CR-MODELS: An Inference Engine for CR-Prolog",
      "author" : [ "M. Balduccini" ],
      "venue" : "Proceedings of LPNMR-07, C. Baral, G. Brewka, and J. S. Schlipf, Eds. Springer, Berlin, 18–30.",
      "citeRegEx" : "Balduccini,? 2007",
      "shortCiteRegEx" : "Balduccini",
      "year" : 2007
    }, {
      "title" : "ASP with non-Herbrand partial functions: a language and system for practical use",
      "author" : [ "M. Balduccini" ],
      "venue" : "Theory and Practice of Logic Programming 13, 4–5, 547–561.",
      "citeRegEx" : "Balduccini,? 2013",
      "shortCiteRegEx" : "Balduccini",
      "year" : 2013
    }, {
      "title" : "Diagnostic Reasoning with A-Prolog",
      "author" : [ "M. Balduccini", "M. Gelfond" ],
      "venue" : "Theory and Practice of Logic Programming 3, 425–461.",
      "citeRegEx" : "Balduccini and Gelfond,? 2003a",
      "shortCiteRegEx" : "Balduccini and Gelfond",
      "year" : 2003
    }, {
      "title" : "Logic Programs with Consistency-Restoring Rules",
      "author" : [ "M. Balduccini", "M. Gelfond" ],
      "venue" : "International Symposium on Logical Formalization of Commonsense Reasoning, P. Doherty, J. McCarthy, and M.-A. Williams, Eds. AAAI 2003 Spring Symposium Series. Palo Alto, CA, 9–18. Balduccini, M. and Gelfond, M. 2012. Language ASP{f} with Arithmetic Expressions",
      "citeRegEx" : "Balduccini and Gelfond,? 2003b",
      "shortCiteRegEx" : "Balduccini and Gelfond",
      "year" : 2003
    }, {
      "title" : "Knowledge Representation, Reasoning, and Declarative Problem Solving",
      "author" : [ "C. Baral" ],
      "venue" : "Cambridge University Press.",
      "citeRegEx" : "Baral,? 2003",
      "shortCiteRegEx" : "Baral",
      "year" : 2003
    }, {
      "title" : "Macros, macro calls and use of ensembles in modular answer set programming",
      "author" : [ "C. Baral", "J. Dzifcak", "H. Takahashi" ],
      "venue" : "Logic Programming, S. Etalle and M. Truszczyski, Eds. Lecture Notes in Computer Science, vol. 4079. Springer Berlin Heidelberg, 376–390.",
      "citeRegEx" : "Baral et al\\.,? 2006",
      "shortCiteRegEx" : "Baral et al\\.",
      "year" : 2006
    }, {
      "title" : "Reasoning Agents in Dynamic Domains",
      "author" : [ "C. Baral", "M. Gelfond" ],
      "venue" : "Kluwer Academic Publishers, Norwell, MA, 257–279.",
      "citeRegEx" : "Baral and Gelfond,? 2000",
      "shortCiteRegEx" : "Baral and Gelfond",
      "year" : 2000
    }, {
      "title" : "Reasoning about Intended Actions",
      "author" : [ "C. Baral", "M. Gelfond" ],
      "venue" : "AAAI-05: Proceedings of the 20th National Conference on Artificial Intelligence. AAAI Press, 689–694.",
      "citeRegEx" : "Baral and Gelfond,? 2005",
      "shortCiteRegEx" : "Baral and Gelfond",
      "year" : 2005
    }, {
      "title" : "On the stable model semantics for intensional functions",
      "author" : [ "M. Bartholomew", "J. Lee" ],
      "venue" : "Journal of Theory and Practice of Logic Programming (TPLP) 13, 4–5, 863–876.",
      "citeRegEx" : "Bartholomew and Lee,? 2013",
      "shortCiteRegEx" : "Bartholomew and Lee",
      "year" : 2013
    }, {
      "title" : "Towards a Theory of Intentional Agents",
      "author" : [ "J. Blount", "M. Gelfond", "M. Balduccini" ],
      "venue" : "M. Sridharan, F. Yang, S. Ramamoorthy, V. Patoglu, and E. Erdem, Eds. AAAI 2014 Spring Symposium Series. AAAI Press, Palo Alto, CA.",
      "citeRegEx" : "Blount et al\\.,? 2014",
      "shortCiteRegEx" : "Blount et al\\.",
      "year" : 2014
    }, {
      "title" : "Functional answer set programming",
      "author" : [ "P. Cabalar" ],
      "venue" : "Journal of Theory and Practice of Logic Programming (TPLP) 11, 2–3, 203–233.",
      "citeRegEx" : "Cabalar,? 2011",
      "shortCiteRegEx" : "Cabalar",
      "year" : 2011
    }, {
      "title" : "Template programs for disjunctive logic programming: An operational semantics",
      "author" : [ "F. Calimeri", "G. Ianni" ],
      "venue" : "AI Communications 19, 3, 193–206.",
      "citeRegEx" : "Calimeri and Ianni,? 2006",
      "shortCiteRegEx" : "Calimeri and Ianni",
      "year" : 2006
    }, {
      "title" : "Biology , 6th ed",
      "author" : [ "N.A. Campbell", "J.B. Reece" ],
      "venue" : "Benjamin Cummings.",
      "citeRegEx" : "Campbell and Reece,? 2001",
      "shortCiteRegEx" : "Campbell and Reece",
      "year" : 2001
    }, {
      "title" : "Planning and Scheduling in Hybrid Domains",
      "author" : [ "S. Chintabathina" ],
      "venue" : "Frontiers in Artificial Intelligence and Applications 241, 59–70.",
      "citeRegEx" : "Chintabathina,? 2012",
      "shortCiteRegEx" : "Chintabathina",
      "year" : 2012
    }, {
      "title" : "Modeling Hybrid Domains Using Process Description Language",
      "author" : [ "S. Chintabathina", "M. Gelfond", "R. Watson" ],
      "venue" : "Proceedings of ASP ’05 Answer Set Programming: Advances in Theory and Implementation. 303–317.",
      "citeRegEx" : "Chintabathina et al\\.,? 2005",
      "shortCiteRegEx" : "Chintabathina et al\\.",
      "year" : 2005
    }, {
      "title" : "A modular action description language for protocol composition",
      "author" : [ "N. Desai", "M.P. Singh" ],
      "venue" : "Proceedings of the Twenty-Second AAAI Conference on Artificial Intelligence, July 22-26, 2007, Vancouver, British Columbia, Canada. 962–967.",
      "citeRegEx" : "Desai and Singh,? 2007",
      "shortCiteRegEx" : "Desai and Singh",
      "year" : 2007
    }, {
      "title" : "Multivalued action languages with constraints in CLP(FD)",
      "author" : [ "A. Dovier", "A. Formisano", "E. Pontelli" ],
      "venue" : "Logic Programming: Lecture Notes in Computer Science 4670, 255–270.",
      "citeRegEx" : "Dovier et al\\.,? 2007",
      "shortCiteRegEx" : "Dovier et al\\.",
      "year" : 2007
    }, {
      "title" : "Updating action domain descriptions",
      "author" : [ "T. Eiter", "E. Erdem", "M. Fink", "J. Senko" ],
      "venue" : "Artif. Intell. 174, 15 (Oct.), 1172–1221.",
      "citeRegEx" : "Eiter et al\\.,? 2010",
      "shortCiteRegEx" : "Eiter et al\\.",
      "year" : 2010
    }, {
      "title" : "Approach to knowledge-state planning: Semantics and complexity",
      "author" : [ "T. Eiter", "W. Faber", "N. Leone", "G. Pfeifer", "A. Polleres" ],
      "venue" : "ACM Transactions on Computational Logic 5, 206–263.",
      "citeRegEx" : "Eiter et al\\.,? 2004",
      "shortCiteRegEx" : "Eiter et al\\.",
      "year" : 2004
    }, {
      "title" : "Combining answer set programming with description logics for the semantic web",
      "author" : [ "T. Eiter", "G. Ianni", "T. Lukasiewicz", "R. Schindlauer", "H. Tompits" ],
      "venue" : "Artificial Intelligence 172, 12–13 (August), 1495–1539.",
      "citeRegEx" : "Eiter et al\\.,? 2008",
      "shortCiteRegEx" : "Eiter et al\\.",
      "year" : 2008
    }, {
      "title" : "Actions as special cases",
      "author" : [ "S. Erdoǧan", "V. Lifschitz" ],
      "venue" : "Principles of Knowledge Representation and Reasoning: Proceedings of the International Conference, P. Doherty, J. Mylopoulos, and C. A. Welty, Eds. AAAI Press, Palo Alto, CA, 377–387.",
      "citeRegEx" : "Erdoǧan and Lifschitz,? 2006",
      "shortCiteRegEx" : "Erdoǧan and Lifschitz",
      "year" : 2006
    }, {
      "title" : "A Library of General-Purpose Action Descriptions",
      "author" : [ "S.T. Erdoǧan" ],
      "venue" : "Ph.D. thesis, University of Texas at Austin, Austin, TX, USA.",
      "citeRegEx" : "Erdoǧan,? 2008",
      "shortCiteRegEx" : "Erdoǧan",
      "year" : 2008
    }, {
      "title" : "Modeling Hybrid Domains Using Process Description Language",
      "author" : [ "P. Fodor", "M. Kifer" ],
      "venue" : "Proceedings of the 27th International Conference on Logic Programming (ICLP), J. P. Gallagher and M. Gelfond, Eds. Schloss Dagstuhl - Leibniz-Zentrum fuer Informatik, Wadern, 162–174.",
      "citeRegEx" : "Fodor and Kifer,? 2011",
      "shortCiteRegEx" : "Fodor and Kifer",
      "year" : 2011
    }, {
      "title" : "Reactive answer set programming",
      "author" : [ "M. Gebser", "T. Grote", "R. Kaminski", "T. Schaub" ],
      "venue" : "LPNMR, J. P. Delgrande and W. Faber, Eds. Lecture Notes in Computer Science, vol. 6645. Springer, 54–66.",
      "citeRegEx" : "Gebser et al\\.,? 2011",
      "shortCiteRegEx" : "Gebser et al\\.",
      "year" : 2011
    }, {
      "title" : "Answer Set Solving in Practice",
      "author" : [ "M. Gebser", "R. Kaminski", "B. Kaufmann", "T. Schaub" ],
      "venue" : "Synthesis Lectures on Artificial Intelligence and Machine Learning. Morgan and Claypool Publishers.",
      "citeRegEx" : "Gebser et al\\.,? 2012",
      "shortCiteRegEx" : "Gebser et al\\.",
      "year" : 2012
    }, {
      "title" : "An incremental answer set programming based system for finite model computation",
      "author" : [ "M. Gebser", "O. Sabuncu", "T. Schaub" ],
      "venue" : "AI Commun. 24, 2, 195–212.",
      "citeRegEx" : "Gebser et al\\.,? 2011",
      "shortCiteRegEx" : "Gebser et al\\.",
      "year" : 2011
    }, {
      "title" : "Yet Another Modular Action Language",
      "author" : [ "M. Gelfond", "D. Inclezan" ],
      "venue" : "Proceedings of SEA-09. University of Bath Opus: Online Publications Store, 64–78.",
      "citeRegEx" : "Gelfond and Inclezan,? 2009",
      "shortCiteRegEx" : "Gelfond and Inclezan",
      "year" : 2009
    }, {
      "title" : "Some properties of system descriptions in ALd",
      "author" : [ "M. Gelfond", "D. Inclezan" ],
      "venue" : "Journal of Applied Non-Classical Logics 23, 105–120.",
      "citeRegEx" : "Gelfond and Inclezan,? 2013",
      "shortCiteRegEx" : "Gelfond and Inclezan",
      "year" : 2013
    }, {
      "title" : "Knowledge Representation, Reasoning, and the Design of Intelligent Agents",
      "author" : [ "M. Gelfond", "Y. Kahl" ],
      "venue" : "Cambridge University Press.",
      "citeRegEx" : "Gelfond and Kahl,? 2014",
      "shortCiteRegEx" : "Gelfond and Kahl",
      "year" : 2014
    }, {
      "title" : "The Stable Model Semantics for Logic Programming",
      "author" : [ "M. Gelfond", "V. Lifschitz" ],
      "venue" : "Proceedings of ICLP-88, R. A. Kowalski and K. A. Bowen, Eds. MIT Press, Cambridge, MA, 1070–1080.",
      "citeRegEx" : "Gelfond and Lifschitz,? 1988",
      "shortCiteRegEx" : "Gelfond and Lifschitz",
      "year" : 1988
    }, {
      "title" : "Classical Negation in Logic Programs and Disjunctive Databases",
      "author" : [ "M. Gelfond", "V. Lifschitz" ],
      "venue" : "New Generation Computing 9, 3/4, 365–386.",
      "citeRegEx" : "Gelfond and Lifschitz,? 1991",
      "shortCiteRegEx" : "Gelfond and Lifschitz",
      "year" : 1991
    }, {
      "title" : "Representing Action and Change by Logic Programs",
      "author" : [ "M. Gelfond", "V. Lifschitz" ],
      "venue" : "Journal of Logic Programming 17, 2–4, 301–321.",
      "citeRegEx" : "Gelfond and Lifschitz,? 1993",
      "shortCiteRegEx" : "Gelfond and Lifschitz",
      "year" : 1993
    }, {
      "title" : "Action languages",
      "author" : [ "M. Gelfond", "V. Lifschitz" ],
      "venue" : "Electronic Transactions on AI 3, 16, 193–210.",
      "citeRegEx" : "Gelfond and Lifschitz,? 1998",
      "shortCiteRegEx" : "Gelfond and Lifschitz",
      "year" : 1998
    }, {
      "title" : "The Common Core of Action Languages B and C",
      "author" : [ "M. Gelfond", "V. Lifschitz" ],
      "venue" : "Proceedings of the 14th International Workshop on Non-Monotonic Reasoning (NMR’2012).",
      "citeRegEx" : "Gelfond and Lifschitz,? 2012",
      "shortCiteRegEx" : "Gelfond and Lifschitz",
      "year" : 2012
    }, {
      "title" : "Nonmonotonic Causal Theories",
      "author" : [ "E. Giunchiglia", "J. Lee", "V. Lifschitz", "N. McCain", "H. Turner" ],
      "venue" : "Artificial Intelligence 153, 1–2, 105–140.",
      "citeRegEx" : "Giunchiglia et al\\.,? 2004",
      "shortCiteRegEx" : "Giunchiglia et al\\.",
      "year" : 2004
    }, {
      "title" : "An Action Language Based on Causal Explanation: Preliminary Report",
      "author" : [ "E. Giunchiglia", "V. Lifschitz" ],
      "venue" : "Proceedings of National Conference on Artificial Intelligence (AAAI). AAAI Press, Palo Alto, CA, 623–630.",
      "citeRegEx" : "Giunchiglia and Lifschitz,? 1998",
      "shortCiteRegEx" : "Giunchiglia and Lifschitz",
      "year" : 1998
    }, {
      "title" : "The SILK System: Scalable Higher-Order Defeasible Rules",
      "author" : [ "B. Grosof", "M. Dean", "M. Kifer" ],
      "venue" : "International RuleML Symposium on Rule Interchange and Applications.",
      "citeRegEx" : "Grosof et al\\.,? 2009",
      "shortCiteRegEx" : "Grosof et al\\.",
      "year" : 2009
    }, {
      "title" : "Project Halo–Progress Toward Digital Aristotle",
      "author" : [ "D. Gunning", "V.K. Chaudhri", "P. Clark", "K. Barker", "Chaw", "S.-Y.", "M. Greaves", "B. Grosof", "A. Leung", "D. McDonald", "S. Mishra", "J. Pacheco", "B. Porter", "A. Spaulding", "D. Tecuci", "J. Tien" ],
      "venue" : "AI Magazine 31, 3, 33–58.",
      "citeRegEx" : "Gunning et al\\.,? 2010",
      "shortCiteRegEx" : "Gunning et al\\.",
      "year" : 2010
    }, {
      "title" : "Elaboration tolerance through objectorientation",
      "author" : [ "J. Gustafsson", "J. Kvarnström" ],
      "venue" : "Artificial Intelligence 153, 239–285.",
      "citeRegEx" : "Gustafsson and Kvarnström,? 2004",
      "shortCiteRegEx" : "Gustafsson and Kvarnström",
      "year" : 2004
    }, {
      "title" : "The integration of functions into logic programming: From theory to practice",
      "author" : [ "M. Hanus" ],
      "venue" : "Journal of Logic Programming 19–20, 583–628.",
      "citeRegEx" : "Hanus,? 1994",
      "shortCiteRegEx" : "Hanus",
      "year" : 1994
    }, {
      "title" : "The LMW traffic world in the fluent calculus",
      "author" : [ "A. Henschel", "M. Thielscher" ],
      "venue" : null,
      "citeRegEx" : "Henschel and Thielscher,? \\Q1999\\E",
      "shortCiteRegEx" : "Henschel and Thielscher",
      "year" : 1999
    }, {
      "title" : "Computing Trajectories of Dynamic Systems Using ASP and Flora",
      "author" : [ "D. Inclezan" ],
      "venue" : null,
      "citeRegEx" : "Inclezan,? \\Q2010\\E",
      "shortCiteRegEx" : "Inclezan",
      "year" : 2010
    }, {
      "title" : "Modular Action Language ALM for Dynamic Domain Representation",
      "author" : [ "D. Inclezan" ],
      "venue" : "Ph.D. thesis, Texas Tech University, Lubbock, TX, USA.",
      "citeRegEx" : "Inclezan,? 2012",
      "shortCiteRegEx" : "Inclezan",
      "year" : 2012
    }, {
      "title" : "Representing Biological Processes in Modular Action Language ALM",
      "author" : [ "D. Inclezan", "M. Gelfond" ],
      "venue" : "Proceedings of the 2011 AAAI Spring Symposium on Formalizing Commonsense. AAAI Press, 49–55.",
      "citeRegEx" : "Inclezan and Gelfond,? 2011",
      "shortCiteRegEx" : "Inclezan and Gelfond",
      "year" : 2011
    }, {
      "title" : "A simple declarative language for describing narratives with actions",
      "author" : [ "A. Kakas", "R. Miller" ],
      "venue" : "Journal of Logic Programming 31, 1–3, 157–200.",
      "citeRegEx" : "Kakas and Miller,? 1997",
      "shortCiteRegEx" : "Kakas and Miller",
      "year" : 1997
    }, {
      "title" : "The DLV system for knowledge representation and reasoning",
      "author" : [ "N. Leone", "G. Pfeifer", "W. Faber", "T. Eiter", "G. Gottlob", "S. Perri", "F. Scarcello" ],
      "venue" : "ACM Transactions on Computational Logic 7, 3, 499–562.",
      "citeRegEx" : "Leone et al\\.,? 2006",
      "shortCiteRegEx" : "Leone et al\\.",
      "year" : 2006
    }, {
      "title" : "Modular answer set solving",
      "author" : [ "Y. Lierler", "M. Truszczynski" ],
      "venue" : "Proceedings of the 27th AAAI Conference on Artificial Intelligence(AAAI-13). 68–70.",
      "citeRegEx" : "Lierler and Truszczynski,? 2013",
      "shortCiteRegEx" : "Lierler and Truszczynski",
      "year" : 2013
    }, {
      "title" : "Logic programs with intensional functions",
      "author" : [ "V. Lifschitz" ],
      "venue" : "Proceedings of International Conference on Principles of Knowledge Representation and Reasoning (KR), G. Brewka, T. Eiter, and S. A. McIlraith, Eds. AAAI Press, 24–31.",
      "citeRegEx" : "Lifschitz,? 2012",
      "shortCiteRegEx" : "Lifschitz",
      "year" : 2012
    }, {
      "title" : "A Modular Action Description Language",
      "author" : [ "V. Lifschitz", "W. Ren" ],
      "venue" : "Proceedings of the Twenty-First National Conference on Artificial Intelligence (AAAI). 853–859.",
      "citeRegEx" : "Lifschitz and Ren,? 2006",
      "shortCiteRegEx" : "Lifschitz and Ren",
      "year" : 2006
    }, {
      "title" : "Stable models and an alternative logic programming paradigm",
      "author" : [ "V.W. Marek", "M. Truszczynski" ],
      "venue" : "The Logic Programming Paradigm: a 25-Year Perspective. Springer Verlag, Berlin, 375–398.",
      "citeRegEx" : "Marek and Truszczynski,? 1999",
      "shortCiteRegEx" : "Marek and Truszczynski",
      "year" : 1999
    }, {
      "title" : "Causal Theories of Action and Change",
      "author" : [ "N. McCain", "H. Turner" ],
      "venue" : "Proceedings of AAAI-97. 460–465.",
      "citeRegEx" : "McCain and Turner,? 1997",
      "shortCiteRegEx" : "McCain and Turner",
      "year" : 1997
    }, {
      "title" : "Situations, actions, and causal laws",
      "author" : [ "J. McCarthy" ],
      "venue" : "Tech. Rep. Memo 2, Stanford University.",
      "citeRegEx" : "McCarthy,? 1963",
      "shortCiteRegEx" : "McCarthy",
      "year" : 1963
    }, {
      "title" : "Programs with common sense",
      "author" : [ "J. McCarthy" ],
      "venue" : "Semantic Information Processing. MIT Press, 403–418.",
      "citeRegEx" : "McCarthy,? 1968",
      "shortCiteRegEx" : "McCarthy",
      "year" : 1968
    }, {
      "title" : "Elaboration Tolerance",
      "author" : [ "J. McCarthy" ],
      "venue" : "Proceedings of Commonsense Reasoning. Available online at: http://www-formal.stanford.edu/jmc/elaboration/elaboration. html.",
      "citeRegEx" : "McCarthy,? 1998",
      "shortCiteRegEx" : "McCarthy",
      "year" : 1998
    }, {
      "title" : "Logic Programs with Stable Model Semantics as a Constraint Programming Paradigm",
      "author" : [ "I. Niemelä" ],
      "venue" : "Annals of Mathematics and Artificial Intelligence 25, 72–79.",
      "citeRegEx" : "Niemelä,? 1998",
      "shortCiteRegEx" : "Niemelä",
      "year" : 1998
    }, {
      "title" : "Smodels - an implementation of the stable model and well-founded semantics for normal logic programs",
      "author" : [ "I. Niemelä", "P. Simons" ],
      "venue" : "Proceedings of the 4th International Conference on Logic Programming and Non-Monotonic Reasoning (LPNMR-97), J. Dix, U. Furbach, and A. Nerode, Eds. Lecture Notes in Artificial Intelligence (LNCS), vol. 1265. Springer, Berlin, 420–429.",
      "citeRegEx" : "Niemelä and Simons,? 1997",
      "shortCiteRegEx" : "Niemelä and Simons",
      "year" : 1997
    }, {
      "title" : "Modular equivalence for normal logic programs",
      "author" : [ "E. Oikarinen", "T. Janhunen" ],
      "venue" : "Proceedings of 17th European Conference on Artificial Intelligence(ECAI), G. Brewka, S. Coradeschi, A. Perini, and P. Traverso, Eds. IOS Press, Amsterdam, 412–416.",
      "citeRegEx" : "Oikarinen and Janhunen,? 2006",
      "shortCiteRegEx" : "Oikarinen and Janhunen",
      "year" : 2006
    }, {
      "title" : "Types in Logic Programming",
      "author" : [ "F. Pfenning", "Ed." ],
      "venue" : "MIT Press.",
      "citeRegEx" : "Pfenning and Ed.,? 1992",
      "shortCiteRegEx" : "Pfenning and Ed.",
      "year" : 1992
    }, {
      "title" : "Logic modelling workshop: Communicating axiomatizations of actions and change",
      "author" : [ "E. Sandewall" ],
      "venue" : "http://www.ida.liu.se/ext/etai/lmw.",
      "citeRegEx" : "Sandewall,? 1999",
      "shortCiteRegEx" : "Sandewall",
      "year" : 1999
    }, {
      "title" : "A language for default reasoning about actions",
      "author" : [ "H. Strass", "M. Thielscher" ],
      "venue" : "Correct Reasoning: Essays in Honor of Vladimir Lifschitz, E. Erdem, J. Lee, Y. Lierler, and D. Pearce, Eds. LNCS, vol. 7265. Springer, 527–542.",
      "citeRegEx" : "Strass and Thielscher,? 2012",
      "shortCiteRegEx" : "Strass and Thielscher",
      "year" : 2012
    }, {
      "title" : "Representing Actions in Logic Programs and Default Theories: A Situation Calculus Approach",
      "author" : [ "H. Turner" ],
      "venue" : "Journal of Logic Programming 31, 1-3 (Jun), 245–298.",
      "citeRegEx" : "Turner,? 1997",
      "shortCiteRegEx" : "Turner",
      "year" : 1997
    }, {
      "title" : "A logic of universal causation",
      "author" : [ "H. Turner" ],
      "venue" : "Artificial Intelligence 113, 87–123.",
      "citeRegEx" : "Turner,? 1999",
      "shortCiteRegEx" : "Turner",
      "year" : 1999
    }, {
      "title" : "The Well-Founded Semantics for General Logic Programs",
      "author" : [ "A. Van Gelder", "K.A. Ross", "J.S. Schlipf" ],
      "venue" : "Journal of the ACM 38, 619–649.",
      "citeRegEx" : "Gelder et al\\.,? 1991",
      "shortCiteRegEx" : "Gelder et al\\.",
      "year" : 1991
    }, {
      "title" : "Program development by stepwise refinement",
      "author" : [ "N. Wirth" ],
      "venue" : "Commun. ACM 14, 4 (Apr.), 221–227.",
      "citeRegEx" : "Wirth,? 1971",
      "shortCiteRegEx" : "Wirth",
      "year" : 1971
    } ],
    "referenceMentions" : [ {
      "referenceID" : 35,
      "context" : "and Lifschitz 1993), B (Gelfond and Lifschitz 1998); AL (Turner 1997; Baral and Gelfond 2000); the non-modular extension of AL with multi-valued fluents (Dovier et al.",
      "startOffset" : 23,
      "endOffset" : 51
    }, {
      "referenceID" : 63,
      "context" : "and Lifschitz 1993), B (Gelfond and Lifschitz 1998); AL (Turner 1997; Baral and Gelfond 2000); the non-modular extension of AL with multi-valued fluents (Dovier et al.",
      "startOffset" : 56,
      "endOffset" : 93
    }, {
      "referenceID" : 9,
      "context" : "and Lifschitz 1993), B (Gelfond and Lifschitz 1998); AL (Turner 1997; Baral and Gelfond 2000); the non-modular extension of AL with multi-valued fluents (Dovier et al.",
      "startOffset" : 56,
      "endOffset" : 93
    }, {
      "referenceID" : 19,
      "context" : "and Lifschitz 1993), B (Gelfond and Lifschitz 1998); AL (Turner 1997; Baral and Gelfond 2000); the non-modular extension of AL with multi-valued fluents (Dovier et al. 2007); C (Giunchiglia and Lifschitz 1998); C+ (Giunchiglia et al.",
      "startOffset" : 153,
      "endOffset" : 173
    }, {
      "referenceID" : 38,
      "context" : "2007); C (Giunchiglia and Lifschitz 1998); C+ (Giunchiglia et al.",
      "startOffset" : 9,
      "endOffset" : 41
    }, {
      "referenceID" : 37,
      "context" : "2007); C (Giunchiglia and Lifschitz 1998); C+ (Giunchiglia et al. 2004); K (Eiter et al.",
      "startOffset" : 46,
      "endOffset" : 71
    }, {
      "referenceID" : 21,
      "context" : "2004); K (Eiter et al. 2004); D (Strass and Thielscher 2012); E (Kakas and Miller 1997); H (Chintabathina et al.",
      "startOffset" : 9,
      "endOffset" : 28
    }, {
      "referenceID" : 62,
      "context" : "2004); D (Strass and Thielscher 2012); E (Kakas and Miller 1997); H (Chintabathina et al.",
      "startOffset" : 9,
      "endOffset" : 37
    }, {
      "referenceID" : 47,
      "context" : "2004); D (Strass and Thielscher 2012); E (Kakas and Miller 1997); H (Chintabathina et al.",
      "startOffset" : 41,
      "endOffset" : 64
    }, {
      "referenceID" : 17,
      "context" : "2004); D (Strass and Thielscher 2012); E (Kakas and Miller 1997); H (Chintabathina et al. 2005; Chintabathina 2012)).",
      "startOffset" : 68,
      "endOffset" : 115
    }, {
      "referenceID" : 16,
      "context" : "2004); D (Strass and Thielscher 2012); E (Kakas and Miller 1997); H (Chintabathina et al. 2005; Chintabathina 2012)).",
      "startOffset" : 68,
      "endOffset" : 115
    }, {
      "referenceID" : 32,
      "context" : "In order to reason about the system, its action language description is often translated into a logic program under the answer set semantics (Gelfond and Lifschitz 1988; 1991).",
      "startOffset" : 141,
      "endOffset" : 175
    }, {
      "referenceID" : 33,
      "context" : "This allows for the use of Answer Set Programming (ASP) (Gelfond and Lifschitz 1991; Niemelä 1998; Marek and Truszczynski 1999) to perform complex reasoning tasks such as planning, diagnosis, etc.",
      "startOffset" : 56,
      "endOffset" : 127
    }, {
      "referenceID" : 57,
      "context" : "This allows for the use of Answer Set Programming (ASP) (Gelfond and Lifschitz 1991; Niemelä 1998; Marek and Truszczynski 1999) to perform complex reasoning tasks such as planning, diagnosis, etc.",
      "startOffset" : 56,
      "endOffset" : 127
    }, {
      "referenceID" : 52,
      "context" : "This allows for the use of Answer Set Programming (ASP) (Gelfond and Lifschitz 1991; Niemelä 1998; Marek and Truszczynski 1999) to perform complex reasoning tasks such as planning, diagnosis, etc.",
      "startOffset" : 56,
      "endOffset" : 127
    }, {
      "referenceID" : 8,
      "context" : "In logic programming, early solutions were based on the concepts of macro and template (Baral et al. 2006; Calimeri and Ianni 2006).",
      "startOffset" : 87,
      "endOffset" : 131
    }, {
      "referenceID" : 14,
      "context" : "In logic programming, early solutions were based on the concepts of macro and template (Baral et al. 2006; Calimeri and Ianni 2006).",
      "startOffset" : 87,
      "endOffset" : 131
    }, {
      "referenceID" : 61,
      "context" : ") Just a few examples of domains that we consider large enough to benefit from the above-mentioned practices are: the Zoo World and Traffic World examples proposed by Erik Sandewall (Sandewall 1999) and modeled in (Henschel and Thielscher 1999; Akman et al.",
      "startOffset" : 182,
      "endOffset" : 198
    }, {
      "referenceID" : 43,
      "context" : ") Just a few examples of domains that we consider large enough to benefit from the above-mentioned practices are: the Zoo World and Traffic World examples proposed by Erik Sandewall (Sandewall 1999) and modeled in (Henschel and Thielscher 1999; Akman et al. 2004); the Monkey and Banana Problem by John McCarthy (McCarthy 1963; McCarthy 1968) and formalized in (Erdoǧan and Lifschitz 2006; Erdoǧan 2008); the Missionaries and Cannibals Problem by John McCarthy (McCarthy 1998) represented in (Gustafsson and Kvarnström 2004; Erdoǧan 2008).",
      "startOffset" : 214,
      "endOffset" : 263
    }, {
      "referenceID" : 0,
      "context" : ") Just a few examples of domains that we consider large enough to benefit from the above-mentioned practices are: the Zoo World and Traffic World examples proposed by Erik Sandewall (Sandewall 1999) and modeled in (Henschel and Thielscher 1999; Akman et al. 2004); the Monkey and Banana Problem by John McCarthy (McCarthy 1963; McCarthy 1968) and formalized in (Erdoǧan and Lifschitz 2006; Erdoǧan 2008); the Missionaries and Cannibals Problem by John McCarthy (McCarthy 1998) represented in (Gustafsson and Kvarnström 2004; Erdoǧan 2008).",
      "startOffset" : 214,
      "endOffset" : 263
    }, {
      "referenceID" : 54,
      "context" : "2004); the Monkey and Banana Problem by John McCarthy (McCarthy 1963; McCarthy 1968) and formalized in (Erdoǧan and Lifschitz 2006; Erdoǧan 2008); the Missionaries and Cannibals Problem by John McCarthy (McCarthy 1998) represented in (Gustafsson and Kvarnström 2004; Erdoǧan 2008).",
      "startOffset" : 54,
      "endOffset" : 84
    }, {
      "referenceID" : 55,
      "context" : "2004); the Monkey and Banana Problem by John McCarthy (McCarthy 1963; McCarthy 1968) and formalized in (Erdoǧan and Lifschitz 2006; Erdoǧan 2008); the Missionaries and Cannibals Problem by John McCarthy (McCarthy 1998) represented in (Gustafsson and Kvarnström 2004; Erdoǧan 2008).",
      "startOffset" : 54,
      "endOffset" : 84
    }, {
      "referenceID" : 23,
      "context" : "2004); the Monkey and Banana Problem by John McCarthy (McCarthy 1963; McCarthy 1968) and formalized in (Erdoǧan and Lifschitz 2006; Erdoǧan 2008); the Missionaries and Cannibals Problem by John McCarthy (McCarthy 1998) represented in (Gustafsson and Kvarnström 2004; Erdoǧan 2008).",
      "startOffset" : 103,
      "endOffset" : 145
    }, {
      "referenceID" : 24,
      "context" : "2004); the Monkey and Banana Problem by John McCarthy (McCarthy 1963; McCarthy 1968) and formalized in (Erdoǧan and Lifschitz 2006; Erdoǧan 2008); the Missionaries and Cannibals Problem by John McCarthy (McCarthy 1998) represented in (Gustafsson and Kvarnström 2004; Erdoǧan 2008).",
      "startOffset" : 103,
      "endOffset" : 145
    }, {
      "referenceID" : 56,
      "context" : "2004); the Monkey and Banana Problem by John McCarthy (McCarthy 1963; McCarthy 1968) and formalized in (Erdoǧan and Lifschitz 2006; Erdoǧan 2008); the Missionaries and Cannibals Problem by John McCarthy (McCarthy 1998) represented in (Gustafsson and Kvarnström 2004; Erdoǧan 2008).",
      "startOffset" : 203,
      "endOffset" : 218
    }, {
      "referenceID" : 41,
      "context" : "2004); the Monkey and Banana Problem by John McCarthy (McCarthy 1963; McCarthy 1968) and formalized in (Erdoǧan and Lifschitz 2006; Erdoǧan 2008); the Missionaries and Cannibals Problem by John McCarthy (McCarthy 1998) represented in (Gustafsson and Kvarnström 2004; Erdoǧan 2008).",
      "startOffset" : 234,
      "endOffset" : 280
    }, {
      "referenceID" : 24,
      "context" : "2004); the Monkey and Banana Problem by John McCarthy (McCarthy 1963; McCarthy 1968) and formalized in (Erdoǧan and Lifschitz 2006; Erdoǧan 2008); the Missionaries and Cannibals Problem by John McCarthy (McCarthy 1998) represented in (Gustafsson and Kvarnström 2004; Erdoǧan 2008).",
      "startOffset" : 234,
      "endOffset" : 280
    }, {
      "referenceID" : 51,
      "context" : "This inadequacy is due to the fact that most action languages, with some notable exceptions like MAD (Lifschitz and Ren 2006; Erdoǧan and Lifschitz 2006; Desai and Singh 2007) and TAL-C (Gustafsson and Kvarnström 2004), have no built-in features for supporting the description of a domain’s ontology and its objects, and for structuring knowledge and creating knowledge-based libraries.",
      "startOffset" : 101,
      "endOffset" : 175
    }, {
      "referenceID" : 23,
      "context" : "This inadequacy is due to the fact that most action languages, with some notable exceptions like MAD (Lifschitz and Ren 2006; Erdoǧan and Lifschitz 2006; Desai and Singh 2007) and TAL-C (Gustafsson and Kvarnström 2004), have no built-in features for supporting the description of a domain’s ontology and its objects, and for structuring knowledge and creating knowledge-based libraries.",
      "startOffset" : 101,
      "endOffset" : 175
    }, {
      "referenceID" : 18,
      "context" : "This inadequacy is due to the fact that most action languages, with some notable exceptions like MAD (Lifschitz and Ren 2006; Erdoǧan and Lifschitz 2006; Desai and Singh 2007) and TAL-C (Gustafsson and Kvarnström 2004), have no built-in features for supporting the description of a domain’s ontology and its objects, and for structuring knowledge and creating knowledge-based libraries.",
      "startOffset" : 101,
      "endOffset" : 175
    }, {
      "referenceID" : 41,
      "context" : "This inadequacy is due to the fact that most action languages, with some notable exceptions like MAD (Lifschitz and Ren 2006; Erdoǧan and Lifschitz 2006; Desai and Singh 2007) and TAL-C (Gustafsson and Kvarnström 2004), have no built-in features for supporting the description of a domain’s ontology and its objects, and for structuring knowledge and creating knowledge-based libraries.",
      "startOffset" : 186,
      "endOffset" : 218
    }, {
      "referenceID" : 29,
      "context" : "It is based on an earlier action language, AL, introduced in (Gelfond and Inclezan 2009) where it is called ALd , which so far has been the authors’ language of choice (see, for instance, (Gelfond and Kahl 2014)).",
      "startOffset" : 61,
      "endOffset" : 88
    }, {
      "referenceID" : 31,
      "context" : "It is based on an earlier action language, AL, introduced in (Gelfond and Inclezan 2009) where it is called ALd , which so far has been the authors’ language of choice (see, for instance, (Gelfond and Kahl 2014)).",
      "startOffset" : 188,
      "endOffset" : 211
    }, {
      "referenceID" : 66,
      "context" : "Modules of a theory can be developed and tested independently, which facilitates the reuse of knowledge and stepwise development and refinement (Wirth 1971) of knowledge bases, and increases their elaboration tolerance (McCarthy 1998).",
      "startOffset" : 144,
      "endOffset" : 156
    }, {
      "referenceID" : 56,
      "context" : "Modules of a theory can be developed and tested independently, which facilitates the reuse of knowledge and stepwise development and refinement (Wirth 1971) of knowledge bases, and increases their elaboration tolerance (McCarthy 1998).",
      "startOffset" : 219,
      "endOffset" : 234
    }, {
      "referenceID" : 59,
      "context" : "(Oikarinen and Janhunen 2006) and (Lierler and Truszczynski 2013).",
      "startOffset" : 0,
      "endOffset" : 29
    }, {
      "referenceID" : 49,
      "context" : "(Oikarinen and Janhunen 2006) and (Lierler and Truszczynski 2013).",
      "startOffset" : 34,
      "endOffset" : 65
    }, {
      "referenceID" : 40,
      "context" : "aimed towards the development of a Digital Aristotle – “an application containing large volumes of scientific knowledge and capable of applying sophisticated problem-solving methods to answer novel questions” (Gunning et al. 2010).",
      "startOffset" : 209,
      "endOffset" : 230
    }, {
      "referenceID" : 39,
      "context" : "The Digital Aristotle uses the knowledge representation language called SILK (Semantic Inferencing on Large Knowledge) (Grosof et al. 2009), which is based on the well-founded semantics (Van Gelder et al.",
      "startOffset" : 119,
      "endOffset" : 139
    }, {
      "referenceID" : 25,
      "context" : "1991) and transaction logic with defaults and argumentation theories (Fodor and Kifer 2011).",
      "startOffset" : 69,
      "endOffset" : 91
    }, {
      "referenceID" : 46,
      "context" : "Our first contribution to Project Halo consisted in creating an ALM formalization of an important biological process, cell division (Inclezan and Gelfond 2011).",
      "startOffset" : 132,
      "endOffset" : 159
    }, {
      "referenceID" : 44,
      "context" : "As a second step, we created a question answering system capable of answering complex temporal projection questions about this biological process (Inclezan 2010).",
      "startOffset" : 146,
      "endOffset" : 161
    }, {
      "referenceID" : 29,
      "context" : "The version of ALM presented here differs from that described in previous papers (Gelfond and Inclezan 2009; Inclezan and Gelfond 2011) in various ways.",
      "startOffset" : 81,
      "endOffset" : 135
    }, {
      "referenceID" : 46,
      "context" : "The version of ALM presented here differs from that described in previous papers (Gelfond and Inclezan 2009; Inclezan and Gelfond 2011) in various ways.",
      "startOffset" : 81,
      "endOffset" : 135
    }, {
      "referenceID" : 7,
      "context" : "to the problem of computing the answer sets of logic programs (for a general description see, for instance, (Baral 2003)) by ASP solvers (see (Niemelä and Simons 1997), (Gebser et al.",
      "startOffset" : 108,
      "endOffset" : 120
    }, {
      "referenceID" : 58,
      "context" : "to the problem of computing the answer sets of logic programs (for a general description see, for instance, (Baral 2003)) by ASP solvers (see (Niemelä and Simons 1997), (Gebser et al.",
      "startOffset" : 142,
      "endOffset" : 167
    }, {
      "referenceID" : 27,
      "context" : "to the problem of computing the answer sets of logic programs (for a general description see, for instance, (Baral 2003)) by ASP solvers (see (Niemelä and Simons 1997), (Gebser et al. 2012), or (Leone et al.",
      "startOffset" : 169,
      "endOffset" : 189
    }, {
      "referenceID" : 48,
      "context" : "2012), or (Leone et al. 2006)).",
      "startOffset" : 10,
      "endOffset" : 29
    }, {
      "referenceID" : 4,
      "context" : "Since the semantics of ALM will be defined in terms of a version of ASP with function symbols, ASP{f} (Balduccini 2013), which does not allow terms with nested user-defined functions, we limit atoms of an action signature to those constructed from terms with at most one user-defined function symbol.",
      "startOffset" : 102,
      "endOffset" : 119
    }, {
      "referenceID" : 4,
      "context" : "Similar to the case of AL, the definition of a state will be given using logic programs under the answer set semantics; specifically, we will use logic programs with nonHerbrand partial functions in the language ASP{f} (Balduccini 2013).",
      "startOffset" : 219,
      "endOffset" : 236
    }, {
      "referenceID" : 13,
      "context" : "3 Other approaches for introducing non-Herbrand functions in ASP can be seen, for instance, in (Cabalar 2011; Lifschitz 2012; Bartholomew and Lee 2013).",
      "startOffset" : 95,
      "endOffset" : 151
    }, {
      "referenceID" : 50,
      "context" : "3 Other approaches for introducing non-Herbrand functions in ASP can be seen, for instance, in (Cabalar 2011; Lifschitz 2012; Bartholomew and Lee 2013).",
      "startOffset" : 95,
      "endOffset" : 151
    }, {
      "referenceID" : 11,
      "context" : "3 Other approaches for introducing non-Herbrand functions in ASP can be seen, for instance, in (Cabalar 2011; Lifschitz 2012; Bartholomew and Lee 2013).",
      "startOffset" : 95,
      "endOffset" : 151
    }, {
      "referenceID" : 31,
      "context" : "Note that the last axiom is a modification of the standard logic programming version of the Inertia Axiom (see, for instance, (Gelfond and Kahl 2014)), which is stated for total (boolean) functions.",
      "startOffset" : 126,
      "endOffset" : 149
    }, {
      "referenceID" : 20,
      "context" : "Our notion of entailment is somewhat similar to the notion of subsumption from (Eiter et al. 2010) – a relation between an action description and a query (including queries having the form of causal laws and executability conditions).",
      "startOffset" : 79,
      "endOffset" : 98
    }, {
      "referenceID" : 64,
      "context" : "There are also related formalisms that allow entailment of causal laws and executability conditions (see, for instance (Turner 1999) and (Giunchiglia et al.",
      "startOffset" : 119,
      "endOffset" : 132
    }, {
      "referenceID" : 37,
      "context" : "There are also related formalisms that allow entailment of causal laws and executability conditions (see, for instance (Turner 1999) and (Giunchiglia et al. 2004)).",
      "startOffset" : 137,
      "endOffset" : 162
    }, {
      "referenceID" : 54,
      "context" : "We exemplify the methodology of representing knowledge in ALM by considering a benchmark commonsense example from the field of reasoning about action and change — the Monkey and Banana Problem (McCarthy 1963; McCarthy 1968).",
      "startOffset" : 193,
      "endOffset" : 223
    }, {
      "referenceID" : 55,
      "context" : "We exemplify the methodology of representing knowledge in ALM by considering a benchmark commonsense example from the field of reasoning about action and change — the Monkey and Banana Problem (McCarthy 1963; McCarthy 1968).",
      "startOffset" : 193,
      "endOffset" : 223
    }, {
      "referenceID" : 31,
      "context" : "System descriptions can be used to solve computational tasks such as temporal projection or planning, using a methodology similar to that developed for non-modular action languages like AL (see, for instance, (Gelfond and Kahl 2014)).",
      "startOffset" : 209,
      "endOffset" : 232
    }, {
      "referenceID" : 5,
      "context" : "Definition 12 (History – adapted from (Balduccini and Gelfond 2003a)) By the recorded history Γn of a system description D up to time step n we mean a collection of observations, i.",
      "startOffset" : 38,
      "endOffset" : 68
    }, {
      "referenceID" : 2,
      "context" : "(There are two small differences between this and the definition of a history by Balduccini and Gelfond (2003a): the latter only allows boolean fluents and observations that have the form observed(l , i) where l is a fluent or its negation.",
      "startOffset" : 81,
      "endOffset" : 112
    }, {
      "referenceID" : 5,
      "context" : "Definition 13 (Model of a History – adapted from (Balduccini and Gelfond 2003a))",
      "startOffset" : 49,
      "endOffset" : 79
    }, {
      "referenceID" : 5,
      "context" : "Definition 14 (Set of Literals Defining a Sequence – adapted from (Balduccini and Gelfond 2003a))",
      "startOffset" : 66,
      "endOffset" : 96
    }, {
      "referenceID" : 5,
      "context" : "Definition 15 (Program Ωtp – adapted from (Balduccini and Gelfond 2003a)) If Γn is a history of system description D up to time step n, then by Ωtp we denote the ASP{f} program constructed as follows:",
      "startOffset" : 42,
      "endOffset" : 72
    }, {
      "referenceID" : 30,
      "context" : "Definition 16 (Well–founded System Description – adapted from (Gelfond and Inclezan 2013))",
      "startOffset" : 62,
      "endOffset" : 89
    }, {
      "referenceID" : 30,
      "context" : "An example of a system description that is not well–founded is n w f shown below and adapted from (Gelfond and Inclezan 2013).",
      "startOffset" : 98,
      "endOffset" : 125
    }, {
      "referenceID" : 30,
      "context" : "structure n w f instances x in c In the case of the non-modular action language AL, there is a known syntactic condition that guarantees that a system description is well–founded (Gelfond and Inclezan 2013).",
      "startOffset" : 179,
      "endOffset" : 206
    }, {
      "referenceID" : 5,
      "context" : "This proposition can be proven using techniques similar to the ones employed in Lemma 5 in (Balduccini and Gelfond 2003a).",
      "startOffset" : 91,
      "endOffset" : 121
    }, {
      "referenceID" : 46,
      "context" : "We used the above methodology of solving temporal projection tasks to create a question answering system in the context of the Digital Aristotle project (Inclezan and Gelfond 2011).",
      "startOffset" : 153,
      "endOffset" : 180
    }, {
      "referenceID" : 6,
      "context" : "This module is defined in CR-Prolog (Balduccini and Gelfond 2003b), an extension of ASP designed to handle, among other things, rare events.",
      "startOffset" : 36,
      "endOffset" : 66
    }, {
      "referenceID" : 6,
      "context" : "For the formal semantics of CR-Prolog, we refer the reader to (Balduccini and Gelfond 2003b).",
      "startOffset" : 62,
      "endOffset" : 92
    }, {
      "referenceID" : 3,
      "context" : "Solvers for CR-Prolog are described in (Balduccini 2007) and (Balai et al.",
      "startOffset" : 39,
      "endOffset" : 56
    }, {
      "referenceID" : 1,
      "context" : "Solvers for CR-Prolog are described in (Balduccini 2007) and (Balai et al. 2012).",
      "startOffset" : 61,
      "endOffset" : 80
    }, {
      "referenceID" : 2,
      "context" : "Definition 19 (Planning Module (Balduccini 2004; Gelfond and Kahl 2014))",
      "startOffset" : 31,
      "endOffset" : 71
    }, {
      "referenceID" : 31,
      "context" : "Definition 19 (Planning Module (Balduccini 2004; Gelfond and Kahl 2014))",
      "startOffset" : 31,
      "endOffset" : 71
    }, {
      "referenceID" : 5,
      "context" : "9 The proof and text of Lemma 5 appear on page 29 of the version of (Balduccini and Gelfond 2003a) available at http://arxiv.",
      "startOffset" : 68,
      "endOffset" : 98
    }, {
      "referenceID" : 51,
      "context" : "In this section we briefly comment on the relationship between ALM and the previously existing modular action languages MAD (Lifschitz and Ren 2006; Erdoǧan and Lifschitz 2006; Desai and Singh 2007), TAL-C (Gustafsson and Kvarnström 2004), and the earlier version of ALM (Gelfond and Inclezan 2009).",
      "startOffset" : 124,
      "endOffset" : 198
    }, {
      "referenceID" : 23,
      "context" : "In this section we briefly comment on the relationship between ALM and the previously existing modular action languages MAD (Lifschitz and Ren 2006; Erdoǧan and Lifschitz 2006; Desai and Singh 2007), TAL-C (Gustafsson and Kvarnström 2004), and the earlier version of ALM (Gelfond and Inclezan 2009).",
      "startOffset" : 124,
      "endOffset" : 198
    }, {
      "referenceID" : 18,
      "context" : "In this section we briefly comment on the relationship between ALM and the previously existing modular action languages MAD (Lifschitz and Ren 2006; Erdoǧan and Lifschitz 2006; Desai and Singh 2007), TAL-C (Gustafsson and Kvarnström 2004), and the earlier version of ALM (Gelfond and Inclezan 2009).",
      "startOffset" : 124,
      "endOffset" : 198
    }, {
      "referenceID" : 41,
      "context" : "In this section we briefly comment on the relationship between ALM and the previously existing modular action languages MAD (Lifschitz and Ren 2006; Erdoǧan and Lifschitz 2006; Desai and Singh 2007), TAL-C (Gustafsson and Kvarnström 2004), and the earlier version of ALM (Gelfond and Inclezan 2009).",
      "startOffset" : 206,
      "endOffset" : 238
    }, {
      "referenceID" : 29,
      "context" : "In this section we briefly comment on the relationship between ALM and the previously existing modular action languages MAD (Lifschitz and Ren 2006; Erdoǧan and Lifschitz 2006; Desai and Singh 2007), TAL-C (Gustafsson and Kvarnström 2004), and the earlier version of ALM (Gelfond and Inclezan 2009).",
      "startOffset" : 271,
      "endOffset" : 298
    }, {
      "referenceID" : 63,
      "context" : "Third, the semantics was initially given in terms of action language AL (Turner 1997; Baral and Gelfond 2000), where the AL semantics is defined by a translation into ASP; now, we give the semantics of our language directly in ASP – in fact, in an extension of ASP with non-Herbrand functions, ASP{f} (Balduccini 2013).",
      "startOffset" : 72,
      "endOffset" : 109
    }, {
      "referenceID" : 9,
      "context" : "Third, the semantics was initially given in terms of action language AL (Turner 1997; Baral and Gelfond 2000), where the AL semantics is defined by a translation into ASP; now, we give the semantics of our language directly in ASP – in fact, in an extension of ASP with non-Herbrand functions, ASP{f} (Balduccini 2013).",
      "startOffset" : 72,
      "endOffset" : 109
    }, {
      "referenceID" : 4,
      "context" : "Third, the semantics was initially given in terms of action language AL (Turner 1997; Baral and Gelfond 2000), where the AL semantics is defined by a translation into ASP; now, we give the semantics of our language directly in ASP – in fact, in an extension of ASP with non-Herbrand functions, ASP{f} (Balduccini 2013).",
      "startOffset" : 301,
      "endOffset" : 318
    }, {
      "referenceID" : 41,
      "context" : "Another modular language is TAL-C (Gustafsson and Kvarnström 2004), which allows definitions of classes of objects that are somewhat similar to those in ALM.",
      "startOffset" : 34,
      "endOffset" : 66
    }, {
      "referenceID" : 42,
      "context" : "10 In the field of logic programming, an early discussion on the introduction of functions appears in (Hanus 1994).",
      "startOffset" : 102,
      "endOffset" : 114
    }, {
      "referenceID" : 26,
      "context" : "Among other things it is worth investigating the possible use of modular logic programming as well as the methods from (Gebser et al. 2011), (Gebser et al.",
      "startOffset" : 119,
      "endOffset" : 139
    }, {
      "referenceID" : 26,
      "context" : "2011), (Gebser et al. 2011), and (Balai et al.",
      "startOffset" : 7,
      "endOffset" : 27
    }, {
      "referenceID" : 1,
      "context" : "2011), and (Balai et al. 2012).",
      "startOffset" : 11,
      "endOffset" : 30
    }, {
      "referenceID" : 22,
      "context" : "(Eiter et al. 2008)) or from typed logic programming (e.",
      "startOffset" : 0,
      "endOffset" : 19
    }, {
      "referenceID" : 17,
      "context" : "In particular, it may be a good idea to combine ALM with action language H (Chintabathina et al. 2005; Chintabathina 2012).",
      "startOffset" : 75,
      "endOffset" : 122
    }, {
      "referenceID" : 16,
      "context" : "In particular, it may be a good idea to combine ALM with action language H (Chintabathina et al. 2005; Chintabathina 2012).",
      "startOffset" : 75,
      "endOffset" : 122
    }, {
      "referenceID" : 12,
      "context" : "(In particular we would like to create an ALM library module containing a theory of intentions in the style of (Blount et al. 2014).",
      "startOffset" : 111,
      "endOffset" : 131
    }, {
      "referenceID" : 40,
      "context" : "The goal of Project Halo was the creation of a Digital Aristotle — “an application containing large volumes of scientific knowledge and capable of applying sophisticated problem-solving methods to answer novel questions” (Gunning et al. 2010).",
      "startOffset" : 221,
      "endOffset" : 242
    }, {
      "referenceID" : 10,
      "context" : "We represented such processes as sequences of actions intended by nature and used a commonsense theory of intentions (Baral and Gelfond 2005) to reason about them.",
      "startOffset" : 117,
      "endOffset" : 141
    }, {
      "referenceID" : 15,
      "context" : "Consider, for instance, the following question from (Campbell and Reece 2001):",
      "startOffset" : 52,
      "endOffset" : 77
    }, {
      "referenceID" : 10,
      "context" : "This latter part was done by incorporating a theory of intentions (Baral and Gelfond 2005) and assuming that naturally evolving processes have the tendency (or the intention) to go through their sequence of phases in order, unless interrupted (e.",
      "startOffset" : 66,
      "endOffset" : 90
    }, {
      "referenceID" : 51,
      "context" : "In this section we give an informal discussion of the relationship between ALM and the modular action language MAD (Lifschitz and Ren 2006; Erdoǧan and Lifschitz 2006).",
      "startOffset" : 115,
      "endOffset" : 167
    }, {
      "referenceID" : 23,
      "context" : "In this section we give an informal discussion of the relationship between ALM and the modular action language MAD (Lifschitz and Ren 2006; Erdoǧan and Lifschitz 2006).",
      "startOffset" : 115,
      "endOffset" : 167
    }, {
      "referenceID" : 38,
      "context" : "The latter expands action language C (Giunchiglia and Lifschitz 1998).",
      "startOffset" : 37,
      "endOffset" : 69
    }, {
      "referenceID" : 36,
      "context" : "Even though these languages have a lot in common (see (Gelfond and Lifschitz 2012)) they differ significantly in the underlying assumptions incorporated in their semantics.",
      "startOffset" : 54,
      "endOffset" : 82
    }, {
      "referenceID" : 53,
      "context" : "” Its underlying logical basis is causal logic (McCain and Turner 1997; Giunchiglia et al. 2004).",
      "startOffset" : 47,
      "endOffset" : 96
    }, {
      "referenceID" : 37,
      "context" : "” Its underlying logical basis is causal logic (McCain and Turner 1997; Giunchiglia et al. 2004).",
      "startOffset" : 47,
      "endOffset" : 96
    }, {
      "referenceID" : 24,
      "context" : "1 has been encoded in MAD as well (Erdoǧan 2008), we are not considering it here because of the length of its representation and, most importantly, because there are substantial differences in how the problem was addressed in ALM versus MAD from the knowledge representation point of view.",
      "startOffset" : 34,
      "endOffset" : 48
    }, {
      "referenceID" : 24,
      "context" : "The body of a MAD module consists of separate (optional) sections for the declarations of sorts specific to the current module, objects, fluents, actions, and variables, in this order, together with a section dedicated to axioms (Erdoǧan 2008).",
      "startOffset" : 229,
      "endOffset" : 243
    }, {
      "referenceID" : 36,
      "context" : "Here is a short summary: • Recursive definitions The representation of state constraints of an ALM system description is not straightforward if the set of state constraints defines a cyclic fluent dependency graph (Gelfond and Lifschitz 2012).",
      "startOffset" : 214,
      "endOffset" : 242
    }, {
      "referenceID" : 45,
      "context" : "Readers interested in a formal translation of system descriptions of ALM to action descriptions of MAD can consult (Inclezan 2012).",
      "startOffset" : 115,
      "endOffset" : 130
    } ],
    "year" : 2015,
    "abstractText" : "The paper introduces a new modular action language, ALM, and illustrates the methodology of its use. It is based on the approach of Gelfond and Lifschitz (1993; 1998) in which a high-level action language is used as a front end for a logic programming system description. The resulting logic programming representation is used to perform various computational tasks. The methodology based on existing action languages works well for small and even medium size systems, but is not meant to deal with larger systems that require structuring of knowledge. ALM is meant to remedy this problem. Structuring of knowledge in ALM is supported by the concepts of module (a formal description of a specific piece of knowledge packaged as a unit), module hierarchy, and library, and by the division of a system description of ALM into two parts: theory and structure. A theory consists of one or more modules with a common theme, possibly organized into a module hierarchy based on a dependency relation. It contains declarations of sorts, attributes, and properties of the domain together with axioms describing them. Structures are used to describe the domain’s objects. These features, together with the means for defining classes of a domain as special cases of previously defined ones, facilitate the stepwise development, testing, and readability of a knowledge base, as well as the creation of knowledge representation libraries.",
    "creator" : "LaTeX with hyperref package"
  }
}