{
  "name" : "1003.0590.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : "Application of CACS approach for distributed logistic systems",
    "authors" : [ "Sami AL-MAQTARI", "Habib ABDULRAB", "Eduard BABKIN" ],
    "emails" : [ "abdulrab}@insa-rouen.fr.", "eababkin@hse.ru." ],
    "sections" : [ {
      "heading" : null,
      "text" : "Controller Agent for Constraints Satisfaction (CACS). That approach combines multi-agent architecture with constraint solvers in the unified framework which expresses major features of Swarm Intelligence approach and replaces traditional stochastic adaptation of the swarm of the autonomous agents by constraint-driven adaptation. We describe major theoretic, methodological and software engineering principles of composition of constraints and agents in the framework of one multi-agent system, as well as application of our approach for modelling of particular logistic problem. 12"
    }, {
      "heading" : "1. INTRODUCTION",
      "text" : "Simultaneous rapid grow of logistics market in different regions of the world [1, 2], and its important role in modern economy require wide application of logistics information and management systems for coordinated planning and control. Distributed organizational structure and application of holonic management principles in modern organizations inevitably determine distributed and autonomous features of information systems supporting logistic operations [5]. In such kinds of the systems it is very difficult to apply usual centralized approaches and algorithms for decision support and optimization.\nSwarm Intelligence [3, 4] represents one of the interesting paradigm for maintaining self-organization and control in the distributed systems. One of the principal aspect of the swarmoriented distributed intelligent systems is presence of multiple intellectual and autonomous particles which interact with each other in some way. As it is started in [4]: ‖Swarm is a population of interacting elements that is able to optimize some global objectives thought collaborative search in space‖.\nDifferent projects offered approaches for practical application of Swarm Intelligence paradigm in the form of multi-agent systems [6, 28, 30]. Although some of them (i.e. [28]) offer a formal framework for declarative expression and analysis, researchers and practitioners still lack proper generic methods for engineering of the multi-agent systems which have such properties of Swarm Intelligence as emergent behavior, peer-topeer communication, etc.\nAnalysis of known logistic problems and algorithms shows that in the domain of applied logistics and optimization general principles of swarm-oriented organization may be realized using proper combination of multi-agent systems (MAS) and constraints satisfaction approach (CSP). So, in this research we\n1 LITIS Laboratory, INSA Rouen, France. Email: {almaqtari, abdulrab}@insa-rouen.fr. 2 TAPRADESS Laboraotry, State University – Higher School of Economics, Nizhny Novgorod, Russia. Email: eababkin@hse.ru.\npursue the goal to offer a new mechanism of emergent multiagent behaviour for collaborative search of some feasible solution in accordance with certain inter-agent constraints. In terms of Swarm Intelligence research we replace stochastic adaptation of the swarm of the autonomous agents by constraintdriven adaptation.\nIn our research we try to satisfy such important requirements of Swarm Intelligence as self-organization and dynamic adaptation to evolving internal or external conditions. Existing approaches to combination of MAS and CSP like [16, 17, 32] do not provide much flexibility and support of dynamic modification of the combined structure of agents and constraints. That’s why in this article we propose an original approach which offers a solution for dynamic modification of the combined structure of agents and constraints. Our approach, which was called CACS (Controller Agent for Constraints Satisfaction), allows for joint exploitation of attractive features of the paradigm of multi-agent systems (MAS) and the paradigm of distributed constraint satisfaction (DCSP).\nThis paper extends and combines our earlier work on joint application of MAS and DCSP paradigms [33, 34]. We describe major theoretic, methodological and software engineering principles of composition of constraints and agents in the framework of one multi-agent system, as well as application of our approach for modelling of particular logistic problem.\nThe paper is organized as follows. In Section 2 we give background information about MAS and DCSP for better understanding of scientific and technological foundations of our research. In Section 3 we describe main principles of CACS approach. Section 4 contains description of software architecture and implementation principles for software prototype which supports proposed CACS approach. The same section contains overview of used 3d party software platforms. Section 5 describes proposed methodology of practical application of CACS during design and development of DSS. In Section 6 we give overview of the application in ship loading logistics based on CACS prototype. We discuss the achieved results and provide directions for future work in Section 7."
    }, {
      "heading" : "2. FOUNDATIONS OF MAS AND DCSP",
      "text" : "Paradigm of swarm intelligence is very often and naturally implemented on the basis of multi-agent systems. These systems express major features of collective intelligence [7, 8, 9] and represent the model of problem in terms of autonomous entities that live in a common environment and who share certain resources. The interactions between these individual entities induce cognitive abilities of the whole. Despite multiple-domainoriented peculiarities majority of multi-agent systems has several significant common features:\n• A limited and local view: every entity has a partial and local knowledge of its environment. • A set of simple rules: each entity follows a set of simple rules. • The interactions are manifold: each individual entity has a relationship with one or more other individuals in the group. •The emerging structure is useful to the community: different entities are a benefit to work (sometimes instinctively) and their performance is better than if they had been alone.\nFrom these points of view, the paradigm of multi-agent systems seek to simulate the coordination of autonomous entities called agents that represent individuals in their community. An agent is an entity that can be viewed as perceiving and acting independently in its environment. According to J. Ferber [10] \"One agent called a physical or virtual:\n1) which can act in an environment, 2) that can communicate directly with other agents, 3) which is driven by a set of trends (in the form of individual objectives or function of satisfaction and even survival, it seeks to optimize), 4) which has its own resources, 5) which is able to collect (but limited) its environment, 6) which has only a partial representation of this environment (and possibly none), 7) has expertise and provides services, 8) which may be repeated, 9) whose behavior tends to meet its objectives, taking into account the resources and skills available to it and according to its perception, its representations and the communications it receives. \" Given such definition of the agent, we can define a multiagent system as a set of agents located in a certain environment. They share some common resources, and they interact with each other either directly or indirectly (via their effects on the environment). They seek to achieve the goals of individual agents in the interest of all. The multi-agent systems have applications in the field of artificial intelligence, where they reduce the complexity of solving a problem by dividing the necessary knowledge into sub-units, involving an intelligent agent independent at each of these sub - sets and coordinating the activity of these agents [10].\nBecause general definitions of inter-agent interaction are too vague we need to apply more strict and formal conventions to express allowable methods of communication between agents. Paradigm of constraints satisfaction, particularly distributed constraints satisfactions, offers flexible and convenient foundations to do this.\nThe paradigm of constraints satisfaction provides a generic\nmethod for declarative description of complex constrained or\noptimization problems in terms of variables and constraints [12,\n13]. Formally, a Constraint Satisfaction Problem (CSP) is a triple\n(V, D, C) where: There is V = {v1, …, vn} is a set of n variables, a corresponding set D = {D(v1), …, D(vn)} of n domains from\nwhich each variable can take its values from,\nand C = {c1, …, cm} is a set of m constraints over the values of the variables in V. Each constraint ci = C(Vi) is a logical\npredicate over subset of variables Vi ⊆ V with an arbitrary arity k : ci (va, …, vk) that maps the Cartesian product D(va) × … × D(vk) to {0, 1}. As usual the value 1 means that the value combination for va, …, vk is allowed, and 0 otherwise.\nConstraints involving only two variables are called binary constraints [14]. A binary constraint between xi and xj can be denoted as cij. Although most of real world problems are represented by non-binary constraints, most of them can be transformed into binary ones using some techniques such as the dual graph method and hidden variable method [15]. Translating non-binary constraints into binary ones allows processing the CSP using efficient techniques adapted only for binary constraints. However, this translation implies normally an increase in number of constraints.\nA solution for a CSP is an assignment of values for each variable in V such that all the constraints in C are satisfied. A single solver supports the tasks of collecting all data of the problem: variables, domains and constraints. It treats all such information in a centralized manner.\nA Distributed Constraint Satisfaction Problem (DCSP) is a CSP where the variables are distributed among agents in a MultiAgent System and the agents are connected by relationships that represent constraints. DCSP is a suitable abstraction to solve constrained problems without global control during per—to-peer agent communication and cooperation [16]. A DCSP can be formalized as a combination of (V, D, C, A, ∂) described as follows: V, D, C are the same as explained for an original CSP,\nA = {a1, …, ap} is a set of p agents,\nand ∂ : V → A is a function used to map each variable vj to its owner agent ai.\nEach variable belongs to only one agent, i.e.\n∀ v1, …, vk ∈ Vi ⇔ ∂ (v1) = … = ∂ (vk) where Vi ⊂ V represents the subset of variables that belong to agent ai. These subsets are\ndistinct, i.e. V1 ∩ … ∩ Vp = ∅ and the union of all subsets\nrepresents the set of all variables, i.e. V1 ∪ … ∪ Vp = V. The distribution of variables among agents divides the set of constraints C into two subsets according to the variables involved within the constraint. The first set is the one of intraagent constraints Cintra that represent the constraints over the variables owned by the same agent\nCintra = {C(Vi) | ∂ (v1) = … = ∂ (vk), v1, …, vk ∈ Vi}. The second set is the one of inter-agent constraints Cinter that represents the constraints over the variables owned by two or more agents. Obviously, these two subsets are distinct\nCintra ∩ Cinter = ∅ and complementary Cintra ∪ Cinter = C. The variables involved within inter-agent constraints Cinter are denoted as interface variables Vinterface. Assigning values to a variable in a constraint that belongs to Cinter has a direct effect on all the agents which have variables involved in the same constraint. The interface variables should take values before the rest of the variables in the system in order to satisfy the constraints inside Cinter firstly. Then, the satisfaction of internal constraints in Cintra becomes an internal problem that can be treated separately inside each agent independently of other agents. If the agent cannot find a solution for its intra-agent constraints, it fails and requests another value proposition for its interface variables. To simplify things, we will assume that there\nare no intra-agent constraints, i.e. Cintra = ∅. Therefore, all variables in V are interface variables V = Vinterface.\nMany techniques are used to solve DCSPs. In general the technique proposes a distributed algorithm which is executed by\nagents that communicate by sending and receiving messages. In general, the messages contain information about assignments of values to variables and rebuttals trust by employees who have no purpose compatible with their own variables. Mainly we mention the Asynchronous Backtracking (ABT) algorithm that was proposed by М. Yokoo [17] and some of its alternatives [18, 19, 20]. These approaches are designed mainly for the treatment of non-binary constraints, however most systems of real constraints are non-binary. Only a few modifications, like [21], were proposed to handle non-binary constraints in the dynamic organization of agents."
    }, {
      "heading" : "3. FUSION OF MAS AND DCSP IN CACS APPROACH",
      "text" : "In order to avoid shortcomings of known DSCP methods and propose new principles of combination between MAS and DCSP we developed several software engineering methods and algorithms which comprise a new approach for developing DSS. This approach was called Controller Agent for Constraints Satisfaction (CACS). Based on the ABT Algorithm of M. Yokoo [17] CACS approach introduces two types of agents in MAS: Variables’ Agent and Controller Agent.\nIn one hand, a Variables’ Agent holds one variable or more. It chooses its values and proposes these values to Controller Agents. On the other hand, Controller Agent encapsulates interagents constraints over these variables. Each Controller Agent holds one constraint or more and validates the propositions received from Variables’ Agents.\nWe can see in Figure 1 (a) an example of constraint network where Variables’ Agent are inter-connected by arcs which represent constraints. These inter-agent constraints are encapsulated in Figure 1 (b) by Controller Agents. The same network can be modified as in Figure 2 by grouping some interagent constraints inside a controller agent. With this ability, we can change the scale of constraints grouping from total distribution to total centralization. The problem can vary from designating a controller agent for each constraint to total centralizing by gathering all constraints inside one central controller agents.\nFor abbreviation purposes we will use the term VAgent to refer to Variables’ Agents and CAgent to refer to Controller Agents. In fact, these terms are used as the name of classes used in the implementation of the prototype. The complete DCSP is formulated in terms of VAgents and CAgents. The solution of the problem is seeking during communication between these types of agents. The proposed algorithm of communication is divided into two stages: (1) domain reducing stage and (2) value proposing and validating stage. These stages are explained as follows:\nA. Domain reducing stage This stage assures constraints consistence by preprocessing variables’ domains. The results are reduced domains by eliminating values that would be surly refused by them. This is done as follows:\n1. A VAgent sends information concerning the domain of its variable to all linked CAgents. The message takes the form\nof (variable, domain).\n2. After receiving the domains of all variables involved in its constraint, the CAgent uses consistency algorithms [22] in\norder to reduce these domains to new ones according to its local constraint(s). Then, the controller sends these domains back to their VAgents. 3. Every VAgent receives the new domains sent by CAgents and combines them (by the intersection of received\ndomains) in order to construct a new version of its variable domain. 4. If any new version of a variable domain was empty then we can say that this DCSP is an over-constrained problem [23]\nwhere no solution can be found. In this case, the system signals that no solution was found (failure). As a prospective, another solution can be investigated by using constraints relaxation [23, 24], in which a VAgent returns\nto an older version of the domain and reconstruct a new version after neglecting the domains sent by the CAgent that represents the soft constraints that the system may violate according to certain constraint hierarchy [23]. On the other hand, if all variables end with single-value domains then one solution is found. Otherwise, the domain reducing stage is repeated as long as we obtain a different new version of a variable domain. When domain reducing is no longer possible (no more change in variables’ domains), we can proceed to the next stage. The result of the domain reducing stage may be one of the three following kinds: 1) The domain of a variable is reduced to an empty field. Having at least one empty domain for a variable means the problem is over-constrained. If there is no solution that satisfies all the constraints and which contains a value for this variable. 2) The former is reduced to a new domain. This reduction may be the result of responses to a controller or more. This change must be propagated to other controllers. For this, the final stages must be repeated. 3) No change in the domain for this particular variable. In this case, we are faced with two situations: a) there are no changed domains at all. This means that the stage is over and we can proceed with the next stage. b) a change to succeed because of the spread of change in the domain of other variables. These variables can be linked directly or indirectly to the variable concerned.\nA. Value proposing and validating stage In this stage VAgents make their propositions of values to related CAgents to be tested. Value proposing can be considered as a domain information message in test mode. A test mode means that when a ―no-solution‖ situation occurs because of a proposition the system backtracks to the last state before that proposition. This proceeds as follows:\n1. From now on, every VAgent starts instantiating values for its variable according to the new domains. It sends this\nproposition to the related CAgents.\n2. The CAgent chooses the value received from the VAgent with the highest priorities. This value is considered as a\ndomain with a single value. CAgent uses consistency algorithms as in the previous stage to reduce other variables’ domains. These new domains are sent to their VAgents to propagate domains change. This step may be viewed as a distributed form of forward checking in an enhanced backtracking algorithm. 3. Like in the previous stage, if all variables end with singlevalue domains then one solution is found. Unlikely, if the\nresult of this propagation was an empty domain for any variable then the proposed value is rejected and another value is requested. If no more value can be proposed then system signals a no-solution situation to user. 4. If the result of the domain propagation was some new reduced domains with more than one value then steps 1-3\nare repeated recursively with the value proposed by the VAgent that have the next priority.\nThe second stage involves one of three situations: 1) The proposed value is rejected if the spread of this value gives an empty domain for one variable at least. The refusal of a value involves retraction of the former domain and demand for another value. 2) Otherwise, the proposed value is accepted and distributed among the agents. The proposal and validation of\nvalues for the other variables continue recursively. 3) If there are more values to be proposed for a variable, the value proposed by the agent who has a higher priority is denied. The algorithm ends in failure when the agent has more priority over proposals valid.\nLet’s consider an example of MAS where three variables x, y, z with original permitted domain {0, 1, 2} are distributed on three VAgents A1, A2 and A3, and two constraints exist: x ≠ y and x + y < z. These constraints are placed into two CAgents C1 and C2.\nDuring the first stage of CACS (fig.3) three agents A1, A2 and A3 are sending the domain { 0, 1, 2} for the three variables x, y and z respectively agents C1 and C2. C1 tries to reduce the domains of x and y. Obviously, no change is possible. On the contrary, the agent C2 changes the domains of variables x and y in {0, 1} and the domain of z in {1, 2}. This change will be propagated to the agent C1 which returns the same domains for variables x and y (i.e. {0, 1}). The domain reducing stage finishes with the domain {0, 1} for the variables x and y and the {1, 2} for the variable z.\nDuring the second stage (fig.4), algorithm will assign priorities to the agents A1, A2 and A3 according to their index. So the agent A1 will have the highest priority, and the agent A3 will have the lowest priority. Suppose that the agent A1 proposes value 0 for the variable x to the agents C1 and C2. C1 treats this value as the domain {0} and reduces the domain of the variable y to {1}. The spread of this new domain reduces the domain of the variable z to {2}. A2 tries to offer as the value 0 for variable y. His proposal will be of lower priority than the agent A1 and will be refused because they are inconsistent. The same result is obtained for any other value.\nAccording to the results of the first and second stages, we can say that the CACS algorithm solves DCSP: 1) When the DCSP is over-constrained, we are faced with two different situations: Either the initial domains of the variables are inconsistent. This means that at the end of the first stage there is at least one empty domain of a variable. This involves termination of the algorithm and the declaration of a state of non-solution. Either the initial domains of the variables are consistent. 2) Where there is a unique solution of DCSP, we face two situations: The domains are consistent as long as there is a solution to the DCSP. If the first stage ends with single-vale domains, it means that the solution is found and the algorithm stops. Otherwise, in the second stage, the value proposed by a variable if it is not inconsistent with a value proposed by another agent with higher priority. The proposals of the agent with the highest priority are a priori accepted by all CAgents (it is necessary that this value is\npart of the final solution to be finally accepted). 3) When the DCSP is under-constrained, many solutions exist. The order of each proposed agent determines convergence towards any particular solution. In other words, the agents start the proposals by the most suitable for their purposes. For example, if an agent tries to minimize the value of its variable, it must begin proposing values from the minimum to the highest values."
    }, {
      "heading" : "4. SOFTWARE IMPLEMENTATION OF CACS",
      "text" : "To prove the proposed methods of constraints satisfaction based on two types of the agents we developed an object-oriented CACS software prototype which can be considered as a generic framework for distributed information syste4ms in logistics. As we can see from Figure 5, the developed CACS prototype uses hierarchical multiple-layer architecture.\nThis architecture allows developing applications more flexibly by separating it into specialized layers. The very top layer is the application layer which is the implementation of a DCSP problem using the proposed system underneath it. From the application view point, the system is composed directly from the two principal types of agents: the CAgent and the VAgent. Both agents are inherited from CommonAgent class that defines some shared functionalities between both types of agents. The user can create the necessary VAgents according to its problem definition. He also creates the constraints and associates them to CAgents.\nThe second layer is the intended system (CACS) where our two-stage interaction algorithm is implemented in accordance with previous definition. Figure 7 shows the interaction between agents during the domain reducing stage. The interaction protocol is a loop of repeated domain informing from the VAgents side to CAgents side and new domain proposing as response. This loop is repeated until no further domain reduction\nis possible (or an empty reduced domain is found which signify that there is no solution).\nThe interaction between agents during value proposing stage is shown in Figure 6. as nest loops: the internal loop is similar to the domain reducing loop in Figure 6. Variables’ domains are reduced according to the proposed value in the external loop. In the external loop, values are proposed and evaluated after the domain reduction to be either accepted or rejected. The external loop continues until we obtain single value domains for all variables.\nThe system layer uses generic interfaces for both MAS and CSP platforms. This allows the system to use any existing MAS and CSP platforms by implementing these interfaces. At the same time this isolates the internal structure from the changes of choice of platforms. An intermediate layer between the system and the real MAS or CSP platform is necessary in order to separate the structure of the system from that of the real MAS and CSP platforms. This layer works as an adapter; it implements the generic platforms in the system layer using the real platforms. This implementation difficulty varies according to the MAS and CSP platforms used for the realization of the final system.\nThe whole CACS prototype was developed in Java language. Due to the object oriented nature of Java language agents and the messages are represented by objects (Figure 8, 9).\nHowever, from the point of view of Multi-Agent System design, agents should not be referenced by a simple public reference that is accessible by any other object in the system. The reason for that is to prevent any direct access to the agent internal functionality. Normally, references to agents should be kept hidden by the MAS platform and communicating with an agent is made by messages that would be delivered by the system using the agent address. Mapping from agent address to its real reference is an internal functionality of the MAS platform.\nIn order to be more generic, we distinguish in the prototype implementation between the agent and its reference. For this purpose, VAgentRef and CAgentRef classes have been designed. Both classes are inherited from the abstract AgentRef class. They are used as references to either variables’ agents or controller agents. When an instance of the class DCSP is used to create an instance of VAgent or a CAgent, it returns an instance of either VAgentRef or CAagentRef classes respectively according to created agent. In the same manner, a variable inside\nvariables’ agents cannot be referred directly. In fact, a controller agent keeps a copy of that variable inside it and propagates any change on that variable to the owner agent. Instead of dealing with variables directly between agents, they deal with variables identifiers. A variables identifier is an instance of VID class. It is simply the name of the variables and the identifier of its owner agent. An instance of VAgentRef is used to create variables inside the corresponding VAgent. A variable creation process returns an instance of VID class identifying the created variable.\nAmong additional features we added to our prototype a possibility to declaratively define a simple DCSP via the use of XML notation. The XML file that describes a DCSP problem should be built according to the following model (fig.10):\nThe choice of multi-agent platforms and multi-solver constraints required a study and testing of several platforms. We reviewed our work over multiple platforms including JADE and Madkit and several constraints solvers as CHOCO, Cream and JCK. Finally we chose for the role of MAS JADE (Java Agent DEvelopment Framework) multi-agent framework [25], and for CSP platform, we have chosen Choco [26, 28].\nJADE is a multi-agent framework compliant with the FIPA specifications [27] and is fully implemented in Java language. JADE was established by the laboratory TILAB Telecom Italia. JADE has three main modules (fig.11): DF (Directory Facilitator): provides a service of \"yellow pages\" to the platform; ACC (Agent Communication Channel) handles communication between agents; AMS (Agent Management System) oversees the registration of agents, authentication, access and use of the system. Each JADE agent is composed of a single thread of execution (thread). Each task agent is represented by an instance of class Behavior. Jade offers the possibility of agents' multithreaded, although the user leaves the responsibility for managing competition (except the timing of the messages file ACLs).\nIn order to implement a behavior, the developer must define one or more objects of class Behavior, the instantiate and add them to the thread of execution of the agent. Every object type has a Behavior method action () (which is the treatment to be performed by it) and a method done () (which checks if the treatment is completed). In detail, the scheduler executes the method action () of each object in the queue of the tasks of the agent. Once this is completed, the method done () is invoked. If the task has been completed then the Behavior object is removed from the queue. The scheduler is non-preemptive and does only one behavior at a time, one can consider the method action () as atomic. It is then necessary to take certain precautions during the implementation of the latter, to avoid endless loops or operations too long. The most classic program behavior is to describe it as a finite state machine. The current status of the agent is stored in local variables.\nAlso JADE simplifies the implementation of multi-agent systems through a set of graphical tools that supports the debugging and deployment phases.\nChoco is a library for constraint satisfaction problems (CSP), constraint programming (CP) and explanation-based constraint solving (e-CP) [28]. It is built on an event-based propagation mechanism with backtrackable structures. Choco is implemented in Java and takes advantage of the principle of inheritance to allow the programmer to define its own types and constraints. This is achieved by using abstract classes (fig. 12):\nIt permits the use of multiple solvers for different problems separately. This allows each CAgent to have its own solver. A distributed constraint problem is created as an instance of the class DCSP. This instance represents the problem to be solved and is used to create the different needed agents.\nOur prototype in its current state is composed of three main packages containing more than 80 classes and Java interfaces and approximately 4300 lines of code."
    }, {
      "heading" : "5. DESIGN METHODOLOGY IN CACS",
      "text" : "A specific methodology was designed to allow the user to develop distributed multi-agenty systems using Swarm Intelligence paradigm and CACS approach. In general this methodology consists of the following steps:\n1. Identify the key actors of the problem (VAgents). These actors are the entities of the system modeled. 2. Determine the properties (variables) of these actors that are restricted by constraints with properties of\nother actors.\n3. Determine all the constraints of the problem. 4. Classify constraints logically in separate groups. 5. Specify a set of Controller Agents to monitor each\ngroup of constraints.\nTo provide a developer with flexible practical methods of the design we offer two refinements of the general methodology: simple and complex.\nTo prove the proposed methods of constraints satisfaction based on two types of the agents we developed an objectoriented CACS software prototype which can be considered as a generic framework for distributed model-driven DSSs. As we can see from Figure 5, the developed CACS prototype uses hierarchical multiple-layer architecture. The following steps correspond to a given DCSP:\n6. Creation of the problem P. This is done by creating an instance of the class DCSP from the package dcsp. 7. Creation of agents to control variables (specifically, their references) via the prolem P. using the method\nmakeVAgent () to create a variable and method makeCAgent () to create a controller. 3) Creating variables distributed via agents which own variables. This is done through the method makeBoundedIntVar () which creates a variable with two upper and lower limits.\n8. Creation of constraints on variables. 9. Addition of constraints to CAgents. 10. Start the algorithm of resolution through the DCSP P.\nThe use of the prototype can be demonstrated via the\nfollowing simple example: V = {x, y, z} is the set of variables from the domain {1, …, 100} for all of them, C = {c1, c2, c3} is the set of constraints:\nc1 : x ≠ y, y ≠ z, x ≠ z (or alldifferent (x, y, z)) c2 : x ≥ y c3 : z ≥ y\nIn order to model this problem using the proposed prototype the user should proceed as follows. We start by assigning variables to VAgents. In this example, agents v1, v2, and v3 own variables x, y, and z respectively. Note that the distribution of variables may be a problem dependant issue which means that the user chooses the owner agent of each variable according to the problem specifications. In the same manner, constraints also should be assigned to CAgents. In this example, we assign each constraint to a CAgent.\n1. Create a distributed problem p (an instance of DCSP class).\nThis class will be used in order to create VAgents and\nCAgents and to start our CACS algorithm."
    }, {
      "heading" : "DCSP p = new DCSP(\"example\");",
      "text" : "This creates a distributed problem with which agents, variables and constraints will be created.\n2. Use this instance to create both types of agents. This is done\nby calling makeVAgent() and makeCAgent() methods from\nthe DCSP instance created in step 1 as follows: VAgentRef v1 = p.makeVAgent (“v1”); VAgentRef v2 = p.makeVAgent (“v2”); VAgentRef v3 = p.makeVAgent (“v3”); CAgentRef c1 = p.makeCAgent (“c1”); CAgentRef c2 = p.makeCAgent (“c2”); CAgentRef c3 = p.makeCAgent (“c3”);\n3. Create variables inside VAgents. In other word, assign\nvariables to variables agents. The method\nmakeBoundedIntVar() is used to achieve this as follows:"
    }, {
      "heading" : "VID x = v1.makeBoundedIntVar (“x”, 1, 100);",
      "text" : ""
    }, {
      "heading" : "VID y = v2.makeBoundedIntVar (“y”, 1, 100);",
      "text" : "VID z = v3.makeBoundedIntVar (“z”, 1, 100);\n4. Create the constraints and post them to CAgents. The\nconstraints are created separately and posted to their owner\nagents using the method post(): c1.post(new AllDifferent(new VID[]{x,y,z})); c2.post(new GreaterOrEqual(x, y)); c3.post(new GreaterOrEqual (y, z));\n5. Start the CACS algorithm by calling solve() method from\nthe DCSP instance: p.solve();\nThis last instruction initiates communication between the different agents in the system in accordance the algorithm described previously in Section 3. If an agent finds a value for its variable that corresponds to a solution then it will notify to this value. The solution will be the combination of all values from all agents. Otherwise, no-solution state is declared.\nAlso the developer can express the structure of DCSP in declarative manner using XML. For instance, the problem described in previous sub-section can be written in XML as follows: <?xml version=\"1.0\" encoding=\"UTF-8\"?> <!DOCTYPE dcsp SYSTEM \"dcsp.dtd\"> <dcsp> <name>example</name> <vagent><name>v1</name><var><name>x</name>\n<inf>1</inf><sup>100</sup></var></vagent>\nv2 and v3 by the same manner\n<cagent>\n<name>c1</name> <constraint><alldiff>\n<vid><name>x</name><owner>v1</owner></vid>\n<vid><name>y</name><owner>v2</owner></vid>\n<vid><name>z</name><owner>v3</owner></vid>\n</alldiff></constraint></cagent>\nc2 and c3 by the same manner\n</dcsp>"
    }, {
      "heading" : "6. CACS APPROACH IN TRANSPORT LOGISTICS",
      "text" : "We consider modern transportation problems as a natural candidate domain for evaluation of the proposed CACS approach. Although there is a lot of different centralized algorithms in this area we believe that multi-agent techniques can radically improve efficiency and fairness of negotiation between participants in the course of problem solving as well as improve reactivity of the logistics systems. Among different benefits of logistics management within the CACS framework we can point out such positive features as: better consideration of individual preferences and ability of their dynamical changes in the course of solving, early availability of partial solutions and inherently distributed structure of the system.\nIn order to create solid foundations for application of Swarm Intelligence and CACS approach in transportation logistics we developed a distributed multi-agent application which mimics major features of modern ship loading problems, and evaluated its feasibility and performance. Our CACS application is based on a simplified ship loading scenario which was originally presented in studied in Chips constraint solver by Kay Chips (Kay 1997) and later was expressed in terms of Java-based Choco constraint solver by prof. A. Aggoun.\nIn the discussed problem a specific precedence function pred in defined over the loading items. For each of the items the number of workers needed for loading is specified.\nAccording to CACS methodology each loading task is realized as a separate Variable Agent in our CACS application. Variable Agent holds three specific variables. These variables determine start time of loading (tistart), finish time of loading (tiend) and predetermined loading duration (d i) accordingly.\nAll constraints of the considered problem are grouped inside Controller Agents. We recognize three different groups of Controller Agents according to the semantics of the constraints. The first group contains Controller Agents which hold duration constraints. The agent of that group is responsible for verifying that the loading tasks are scheduled within the time frame. It means that for each task i the following constraint should be satisfied: tistart + d i tiend.\nThe second group contains Controller Agents which are responsible for verifying that the loading plan satisfies precedence constraints given (like one on the fig. 13). Finally the third group contains Controller Agents which are responsible for verifying availability of the resources for the loading plan. Controller Agent of that kind holds cumulative constraint over the number of workers available for finishing the ship loading within the total time.\nThat cumulative constraint may be expressed using current values of tistart, and t i end variables, as well predetermined workforce effort needed for each task wi. Given these values we can define the scheduling matrix SC.\nSC =\nNN ww\nww\nwww\n...0000000\n0...00000\n0...0000\n22\n111\nThe element SCij is equal to wi iff at the time moment j the loading task i is performed, and it is equal to 0 in the opposite case.\nUsing that matrix we may define the maximum number of workers needed at each moment of the time and the needed\ncumulative constraint: PersonsSC N\ni\nij j maxmax 1\n.\nWith such problem interpretation we may completely describe it in terms of our CACS approach. The original structure of the agents is presented on Figure 15.\nUsing the proposed methodology we designed the Java-based application that solves the ship loading problem. In that program at the first moment the ControllerAgents are created:"
    }, {
      "heading" : "CAgentRef startEndController =",
      "text" : "dpb.makeCAgent(\"startEndController\");"
    }, {
      "heading" : "CAgentRef precendenceController =",
      "text" : "dpb.makeCAgent(\"precendenceController\");"
    }, {
      "heading" : "CAgentRef cumulativeController =",
      "text" : "dpb.makeCAgent(\"cumulativeController\");\nThen auxiliary VariableAgent is created which stores the total\ntime of loading operations: VAgentRef general = dpb.makeVAgent(\"General\");"
    }, {
      "heading" : "VID generalEnd = general.createVar(\"General_End\",",
      "text" : "0, timeHorizon);\nAfter that in the cycle thirty-four VariableAgents are created which correspond to the loading tasks and store needed variables tistart, t i end and duration d i. In the same cycle the duration constraints are created and attached to the corresponding ControllerAgent.\nfor (int j = 0; j < nbTasks; j++) { taskAgents[j] = dpb.makeVAgent(\"task_agent_\" +\n(j + 1));\ntaskStarts[j] = taskAgents[j].\ncreateVar(\"Start\", 0, timeHorizon);\ntaskEnds[j] = taskAgents[j].createVar(\"End\",\n0, timeHorizon);\ntaskDurations[j] = taskAgents[j].\ncreateVar(\"Duration\", durations[j], durations[j]);"
    }, {
      "heading" : "DOperation startEndOperation = new",
      "text" : "Subtract(taskStarts[j], taskEnds[j]);"
    }, {
      "heading" : "DConstraint startEndConstraint = new",
      "text" : "Equal(startEndOperation, taskDurations[j]);\nstartEndController.post(startEndConstraint);"
    }, {
      "heading" : "DConstraint endConstraint =",
      "text" : "new LessOrEqual(taskEnds[j], generalEnd);\nstartEndController.post(endConstraint); }\nFinally the precedence constraint and cumulative constraint\nare determed and the process of solution search is started.\nWith the given conditions in the result of application run the values of variables tistart, t i end will constitute a feasible solution ot the ship loading problem."
    }, {
      "heading" : "7. CONCLUSIONS & FUTURE WORK",
      "text" : "In this article we proposed a new approach for combination of MAS and DCSP in multi-agent swarm systems. This approach called CACS (Controller-Agent for Solving Constraints) based on the use of a specific type of agents called Agent Controller and Variables’ Agent. We believe that proposed process of constraint satisfaction in the multi-agent system fits well the general principles of Swarm Intelligence. In particular, the stage\nof domain reduction in our algorithm may be seen exchange of ―rules, tips and believes about how to process the information [4]‖.\nAlso in our approach we implemented a principal feature of Swarm systems, which is principal ability to modify multi-agent structure in response of various influencing factors. First of all, declarative manner of constraints based formalization of the problem allows for changing inter- and intra-agent behavior. Secondly, the composition of inter-agent constraints inside ControllerAgent may be changed during evolution of the system (as it shown on fig.1 and fig .2).\nIn the proposed CACS architecture we see good opportunities for further moving towards to implementation of advanced swarm intelligence capabilities. Modern MAS platforms like JADE implement different peer-to-peer communication mechanisms for which direct correspondence may be found in computational biology. Given such mechanisms as foundation for reliable distributed inter-agent communication we will extend discussed algorithms of interaction between Controllers Agents and Variables Agents by adaptation framework. In such framework agents will be able to discover critical changes in MAS configuration (faults of agents, misbehavior, etc), negotiate responsibilities and change the roles accordingly in order to continue proper collective operations.\nThe model of distributed constraints satisfaction proposed in SACS also offers two main contributions in DCSP research. First, it is the possibility of a direct and easier dealing with nonbinary constraints without having to use methods of transformation of non-binary constraints to binary constraints. Second, CACS offers us the possibility to organize the constraints logically related groups. This grouping of constraints allows us to form sub-problems, each group is monitored and processed by a single controller. This also helps reduce the total number of Controller Agents needed.\nNon-binary constraints are more common in real problems than binary ones. Some methods are used in order to allow using binary constraint solving techniques on non-binary ones. Methods like hidden and dual transformation [14, 15] convert non-binary constraints into equivalent binary ones. Other methods are proposed in the DCSP domain in order to deal with non-binary constraints. I. Brito [21, 33,34] has proposed organizing agents involved in a non-binary dynamically in order to form a proper propose-validate sequence. Agents then follow that sequence to find a solution for that constraint.\nOur algorithm proposes another direct alternative. Any constraint is encapsulated inside a controller agent regardless this constraint is binary or non-binary. Agents involved in any constraint are not forced to follow any order in proposing values for their variables.\nThe increase in number of agents is an inconvenience of our model. We can investigate the possibility of using a hybrid system of both, our model and a standard ABT model, in order to model a DCSP. In such hybrid system, binary constraints relate variables’ agents directly while non-binary constraints are encapsulated inside controller agents. The possibility of gathering constraints gives also the possibility of decreasing the number of agents. The user can group some constraints according to the modeled problem logic.\nTo prove the feasibility of the proposed theoretical principles we implemented software prototype of CACS. It uses generic interfaces for integration with different third-party MAS-\nplatforms and CSP-solvers. In the final implementation we used the MAS platform JADE and the Choco CSP solver. Apart from direct Java programming of DCSP problems our prototype also provides an opportunity to describe the problem using XML facilitating the modeling of simple problems without the need to write and compile a Java program.\nDemonstrated applicability of CACS for solution of logistics problems opens opportunity for further progress in developing Swarm Intelligence applications. Following that direction we plan to continue in design of meta-communication protocol between ControllerAgents, which will permit define formal methods of re-composition of constraints inside different ControllerAgents during evolution of the system.\nAnother interesting problem for CACS application comes from the domain of modern transportation systems. Here we wish to apply CACS approach for the ―transport on demand‖ challenge and solution of complex logistics problems in real conditions of modern warehouses. Also we are going to investigate ways to add optimization mechanism to the system similar to DPOP algorithm [34]. This will allow the user to adjust the Variables’ Agent value choosing according to a given optimizing mechanism.\nThis work was partially supported by HSE grant # T3-61.1."
    } ],
    "references" : [ {
      "title" : "Logistics Management in China. Building Supply Chain Excellence in Emerging Economies",
      "author" : [ "G. Feng", "G. Yu", "W. Jiang" ],
      "venue" : null,
      "citeRegEx" : "1",
      "shortCiteRegEx" : "1",
      "year" : 2007
    }, {
      "title" : "Growth Prospects of Russian Transportation and Logistics Market. Das Beste der Logistik:Innovationen, Strategien, Umsetzungen. pp.369-379",
      "author" : [ "L. Simonova" ],
      "venue" : null,
      "citeRegEx" : "2",
      "shortCiteRegEx" : "2",
      "year" : 2008
    }, {
      "title" : "Swarm Intelligence: From Natural to Artifical Systems",
      "author" : [ "E. Bonabeau", "M. Dorigo", "Theraulaz G" ],
      "venue" : null,
      "citeRegEx" : "3",
      "shortCiteRegEx" : "3",
      "year" : 1999
    }, {
      "title" : "Approaches to Methods of Autonomous Cooperation and Control for the Management-, Information- and Communication-Layer of Logistics. Understanding Autonomous Cooperation and Control in Logistics (Katja Windt and Michael Hülsmann eds.)",
      "author" : [ "M. Hülsmann", "K. Windt" ],
      "venue" : null,
      "citeRegEx" : "5",
      "shortCiteRegEx" : "5",
      "year" : 2007
    }, {
      "title" : "Agent-Based Approaches to Transport Logistics",
      "author" : [ "Davidsson", "L.P. Henesey", "L. Ramstedt", "J. Törnquist", "F. Wernstedt" ],
      "venue" : "Applications of Agent Technology in Traffic and Transportation. pp.1-15. Birkhäuser Basel",
      "citeRegEx" : "6",
      "shortCiteRegEx" : "6",
      "year" : 2005
    }, {
      "title" : "Collective Intelligence in Multi-Agent Robotics: Stigmergy, Self-Organization and Evolution",
      "author" : [ "E. Izquierdo-Torres" ],
      "venue" : null,
      "citeRegEx" : "7",
      "shortCiteRegEx" : "7",
      "year" : 2004
    }, {
      "title" : "COLLECTIVE INTELLIGENCE: Creating a Prosperous World at Peace",
      "author" : [ "T. Atlee", "Y. Benkler", "T. Homer-Dixon", "P. Levy", "T. Malone", "R.H.P. Martin", "H. Masum", "R. Steele", "M. Tovey" ],
      "venue" : "Earth Intelligence Network",
      "citeRegEx" : "8",
      "shortCiteRegEx" : "8",
      "year" : 2008
    }, {
      "title" : "Modélisation d’accompagnement Simulations multiagents et gestion des ressources naturelles et renouvelables",
      "author" : [ "F. Bousquet" ],
      "venue" : null,
      "citeRegEx" : "9",
      "shortCiteRegEx" : "9",
      "year" : 2001
    }, {
      "title" : "Multi-agent Systems-An Introduction to Distributed Artificial Intelligence",
      "author" : [ "J. Ferber" ],
      "venue" : null,
      "citeRegEx" : "10",
      "shortCiteRegEx" : "10",
      "year" : 1999
    }, {
      "title" : "A Nonlinear Multi-agent System designed for Swarm Intelligence: the Logistic MAS",
      "author" : [ "R. Charrier", "C. Bourjot", "F. Charpillet" ],
      "venue" : "SASO '07. First International Conference on Self-Adaptive and Self- Organizing Systems,",
      "citeRegEx" : "11",
      "shortCiteRegEx" : "11",
      "year" : 2007
    }, {
      "title" : "Constraint Programming: In Pursuit of the Holy Grail, in Proceedings of WDS99 (invited lecture)",
      "author" : [ "R. Barták" ],
      "venue" : null,
      "citeRegEx" : "12",
      "shortCiteRegEx" : "12",
      "year" : 1999
    }, {
      "title" : "Distributed Constraint Satisfaction for Coordinating and Integrating a Large-Scale, Heterogeneous Enterprise, University of London",
      "author" : [ "C. Eisenberg" ],
      "venue" : null,
      "citeRegEx" : "13",
      "shortCiteRegEx" : "13",
      "year" : 2003
    }, {
      "title" : "On the Conversion between Non-Binary and Binary Constraint Satisfaction Problems",
      "author" : [ "F. Bacchus", "Beek", "P. v" ],
      "venue" : "Proceedings of the 15th National Conference on Artificial Intelligence (AAAI-98) and of the 10th Conference on Innovative Applications of Artificial Intelligence",
      "citeRegEx" : "15",
      "shortCiteRegEx" : "15",
      "year" : 1998
    }, {
      "title" : "NoGood Caching for MultiAgent Backtrack Search",
      "author" : [ "W.S. Havens" ],
      "venue" : "Proceedings of American Association for Artificial Intelligence",
      "citeRegEx" : "16",
      "shortCiteRegEx" : "16",
      "year" : 1997
    }, {
      "title" : "Algorithms for Distributed Constraint Satisfaction: A Review. in Autonomous Agents and Multi-Agent Systems, pp",
      "author" : [ "M. Yokoo", "K. Hirayama" ],
      "venue" : null,
      "citeRegEx" : "17",
      "shortCiteRegEx" : "17",
      "year" : 2000
    }, {
      "title" : "The Asynchronous Backtracking Family, LIRMM-CNRS",
      "author" : [ "C. Bessiere", "Brito I", "A. Maestre", "P. Meseguer" ],
      "venue" : "March 2003,",
      "citeRegEx" : "18",
      "shortCiteRegEx" : "18",
      "year" : 2003
    }, {
      "title" : "Asynchronous Backtracking without Adding Links: A New Member in the ABT Family",
      "author" : [ "C. Bessiere", "I. Brito" ],
      "venue" : null,
      "citeRegEx" : "19",
      "shortCiteRegEx" : "19",
      "year" : 2005
    }, {
      "title" : "Distributed Stable Matching Problems with Ties and Incomplete Lists",
      "author" : [ "I. Brito", "P. Meseguer" ],
      "venue" : "In Proceedings of the Twelfth International Conference on Principles and Practice of Constraint Programming (CP-2006),",
      "citeRegEx" : "21",
      "shortCiteRegEx" : "21",
      "year" : 2006
    }, {
      "title" : "Bound Consistency on Linear Constraints in Finite Domain Constraint Programming",
      "author" : [ "Zhang Y", "H. Wu" ],
      "venue" : "In 13th European Conference on Artificial Intelligence Young Researcher Paper,",
      "citeRegEx" : "22",
      "shortCiteRegEx" : "22",
      "year" : 1998
    }, {
      "title" : "Constraint Satisfaction with Preferences",
      "author" : [ "H. Rudova" ],
      "venue" : "In Faculty of Informatics Brno - Czech Republic: Masaryk University,",
      "citeRegEx" : "23",
      "shortCiteRegEx" : "23",
      "year" : 2001
    }, {
      "title" : "A Cooperative Mediation-Based Protocol for Dynamic, Distributed Resource Allocation. In IEEE Transaction on Systems, Man, and Cybernetics, Part C, Special Issue on Game-theoretic Analysis and Stochastic Simulation of Negotiation",
      "author" : [ "R. Mailler", "V.V. Lesser" ],
      "venue" : null,
      "citeRegEx" : "24",
      "shortCiteRegEx" : "24",
      "year" : 2004
    }, {
      "title" : "Developing Multi- Agent Systems with JADE, Wiley",
      "author" : [ "F.L. Bellifemine", "Caire G", "D. Greenwood" ],
      "venue" : null,
      "citeRegEx" : "25",
      "shortCiteRegEx" : "25",
      "year" : 2007
    }, {
      "title" : "OPERAS: A Framework for the Formal Modelling of Multi-Agent Systems and Its Application to Swarm-Based Systems",
      "author" : [ "I. Stamatopoulou", "P. Kefalas", "M. Gheorghe" ],
      "venue" : "World VIII.pp.158-174,",
      "citeRegEx" : "28",
      "shortCiteRegEx" : "28",
      "year" : 2008
    } ],
    "referenceMentions" : [ {
      "referenceID" : 0,
      "context" : "Simultaneous rapid grow of logistics market in different regions of the world [1, 2], and its important role in modern economy require wide application of logistics information and management systems for coordinated planning and control.",
      "startOffset" : 78,
      "endOffset" : 84
    }, {
      "referenceID" : 1,
      "context" : "Simultaneous rapid grow of logistics market in different regions of the world [1, 2], and its important role in modern economy require wide application of logistics information and management systems for coordinated planning and control.",
      "startOffset" : 78,
      "endOffset" : 84
    }, {
      "referenceID" : 3,
      "context" : "Distributed organizational structure and application of holonic management principles in modern organizations inevitably determine distributed and autonomous features of information systems supporting logistic operations [5].",
      "startOffset" : 221,
      "endOffset" : 224
    }, {
      "referenceID" : 2,
      "context" : "Swarm Intelligence [3, 4] represents one of the interesting paradigm for maintaining self-organization and control in the distributed systems.",
      "startOffset" : 19,
      "endOffset" : 25
    }, {
      "referenceID" : 4,
      "context" : "Different projects offered approaches for practical application of Swarm Intelligence paradigm in the form of multi-agent systems [6, 28, 30].",
      "startOffset" : 130,
      "endOffset" : 141
    }, {
      "referenceID" : 22,
      "context" : "Different projects offered approaches for practical application of Swarm Intelligence paradigm in the form of multi-agent systems [6, 28, 30].",
      "startOffset" : 130,
      "endOffset" : 141
    }, {
      "referenceID" : 22,
      "context" : "[28]) offer a formal framework for declarative expression and analysis, researchers and practitioners still lack proper generic methods for engineering of the multi-agent systems which have such properties of Swarm Intelligence as emergent behavior, peer-topeer communication, etc.",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 13,
      "context" : "Existing approaches to combination of MAS and CSP like [16, 17, 32] do not provide much flexibility and support of dynamic modification of the combined structure of agents and constraints.",
      "startOffset" : 55,
      "endOffset" : 67
    }, {
      "referenceID" : 14,
      "context" : "Existing approaches to combination of MAS and CSP like [16, 17, 32] do not provide much flexibility and support of dynamic modification of the combined structure of agents and constraints.",
      "startOffset" : 55,
      "endOffset" : 67
    }, {
      "referenceID" : 5,
      "context" : "These systems express major features of collective intelligence [7, 8, 9] and represent the model of problem in terms of autonomous entities that live in a common environment and who share certain resources.",
      "startOffset" : 64,
      "endOffset" : 73
    }, {
      "referenceID" : 6,
      "context" : "These systems express major features of collective intelligence [7, 8, 9] and represent the model of problem in terms of autonomous entities that live in a common environment and who share certain resources.",
      "startOffset" : 64,
      "endOffset" : 73
    }, {
      "referenceID" : 7,
      "context" : "These systems express major features of collective intelligence [7, 8, 9] and represent the model of problem in terms of autonomous entities that live in a common environment and who share certain resources.",
      "startOffset" : 64,
      "endOffset" : 73
    }, {
      "referenceID" : 8,
      "context" : "Ferber [10] \"One agent called a physical or virtual: 1) which can act in an environment, 2) that can communicate directly with other agents, 3) which is driven by a set of trends (in the form of individual objectives or function of satisfaction and even survival, it seeks to optimize), 4) which has its own resources, 5) which is able to collect (but limited) its environment, 6) which has only a partial representation of this environment (and possibly none), 7) has expertise and provides services, 8) which may be repeated, 9) whose behavior tends to meet its objectives, taking into account the resources and skills available to it and according to its perception, its representations and the communications it receives.",
      "startOffset" : 7,
      "endOffset" : 11
    }, {
      "referenceID" : 8,
      "context" : "The multi-agent systems have applications in the field of artificial intelligence, where they reduce the complexity of solving a problem by dividing the necessary knowledge into sub-units, involving an intelligent agent independent at each of these sub - sets and coordinating the activity of these agents [10].",
      "startOffset" : 306,
      "endOffset" : 310
    }, {
      "referenceID" : 12,
      "context" : "Although most of real world problems are represented by non-binary constraints, most of them can be transformed into binary ones using some techniques such as the dual graph method and hidden variable method [15].",
      "startOffset" : 208,
      "endOffset" : 212
    }, {
      "referenceID" : 13,
      "context" : "DCSP is a suitable abstraction to solve constrained problems without global control during per—to-peer agent communication and cooperation [16].",
      "startOffset" : 139,
      "endOffset" : 143
    }, {
      "referenceID" : 14,
      "context" : "Yokoo [17] and some of its alternatives [18, 19, 20].",
      "startOffset" : 6,
      "endOffset" : 10
    }, {
      "referenceID" : 15,
      "context" : "Yokoo [17] and some of its alternatives [18, 19, 20].",
      "startOffset" : 40,
      "endOffset" : 52
    }, {
      "referenceID" : 16,
      "context" : "Yokoo [17] and some of its alternatives [18, 19, 20].",
      "startOffset" : 40,
      "endOffset" : 52
    }, {
      "referenceID" : 17,
      "context" : "Only a few modifications, like [21], were proposed to handle non-binary constraints in the dynamic organization of agents.",
      "startOffset" : 31,
      "endOffset" : 35
    }, {
      "referenceID" : 14,
      "context" : "Yokoo [17] CACS approach introduces two types of agents in MAS: Variables’ Agent and Controller Agent.",
      "startOffset" : 6,
      "endOffset" : 10
    }, {
      "referenceID" : 18,
      "context" : "After receiving the domains of all variables involved in its constraint, the CAgent uses consistency algorithms [22] in order to reduce these domains to new ones according to its local constraint(s).",
      "startOffset" : 112,
      "endOffset" : 116
    }, {
      "referenceID" : 19,
      "context" : "If any new version of a variable domain was empty then we can say that this DCSP is an over-constrained problem [23] where no solution can be found.",
      "startOffset" : 112,
      "endOffset" : 116
    }, {
      "referenceID" : 19,
      "context" : "As a prospective, another solution can be investigated by using constraints relaxation [23, 24], in which a VAgent returns",
      "startOffset" : 87,
      "endOffset" : 95
    }, {
      "referenceID" : 20,
      "context" : "As a prospective, another solution can be investigated by using constraints relaxation [23, 24], in which a VAgent returns",
      "startOffset" : 87,
      "endOffset" : 95
    }, {
      "referenceID" : 19,
      "context" : "to an older version of the domain and reconstruct a new version after neglecting the domains sent by the CAgent that represents the soft constraints that the system may violate according to certain constraint hierarchy [23].",
      "startOffset" : 219,
      "endOffset" : 223
    }, {
      "referenceID" : 21,
      "context" : "Finally we chose for the role of MAS JADE (Java Agent DEvelopment Framework) multi-agent framework [25], and for CSP platform, we have chosen Choco [26, 28].",
      "startOffset" : 99,
      "endOffset" : 103
    }, {
      "referenceID" : 22,
      "context" : "Finally we chose for the role of MAS JADE (Java Agent DEvelopment Framework) multi-agent framework [25], and for CSP platform, we have chosen Choco [26, 28].",
      "startOffset" : 148,
      "endOffset" : 156
    }, {
      "referenceID" : 22,
      "context" : "Choco is a library for constraint satisfaction problems (CSP), constraint programming (CP) and explanation-based constraint solving (e-CP) [28].",
      "startOffset" : 139,
      "endOffset" : 143
    }, {
      "referenceID" : 12,
      "context" : "Methods like hidden and dual transformation [14, 15] convert non-binary constraints into equivalent binary ones.",
      "startOffset" : 44,
      "endOffset" : 52
    }, {
      "referenceID" : 17,
      "context" : "Brito [21, 33,34] has proposed organizing agents involved in a non-binary dynamically in order to form a proper propose-validate sequence.",
      "startOffset" : 6,
      "endOffset" : 17
    } ],
    "year" : 2010,
    "abstractText" : "The article offers original approach which is called Controller Agent for Constraints Satisfaction (CACS). That approach combines multi-agent architecture with constraint solvers in the unified framework which expresses major features of Swarm Intelligence approach and replaces traditional stochastic adaptation of the swarm of the autonomous agents by constraint-driven adaptation. We describe major theoretic, methodological and software engineering principles of composition of constraints and agents in the framework of one multi-agent system, as well as application of our approach for modelling of particular logistic problem. 12",
    "creator" : "Microsoft® Office Word 2007"
  }
}