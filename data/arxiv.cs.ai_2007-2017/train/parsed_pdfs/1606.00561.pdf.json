{
  "name" : "1606.00561.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : "Mining Software Components from Object-Oriented APIs",
    "authors" : [ "Anas Shatnawi", "Abdelhak Seriai", "Houari Sahraoui", "Zakarea Al-Shara" ],
    "emails" : [ "alshara@lirmm.fr", "sahraoui@iro.umontreal.ca" ],
    "sections" : [ {
      "heading" : null,
      "text" : "Keywords: Reuse· reusability· component· API· object-oriented· reengineering· mining· understandability· frequent usage pattern."
    }, {
      "heading" : "1 Introduction",
      "text" : "Nowadays, the development of large and complex software applications is based on reusing pre-existing functionalities instead of developing them from scratch [1, 2]. Application Programming Interfaces (APIs) are recognized as the most commonly used repositories supporting software reuse [1]. APIs provide a preimplemented, tested and high quality set of functionalities [2, 3]. Consequently, they increase software quality and reduce the effort spent on coding, testing and maintenance activities [2].\nIn the case of object-oriented APIs, e.g., Standard Template Libraries in C++ or Java SDK, the functionalities are encapsulated as object-oriented classes. It is well known that reusing and understanding large APIs such as Java SDK, which contains more than 7.000 classes, is not an easy task [4, 5]. Consequently, several approaches have been proposed, such as [6–8], in order to facilitate the understandability and the reusability of APIs by discovering frequent usage patterns of APIs. This is based on the API usage history of software applications (i.e. API clients). Despite the value of frequent usage patterns, these are not sufficient to provide a high degree of API reusability and understandability. These are used as guides for reusing API classes and are not themselves reusable entities [9].\nOtherwise, software components are admitted to be more reusable and understandable entities than Object-Oriented (OO) ones [10]. This is because components are considered coarse-grained software entities, while OO classes are considered fine-grained ones. In addition, components define their required and provided interfaces. This means that the component dependencies are more understandable compared to the dependencies among objects. Consequently many approaches have been proposed to identify components from OO software applications such as [11, 12]. Nevertheless, no approach has been proposed to identify components from object-oriented APIs. Thus, in this paper, we propose an approach to mine components from object-oriented APIs. This does not only improve the reusability of APIs themselves, but also supporting component-based ar X iv :1\n60 6.\n00 56\n1v 1\n[ cs\n.S E\n] 2\nJ un\n2 01\n6\nreuse techniques by providing component based APIs. The approach exploits specificities of API entities. We statically analyze the source code of both APIs and their software clients to identify groups of API classes that are able to form OO components. This is based on two criteria. The first one is the probability of classes to be reused together by API clients. The second one is related to the structural and behavioral dependencies among classes and thus their ability to form a quality-centric component. In order to validate the proposed approach, we experimented on a set of 100 Java applications that use three Android APIs. The evaluation shows that structuring object-oriented APIs as component-based ones improves the reusability and the understandability of these APIs.\nThe rest of this paper is organized as follows. The subsequent section, Section 2 puts in context the problem of component identification from APIs. It presents the goal of the proposed approach, the background needed to understand our proposal and the problem analysis. Section 3 presents the foundation of our approach. Then, in Section 4 we present the identification of component interface classes. Section 5 presents how APIs are organized as component-based libraries. Experimentation and results of our approach are discussed through three APIs case studies in section 6. Next, the related work is discussed in Section 7. Finally, concluding remarks and future directions are presented in section 8."
    }, {
      "heading" : "2 Putting Problem in Context",
      "text" : ""
    }, {
      "heading" : "2.1 The Goal: Object to Component",
      "text" : "Our goal is to reengineer object-oriented APIs into component based ones. Based on [10, 13, 14], we consider a component as, “a software element that (a) can be composed without modification, (b) can be distributed in an autonomous way, (c) encapsulates the implementation of one or many closed functionalities, and (d) adheres to a component model”. According to this definition, we derive three quality characteristics that should be satisfied by a component; Composability, Autonomy and Specificity. Composability of a component refers to its ability to be composed through its interfaces without any modification. Autonomy refers to that a component can be reused in an autonomous way because it encapsulates the strongly dependent functionalities. Specificity refers to that a component implements a limited number of closed functionalities, which makes it a coarsegrained entity. Based on that, we consider as OO components those implemented as a group of OO classes.\nIn the context of our approach, the identification3 of a component means identifying OO classes that can be considered as the implementation of this component. Thus we consider that a component can be identified from a cluster of classes that may belong to different packages. Classes that have direct links (e.g. method call, attribute access) with classes implementing other components compose the interfaces of the component. Provided Interfaces of a component are defined as a group of methods implemented by classes composing these interfaces. Required interfaces of a component are defined as a group of methods invoked by the component and provided by other components. Figure 1 shows our object to component mapping model.\n3 Component identification is the first step of the migration process of object-tocomponent\n2.2 Background Identifying Components in Software Applications : Synthesis of Previous Work We have proposed in our previous works related to ROMANTIC4 approach [11, 15] a set of metrics to measure the ability of a group of classes in a software application to form a component. These metrics are defined based on the main characteristics of a component (i.e. Composability, Autonomy and Specificity). Similar to the software quality model ISO 9126 [16], we proposed to refine the characteristics of the component into sub-characteristics. Next, the sub-characteristics are refined into the properties of the component (e.g. number of required interfaces). Then, these properties are mapped to the properties of the group of classes from which the component is identified (e.g. group of classes coupling). Lastly, these properties are refined into OO metrics (e.g. coupling metric). This quality refinement model is shown in Figure 2. According to this model, a quality function has been proposed to measure the component quality. This quality function is used as a similarity metric for a hierarchal clustering algorithm [11, 15] as well as in search-based algorithms [17] to partition the OO classes into groups; where each group represents a component.\nFrequent Usage Patterns In the domain of data mining, a Frequent Usage Pattern (FUP) is defined as a set of items, subsequences or substructures that 4 ROMANTIC: Re-engineering of Object-oriented systeMs by Architecture extractioN and migraTIon to Component based ones\nare frequently used together by customers [18]. It provides information that helps decision makers (e.g. customer shopping behavior) by mining associations and correlations among a set of items in a huge data set. An example of FUP mining is a market basket analysis. In this example, the customer buying habits are analyzed to identify items that are frequently bought together in the customer shopping baskets, for instance, milk and bread form a FUP when they bought frequently together. The identification of FUP is based on Support quality metric that is used to measure the interestingness of a set of items. Support refers to the probability of finding a set of items in the transactions. For example, the value of 0.30 Support, means that 30% of all the transactions contain the target item set. The following equation refers to Support :\nS(E1, E2) = P (E1 ∪ E2) (1)\nWhere E1, E2 are sets of items; S refers to Support ; P refers to the probability."
    }, {
      "heading" : "2.3 Component and Frequent Usage Pattern",
      "text" : "FUPs are observations made based on the analysis of previous uses of APIs. They aim to help users of APIs by identifying recurring patterns, composed of classes frequently used together.\nFUPs and components serve the reuse needs in two different ways. Components are entities that can be directly reused and integrated into software applications, while FUPs are guides for reuse and not entities for reuse. In addition, components and FUPs are structurally different. Related to Specificity characteristic, classes composing a component serve a coherent body of services, while classes composing a FUP may be related to different services. Concerning Autonomy characteristic, dependencies of component’s classes are mostly internal, which forms an autonomous entity. FUP’s classes can be very dependent on other classes that are not directly used by clients of APIs. Concerning Composability characteristic, a component is structured and reused via interfaces, while FUPs are not directly reusable entities."
    }, {
      "heading" : "3 The Proposed Solution Foundations",
      "text" : "Based on the observations made in the previous sections, we consider that: – In object-oriented APIs, a component is identified as a group of classes. – To reengineer the entire object-oriented API into component-based one, each\nclass of the API is mapped to be part of at least one component. Each class is mapped either as a class of the component interfaces or as a part of the internal classes of the component. – Classes directly accessed by the software clients represent the end-users’ services. These classes compose FUPs. These ones are the candidate to form the provided interface of the components mined from the API. – As a FUP can be composed of classes providing multiple services, its classes can be mapped to be a part of different component interfaces. – A class of an API can be a part of several FUPs and can participate to implement multiple services. Consequently a class can be mapped into multiple component interfaces.\nFigure 3 shows our mapping model which maps class-to-component through FUPs. According to this mapping model, we propose the following process to mine components from APIs (c.f. Figure 4):"
    }, {
      "heading" : "4 Identification of component interfaces",
      "text" : "The identification of classes forming an API component is driven by the identification of classes composing the provided interfaces of this component. Classes composing these interfaces are those directly accessed by the clients of the API. Classes belonging to the same interface are those frequently used together. Therefore they are identified from frequent usage patterns. Classes of the API composing frequent usage patterns are identified based on the analysis of how API classes were used by the API clients. API classes used together constitute transactions of usage."
    }, {
      "heading" : "4.1 Extracting Transactions of Usage",
      "text" : "A transaction of usage is a set of interactions between an API and a client of this API. These interactions consist of calling methods, accessing attributes, inheritance or creating an instance object based on a class of the API. They are identified by statically analyzing the source code of the API and its clients. Transactions are different depending on the choice of API clients. Therefore the choice of the API clients directly affects the type of the resulting patterns. A client can be considered either a class, a group of classes or the whole software application. We define a client as group of classes forming a functional component in software applications. The idea behind that is to mine patterns related to functionalities composing the applications. Thus, a transaction is a set of API classes used by classes composing a client component (c.f. Figure 7). To this end, we use ROMANTIC approach to identify client components composing software applications. Algorithm 1 shows the process of transaction identification. It starts by partitioning each software client into components. Then, for each component, it identifies API classes that are reused by the component classes."
    }, {
      "heading" : "4.2 Mining Frequent Usage Patterns of Classes",
      "text" : "In the previous step, the interactions of all client components with the API are identified as transactions. Based on these transactions, we identify FUPs. A FUP is a set of API classes that are frequently used together by client components. It\nallows the detection of hidden correlations of usage among classes of the API. We mine FUPs based on the FPGrowth algorithm [18]. In this algorithm, a pattern is considered as frequent if it reaches a predefined threshold of interestingness metric. This metric is known as Support. The Support refers to the probability of finding a set of API classes in the transactions. The use of the Support metric separates the classes of API into two groups according to whether they belong to at least one FUP or not. Classes that do not belong to any of the identified FUPs are the less commonly used classes. As each API class that belongs to a transaction is a class that has been accessed by the clients of the API, therefore it must be a part of the classes composing the interfaces of at least one component. We propose assigning each class of the less commonly used classes to the pattern holding the maximum Support value when they are merged together."
    }, {
      "heading" : "4.3 Identifying Classes Composing Component Interfaces from Frequent Usage Patterns",
      "text" : "We identify classes composing component interfaces from those composing FUPs. Each FUP is partitioned into a set of groups, where each group represents a component interface. Classes are grouped together according to three heuristics that measure the probability of a set of classes to be a part of the same interface. The first is the frequency of simultaneous use of these classes by the same client. The second is the cohesion of these classes. This measures the strength of sharing data (e.g. attributes) between these classes. The third heuristic is the lexical similarity between these classes based on the textual names of the classes, their methods as well as their attributes. Based on the above heuristics, we propose a fitness function, given below, measuring the ability of a group of classes to form a component interface. We use LCC metric [19] to measure the cohesion of a set of classes, Conceptual Coupling metric [20] to measure classes’ lexical similarity and Support metric to measure the association frequency of a set of classes. The partition of each pattern into groups of classes is based on a hierarchical clustering algorithm which uses this function as a function of similarity.\nI(E) = 1∑ i λi · (λ1 · LCC(E) + λ2 · CC(E) + λ3 · S(E)) (2)\nWhere E is a set of OO classes; LCC(E) is the Cohesion of E ; CC(E) is Conceptual Coupling of E ; S(E) is the Support of E ; and λ1, λ2, λ3 are weight values, situated in [0-1]. These are used by the API expert to weight each characteristic as needed.\nInput: Source Code of a Set of Software Clients(clients), API Source Code(api) Output: A Set of Transactions(trans) for each c in clients do\ncomponents.add(ROMANTIC(c)); end for each com in components do\ntransaction = ∅; for each class in com do\ntransaction.add(class.getUsedClasses(api)); end trans.add(transaction);\nend return trans\nAlgorithm 1: Identifying Transactions"
    }, {
      "heading" : "5 API as Library of Components",
      "text" : ""
    }, {
      "heading" : "5.1 Identifying Classes Composing Components",
      "text" : "As we mentioned before, the component identification process is driven by the identification of its provided interfaces. This means that API classes forming a component are identified in relation to their direct or indirect structural and behavioral dependencies with the classes forming provided interfaces of the component. The selection of a class of the API to be a part of the component classes is based on the measurement of the quality of this component, when this is included. The identification of these classes is done gradually. In other words, we start to form the group of classes composing the interface ones, and then we add other classes to form a component based on the component quality measurement model. Classes having either direct or indirect links with the interface ones represent the candidate classes to be added to them. At each step, we add a new API class. This is selected based on the quality value of the component, formed by adding this class to the ones already selected. The class that maximizes the quality value is selected in this step. This is done until all API classes are investigated. Each time we add a class, we evaluate the component quality. Then, we select the peak quality value to decide which classes form the component. This means that we exclude classes added after the peak value. As an example, Class7 and Class8 in Figure 8 are excluded from the resulting component because they were added after the quality value reached the peak."
    }, {
      "heading" : "5.2 Organizing API as Layers of Components",
      "text" : "As we previously mentioned, the API is structured in N layers of components. To identify components of layer L, we rely on components of layer L − 1. We proceed similarly to the identification of the components of the first layer. We use required interfaces of the components already identified in layer L−1 to identify the interfaces provided by components in layer L. This continues until reaching a layer where its components either do not require any interface or they require ones already identified. Each interface defined as a required for a component of layer L − 1 is considered as a provided by a component of layer L except ones\nprovided by the already identified components. All interfaces provided in layer L are grouped into clusters to identify those provided by the same component of layer L. The clusters are obtained based on a hierarchical clustering algorithm. This algorithm uses a similarity function that measures: (i) the cohesion of classes composing a group of interfaces, (ii) the lexical similarity of these classes and (iii) the frequency of their simultaneous use. Clusters that maximize this function are selected. The interfaces composing each cluster are considered as provided by the same component. Analogously to the identification of the components of the first layer, the other classes composing each component are identified starting from classes composed of its already identified provided interfaces."
    }, {
      "heading" : "6 Experimentation and Results",
      "text" : ""
    }, {
      "heading" : "6.1 Experimental Design",
      "text" : "Data Collection We collected a set of 100 Android− Java applications from open-source repositories5. The average size of these applications in terms of number of classes is 90. The application names are listed in the Appendix. These applications are developed based on classes of the android APIs6. In our experimentation, we focus on three of these APIs. The first is the android.view composed of 491 classes. This API provides services related to the definition and management of the user interfaces in android applications. The second API is the android.app composed of 361 classes. This API provides services related to creating and managing android applications. The last API is the android composed of 5790 classes. This API includes all of the android services.\nResearch Questions and Evaluation Method The approach is evaluated on the collected software applications and APIs. We identify client components independently from each software application. Each component in software is considered as a client of the APIs to form a transaction of classes. Then, we mine Frequent Usage Pattern (FUP) from the identified transactions. Next, from classes composing each FUP, we identify classes composing a set of component interfaces. Then, we identify all component classes starting from ones composing their interfaces. Lastly, the final results obtained by our approach are presented.\nWe evaluate the obtained components by answering the three following research questions.\n– RQ1: Does the Approach Reduce the Understandability Efforts? This research question aims at measuring the saved efforts in the API understandability that are brought by migrating object-oriented APIs into component-based ones. – RQ2: Are the Mined Components Reusable? As our approach aims at mining reusable components, we evaluate the reusability of the resulted component. This is based on measuring how much related classes are grouped into the same components. – RQ3: Is the Identification of Provided Interfaces Based on FUPs Useful? The proposed approach identifies the provided interfaces of the components based on how clients have used the API classes (i.e. FUPs). Thus, this research question evaluates how much benefit the use of FUPs brings by comparing components identified by our approach with ones identified without taking FUPs into account.\n5 sourceforge.net, code.google.com, github.com, gitorious.org, and aopensource.com 6 We select android API level 14 as a reference\nTo answer the second question that related to the reusability, we use theK−fold cross validation method [18]. The idea is to partition the client applications into K parts. Then, the identification process is applied K times by considering, each time, K − 1 different parts for the identification process and by using the remaining part to measure the reusability. Next, we take the average of all K trail results. In our experiment, we set K to 2, 4, and 8."
    }, {
      "heading" : "6.2 Results",
      "text" : "Intermediate Results and Identified Components The average number of client components identified from each software is 4.5 and the average number of classes composing each component is 18.73. Table 1 shows the average number of transactions per software application (ANTIC), the average of transaction size in terms of classes (ATS), and the percentage of components that have used the API (PCU). The last column of this table shows an example of transactions.\nThe results show that android, view, and app APIs have been used respectively by only 54%, 29% and 32% of client components. In addition, we note that each client component has used the API classes intensively compared to the number of classes composing it. For example, the transaction size is 17.91 classes for the view API, where the average number of classes per component is 18.73. This is due to the fact that classes that serve the same services in software applications, and consequently depend on the same API classes, are grouped together in the same client component.\nThe identification of FUPs relies on the value of the Support threshold. The number and the size of the mined FUPs depend on this value. For all application domains where FUPs are used (e.g. data mining), this value is determined by domain experts. In our approach, to help API experts to determine this value, we assign the Support threshold values situated in [30%-100%]. We give for each Support value the number of the mined FUPs and the average size of the mined FUPs for each API (c.f. Figure 9). The results show that the number of mined\nFUPs is directly proportional to the Support value, while the average size of the mined FUPs is inversely proportional.\nBased on their knowledge of the API, API experts can select the value of the Support. For example, if the known average number of API classes used together to implement an application service is N , then the experts can choose the Support value corresponding to FUPs having N as the average size. Based on the obtained results and our knowledge on android APIs7, we select the Support threshold values as 60%, 45%, and 45% respectively for the android, the view and the app APIs.\nTable 2 shows examples of the mined FUPs. For instance, the FUP related to view API contains 10 classes. The analysis of this FUP shows that it corresponds to three services: animation (Animation and AnimationUtils classes), view (Surface, SurfaceView, SurfaceHolder, MeasureSpec, ViewManager and MenuInflater classes), and persistence of the view states (AbsSavedState and AccessibilityRecord classes). These services are dependent. Animation service needs the view service and the data of animation view needs to be persistent.\nIn Table 3, we present the results of interface identification in terms of the average number of component interfaces identified from a FUP (ANCIP ), the average number of classes composing component interfaces (ACIS) and the total number of component interfaces in the API (TNCI). The last column of this table presents examples of component interfaces identified from the FUPs given in Table 2. For instance, the analysis of classes composing the component interfaces identified from the FUP related to the view API shows that they are related to surface view services.\nTable 4 presents the results related to the mined components composing the first API layer. For each API, we give the number of the mined components (NMC) and the average number of classes composing the mined components (ACS). The last column of this table shows examples of classes composing components identified started from classes composing provided component interfaces presented in Table 3. The results show that the services offered by classes of android, view and app APIs are identified as 232, 19 and 10 components respectively. This means that developers only require to interact with these components to get the needed services from these APIs.\n7 The authors of this paper are experts on the android APIs\nTable 5 shows the final results obtained by our approach. For each API, we firstly give the size of the API in terms of the number of OO classes composing the API and the number of the identified components. Secondly, we present the total number of used entities (classes and respectively components) by the software clients. The results show that classes participating in providing related services are grouped into one component. Furthermore, the total number of cohesive and decoupled services is identified for each API. For instance, android API consists of 497 components (coarse-grained services), while view and app APIs contain 43 and 55 components respectively.\nAnswering Research Questions RQ1: Does the Approach Reduce the Understandability Efforts? The efforts spent to understand such an API is directly proportional to the complexity of the API. This complexity is related to the number of API elements and the individual element’s complexity. On the one hand, the reduction in the number of elements composing the API is obtained by grouping classes collaborating to provide one coarse-grained service into one component. The results show that the average number of identified components for the studied APIs is 11% ( ( (497/5790) + (43/491) + (55/361) ) /3 ) of the number of classes composing the APIs. This means that the API size is significantly reduced by mapping class-to-component. On the other hand, the reduction in the individual element complexity is done by migrating object-oriented APIs into component-based ones. Meaning, components define their required and provided interfaces, while OO classes at least do not define required interfaces (e.g. a class may call a large number of methods belonging to a set of classes without an explicit specification of these dependencies). The results show that the average number of used components for the APIs is 4% ( ( (54/491) + (17/42) + (5/45) ) /3 ) of the number of used classes. This means that the effort spent to understand API entities is significantly reduced in the case of software applications developed based on API components compared to the development based on API classes. Note that, developers only need to understand the component interfaces, but not the whole component implementation.\nRQ2: Are the Mined Components Reusable? We consider that the reusability of a software component is related to the number of used classes among all ones composing the software component. Thus, we calculate the reusability of the component based on the ratio between the numbers of used classes composing the component to the total number of classes composing the component. To\nprove that our resulted component-based APIs could be generalized to another independent set of client applications, we rely on K − fold cross validation method. Table 6 presents the results of this measurement. These results show that the reusability results is distributed in a disparate manner. The reason behind this disputation is the size of the train and test data as well as the size of the API. For instance, the average reusability for the app API is 37% when the number of train clients is 50 application clients, while it is 51% when the number of train clients is 88 application clients. Thus, the reusability of the components increases when the number of train client applications increases. The results show that our approach identifies reusable components, where the average reusability for all APIs is 47%.\nRQ3: Is the Identification of Provided Interfaces Based on FUPs Useful? To prove the utility of using FUPs during the identification process, we compare the components mined based on our approach with ones mined using ROMANTIC approach, which does not take FUPs into consideration. This is based on the density of using the component provided interfaces by application clients. The density refers to the ratio between the number of used interface classes to the total number of interface classes for each component. Table 7 shows the average density for the two identification approaches. These results show that our approach outperforms ROMANTIC approach. For instance, the application clients need to reuse a larger number of components of ones mined based on ROMANTIC with less density of provided interface classes compared to component mined based on our approach. For instance, the average usage density of classes composing provided interfaces of ROMANTIC components is 21%, while it is 61% for components mined by our approach for all APIs."
    }, {
      "heading" : "7 Related work",
      "text" : "To the best of our knowledge, no approach has been proposed to identify components from object-oriented APIs. However, we present two research areas that are related to our approach. The First one aims at identifying components from OO software applications. The second area aims at mining frequent patterns of API usage.\nConcerning the identification of software components from the source code of software applications, numerous approaches have been presented. Garcia et al. provide a survey of some of these approaches [21]. In [22], Detten et al. presented the Archimetrix approach, which aims at mining the architecture of the legacy software. It relies on a clustering algorithm to partition the system classes into components. This algorithm depends on name resemblance, coupling and cohesion metrics as a fitness function. In [11], Kebir et al. presented\nan approach to extract components from a single OO software system. Classes composing the extracted components form a partition. Mined components are considered as a part of the component-based architecture of the corresponding software. In [12] Allier et al. depended on dynamic dependencies between classes to recover components. Based on the use case diagram, the execution trace scenarios are identified. Classes that frequently occur in the execution traces are grouped into a single component. Cohesion and coupling metrics are also taken into account during the identification process. Weinreich et al. proposed, in [23], an approach to recover multi-view architecture model of software applications implemented based on service oriented architecture. The authors classified software artifacts based on the information from source code, configuration files and binary codes. In [24], an approach has been presented to mine reusable components from a set of similar software applications. A component is considered as more reusable, when it is reused many times by the software applications. The authors firstly identified components independently from each software application. Then, based on the lexical similarity between the classes composing these components, they identified reusable ones.\nIn the context of API mining, many approaches have been proposed to mine frequent usage patterns of APIs based on the usage history of APIs. Robillard et al. provide a survey of these approaches [25]. These approaches can be mainly classified based on four main criteria. The first one is related to the goal, which can be either giving examples and recommendations of how to use API entities (e.g. [7, 5]), supporting the documentation of APIs (e.g. [7, 6]), or improving the bug detection task (e.g. [8]). The second criterion is related to the pattern ordering, where some approaches mine ordered patterns (e.g. [7, 6]), while other ones mine unordered patterns (e.g. [8, 26]). The third one concerns the granularity of the elements composing a pattern. For examples, in [7, 6]), the approaches mine patterns composed of methods, and the approach in [26] mines patterns composed of classes. The fourth one related to the technique that is used to identify the patterns. The used technique can be association rules mining (e.g. [26]), clustering algorithms (e.g. [6]) or a heuristic defined by the authors such as [7, 8]. Some approaches combines many techniques, e.g., Unddin et al. used Principle Component Analysis with Clustering algorithm [5], and Buse and Weimer combined the clustering algorithm with their own proposed heuristic [27]."
    }, {
      "heading" : "8 Conclusion and Future Work",
      "text" : "In this paper, we presented an approach aimed at mining software components from object-oriented APIs. It is based on static analysis of the source code of both the APIs and their software clients. The mining process is used-driven. This means that components are identified starting from classes composing their interfaces. Classes composing the provided interface of the first layer components compose FUPs. We experimented our approach by applying it on a set of open source Java applications as clients for three android APIs. The results show that our approach improves the reusability of the API.\nAs our approach is used-driven, the results depend on the quality and the number of usages of the API. This means that identified FUPs rely on the considered software clients. Therefore the identification of provided interfaces and then their corresponding components depends on API clients. Consequently it is essential to select clients having the largest number of usages of the API.\nOur future work will focus on migrating the identified OO components into existing component models such as OSGI model, and developing a visual environment that allows domain experts to interact with the approach at each step of the identification process, thus modify the obtained results as needed.\nAppendix: These are the names of the applications that considered as clients of the APIs.\nADW Launcher, APV, ARMarker, ARviewer, Alerts, Alogcat, AndorsTrail, AndroMaze, AndroidomaticKeyer, AppsOrganizer, AripucaTracker, AsciiCam, Asqare, AugmentRealityFW, AussieWeatherRadar, AutoAnswer, Avare, BansheeRemote, BiSMoClient, BigPlanetTracks, BinauralBeats, Blokish, BostonBusMap, CalendarPicker, CH-EtherDroid, CVox, CamTimer, ChanImageBrowser, CidrCalculator, ColorPicker, CompareMyDinner, ConnectBot, CorporateAddressBook, Countdown, CountdownTimer, CrossWord, CustomMaps, DIYgenomics, Dazzle, Dialer2, DiskUsage, DistLibrary, Dolphin, Doom, DriSMo, DroidLife, DroidStack, Droidar, ExchangeOWA, FeedGoal, FileManager, FloatingImage, Gcstar, GeekList, GetARobotVPNFrontend, GlTron, GoHome, GoogleMapsSupport, GraphView, HeartSong, Hermit, Historify, Holoken, HotDeath, Introspy, LegoMindstroms, Lexic, LibVoyager, LiveMusic, LocaleBridge, MAME4droid, Look, LookSocial, Macnos, Mandelbrot, Mathdoku, MediaPlayer, Ministocks, MotionDetection, NGNStack, NewspaperPuzzles, OnMyWay, OpenIntents, OpenMap, OpenSudoku, Pedometer, Phoenix, PhotSpot, Prey, PubkeyGenerator, PwdHash, QueueMan, RateBeerMobile, AlienbloodBath, SuperGenPass, SwallowCatcher, Swiftp, Tumblife, VectorPinball, WordSearch."
    } ],
    "references" : [ {
      "title" : "Software reuse research: status and future",
      "author" : [ "W. Frakes", "K. Kang" ],
      "venue" : "IEEE Transactions on Software Engineering. 31(7), 529–536",
      "citeRegEx" : "1",
      "shortCiteRegEx" : null,
      "year" : 2005
    }, {
      "title" : "Useful, but usable? factors affecting the usability of apis",
      "author" : [ "M. Zibran", "F. Eishita", "C. Roy" ],
      "venue" : "18th Working Conf. on Reverse Engineering (WCRE), pp. 151–155.",
      "citeRegEx" : "2",
      "shortCiteRegEx" : null,
      "year" : 2011
    }, {
      "title" : "What should developers be aware of? an empirical study on the directives of api documentation",
      "author" : [ "M. Monperrus", "M. Eichberg", "E. Tekes", "M. Mezini" ],
      "venue" : "Empirical Software Engineering. 17(6), 703–737",
      "citeRegEx" : "3",
      "shortCiteRegEx" : null,
      "year" : 2012
    }, {
      "title" : "Usage patterns of the java standard api",
      "author" : [ "H. Ma", "R. Amor", "E. Tempero" ],
      "venue" : "13th Asia Pacific Software Engineering Conf. (APSEC), pp. 342–352.",
      "citeRegEx" : "4",
      "shortCiteRegEx" : null,
      "year" : 2006
    }, {
      "title" : "Temporal analysis of api usage concepts",
      "author" : [ "G. Uddin", "B. Dagenais", "M.P. Robillard" ],
      "venue" : "Proc. of the 2012 Inter. Conf. on Software Engineering (ICSE), pp. 804–814. IEEE Press, Piscataway, NJ, USA",
      "citeRegEx" : "5",
      "shortCiteRegEx" : null,
      "year" : 2012
    }, {
      "title" : "Mining succinct and high-coverage api usage patterns from source code",
      "author" : [ "J. Wang", "Y. Dang", "H. Zhang", "K. Chen", "T. Xie", "D. Zhang" ],
      "venue" : "Proc. of the 10th Working Conf. on Mining Software Repositories (MSR), pp. 319–328. IEEE Press, Piscataway, NJ, USA",
      "citeRegEx" : "6",
      "shortCiteRegEx" : null,
      "year" : 2013
    }, {
      "title" : "Documenting apis with examples: Lessons learned with the apiminer platform",
      "author" : [ "J. Montandon", "H. Borges", "D. Felix", "M. Valente" ],
      "venue" : "20th Working Conf. on Reverse Engineering (WCRE), pp. 401–408.",
      "citeRegEx" : "7",
      "shortCiteRegEx" : null,
      "year" : 2013
    }, {
      "title" : "Detecting missing method calls in objectoriented software",
      "author" : [ "M. Monperrus", "M. Bruch", "M. Mezini" ],
      "venue" : "European Conf. on Object-Oriented Programming ECOOP. LNCS, vol. 6183, pp. 2–25. Springer, Heidelberg",
      "citeRegEx" : "8",
      "shortCiteRegEx" : null,
      "year" : 2010
    }, {
      "title" : "Patterns of knowledge in api reference documentation",
      "author" : [ "W. Maalej", "M. Robillard" ],
      "venue" : "IEEE Transactions on Software Engineering. 39(9), 1264–1282",
      "citeRegEx" : "9",
      "shortCiteRegEx" : null,
      "year" : 2013
    }, {
      "title" : "Component Software: Beyond Object-Oriented Programming",
      "author" : [ "C. Szyperski" ],
      "venue" : "Pearson Education",
      "citeRegEx" : "10",
      "shortCiteRegEx" : null,
      "year" : 2002
    }, {
      "title" : "Quality-centric approach for software component identification from object-oriented code",
      "author" : [ "S. Kebir", "A.D. Seriai", "S. Chardigny", "A. Chaoui" ],
      "venue" : "Joint Working IEEE/IFIP Conf. and European Conf. on Software Architecture (WICSA)/(ECSA), pp. 181–190.",
      "citeRegEx" : "11",
      "shortCiteRegEx" : null,
      "year" : 2012
    }, {
      "title" : "From object-oriented applications to component-oriented applications via component-oriented architecture",
      "author" : [ "S. Allier", "S. Sadou", "H. Sahraoui", "R. Fleurquin" ],
      "venue" : "9th Working IEEE/IFIP Conf. on Software Architecture (WICSA), pp. 214–223.",
      "citeRegEx" : "12",
      "shortCiteRegEx" : null,
      "year" : 2011
    }, {
      "title" : "Composition Environments for Deployable Software Components",
      "author" : [ "C. Lüer", "A. Van Der Hoek" ],
      "venue" : "Citeseer",
      "citeRegEx" : "13",
      "shortCiteRegEx" : null,
      "year" : 2002
    }, {
      "title" : "Component-Based Software Engineering: Putting the Pieces Together",
      "author" : [ "G.T. Heineman", "W.T. Councill" ],
      "venue" : "Addison-Wesley Reading",
      "citeRegEx" : "14",
      "shortCiteRegEx" : null,
      "year" : 2001
    }, {
      "title" : "Extraction of componentbased architecture from object-oriented systems",
      "author" : [ "S. Chardigny", "A. Seriai", "M. Oussalah", "D. Tamzalit" ],
      "venue" : "7th Working IEEE/IFIP Conf. on Software Architecture (WICSA), pp. 285–288.",
      "citeRegEx" : "15",
      "shortCiteRegEx" : null,
      "year" : 2008
    }, {
      "title" : "Software Engineering – Product Quality – Part 1: Quality Model",
      "author" : [ "ISO" ],
      "venue" : "Technical Report ISO/IEC 9126-1, International Organization for Standardization",
      "citeRegEx" : "16",
      "shortCiteRegEx" : null,
      "year" : 2001
    }, {
      "title" : "Search-based extraction of component-based architecture from object-oriented systems",
      "author" : [ "S. Chardigny", "A.D. Seriai", "M. Oussalah", "D. Tamzalit" ],
      "venue" : "2nd European Conf. in Software Architecture (ECSA). LNCS, vol. 5292, pp. 322–325. Springer, Heidelberg",
      "citeRegEx" : "17",
      "shortCiteRegEx" : null,
      "year" : 2008
    }, {
      "title" : "Data mining: concepts and techniques",
      "author" : [ "J. Han", "M. Kamber", "J. Pei" ],
      "venue" : "Morgan kaufmann",
      "citeRegEx" : "18",
      "shortCiteRegEx" : null,
      "year" : 2006
    }, {
      "title" : "Cohesion and reuse in an object-oriented system",
      "author" : [ "J.M. Bieman", "B.K. Kang" ],
      "venue" : "Proc. of the 1995 Symposium on Software Reusability (SSR), pp. 259–262. ACM, New York, NY, USA",
      "citeRegEx" : "19",
      "shortCiteRegEx" : null,
      "year" : 1995
    }, {
      "title" : "The conceptual coupling metrics for object-oriented systems",
      "author" : [ "D. Poshyvanyk", "A. Marcus" ],
      "venue" : "22nd IEEE Inter. Conf. on Software Maintenance (ICSM), pp. 469–478.",
      "citeRegEx" : "20",
      "shortCiteRegEx" : null,
      "year" : 2006
    }, {
      "title" : "A comparative analysis of software architecture recovery techniques",
      "author" : [ "J. Garcia", "I. Ivkovic", "N. Medvidovic" ],
      "venue" : "IEEE/ACM 28th Inter. Conf. on Automated Software Engineering (ASE), pp. 486–496.",
      "citeRegEx" : "21",
      "shortCiteRegEx" : null,
      "year" : 2013
    }, {
      "title" : "Reengineering component-based software systems with archimetrix",
      "author" : [ "M. Von Detten", "M.C. Platenius", "S. Becker" ],
      "venue" : "Software & Systems Modeling 13(4), 1239–1268",
      "citeRegEx" : "22",
      "shortCiteRegEx" : null,
      "year" : 2014
    }, {
      "title" : "Extracting and facilitating architecture in service-oriented software systems",
      "author" : [ "R. Weinreich", "C. Miesbauer", "G. Buchgeher", "T. Kriechbaum" ],
      "venue" : "Joint Working IEEE/IFIP Conf. and European Conf. on Software Architecture (WICSA)/(ECSA), pp. 81–90.",
      "citeRegEx" : "23",
      "shortCiteRegEx" : null,
      "year" : 2012
    }, {
      "title" : "Mining reusable software components from objectoriented source code of a set of similar software",
      "author" : [ "A. Shatnawi", "A.D. Seriai" ],
      "venue" : "IEEE 14th Inter. Conf. on Information Reuse and Integration (IRI), pp. 193–200.",
      "citeRegEx" : "24",
      "shortCiteRegEx" : null,
      "year" : 2013
    }, {
      "title" : "Automated api property inference techniques",
      "author" : [ "M. Robillard", "E. Bodden", "D. Kawrykow", "M. Mezini", "T. Ratchford" ],
      "venue" : "IEEE Transactions on Software Engineering. 39(5), 613–637",
      "citeRegEx" : "25",
      "shortCiteRegEx" : null,
      "year" : 2013
    }, {
      "title" : "Fruit: Ide support for framework understanding",
      "author" : [ "M. Bruch", "T. Schäfer", "M. Mezini" ],
      "venue" : "Proc. of the 2006 OOPSLA Workshop on Eclipse Technology eXchange, pp. 55– 59. ACM, New York, NY, USA",
      "citeRegEx" : "26",
      "shortCiteRegEx" : null,
      "year" : 2006
    }, {
      "title" : "Synthesizing api usage examples",
      "author" : [ "R.P.L. Buse", "W. Weimer" ],
      "venue" : "Proc. of the 2012 Inter. Conf. on Software Engineering (ICSE), pp. 782–792. IEEE Press, Piscataway, NJ, USA",
      "citeRegEx" : "27",
      "shortCiteRegEx" : null,
      "year" : 2012
    } ],
    "referenceMentions" : [ {
      "referenceID" : 0,
      "context" : "Nowadays, the development of large and complex software applications is based on reusing pre-existing functionalities instead of developing them from scratch [1, 2].",
      "startOffset" : 158,
      "endOffset" : 164
    }, {
      "referenceID" : 1,
      "context" : "Nowadays, the development of large and complex software applications is based on reusing pre-existing functionalities instead of developing them from scratch [1, 2].",
      "startOffset" : 158,
      "endOffset" : 164
    }, {
      "referenceID" : 0,
      "context" : "Application Programming Interfaces (APIs) are recognized as the most commonly used repositories supporting software reuse [1].",
      "startOffset" : 122,
      "endOffset" : 125
    }, {
      "referenceID" : 1,
      "context" : "APIs provide a preimplemented, tested and high quality set of functionalities [2, 3].",
      "startOffset" : 78,
      "endOffset" : 84
    }, {
      "referenceID" : 2,
      "context" : "APIs provide a preimplemented, tested and high quality set of functionalities [2, 3].",
      "startOffset" : 78,
      "endOffset" : 84
    }, {
      "referenceID" : 1,
      "context" : "Consequently, they increase software quality and reduce the effort spent on coding, testing and maintenance activities [2].",
      "startOffset" : 119,
      "endOffset" : 122
    }, {
      "referenceID" : 3,
      "context" : "000 classes, is not an easy task [4, 5].",
      "startOffset" : 33,
      "endOffset" : 39
    }, {
      "referenceID" : 4,
      "context" : "000 classes, is not an easy task [4, 5].",
      "startOffset" : 33,
      "endOffset" : 39
    }, {
      "referenceID" : 5,
      "context" : "Consequently, several approaches have been proposed, such as [6–8], in order to facilitate the understandability and the reusability of APIs by discovering frequent usage patterns of APIs.",
      "startOffset" : 61,
      "endOffset" : 66
    }, {
      "referenceID" : 6,
      "context" : "Consequently, several approaches have been proposed, such as [6–8], in order to facilitate the understandability and the reusability of APIs by discovering frequent usage patterns of APIs.",
      "startOffset" : 61,
      "endOffset" : 66
    }, {
      "referenceID" : 7,
      "context" : "Consequently, several approaches have been proposed, such as [6–8], in order to facilitate the understandability and the reusability of APIs by discovering frequent usage patterns of APIs.",
      "startOffset" : 61,
      "endOffset" : 66
    }, {
      "referenceID" : 8,
      "context" : "These are used as guides for reusing API classes and are not themselves reusable entities [9].",
      "startOffset" : 90,
      "endOffset" : 93
    }, {
      "referenceID" : 9,
      "context" : "Otherwise, software components are admitted to be more reusable and understandable entities than Object-Oriented (OO) ones [10].",
      "startOffset" : 123,
      "endOffset" : 127
    }, {
      "referenceID" : 10,
      "context" : "Consequently many approaches have been proposed to identify components from OO software applications such as [11, 12].",
      "startOffset" : 109,
      "endOffset" : 117
    }, {
      "referenceID" : 11,
      "context" : "Consequently many approaches have been proposed to identify components from OO software applications such as [11, 12].",
      "startOffset" : 109,
      "endOffset" : 117
    }, {
      "referenceID" : 9,
      "context" : "Based on [10, 13, 14], we consider a component as, “a software element that (a) can be composed without modification, (b) can be distributed in an autonomous way, (c) encapsulates the implementation of one or many closed functionalities, and (d) adheres to a component model”.",
      "startOffset" : 9,
      "endOffset" : 21
    }, {
      "referenceID" : 12,
      "context" : "Based on [10, 13, 14], we consider a component as, “a software element that (a) can be composed without modification, (b) can be distributed in an autonomous way, (c) encapsulates the implementation of one or many closed functionalities, and (d) adheres to a component model”.",
      "startOffset" : 9,
      "endOffset" : 21
    }, {
      "referenceID" : 13,
      "context" : "Based on [10, 13, 14], we consider a component as, “a software element that (a) can be composed without modification, (b) can be distributed in an autonomous way, (c) encapsulates the implementation of one or many closed functionalities, and (d) adheres to a component model”.",
      "startOffset" : 9,
      "endOffset" : 21
    }, {
      "referenceID" : 10,
      "context" : "Identifying Components in Software Applications : Synthesis of Previous Work We have proposed in our previous works related to ROMANTIC4 approach [11, 15] a set of metrics to measure the ability of a group of classes in a software application to form a component.",
      "startOffset" : 146,
      "endOffset" : 154
    }, {
      "referenceID" : 14,
      "context" : "Identifying Components in Software Applications : Synthesis of Previous Work We have proposed in our previous works related to ROMANTIC4 approach [11, 15] a set of metrics to measure the ability of a group of classes in a software application to form a component.",
      "startOffset" : 146,
      "endOffset" : 154
    }, {
      "referenceID" : 15,
      "context" : "Similar to the software quality model ISO 9126 [16], we proposed to refine the characteristics of the component into sub-characteristics.",
      "startOffset" : 47,
      "endOffset" : 51
    }, {
      "referenceID" : 10,
      "context" : "This quality function is used as a similarity metric for a hierarchal clustering algorithm [11, 15] as well as in search-based algorithms [17] to partition the OO classes into groups; where each group represents a component.",
      "startOffset" : 91,
      "endOffset" : 99
    }, {
      "referenceID" : 14,
      "context" : "This quality function is used as a similarity metric for a hierarchal clustering algorithm [11, 15] as well as in search-based algorithms [17] to partition the OO classes into groups; where each group represents a component.",
      "startOffset" : 91,
      "endOffset" : 99
    }, {
      "referenceID" : 16,
      "context" : "This quality function is used as a similarity metric for a hierarchal clustering algorithm [11, 15] as well as in search-based algorithms [17] to partition the OO classes into groups; where each group represents a component.",
      "startOffset" : 138,
      "endOffset" : 142
    }, {
      "referenceID" : 17,
      "context" : "are frequently used together by customers [18].",
      "startOffset" : 42,
      "endOffset" : 46
    }, {
      "referenceID" : 17,
      "context" : "We mine FUPs based on the FPGrowth algorithm [18].",
      "startOffset" : 45,
      "endOffset" : 49
    }, {
      "referenceID" : 18,
      "context" : "We use LCC metric [19] to measure the cohesion of a set of classes, Conceptual Coupling metric [20] to measure classes’ lexical similarity and Support metric to measure the association frequency of a set of classes.",
      "startOffset" : 18,
      "endOffset" : 22
    }, {
      "referenceID" : 19,
      "context" : "We use LCC metric [19] to measure the cohesion of a set of classes, Conceptual Coupling metric [20] to measure classes’ lexical similarity and Support metric to measure the association frequency of a set of classes.",
      "startOffset" : 95,
      "endOffset" : 99
    }, {
      "referenceID" : 0,
      "context" : "Where E is a set of OO classes; LCC(E) is the Cohesion of E ; CC(E) is Conceptual Coupling of E ; S(E) is the Support of E ; and λ1, λ2, λ3 are weight values, situated in [0-1].",
      "startOffset" : 171,
      "endOffset" : 176
    }, {
      "referenceID" : 17,
      "context" : "To answer the second question that related to the reusability, we use theK−fold cross validation method [18].",
      "startOffset" : 104,
      "endOffset" : 108
    }, {
      "referenceID" : 20,
      "context" : "provide a survey of some of these approaches [21].",
      "startOffset" : 45,
      "endOffset" : 49
    }, {
      "referenceID" : 21,
      "context" : "In [22], Detten et al.",
      "startOffset" : 3,
      "endOffset" : 7
    }, {
      "referenceID" : 10,
      "context" : "In [11], Kebir et al.",
      "startOffset" : 3,
      "endOffset" : 7
    }, {
      "referenceID" : 11,
      "context" : "In [12] Allier et al.",
      "startOffset" : 3,
      "endOffset" : 7
    }, {
      "referenceID" : 22,
      "context" : "proposed, in [23], an approach to recover multi-view architecture model of software applications implemented based on service oriented architecture.",
      "startOffset" : 13,
      "endOffset" : 17
    }, {
      "referenceID" : 23,
      "context" : "In [24], an approach has been presented to mine reusable components from a set of similar software applications.",
      "startOffset" : 3,
      "endOffset" : 7
    }, {
      "referenceID" : 24,
      "context" : "provide a survey of these approaches [25].",
      "startOffset" : 37,
      "endOffset" : 41
    }, {
      "referenceID" : 6,
      "context" : "[7, 5]), supporting the documentation of APIs (e.",
      "startOffset" : 0,
      "endOffset" : 6
    }, {
      "referenceID" : 4,
      "context" : "[7, 5]), supporting the documentation of APIs (e.",
      "startOffset" : 0,
      "endOffset" : 6
    }, {
      "referenceID" : 6,
      "context" : "[7, 6]), or improving the bug detection task (e.",
      "startOffset" : 0,
      "endOffset" : 6
    }, {
      "referenceID" : 5,
      "context" : "[7, 6]), or improving the bug detection task (e.",
      "startOffset" : 0,
      "endOffset" : 6
    }, {
      "referenceID" : 7,
      "context" : "[8]).",
      "startOffset" : 0,
      "endOffset" : 3
    }, {
      "referenceID" : 6,
      "context" : "[7, 6]), while other ones mine unordered patterns (e.",
      "startOffset" : 0,
      "endOffset" : 6
    }, {
      "referenceID" : 5,
      "context" : "[7, 6]), while other ones mine unordered patterns (e.",
      "startOffset" : 0,
      "endOffset" : 6
    }, {
      "referenceID" : 7,
      "context" : "[8, 26]).",
      "startOffset" : 0,
      "endOffset" : 7
    }, {
      "referenceID" : 25,
      "context" : "[8, 26]).",
      "startOffset" : 0,
      "endOffset" : 7
    }, {
      "referenceID" : 6,
      "context" : "For examples, in [7, 6]), the approaches mine patterns composed of methods, and the approach in [26] mines patterns composed of classes.",
      "startOffset" : 17,
      "endOffset" : 23
    }, {
      "referenceID" : 5,
      "context" : "For examples, in [7, 6]), the approaches mine patterns composed of methods, and the approach in [26] mines patterns composed of classes.",
      "startOffset" : 17,
      "endOffset" : 23
    }, {
      "referenceID" : 25,
      "context" : "For examples, in [7, 6]), the approaches mine patterns composed of methods, and the approach in [26] mines patterns composed of classes.",
      "startOffset" : 96,
      "endOffset" : 100
    }, {
      "referenceID" : 25,
      "context" : "[26]), clustering algorithms (e.",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 5,
      "context" : "[6]) or a heuristic defined by the authors such as [7, 8].",
      "startOffset" : 0,
      "endOffset" : 3
    }, {
      "referenceID" : 6,
      "context" : "[6]) or a heuristic defined by the authors such as [7, 8].",
      "startOffset" : 51,
      "endOffset" : 57
    }, {
      "referenceID" : 7,
      "context" : "[6]) or a heuristic defined by the authors such as [7, 8].",
      "startOffset" : 51,
      "endOffset" : 57
    }, {
      "referenceID" : 4,
      "context" : "used Principle Component Analysis with Clustering algorithm [5], and Buse and Weimer combined the clustering algorithm with their own proposed heuristic [27].",
      "startOffset" : 60,
      "endOffset" : 63
    }, {
      "referenceID" : 26,
      "context" : "used Principle Component Analysis with Clustering algorithm [5], and Buse and Weimer combined the clustering algorithm with their own proposed heuristic [27].",
      "startOffset" : 153,
      "endOffset" : 157
    } ],
    "year" : 2016,
    "abstractText" : "Object-oriented Application Programing Interfaces (APIs) support software reuse by providing pre-implemented functionalities. Due to the huge number of included classes, reusing and understanding large APIs is a complex task. Otherwise, software components are admitted to be more reusable and understandable entities than object-oriented ones. Thus, in this paper, we propose an approach for reengineering objectoriented APIs into component-based ones. We mine components as a group of classes based on the frequency they are used together and their ability to form a quality-centric component. To validate our approach, we experimented on 100 Java applications that used Android APIs.",
    "creator" : "TeX"
  }
}