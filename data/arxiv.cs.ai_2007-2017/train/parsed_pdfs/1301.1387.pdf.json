{
  "name" : "1301.1387.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : "Language ASP{f} with Arithmetic Expressions and Consistency-Restoring Rules",
    "authors" : [ "Marcello Balduccini", "Michael Gelfond" ],
    "emails" : [ "marcello.balduccini@gmail.com", "michael.gelfond@ttu.edu" ],
    "sections" : [ {
      "heading" : "1 Introduction",
      "text" : "In this paper we describe an extension of Answer Set Programming (ASP) [12,16,4] called ASP{f,cr}. This work continues our research on the introduction of nonHerbrand functions in ASP.\nIn logic programming, functions are typically interpreted over the Herbrand Universe, with each functional term f(x) mapped to its own canonical syntactical representation. That is, in most logic programming languages, the value of an expression f(x) is f(x) itself, and thus, if equality is understood as identity, f(x) = 2 is false. This type of functions, the corresponding languages and efficient implementation of solvers is the subject of a substantial amount of research (we refer the reader to e.g. [8,6]).\nWhen representing certain kinds of knowledge, however, it is sometimes convenient to use functions with non-Herbrand domains (non-Herbrand functions for short), i.e. functions that are interpreted over domains other than the Herbrand Universe. For example, when describing a domain in which people enter and exit a room over time, it may be convenient to represent the number of people in the room at step s by means of a function occupancy(s) and to state the effect of a person entering the room by means of a statement such as\noccupancy(S + 1) = O + 1← occupancy(S) = O\nwhere S is a variable ranging over the possible time steps in the evolution of the domain and O ranges over natural numbers.\nar X\niv :1\n30 1.\n13 87\nv1 [\ncs .A\nI] 8\nOf course, in most logic programming languages, non-Herbrand functions can still be represented, but the corresponding encodings are not as natural and declarative as the one above. For instance, a common approach consists in representing the functions of interest using relations, and then characterizing the functional nature of these relations by writing auxiliary axioms. In ASP, one would encode the above statement by (1) introducing a relation occupancy′(s, o), whose intuitive meaning is that occupancy′(s, o) holds iff the value of occupancy(s) is o; and (2) re-writing the original statement as a rule occupancy′(S + 1, O + 1)← occupancy′(S,O). (1) The characterization of the relation as representing a function would be completed by an axiom such as\n¬occupancy′(S,O′)← occupancy′(S,O), O 6= O′. (2)\nwhich intuitively states that occupancy(s) has a unique value. The disadvantage of this representation is that the functional nature of occupancy′(s, o) is only stated in (2). When reading (1), one is given no indication that occupancy′(s, o) represents a function – and, before finding statements such as (2), one can make no assumption about the functional nature of the relations in a program when a combination of (proper) relations and non-Herbrand functions are present. Moreover, in ASP relational encodings of functions often pose performance issues. For example, the grounding of rule (2) grows withO(|D|2) whereD is the range of variablesO andO′. If |D| is large, which is often the case especially with numerical variables, the size of the grounding can affect very negatively the overall solver performance.\nVarious extensions of ASP with non-Herbrand functions exist in the literature. In [7], Quantified Equilibrium Logic is extended with support for equality. A subset of the general language, called FLP, is then identified, which can be translated into normal logic programs. Such translation makes it possible to compute the answer sets of FLP programs using ASP solvers, although the performance issues due to the size of the grounding remain. [14] proposes instead the use of second-order theories for the definition of the semantics of the language. Again, a transformation is (partially) described, which removes non-Herbrand functions and makes it possible to use ASP solvers for the computation of the answer sets of programs in the extended language. As with the previous approach, the performance issues are present. In [15,17] the semantics is based on the notion of reduct as in the original ASP semantics [12]. For the purpose of computing answer sets, a translation is defined, which maps programs of the language from [15,17] to constraint satisfaction problems, so that CSP solvers can be used for the computation of the answer sets of programs in the extended language. Finally, the language of CLINGCON [9] extends ASP with elements from constraint satisfaction. The CLINGCON solver finds the answer sets of a program by interleaving the computations of an ASP solver and of a CSP solver. All the approaches except for [7] support only total functions. While the approaches from [15,17,9] are computationally efficient, the approaches of [7,14], based on translations to ASP, are affected by performance issues due to the size of the grounding. Finally, in [1,2] we have proposed an extension of ASP with non-Herbrand functions, called ASP{f}, that supports partial functions and is computationally more efficient than [7].\nIn the present paper, we extend the definition of ASP{f} from [1,2] further, by adding to it support for full-fledged arithmetic expressions and for consistency restoring rules from CR-Prolog [3]. We also contribute our perspective to the current debate on the usefulness of partial vs. total functions and on the role of non-Herbrand languages in general by demonstrating the use of our extended language for the representation of important types of knowledge and for the encoding of some classical scenarios, pointing out the differences with other approaches and with ASP encodings.\nThe rest of the paper is organized as follows. In the next section we extend ASP{f}with full-fledged arithmetic expressions. In the following section we introduce consistencyrestoring. The resulting language is called ASP{f,cr}. Next, we address high-level issues of knowledge representation in ASP{f,cr} and we demonstrate the use of ASP{f,cr} for the formalization of some classical problems. Finally, we draw conclusions and discuss future work.\n2 ASP{f} with Arithmetic Expressions\nIn this section we summarize the syntax and the semantics of ASP{f} [1,2], and extend the language with support for arithmetic expressions over non-Herbrand functional terms. For simplicity, in the rest of this paper we drop the attribute “non-Herbrand” and simply talk about functions and (functional) terms.\nThe syntax of ASP{f} is based on a signature Σ = 〈C,F ,R〉 whose elements are, respectively, finite disjoint sets of constants, function symbols and relation symbols. Some constants and function symbols are numerical (e.g. numerical constants 1 and 5) and have the standard interpretation.3 A simple term is an expression f(c1, . . . , cn) where f ∈ F , and ci’s are 0 or more constants. An arithmetic term is either a simple term where f is a numerical function, or an expression constructed from such simple terms and numerical constants using arithmetic operations, such as (f(c1) + g(c2))/2 and |f(c1) − g(c2)|. Simple terms and arithmetic terms are called terms. An atom is an expression r(c1, . . . , cn), where r ∈ R, and ci’s are constants. The set of all simple terms that can be formed fromΣ is denoted by S; the set of all atoms fromΣ is denoted by A. A term-atom, or t-atom, is an expression of the form f op g, where f and g are terms and op ∈ {=, 6=,≤, <,>,≥}. A seed t-atom is a t-atom of the form f = v such that f is a simple term and v is a constant. All other t-atoms are called dependent.\nA regular literal is an atom a or its strong negation ¬a. A literal is either an atom a, its strong negation ¬a, or a t-atom. Any literal that is not a dependent t-atom is called seed literal.\nA rule r is a statement of the form:\nh← l1, . . . , lm, not lm+1, . . . , not ln (3)\nwhere h is a seed literal and li’s are literals. Similarly to ASP, the informal reading of r is that a rational agent who believes l1, . . . , lm and has no reason to believe lm+1, . . . , ln must believe h.\n3 In the rest of the paper, whether an element of Σ is numerical will be clear from the context.\nGiven rule r, head(r) denotes {h}; body(r) denotes {l1, . . . , not ln}; pos(r) denotes {l1, . . . , lm}; neg(r) denotes {lm+1, . . . , ln}. A constraint is a special type of regular rule with an empty head, informally meaning that the condition described by the body of the constraint must never be satisfied. A constraint is considered a shorthand of ⊥ ← l1, . . . , lm, not lm+1, . . . , not ln, not ⊥, where ⊥ is a fresh atom. A program is a pair Π = 〈Σ,P 〉, where Σ is a signature and P is a set of rules. Whenever possible, in this paper the signature is implicitly defined from the rules of Π , and Π is identified with its set of rules. In that case, the signature is denoted by Σ(Π) and its elements by C(Π), F(Π) and R(Π). A rule r is positive if neg(r) = ∅. A program Π is positive if every r ∈ Π is positive. A program Π is also t-atom free if no t-atoms occur in the rules of Π .\nAs in ASP, variables can be used for a more compact notation. The grounding of a rule r is the set of all the rules (its ground instances) obtained by replacing every variable of r with an element of C4 and by performing any arithmetic operation over numerical constants. For example, one of the groundings of p(X + Y ) ← r(X), q(Y ) is p(5) ← r(3), q(2). The grounding of a program Π is the set of the groundings of the rules of Π . A syntactic element of the language is ground if it contains neither variables nor arithmetic operations over numerical constants and non-ground otherwise. For example, p(5) is ground while p(X + Y ) and p(3 + 2) are non-ground.\nThe semantics of a non-ground program is defined to coincide with the semantics of its grounding. The semantics of ground ASP{f} programs is defined below. It is worth noting that the semantics of ASP{f} is obtained from that of ASP in [12] by simply extending entailment to t-atoms.\nIn the rest of this section, we consider only ground terms, literals, rules and programs and thus omit the word “ground.” A set S of seed literals is consistent if (1) for every atom a ∈ A, {a,¬a} 6⊆ S; (2) for every term t ∈ S and v1, v2 ∈ C such that v1 6= v2, {t = v1, t = v2} 6⊆ S. Hence, S1 = {p,¬q, f = 3} and S2 = {q, f = 3, g = 2} are consistent, while {p,¬p, f = 3} and {q, f = 3, f = 2} are not. The value of a simple term tw.r.t. a consistent set S of seed literals (denoted by valS(t)) is v iff t = v ∈ S. If, for every v ∈ C, t = v 6∈ S, the value of t w.r.t. S is undefined. The value of a arithmetic term t w.r.t. S is obtained by applying the usual rules of arithmetic to the values of the terms in t w.r.t. S, if the values of all the terms in t are defined; otherwise its value is undefined.5 Finally, the value of a constant v ∈ C w.r.t. S (valS(v)) is v itself. For example given S1 and S2 as above, valS2(f) is 3 and valS2(g) is 2, whereas valS1(g) is undefined. Given S1 and a signature with C = {0, 1}, valS1(1) = 1.\nA literal l is satisfied by a consistent set S of seed literals under the following conditions: (1) if l is a seed literal, then l is satisfied by S iff l ∈ S; (2) if l is a dependent\n4 The replacement is with constants of suitable sort. We omit the details of this process to save space. 5 This definition does not adequately capture the value of expressions such as 0 ∗ f in the presence of undefined terms. We plan to address this and some related issues in a later paper.\nt-atom of the form f op g, then l is satisfied by S iff both valS(f) and valS(g) are defined, and they satisfy the equality or inequality relation op according to the usual arithmetic interpretation. Thus, seed literals q and f = 3 are satisfied by S2; f 6= g is also satisfied by S2 because valS2(f) and valS2(g) are defined, and valS2(f) is different from valS2(g). Conversely, f = g is not satisfied, because valS2(f) is different from valS2(g). The t-atom f 6= h is also not satisfied by S2, because valS2(h) is undefined. When a literal l is satisfied (resp., not satisfied) by S, we write S |= l (resp., S 6|= l).\nAn extended literal is a literal l or an expression of the form not l. An extended literal not l is satisfied by a consistent set S of seed literals (S |= not l) if S 6|= l. Similarly, S 6|= not l if S |= l. Considering set S2 again, extended literal not f = h is satisfied by S2, because f = h is not satisfied by S2.\nFinally, a set E of extended literals is satisfied by a consistent set S of seed literals (S |= E) if S |= e for every e ∈ E.\nNext, we define the semantics of ASP{f}. A set S of seed literals is closed under positive rule r if S |= h, where head(r) = {h}, whenever S |= pos(r). Hence, set S2 described earlier is closed under f = 3 ← g 6= 1 and (trivially) under f = 2 ← r, but it is not closed under p ← f = 3, because S2 |= f = 3 but S2 6|= p. S is closed under Π if it is closed under every rule r ∈ Π .\nDefinition 1. A set S of seed literals is an answer set of a positive program Π if it is consistent and closed underΠ , and is minimal (w.r.t. set-theoretic inclusion) among the sets of seed literals that satisfy such conditions.\nThus, the program {p ← f = 2. f = 2. q ← q.} has one answer sets, {f = 2, p}. The set {f = 2} is not closed under the first rule of the program, and therefore is not an answer set. The set {f = 2, p, q} is also not an answer set, because it is not minimal (it is a proper superset of another answer set). Notice that positive programs may have no answer set. For example, the program {f = 3. f = 2 ← q. q.} has no answer set. Programs that have answer sets (resp., no answer sets) are called consistent (resp., inconsistent).\nPositive programs enjoy the following property:\nProposition 1. Every consistent positive ASP{f} program Π has a unique answer set.\nNext, we define the semantics of arbitrary ASP{f} programs.\nDefinition 2. The reduct of a program Π w.r.t. a consistent set S of seed literals is the set ΠS consisting of a rule head(r) ← pos(r) (the reduct of r w.r.t. S) for each rule r ∈ Π for which S |= body(r) \\ pos(r).\nExample 1. Consider a set of seed literals S3 = {g = 3, f = 2, p, q}, and program Π1:\nr1 : p← f = 2, not g = 1, not h = 0. r2 : q ← p, not g 6= 2. r3 : g = 3. r4 : f = 2.\nand let us compute its reduct. For r1, first we have to check if S3 |= body(r1)\\pos(r1), that is if S3 |= not g = 1, not h = 0. Extended literal not g = 1 is satisfied by S3 only if S3 6|= g = 1. Because g = 1 is a seed literal, it is satisfied by S3 if g = 1 ∈ S3. Since g = 1 6∈ S3, we conclude that S3 6|= g = 1 and thus not g = 1 is satisfied by S3. In a similar way, we conclude that S3 |= not h = 0. Hence, S3 |= body(r1) \\ pos(r1). Therefore, the reduct of r1 is p ← f = 2. For the reduct of r2, notice that not g 6= 2 is not satisfied by S3. In fact, S3 |= not g 6= 2 only if S3 6|= g 6= 2. However, it is not difficult to show that S3 |= g 6= 2: in fact, valS3(g) is defined and valS3(g) 6= 2. Therefore, not g 6= 2 is not satisfied by S3, and thus the reduct of Π1 contains no rule for r2. The reducts of r3 and r4 are the rules themselves. Summing up, ΠS31 is {r′1 : p← f = 2, r′3 : g = 3, r′4 : f = 2}\nThe semantics of arbitrary ASP{f} programs is given by the following definition:\nDefinition 3. Finally, a consistent set S of seed literals is an answer set of Π if S is the answer set of ΠS .\nExample 2. By applying the definitions given earlier, it is not difficult to show that an answer set of ΠS31 is {f = 2, g = 3, p} = S3. Hence, S3 is an answer set of Π S3 1 . Consider instead S4 = S3 ∪{h = 1}. Clearly ΠS41 = Π S3 1 . From the uniqueness of the answer sets of positive programs, it follows immediately that S4 is not an answer set of ΠS41 . Therefore, S4 is not an answer set of Π1.\n3 ASP{f,cr}: Consistency-Restoring Rules in ASP{f}\nIn this section we extend ASP{f} by consistency-restoring rules from CR-Prolog [3]. We denote the extended language by ASP{f,cr}. As discussed in the literature on CRProlog, consistency-restoring rules are convenient for the formalization of various types of knowledge and of reasoning tasks. Later in this paper we show how consistencyrestoring rules are useful for the formalization of knowledge about non-Herbrand functions as well.\nA consistency-restoring rule (or cr-rule) is a statement of the form:\nh +← l1, . . . , lm, not lm+1, . . . , not ln. (4)\nwhere h is a seed literal and li’s are literals. The intuitive reading of the statement is that a reasoner who believes {l1, . . . , lm} and has no reason to believe {lm+1, . . . , ln}, may possibly believe h. The implicit assumption is that this possibility is used as little as possible, only when the reasoner cannot otherwise form a non-contradictory set of beliefs.\nBy ASP{f,cr} program we mean a pair 〈Σ,Π〉, where Σ is a signature and Π is a set of rules and cr-rules over Σ.\nGiven an ASP{f,cr} program Π , we denote the set of its rules by Πr and the set of its cr-rules by Πcr. By α(r) we denote the rule obtained from cr-rule r by replacing symbol +←with←. Given a set of cr-rulesR, α(R) denotes the set obtained by applying α to each cr-rule in R. The semantics of ASP{f,cr} programs is defined in two steps.\nDefinition 4 (Answer Sets of CR-Rule Free Programs). The answer sets of a cr-rule free ASP{f,cr} program are the answer sets of the corresponding ASP{f} program.\nDefinition 5. Given an arbitrary ASP{f,cr} programΠ , a subsetR ofΠcr is an abductive support of Π if Πr ∪ α(R) is consistent and R is set-theoretically minimal among the sets satisfying this property.\nDefinition 6 (Answer Sets of Arbitrary Programs). For an arbitrary ASP{f,cr} program Π , a set of literals A is an answer set of Π if it is an answer set of the program Πr ∪ α(R) for some abductive support R of Π .\nAlthough out of the scope of the present paper, it is also possible to extend ASP{f,cr} to allow for the specification of CR-Prolog-style preferences over cr-rules.\n4 Knowledge Representation with ASP{f,cr}\nIn this section we demonstrate the use of ASP{f,cr} for the formalization of certain types of knowledge. Whenever appropriate, we also compare with ASP and with other extensions of ASP by non-Herbrand functions.\nConsider a scenario in which data from a town registry about births and deaths is used to determine who should receive a certain tax bill. The registry lists the year of birth and the year of death of a person. If a person is alive, no year of death is in the registry. The tax bill should only be sent to living people who are between 18 and 65 years old. To ensure robustness, we want to be able to deal with (infrequently) missing information. Hence, whenever there is uncertainty (represented by an atom uncertain(p)) about whether a person should receive the tax bill or not, a manual check will be performed. The first requirement can be encoded in ASP{f,cr} by the rule:\nbill(P )← person(P ), age(P ) ≥ 18, age(P ) ≤ 65, not uncertain(P ), not ¬bill(P ).\nRelation person defines a list of people known to the system. To shorten the rules, from now on we will implicitly assume the occurrence of an atom person(P ) in every rule where P occurs. The condition not ¬bill(P ) allows one to specify exceptions in the usual way. For example, the tax might be waived for low-income people:\n¬bill(P )← low income(P ).\nSimilarly, condition not uncertain(P ) ensures that the bill is not sent if there is uncertainty about whether the person is subject to the tax.\nNext, we define a person’s current age based on their year of birth. Following intuition, we define age only for people who are alive.\nhas birth year(P )← birth year(P ) = X. (5) ¬has birth year(P )← not has birth year(P ). (6)\nhas death year(P )← death year(P ) = X. (7) ¬has death year(P )← not has death year(P ). (8)\n¬alive(P )← has death year(P ). (9) alive(P )← has birth year(P ),¬has death year(P ). (10)\nage(P ) = X ← alive(P ), X = current year − birth year(P ). (11)\nRules (5) and (7) determine when information about a person’s birth and death year is available. Rules (6) and (8) formalize the closed world assumption (CWA) of relations has birth year and has death year. Although this encoding of CWA is common practice in ASP, it plays an important role in the distinction between languages with partial functions and languages with total functions, as we discuss later. Rule (9) states that it is possible to conclude that a person is dead if a year of death is found in the registry. Rule (10) states that a person is alive if the registry contains a year of birth and does not contain information about the person’s death. Finally, rule (11) calculates a person’s age. current year is a function of arity 0 whose value corresponds to the current year.\nThe next set of rules deals with the possibility of information missing from the registry. One important case to consider is that in which information about a person’s death is accidentally missing from the registry. In (10) a person is assumed to be alive unless evidence exists about the person’s death. This modeling choice is justified because missing information is assumed to be infrequent. Exceptional conditions can be dealt with by requesting a manual check on whether the person should receive the tax bill. Rule (12) below states that one such case is when a person’s age according to the registry is beyond that person’s maximum life span.\nuncertain(P )← alive(P ), age(P ) ≥ max span(P ). (12) max span(P ) = 92← not max span(P ) 6= 92. (13) max span(P ) = 100← long lived family(P ). (14)\nuncertain(P )← not alive(P ), not ¬alive(P ). (15)\nRule (13) provides a simple definition of a person’s maximum life span, stating that, normally, a person’s maximum life span is 92 years. Note that the rule is written in the form of a default over non-Herbrand functions. This makes it possible for example to predict a different life span depending on a person’s medical or family history. Along\nthe lines of [5], the reading of (13) is “if P ’s maximum life span may be 92, then it is 92.” Generally speaking, an expressions of the form not f 6= g can be viewed to intuitively state “f may be (equal to) g”. Rule (14) encodes one possible exception to the default, for people from families with a history of long life spans. Rule (15) covers instead the case in which the system couldn’t determine if a person is dead or alive. The formalization of this type of test has already been covered in the literature and is shown here for completeness, and using a a slightly simplified encoding. A discussion on this topic and proposals for more sophisticated formalizations can be found in [10,11].\nIt is currently a source of debate [14,7] whether support for partial functions should be allowed in languages with non-Herbrand functions. Although of course from the point of view of computational complexity partial and total functions in this context are equivalent, we believe that the following elaboration of the tax-bill scenario appears to show that the availability of partial functions is indeed important.\nFirst of all, notice that, in a language that only supported total functions, the scenario discussed so far would have to be formalized by introducing a special constant. This special constant is to be used when the birth or death years are unknown. For the sake of this discussion, let us denote the special constant by <undef>.\nNotice that, to allow for the use of <undef>, a design requirement would have to be imposed on the town registry so that entries that do not have a value are set to<undef>. It is worth mentioning that one might be tempted to avoid the use of <undef> and instead reason by cases, one for each possible value of the year of birth or death. This approach however does not appear to work well in this scenario. In fact, in this scenario it is important to know whether the year of death is present in the registry at all – see e.g. rules (5) and (7). When reasoning by cases, it is not possible to reason about this circumstance from within the program, unless rather sophisticated extensions of ASP such as [10,11] are used.\nGoing back to our scenario, suppose that we want to incorporate in our system information from a database of deadly car accidents. Suppose the database consists of statements of the form died(p, y), where p is a person and y is the year in which the deadly accident occurred. If there are inconsistencies between the town registry and the accident database, we would like to give precedence to the former. This can be easily formalized in ASP{f,cr} with:\ndeath year(P ) = Y ← died(P, Y ), not death year(P ) 6= Y. (16)\nInformally, the rule states that, if p is reported to have died in a car accident in year y, then that is assumed to be p’s death year, unless the town registry contains information to the contrary.\nIt is important to notice that our ASP{f,cr} formalization makes it possible to incorporate the car accident database in a completely incremental fashion. No changes are needed to the rules we showed earlier. This is possible mainly because death year is a partial function.\nLet us see now how using a language with total functions would affect the incorporation of the car accident database. Let us consider a situation in which no death year is\nspecified for person p in the town registry, but an entry died(p, 1998) exists in the car accident database. As discussed above, in a language that only supported total functions, death year(p) would have to be set to <undef> in the town registry. Hence, the body of rule (16) would never be satisfied.\nTo the best of our knowledge, working around this issue when using a language with total functions is non-trivial and the solutions are characterized by reduced elaboration tolerance. For example, one possible method consists in introducing a relation determined death year(P ) that encodes the overall belief of the system about a person’s death year. By default, the value of determined death year(P ) is obtained from the town registry. When that value is undefined, a death year can be derived from the car accident database by means of a rule similar to (to avoid using a specific language from the literature, we write the rule in the syntax of ASP{f,cr}):\ndetermined death year(P ) = Y ← died(P, Y ), not determined death year(P ) 6= Y.\nFurthermore, any rule that previously involved relation death year would have to be modified to use the new relation. This process, although seemingly harmless on the surface, tends to be error-prone and the corresponding encoding is hardly elaboration tolerant. Every time information from another database had to be incorporated, more changes to the existing program are required – for example, the reader may want to consider would happen if one had to incorporate information about births from e.g. a health insurance database.\nUp to this point we have discussed cases in which the use of total functions appears to cause some issues. One may be wondering whether it is possible to represent total functions in ASP{f,cr}, and if there are any drawbacks. To address this topic, let us suppose that we would like to determine the number of dependents of a person. This information could be used for example in order to ensure that certain individuals are waived from paying the tax discussed earlier. For simplicity of presentation, however, we discuss the determination of the number of dependents independently of the code shown earlier.\nLet us assume that the number of a person’s dependents is found in their tax return, if one exists. If no tax return has been filed, we would like to consider separately each possible case, corresponding to a number of dependents ranging between 0 and maxd. The number of dependents can then be viewed as a total function.\nIn our formalization, an atom of the form return dep(p, d) states that p has d dependents according to p’s latest tax return (or, equivalently, a function could be used instead of a relation). We will represent the number of a person p’s dependents by means of a function dependents(p).\nA straightforward formalization, Πi1, of such a total function is:\ndependents(P ) = D ← return dep(P,D). (17) dependents(P ) = V ← not dependents(P ) 6= V. (18)\nRule (17) states that the number of dependents can be obtained from the tax return, if available. Rule (18) states that a person can have any number of dependents, unless there is reason to believe otherwise. Here and below we assume that variable V ranges over the domain [0,maxd] (this can be easily implemented by adding a condition dom(V ) and a suitable definition of relation dom).\nΠi1 formalizes the nature of total function dependents for simple situations. However, suppose that one wanted to take into account the case in which p’s tax return was audited and the number of p’s dependents found to be different from what was stated in the tax return. Rule (17) does not properly deal with this case, because it prevents one from overriding a person’s dependents based on information from the audit. So, a different formalization of total functions is needed to deal with more sophisticated examples.\nOne might then be tempted to rewrite (17) as a default and to add a suitable exception, obtaining Πi2:\ndependents(P ) = D ← return dep(P,D), not dependents(P ) 6= D. (19) dependents(P ) = V ← not dependents(P ) 6= V. (20) dependents(P ) = D ← assessed deps(P,D). (21)\nUnfortunately this formalization does not yield the intended answers because of the interaction between defaults (19) and (20): consider a person p1 with 3 dependents according to their tax return, I1 = {return deps(P, 3)}. One might expect I1 ∪Πi2 to yield the conclusion dependents(p) = 3, but in fact the program has multiple answer sets, enumerating all the possible numbers of dependents between 0 and maxd. This is an instance of a phenomenon already studied in the literature (see e.g. [13]), which can be circumvented by properly prioritizing the defaults of Πi2. Doing so however tends to affect the elaboration tolerance of the encoding (e.g. in case further defaults must be added) and is somewhat cumbersome and error-prone.\nA more robust and elaboration tolerant approach relies on the use of cr-rules. Intuitively, in this approach, a cr-rule determines when to trigger the default behavior of considering all the possible values of a total function. Consider the following program, Πi3:\ndependents(P ) = D ← return deps(P,D), not dependents(P ) 6= D. (22) dependents(P ) = D ← assessed deps(P,D). (23)\nhas dep info(P )← dependents(P ) = D. (24) ← not has dep info(P ). (25)\ndependents(P ) = D +← . (26)\nProgram Πi3 is obtained from Π i 2 by replacing rule (20) by (24-26). Rules (24-25) intuitively state that the number of dependents must be known for every person. Crrule (26) intuitively states that it is possible to assume that a person has any number of dependents, but that this possibility should be used only if strictly necessary and in order to restore consistency.\nIt is not difficult to see that Πi3 yields the expected conclusions. To this extent, it is important to notice that cr-rule (26) will only be used for people for whom no other dependent information is available. In fact, let I3 be a set of facts providing partial information about the dependents of a group of people, and U3 = {p1, . . . , pu} be the set of people from I3 for whom no dependent information is available. According to Definition 5, any abductive support of Πi3 ∪ I3 must contain, for every pi ∈ U3, a ground cr-rule dependents(pi) = d\n+← for some d. Let now R3 be the set of all such cr-rules, and consider a person p′ for whom dependent information is provided in I3. The corresponding set R′3 = R3 ∪ {dependents(p′) = d′\n+←} is not an abductive support of Πi3 ∪ I3 because it is not set-theoretically minimal. Hence, cr-rule (26) is only used for the people in U3.\nIt is not difficult to see that this approach for the encoding of total functions in ASP{f,cr} is applicable in general, and that (24) can be rewritten as a general, domainindependent axiom (an example of a domain-independent axiom can be found in the next section).\n5 Some Modeling and Solving Tasks in ASP{f,cr}\nIn this section we demonstrate the use of ASP{f,cr} for a sample of modeling and solving tasks from the literature. We also include a (partial) discussion of the features of our encodings in relation with other methods for representing non-Herbrand functions. We refer the reader to the description and original encodings from http://www.cs.unipotsdam.de/∼torsten/kr12tutorial.\nWater Buckets on a Scale (page 216). In this scenario, one bucket is placed on each arm of a two-armed scale. Each bucket initially contains an amount of water between 0 and 100. All amounts of water in this scenario are represented by integer values. At every time step, an agent must pour an amount k, 1 ≤ k ≤ maxw of water into one of the buckets.6 The agent’s goal is to balance the two buckets on the scale. The ASP{f,cr} encoding, Πw, of this scenario is:\nbucket(a). bucket(b).\n1{pour(B, T,K) : bucket(B) : K ≥ 1 : K ≤ maxw}1← time(T ), T < t. (27) poured(B, T ) = K ← pour(B, T,K). (28) volume(B, T + 1) = V ← V = volume(V, T ) + poured(B, T ). (29) volume(B, T + 1) = volume(B, T )← not volume(B, T + 1) 6= volume(B, T ). (30) heavier(B, T )← bucket(B), bucket(C), time(T ), volume(C, T ) < volume(B, T ).\n(31)\n← bucket(B), heavier(B, t). (32)\nRule (27) states that the agent can pour any allowed amount of water in any one bucket at every time step. For compactness, the rule uses the syntax of choice rules from\n6 We deviate slightly from the original scenario in that the agent is allowed to decide how much water is to be poured.\nLPARSE and GRINGO. Extending the definition of ASP{f,cr} to support choice rules is trivial. Rule (28) states that the amount of water poured as a consequence of action pour(b, t, k) is k. Rule (29) encodes a dynamic law; it states that when water is poured into a bucket, the volume of water in the bucket increases by the amount of water poured. We assume that a suitable domain has been specified for variable V . Rule (30) formalizes the inertia axiom. It states that the volume of water in a bucket stays the same unless it is forced to change. Rule (31) describes the conditions under which a buckets is heavier than the other. Finally, rule (32) states that it is impossible for a bucket to be heavier than the other at the end of the execution of the plan.\nIt is worth observing that, as prescribed by good knowledge representation principles, in Πw the inertia axiom is written without references to the occurrence of any action. This allows for a rather elaboration tolerant encoding. In the original CLINGCON encoding, on the other hand, the inertia axiom mentions the occurrence of actions:\namount(B, T )$ == 0← not pour(B, T ), bucket(B), T < t. (33) volume(B, T + 1)$ == volume(B, T ) + amount(B, T )← bucket(B), T < t. (34)\nThis encoding is arguably less elaboration tolerant than Πw: for example, the CLINGCON inertia axiom (33) must be modified whenever new actions are introduced in the representation, while the inertia axiom from Πw does not have to be changed, and the whole program can be extended in a completely incremental fashion. In fact, ASP{f,cr} makes it possible to encode the inertia axiom in a form that is even more general than that of rule (30):7\nnum fluent(volume(B))← bucket(B). (35) val(N,T + 1) = val(N,T )← num fluent(N), not val(N,T + 1) 6= val(N,T ). (36)\nRule (35) states that volume(·) is a “numerical fluent”. Rule (36) states that the value of any numerical fluent remains the same over time unless it is forced to change. The advantage of this generalized form of the inertia axiom is that the corresponding rules apply without changes to any numerical fluent, so that now the addition of new numerical fluents to the encoding can be fully incremental as well.\nFrom the point of view of the size of the grounding, the CLINGCON encoding is however superior to Πw, because in Πw rule (29) must be grounded for every possible value of variable V , while in the CLINGCON encoding the grounding is entirely independent of the volume of water in the buckets. On the other hand, the size of the grounding of Πw is substantially better than the best ASP encodings that we are aware of. In the ASP encodings, in fact, the grounding of the inertia axiom grows proportionally to the square of the domain of variable V . A similar phenomenon can be observed in the encodings based on the languages of [7,14], since in those approaches computation of the answer sets is performed by translating the programs to ASP.\n7 To complete the encoding (29) and (31) have to be modified in a straightforward way to use val(·, ·) as well. From a technical perspective, in this encoding ground expressions volume(a) and volume(b) are viewed as constants. This is possible because no assumptions are made about the set of constants in our definition of the language. Alternatively, one could of course extend the language with Herbrand function symbols and of Herbrand terms, at the cost of a slightly more complex presentation.\nN-Queens (page 176). In this scenario an agent must place n queens on an n× n chess board so that no queen can attack another. In this scenario the size of the grounding and the execution time tend to grow quickly with the increase of parameter n. In straightforward ASP encodings, the growth of the grounding is due to the tests ensuring that no queen can attack another. Πq1 shows one possible ASP encoding:\n← queen(X1, Y1), queen(X1, Y2), Y1 < Y2. ← queen(X1, Y1), queen(X2, Y1), X1 < X2. ← queen(X1, Y1), queen(X2, Y2), X1 < X2, X2 −X1 = |Y2 − Y1|.\nConditions Y1 < Y2 and X1 < X2 are introduced in order to break symmetries. The last rule is the most problematic with respect to the size of the grounding, because its grounding grows roughly with O(n4). Several modifications of Πq1 are known, which decrease the size of the grounding.8 However, it is often argued that these modifications make the corresponding encodings either less declarative, or less elaboration tolerant. Certainly, most of the modifications achieve performance by a less straightforward encoding of the constraints of the problem.\nIt is then interesting to compare Πq1 with a straightforward ASP{f,cr} encoding, Π q 2 :\n← Q1 < Q2, col(Q1) = col(Q2). ← Q1 < Q2, row(Q1) = row(Q2). ← Q1 < Q2, col(Q2)− col(Q1) = |row(Q2)− row(Q1)|.\nCondition Q1 < Q2 performs basic symmetry breaking. Π q 2 uses two functions to encode the positions of the queens. What is remarkable about Πq2 is that the grounding of the last rule grows roughly with O(n2), although we argue that it is as straightforward an encoding of the requirement as the corresponding rule from Πq1 . As in the previous scenario, we expect a similar growth for comparable CLINGCON encodings, and a growth of O(n4) for the grounding of the encodings written in the languages of [7,14]."
    }, {
      "heading" : "6 Conclusions and Future Work",
      "text" : "In this paper we have defined the syntax and semantics of an extension of ASP by nonHerbrand functions with full-fledged arithmetic expressions and consistency-restoring rules. The resulting language ASP{f,cr} supports partial functions and we hope we have demonstrated that it allows for the encoding of rather sophisticated kinds of knowledge, including knowledge about total functions. Compared to similar languages, ASP{f,cr} strikes a remarkable balance between expressive power and efficiency of computation. In the previous section, the discussion on the efficiency of computation was based only on the size of the grounding of the corresponding encodings, but in [1] experimental evidence on solver performance was obtained using a prototype of an ASP{f} solver (available at http://marcy.cjb.net/clingof). We expect that a version of the solver including support for the extended language defined in this paper will be available soon. Once that becomes available, we plan to substantiate the discussion from the previous section with experimental results.\n8 See especially http://www.cs.uni-potsdam.de/∼torsten/kr12tutorial."
    } ],
    "references" : [ {
      "title" : "Answer Set Solving and Non-Herbrand Functions",
      "author" : [ "M. Balduccini" ],
      "venue" : "Rosati, R., Woltran, S. (eds.) Proceedings of the 14th International Workshop on Non-Monotonic Reasoning (NMR’2012)",
      "citeRegEx" : "1",
      "shortCiteRegEx" : null,
      "year" : 2012
    }, {
      "title" : "Correct Reasoning: Essays on Logic-Based AI in Honour of Vladimir Lifschitz, chap",
      "author" : [ "M. Balduccini" ],
      "venue" : "3. A “Conservative” Approach to Extending Answer Set Programming with NonHerbrand Functions, pp. 23–39. Lecture Notes in Artificial Intelligence (LNCS), Springer Verlag, Berlin",
      "citeRegEx" : "2",
      "shortCiteRegEx" : null,
      "year" : 2012
    }, {
      "title" : "Logic Programs with Consistency-Restoring Rules",
      "author" : [ "M. Balduccini", "M. Gelfond" ],
      "venue" : "Doherty, P., McCarthy, J., Williams, M.A. (eds.) International Symposium on Logical Formalization of Commonsense Reasoning. pp. 9–18. AAAI 2003 Spring Symposium Series",
      "citeRegEx" : "3",
      "shortCiteRegEx" : null,
      "year" : 2003
    }, {
      "title" : "Knowledge Representation, Reasoning, and Declarative Problem Solving",
      "author" : [ "C. Baral" ],
      "venue" : "Cambridge University Press",
      "citeRegEx" : "4",
      "shortCiteRegEx" : null,
      "year" : 2003
    }, {
      "title" : "Logic Programming and Knowledge Representation",
      "author" : [ "C. Baral", "M. Gelfond" ],
      "venue" : "Journal of Logic Programming 19(20), 73–148",
      "citeRegEx" : "5",
      "shortCiteRegEx" : null,
      "year" : 1994
    }, {
      "title" : "A Decidable Subclass of Finitary Programs",
      "author" : [ "S. Baselice", "P.A. Bonatti" ],
      "venue" : "Journal of Theory and Practice of Logic Programming (TPLP) 10(4–6), 481–496",
      "citeRegEx" : "6",
      "shortCiteRegEx" : null,
      "year" : 2010
    }, {
      "title" : "Functional Answer Set Programming",
      "author" : [ "P. Cabalar" ],
      "venue" : "Journal of Theory and Practice of Logic Programming (TPLP) 11, 203–234",
      "citeRegEx" : "7",
      "shortCiteRegEx" : null,
      "year" : 2011
    }, {
      "title" : "Enhancing ASP by Functions: Decidable Classes and Implementation Techniques",
      "author" : [ "F. Calimeri", "S. Cozza", "G. Ianni", "N. Leone" ],
      "venue" : "Proceedings of the Twenty-Fourth Conference on Artificial Intelligence. pp. 1666–1670",
      "citeRegEx" : "8",
      "shortCiteRegEx" : null,
      "year" : 2010
    }, {
      "title" : "Constraint Answer Set Solving",
      "author" : [ "M. Gebser", "M. Ostrowski", "T. Schaub" ],
      "venue" : "25th International Conference on Logic Programming (ICLP09). vol. 5649",
      "citeRegEx" : "9",
      "shortCiteRegEx" : null,
      "year" : 2009
    }, {
      "title" : "Strong Introspection",
      "author" : [ "M. Gelfond" ],
      "venue" : "Dean, T., McKeown, K. (eds.) Proceedings of the 9th National Conference on Artifical Intelligence. pp. 386–391. AAAI Press/The MIT Press, Menlo Park, CA",
      "citeRegEx" : "10",
      "shortCiteRegEx" : null,
      "year" : 1991
    }, {
      "title" : "New Semantics for Epistemic Specifications",
      "author" : [ "M. Gelfond" ],
      "venue" : "Delgrande, J.P., Faber, W. (eds.) 11th International Conference on Logic Programming and Nonmonotonic Reasoning (LPNMR11). Lecture Notes in Artificial Intelligence (LNCS), vol. 6645, pp. 260–265. Springer Verlag, Berlin",
      "citeRegEx" : "11",
      "shortCiteRegEx" : null,
      "year" : 2011
    }, {
      "title" : "Classical Negation in Logic Programs and Disjunctive Databases",
      "author" : [ "M. Gelfond", "V. Lifschitz" ],
      "venue" : "New Generation Computing 9, 365–385",
      "citeRegEx" : "12",
      "shortCiteRegEx" : null,
      "year" : 1991
    }, {
      "title" : "Reasoning with Prioritized Defaults",
      "author" : [ "M. Gelfond", "T.C. Son" ],
      "venue" : "Third International Workshop, LPKR’97. Lecture Notes in Artificial Intelligence (LNCS), vol. 1471, pp. 164–224",
      "citeRegEx" : "13",
      "shortCiteRegEx" : null,
      "year" : 1997
    }, {
      "title" : "Logic Programs with Intensional Functions (Preliminary Report)",
      "author" : [ "V. Lifschitz" ],
      "venue" : "ICLP11 Workshop on Answer Set Programming and Other Computing Paradigms (ASPOCP11)",
      "citeRegEx" : "14",
      "shortCiteRegEx" : null,
      "year" : 2011
    }, {
      "title" : "Answer Set Programming with Functions",
      "author" : [ "F. Lin", "Y. Wang" ],
      "venue" : "Proceedings of the International Conference on Principles of Knowledge Representation and Reasoning (KR2008). pp. 454–465",
      "citeRegEx" : "15",
      "shortCiteRegEx" : null,
      "year" : 2008
    }, {
      "title" : "The Logic Programming Paradigm: a 25-Year Perspective, chap",
      "author" : [ "V.W. Marek", "M. Truszczynski" ],
      "venue" : "Stable Models and an Alternative Logic Programming Paradigm, pp. 375–398. Springer Verlag, Berlin",
      "citeRegEx" : "16",
      "shortCiteRegEx" : null,
      "year" : 1999
    }, {
      "title" : "Weight Constraint Programs with Functions",
      "author" : [ "Y. Wang", "J.H. You", "L.Y. Yuan", "M. Zhang" ],
      "venue" : "Erdem, E., Lin, F., Schaub, T. (eds.) 10th International Conference on Logic Programming and Nonmonotonic Reasoning (LPNMR09). Lecture Notes in Artificial Intelligence (LNCS), vol. 5753, pp. 329–341. Springer Verlag, Berlin",
      "citeRegEx" : "17",
      "shortCiteRegEx" : null,
      "year" : 2009
    } ],
    "referenceMentions" : [ {
      "referenceID" : 11,
      "context" : "In this paper we describe an extension of Answer Set Programming (ASP) [12,16,4] called ASP{f,cr}.",
      "startOffset" : 71,
      "endOffset" : 80
    }, {
      "referenceID" : 15,
      "context" : "In this paper we describe an extension of Answer Set Programming (ASP) [12,16,4] called ASP{f,cr}.",
      "startOffset" : 71,
      "endOffset" : 80
    }, {
      "referenceID" : 3,
      "context" : "In this paper we describe an extension of Answer Set Programming (ASP) [12,16,4] called ASP{f,cr}.",
      "startOffset" : 71,
      "endOffset" : 80
    }, {
      "referenceID" : 7,
      "context" : "[8,6]).",
      "startOffset" : 0,
      "endOffset" : 5
    }, {
      "referenceID" : 5,
      "context" : "[8,6]).",
      "startOffset" : 0,
      "endOffset" : 5
    }, {
      "referenceID" : 6,
      "context" : "In [7], Quantified Equilibrium Logic is extended with support for equality.",
      "startOffset" : 3,
      "endOffset" : 6
    }, {
      "referenceID" : 13,
      "context" : "[14] proposes instead the use of second-order theories for the definition of the semantics of the language.",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 14,
      "context" : "In [15,17] the semantics is based on the notion of reduct as in the original ASP semantics [12].",
      "startOffset" : 3,
      "endOffset" : 10
    }, {
      "referenceID" : 16,
      "context" : "In [15,17] the semantics is based on the notion of reduct as in the original ASP semantics [12].",
      "startOffset" : 3,
      "endOffset" : 10
    }, {
      "referenceID" : 11,
      "context" : "In [15,17] the semantics is based on the notion of reduct as in the original ASP semantics [12].",
      "startOffset" : 91,
      "endOffset" : 95
    }, {
      "referenceID" : 14,
      "context" : "For the purpose of computing answer sets, a translation is defined, which maps programs of the language from [15,17] to constraint satisfaction problems, so that CSP solvers can be used for the computation of the answer sets of programs in the extended language.",
      "startOffset" : 109,
      "endOffset" : 116
    }, {
      "referenceID" : 16,
      "context" : "For the purpose of computing answer sets, a translation is defined, which maps programs of the language from [15,17] to constraint satisfaction problems, so that CSP solvers can be used for the computation of the answer sets of programs in the extended language.",
      "startOffset" : 109,
      "endOffset" : 116
    }, {
      "referenceID" : 8,
      "context" : "Finally, the language of CLINGCON [9] extends ASP with elements from constraint satisfaction.",
      "startOffset" : 34,
      "endOffset" : 37
    }, {
      "referenceID" : 6,
      "context" : "All the approaches except for [7] support only total functions.",
      "startOffset" : 30,
      "endOffset" : 33
    }, {
      "referenceID" : 14,
      "context" : "While the approaches from [15,17,9] are computationally efficient, the approaches of [7,14], based on translations to ASP, are affected by performance issues due to the size of the grounding.",
      "startOffset" : 26,
      "endOffset" : 35
    }, {
      "referenceID" : 16,
      "context" : "While the approaches from [15,17,9] are computationally efficient, the approaches of [7,14], based on translations to ASP, are affected by performance issues due to the size of the grounding.",
      "startOffset" : 26,
      "endOffset" : 35
    }, {
      "referenceID" : 8,
      "context" : "While the approaches from [15,17,9] are computationally efficient, the approaches of [7,14], based on translations to ASP, are affected by performance issues due to the size of the grounding.",
      "startOffset" : 26,
      "endOffset" : 35
    }, {
      "referenceID" : 6,
      "context" : "While the approaches from [15,17,9] are computationally efficient, the approaches of [7,14], based on translations to ASP, are affected by performance issues due to the size of the grounding.",
      "startOffset" : 85,
      "endOffset" : 91
    }, {
      "referenceID" : 13,
      "context" : "While the approaches from [15,17,9] are computationally efficient, the approaches of [7,14], based on translations to ASP, are affected by performance issues due to the size of the grounding.",
      "startOffset" : 85,
      "endOffset" : 91
    }, {
      "referenceID" : 0,
      "context" : "Finally, in [1,2] we have proposed an extension of ASP with non-Herbrand functions, called ASP{f}, that supports partial functions and is computationally more efficient than [7].",
      "startOffset" : 12,
      "endOffset" : 17
    }, {
      "referenceID" : 1,
      "context" : "Finally, in [1,2] we have proposed an extension of ASP with non-Herbrand functions, called ASP{f}, that supports partial functions and is computationally more efficient than [7].",
      "startOffset" : 12,
      "endOffset" : 17
    }, {
      "referenceID" : 6,
      "context" : "Finally, in [1,2] we have proposed an extension of ASP with non-Herbrand functions, called ASP{f}, that supports partial functions and is computationally more efficient than [7].",
      "startOffset" : 174,
      "endOffset" : 177
    }, {
      "referenceID" : 0,
      "context" : "In the present paper, we extend the definition of ASP{f} from [1,2] further, by adding to it support for full-fledged arithmetic expressions and for consistency restoring rules from CR-Prolog [3].",
      "startOffset" : 62,
      "endOffset" : 67
    }, {
      "referenceID" : 1,
      "context" : "In the present paper, we extend the definition of ASP{f} from [1,2] further, by adding to it support for full-fledged arithmetic expressions and for consistency restoring rules from CR-Prolog [3].",
      "startOffset" : 62,
      "endOffset" : 67
    }, {
      "referenceID" : 2,
      "context" : "In the present paper, we extend the definition of ASP{f} from [1,2] further, by adding to it support for full-fledged arithmetic expressions and for consistency restoring rules from CR-Prolog [3].",
      "startOffset" : 192,
      "endOffset" : 195
    }, {
      "referenceID" : 0,
      "context" : "In this section we summarize the syntax and the semantics of ASP{f} [1,2], and extend the language with support for arithmetic expressions over non-Herbrand functional terms.",
      "startOffset" : 68,
      "endOffset" : 73
    }, {
      "referenceID" : 1,
      "context" : "In this section we summarize the syntax and the semantics of ASP{f} [1,2], and extend the language with support for arithmetic expressions over non-Herbrand functional terms.",
      "startOffset" : 68,
      "endOffset" : 73
    }, {
      "referenceID" : 11,
      "context" : "It is worth noting that the semantics of ASP{f} is obtained from that of ASP in [12] by simply extending entailment to t-atoms.",
      "startOffset" : 80,
      "endOffset" : 84
    }, {
      "referenceID" : 2,
      "context" : "In this section we extend ASP{f} by consistency-restoring rules from CR-Prolog [3].",
      "startOffset" : 79,
      "endOffset" : 82
    }, {
      "referenceID" : 4,
      "context" : "the lines of [5], the reading of (13) is “if P ’s maximum life span may be 92, then it is 92.",
      "startOffset" : 13,
      "endOffset" : 16
    }, {
      "referenceID" : 9,
      "context" : "A discussion on this topic and proposals for more sophisticated formalizations can be found in [10,11].",
      "startOffset" : 95,
      "endOffset" : 102
    }, {
      "referenceID" : 10,
      "context" : "A discussion on this topic and proposals for more sophisticated formalizations can be found in [10,11].",
      "startOffset" : 95,
      "endOffset" : 102
    }, {
      "referenceID" : 13,
      "context" : "It is currently a source of debate [14,7] whether support for partial functions should be allowed in languages with non-Herbrand functions.",
      "startOffset" : 35,
      "endOffset" : 41
    }, {
      "referenceID" : 6,
      "context" : "It is currently a source of debate [14,7] whether support for partial functions should be allowed in languages with non-Herbrand functions.",
      "startOffset" : 35,
      "endOffset" : 41
    }, {
      "referenceID" : 9,
      "context" : "When reasoning by cases, it is not possible to reason about this circumstance from within the program, unless rather sophisticated extensions of ASP such as [10,11] are used.",
      "startOffset" : 157,
      "endOffset" : 164
    }, {
      "referenceID" : 10,
      "context" : "When reasoning by cases, it is not possible to reason about this circumstance from within the program, unless rather sophisticated extensions of ASP such as [10,11] are used.",
      "startOffset" : 157,
      "endOffset" : 164
    }, {
      "referenceID" : 12,
      "context" : "[13]), which can be circumvented by properly prioritizing the defaults of Π 2.",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 6,
      "context" : "A similar phenomenon can be observed in the encodings based on the languages of [7,14], since in those approaches computation of the answer sets is performed by translating the programs to ASP.",
      "startOffset" : 80,
      "endOffset" : 86
    }, {
      "referenceID" : 13,
      "context" : "A similar phenomenon can be observed in the encodings based on the languages of [7,14], since in those approaches computation of the answer sets is performed by translating the programs to ASP.",
      "startOffset" : 80,
      "endOffset" : 86
    }, {
      "referenceID" : 6,
      "context" : "As in the previous scenario, we expect a similar growth for comparable CLINGCON encodings, and a growth of O(n) for the grounding of the encodings written in the languages of [7,14].",
      "startOffset" : 175,
      "endOffset" : 181
    }, {
      "referenceID" : 13,
      "context" : "As in the previous scenario, we expect a similar growth for comparable CLINGCON encodings, and a growth of O(n) for the grounding of the encodings written in the languages of [7,14].",
      "startOffset" : 175,
      "endOffset" : 181
    }, {
      "referenceID" : 0,
      "context" : "In the previous section, the discussion on the efficiency of computation was based only on the size of the grounding of the corresponding encodings, but in [1] experimental evidence on solver performance was obtained using a prototype of an ASP{f} solver (available at http://marcy.",
      "startOffset" : 156,
      "endOffset" : 159
    } ],
    "year" : 2013,
    "abstractText" : "In this paper we continue the work on our extension of Answer Set Programming by non-Herbrand functions and add to the language support for arithmetic expressions and various inequality relations over non-Herbrand functions, as well as consistency-restoring rules from CR-Prolog. We demonstrate the use of this latest version of the language in the representation of important kinds of knowledge.",
    "creator" : "LaTeX with hyperref package"
  }
}