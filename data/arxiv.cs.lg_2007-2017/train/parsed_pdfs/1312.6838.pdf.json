{
  "name" : "1312.6838.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : "Greedy Column Subset Selection for Large-scale Data Sets",
    "authors" : [ "Ahmed K. Farahat", "Ahmed Elgohary", "Ali Ghodsi", "Mohamed S. Kamel" ],
    "emails" : [ "afarahat@uwaterloo.ca", "aelgohary@uwaterloo.ca", "aghodsib@uwaterloo.ca", "mkamel@uwaterloo.ca" ],
    "sections" : [ {
      "heading" : null,
      "text" : "Ahmed K. Farahat Department of Electrical and Computer Engineering University of Waterloo Waterloo, Ontario, Canada N2L 3G1 Tel.: +1 519-888-4567 E-mail: afarahat@uwaterloo.ca\nAhmed Elgohary Department of Electrical and Computer Engineering University of Waterloo Waterloo, Ontario, Canada N2L 3G1 Tel.: +1 519-888-4567 E-mail: aelgohary@uwaterloo.ca\nAli Ghodsi Department of Statistics and Actuarial Science University of Waterloo Waterloo, Ontario, Canada N2L 3G1 Tel.: +1 519-888-4567 x37316 E-mail: aghodsib@uwaterloo.ca\nMohamed S. Kamel Department of Electrical and Computer Engineering University of Waterloo Waterloo, Ontario, Canada N2L 3G1 Tel.: +1 519-888-4567 x35761 E-mail: mkamel@uwaterloo.ca\nar X\niv :1\n31 2.\n68 38\nv1 [\ncs .D\nS] 2\n4 D\nec 2\n01 3\napproximation of the corresponding matrix. This paper presents a fast and accurate greedy algorithm for large-scale column subset selection. The algorithm minimizes an objective function which measures the reconstruction error of the data matrix based on the subset of selected columns. The paper first presents a centralized greedy algorithm for column subset selection which depends on a novel recursive formula for calculating the reconstruction error of the data matrix. The paper then presents a MapReduce algorithm which selects a few representative columns from a matrix whose columns are massively distributed across several commodity machines. The algorithm first learns a concise representation of all columns using random projection, and it then solves a generalized column subset selection problem at each machine in which a subset of columns are selected from the sub-matrix on that machine such that the reconstruction error of the concise representation is minimized. The paper demonstrates the effectiveness and efficiency of the proposed algorithm through an empirical evaluation on benchmark data sets.1\nKeywords Column Subset Selection; Greedy Algorithms; Distributed Computing; Big Data; MapReduce;"
    }, {
      "heading" : "1 Introduction",
      "text" : "Recent years have witnessed the rise of the big data era in computing and storage systems. With the great advances in information and communication technology, hundreds of petabytes of data are generated, transferred, processed and stored every day. The availability of this overwhelming amount of structured and unstructured data creates an acute need to develop fast and accurate algorithms to discover useful information that is hidden in the big data. One of the crucial problems in the big data era is the ability to represent the data and its underlying information in a succinct format.\nAlthough different algorithms for clustering and dimension reduction can be used to summarize big data, these algorithms tend to learn representatives whose meanings are difficult to interpret. For instance, the traditional clustering algorithms such as k-means [32] tend to produce centroids which encode information about thousands of data instances. The meanings of these centroids are hard to interpret. Even clustering methods that use data instances as prototypes, such as k-medoid [36], learn only one representative for each cluster, which is usually not enough to capture the insights of the data instances in that cluster. In addition, using medoids as representatives implicitly assumes that the data points are distributed as clusters and that the number of those clusters are known ahead of time. This assumption is not true for many data sets. On the other hand, traditional dimension reduction algorithms such as Latent Semantic Analysis (LSA) [13] tend to learn a few latent concepts in the feature space. Each of these concepts is represented by a dense vector which combines thousands of features with positive and negative\n1 A preliminary version of this paper appeared as [23]\nweights. This makes it difficult for the data analyst to understand the meaning of these concepts. Even if the goal of representative selection is to learn a low-dimensional embedding of data instances, learning dimensions whose meanings are easy to interpret allows the understanding of the results of the data mining algorithms, such as understanding the meanings of data clusters in the low-dimensional space.\nThe acute need to summarize big data to a format that appeals to data analysts motivates the development of different algorithms to directly select a few representative data instances and/or features. This problem can be generally formulated as the selection of a subset of columns from a data matrix, which is formally known as the Column Subset Selection (CSS) problem [26], [19] [6] [5] [3]. Although many algorithms have been proposed for tackling the CSS problem, most of these algorithms focus on randomly selecting a subset of columns with the goal of using these columns to obtain a low-rank approximation of the data matrix. In this case, these algorithms tend to select a relatively large number of columns. When the goal is to select a very few columns to be directly presented to a data analyst or indirectly used to interpret the results of other algorithms, the randomized CSS methods are not going to produce a meaningful subset of columns. One the other hand, deterministic algorithms for CSS, although more accurate, do not scale to work on big matrices with massively distributed columns.\nThis paper addresses the aforementioned problem by first presenting a fast and accurate greedy algorithm for column subset selection. The algorithm minimizes an objective function which measures the reconstruction error of the data matrix based on the subset of selected columns. The paper presents a novel recursive formula for calculating the reconstruction error of the data matrix, and then proposes a fast and accurate algorithm which selects the most representative columns in a greedy manner. The paper then presents a distributed column subset selection algorithm for selecting a very few columns from a big data matrix with massively distributed columns. The algorithm starts by learning a concise representation of the data matrix using random projection. Each machine then independently solves a generalized column subset selection problem in which a subset of columns is selected from the current sub-matrix such that the reconstruction error of the concise representation is minimized. A further selection step is then applied to the columns selected at different machines to select the required number of columns. The proposed algorithm is designed to be executed efficiently over massive amounts of data stored on a cluster of several commodity nodes. In such settings of infrastructure, ensuring the scalability and the fault tolerance of data processing jobs is not a trivial task. In order to alleviate these problems, MapReduce [12] was introduced to simplify large-scale data analytics over a distributed environment of commodity machines. Currently, MapReduce (and its open source implementation Hadoop [47]) is considered the most successful and widely-used framework for managing big data processing jobs. The approach proposed in this paper considers the different aspects of developing MapReduce-efficient algorithms.\nThe contributions of the paper can be summarized as follows:\n– The paper first presents a fast and accurate algorithm for Column Subset Selection (CSS) which selects the most representative columns from a data matrix in a greedy manner. The algorithm minimizes an objective function which measures the reconstruction error of the data matrix based on the subset of selected columns. – The paper presents a novel recursive formula for calculating the reconstruction error of the data matrix based on the subset of selected columns, and then uses this formula to develop a fast and accurate algorithm for greedy CSS. – The paper proposes an algorithm for distributed CSS which first learns a concise representation of the data matrix and then selects columns from distributed sub-matrices that approximate this concise representation. – To facilitate CSS from different sub-matrices, a fast and accurate algorithm for generalized CSS is proposed. This algorithm greedily selects a subset of columns from a source matrix which approximates the columns of a target matrix. – A MapReduce-efficient algorithm is proposed for learning a concise representation using random projection. The paper also presents a MapReduce algorithm for distributed CSS which only requires two passes over the data with a very low communication overhead. – Medium and large-scale experiments have been conducted on benchmark data sets in which different methods for CSS are compared.\nThe rest of the paper is organized as follows. Section 2 describes the notations used throughout the paper. Section 3 gives a brief background on the CSS problem and the MapReduce framework. Section 4 describes the centralized greedy algorithm for CSS. The proposed MapReduce algorithm for distributed CSS is described in details in Section 5. Section 6 reviews the state-of-the-art CSS methods and their applicability to distributed data. In Section 7, an empirical evaluation of the proposed method is described. Finally, Section 8 concludes the paper."
    }, {
      "heading" : "2 Notations",
      "text" : "The following notations are used throughout the paper unless otherwise indicated. Scalars are denoted by small letters (e.g., m, n), sets are denoted in script letters (e.g., S, R), vectors are denoted by small bold italic letters (e.g., f , g), and matrices are denoted by capital letters (e.g., A, B). The subscript (i) indicates that the variable corresponds to the i-th block of data in the distributed environment. In addition, the following notations are used: For a set S: |S| the cardinality of the set. For a vector x ∈ Rm:\nxi i-th element of x. ‖x‖ the Euclidean norm (`2-norm) of x.\nFor a matrix A ∈ Rm×n: Aij (i, j)-th entry of A. Ai: i-th row of A. A:j j-th column of A. A:S the sub-matrix of A which consists of the set S of columns. AT the transpose of A.\n‖A‖F the Frobenius norm of A: ‖A‖F = √ Σi,jA2ij .\nÃ a low rank approximation of A. ÃS a rank-l approximation of A based on the set S of columns, where |S| = l."
    }, {
      "heading" : "3 Background",
      "text" : "This section reviews the necessary background on the Column Subset Selection (CSS) problem and the MapReduce paradigm used to develop the large-scale CSS algorithm presented in this paper.\n3.1 Column Subset Selection (CSS)\nThe Column Subset Selection (CSS) problem can be generally defined as the selection of the most representative columns of a data matrix [6] [5] [3]. The CSS problem generalizes the problem of selecting representative data instances as well as the unsupervised feature selection problem. Both are crucial tasks, that can be directly used for data analysis or as pre-processing steps for developing fast and accurate algorithms in data mining and machine learning.\nAlthough different criteria for column subset selection can be defined, a common criterion that has been used in much recent work measures the discrepancy between the original matrix and the approximate matrix reconstructed from the subset of selected columns [26] [17] [18] [19] [15] [6] [5] [3] [8]. Most of the recent work either develops CSS algorithms that directly optimize this criterion or uses this criterion to assess the quality of the proposed CSS algorithms. In the present work, the CSS problem is formally defined as\nProblem 1 (Column Subset Selection) Given an m×n matrix A and an integer l, find a subset of columns L such that |L| = l and\nL = arg min S ‖A− P (S)A‖2F ,\nwhere P (S) is an m ×m projection matrix which projects the columns of A onto the span of the candidate columns A:S .\nThe criterion F (S) = ‖A− P (S)A‖2F represents the sum of squared errors between the original data matrix A and its rank-l column-based approximation (where l = |S|),\nÃS = P (S)A . (1)\nIn other words, the criterion F (S) calculates the Frobenius norm of the residual matrix E = A− ÃS . Other types of matrix norms can also be used to quantify the reconstruction error. Some of the recent work on the CSS problem [6] [5] [3] derives theoretical bounds for both the Frobenius and spectral norms of the residual matrix. The present work, however, focuses on developing algorithms that minimize the Frobenius norm of the residual matrix.\nThe projection matrix P (S) can be calculated as\nP (S) = A:S ( AT:SA:S )−1 AT:S , (2)\nwhere A:S is the sub-matrix of A which consists of the columns corresponding to S.\nIt should be noted that if the subset of columns S is known, the projection matrix P (S) can be derived as follows. The columns of the data matrix A can be approximated as linear combinations of the subset of columns S:\nÃS = A:ST ,\nwhere T is an l × n matrix of coefficients which can be found by solving the following optimization problem.\nT ∗ = arg min T ‖A−A:ST‖2F .\nThis is a least-squares problem whose closed-form solution is T ∗ = ( AT:SA:S )−1 AT:SA. Substituting with T ∗ in ÃS gives\nÃS = A:ST = A:S ( AT:SA:S )−1 AT:SA = P (S)A .\nThe set of selected columns (i.e., data instances or features) can be directly presented to a data analyst to learn about the insights of the data, or they can be used to preprocess the data for further analysis. For instance, the selected columns can be used to obtain a low-dimensional representation of all columns into the subspace of selected ones. This representation can be calculated as follows.\n1. Calculate an orthonormal basis Q for the selected columns,\nQ = orth (A:S) ,\nwhere orth (.) is a function that orthogonalizes the columns of its input matrix and Q is an m× l orthogonal matrix whose columns span the range of A:S . The matrix Q can be obtained by applying an orthogonalization algorithm such as the Gram-Schmidt algorithm to the columns of A:S , or by calculating the Singular Value Decomposition (SVD) or the QR decomposition of A:S [27].\n2. Embed all columns of A into the subspace of Q,\nW = QTA , (3)\nwhere W is an l × n matrix whose columns represent an embedding of all columns into the subspace of selected ones.\nThe selected columns can also be used to calculate a column-based lowrank approximation of A [19]. Given a subset S of columns with |S| = l, a rank-l approximation of the data matrix A can be calculated as:\nÃS = P (S)A = A:S ( AT:SA:S )−1 AT:SA . (4)\nIn order to calculate a rank-k approximation of the data matrix A where k ≤ l, the following procedure suggested by Boutsidis et al. [3] can be used.\n1. Calculate an orthonormal basis Q for the columns of A:S and embed all columns of A into the subspace of Q:\nQ = orth (A:S) ,\nW = QTA ,\nwhere Q is an m × l orthogonal matrix whose columns span the range of A:S and W is an l × n matrix whose columns represent an embedding of all columns into the subspace of selected ones. 2. Calculate the best rank-k approximation of the embedded columns using Singular Value Decomposition (SVD):\nW̃k = U (W ) k Σ (W ) k V (W )T k ,\nwhere U (W ) k and V (W ) k are l×k and n×k matrices whose columns represent the leading k left and right singular vectors of W respectively, Σ (W ) k is a k × k matrix whose diagonal elements are the leading k singular values of W , and W̃k is the best rank-k approximation of W .\n3. Calculate the column-based rank-k approximation of A as:\nÃS,k = QW̃k ,\nwhere ÃS,k is a rank-k approximation of A based on the set S of columns.\nThis procedure results in a rank-k approximation of A within the column space of A:S that achieves the minimum reconstruction error in terms of Frobenius norm [3]:\nT ∗ = arg min T, rank(T )=k ‖A−A:ST‖2F .\nMoreover, the leading singular values and vectors of the low-dimensional embedding W can be used to approximate those of the data matrix as follows:\nŨ (A) k = QU (W ) k , Σ̃ (A) k = Σ (W ) k , Ṽ (A) k = V (W ) k (5)\nwhere Ũ (A) k and Ṽ (A) k are l×k and n×k matrices whose columns approximate the leading k left and right singular vectors of A respectively, and Σ̃ (A) k is a k × k matrix whose diagonal elements approximate the leading k singular values of A.\n3.2 MapReduce Paradigm\nMapReduce [12] was presented as a programming model to simplify large-scale data analytics over a distributed environment of commodity machines. The rationale behind MapReduce is to impose a set of constraints on data access at each individual machine and communication between different machines to ensure both the scalability and fault-tolerance of the analytical tasks. Currently, MapReduce has been successfully used for scaling various data analysis tasks such as regression [42], feature selection [45], graph mining [33,48], and most recently kernel k-means clustering [20].\nA MapReduce job is executed in two phases of user-defined data transformation functions, namely, map and reduce phases. The input data is split into physical blocks distributed among the nodes. Each block is viewed as a list of key-value pairs. In the first phase, the key-value pairs of each input block b are processed by a single map function running independently on the node where the block b is stored. The key-value pairs are provided one-by-one to the map function. The output of the map function is another set of intermediate key-value pairs. The values associated with the same key across all nodes are grouped together and provided as an input to the reduce function in the second phase. Different groups of values are processed in parallel on different machines. The output of each reduce function is a third set of key-value pairs and collectively considered the output of the job. It is important to note that the set of the intermediate key-value pairs is moved across the network between the nodes which incurs significant additional execution time when much data are to be moved. For complex analytical tasks, multiple jobs are typically chained together [21] and/or many rounds of the same job are executed on the input data set [22].\nIn addition to the programming model constraints, Karloff et al. [34] defined a set of computational constraints that ensure the scalability and the efficiency of MapReduce-based analytical tasks. These computational constraints limit the used memory size at each machine, the output size of both the map and reduce functions and the number of rounds used to complete a certain tasks.\nThe MapReduce algorithms presented in this paper adhere to both the programming model constraints and the computational constraints. The proposed algorithm aims also at minimizing the overall running time of the distributed column subset selection task to facilitate interactive data analytics."
    }, {
      "heading" : "4 Greedy Column Subset Selection",
      "text" : "The column subset selection criterion presented in Section 3.1 measures the reconstruction error of a data matrix based on the subset of selected columns. The minimization of this criterion is a combinatorial optimization problem whose optimal solution can be obtained inO ( nlmnl ) [5]. This section describes a deterministic greedy algorithm for optimizing this criterion, which extends\nthe greedy method for unsupervised feature selection recently proposed by Farahat et al. [24] [25]. First, a recursive formula for the CSS criterion is presented and then the greedy CSS algorithm is described in details.\n4.1 Recursive Selection Criterion\nThe recursive formula of the CSS criterion is based on a recursive formula for the projection matrix P (S) which can be derived as follows.\nLemma 1 Given a set of columns S. For any P ⊂ S,\nP (S) = P (P) +R(R) ,\nwhere R(R) is a projection matrix which projects the columns of E = A−P (P)A onto the span of the subset R = S \\ P of columns,\nR(R) = E:R ( ET:RE:R )−1 ET:R .\nProof Define a matrix B = AT:SA:S which represents the inner-product over the columns of the sub-matrix A:S . The projection matrix P\n(S) can be written as:\nP (S) = A:SB −1AT:S . (6)\nWithout loss of generality, the columns and rows of A:S and B in Equation (6) can be rearranged such that the first sets of rows and columns correspond to P:\nA:S = [ A:P A:R ] , B = [ BPP BPR BTPR BRR ] ,\nwhere BPP = A T :PA:P , BPR = A T :PA:R and BRR = A T :RA:R.\nLet S = BRR − BTPRB −1 PPBPR be the Schur complement [41] of BPP in\nB. Using the block-wise inversion formula [41], B−1 can be calculated as:\nB−1 =\n[ B−1PP +B −1 PPBPRS −1BTPRB −1 PP −B −1 PPBPRS −1\n−S−1BTPRB −1 PP S −1 ] Substitute with A:S and B −1 in Equation (6):\nP (S) = [ A:P A:R ] [B−1PP +B−1PPBPRS−1BTPRB−1PP −B−1PPBPRS−1 −S−1BTPRB −1 PP S −1 ]AT:P AT:R  =A:PB −1 PPA T :P +A:PB −1 PPBPRS −1BTPRB −1 PPA T :P −A:PB−1PPBPRS −1AT:R\n−A:RS−1BTPRB−1PPA T :P +A:RS −1AT:R .\nTake out A:PB −1 PPBPRS −1 as a common factor from the 2nd and 3rd terms, and A:RS −1 from the 4th and 5th terms:\nP (S) =A:PB −1 PPA T :P −A:PB−1PPBPRS −1 (AT:R −BTPRB−1PPAT:P) +A:RS −1 (AT:R −BTPRB−1PPAT:P) .\nTake out S−1 ( AT:R −BTPRB −1 PPA T :P )\nas a common factor from the 2nd and 3rd terms:\nP (S) = A:PB −1 PPA T :P + ( A:R −A:PB−1PPBPR ) S−1 ( AT:R −BTPRB−1PPA T :P ) .\n(7)\nThe first term of Equation (7) is the projection matrix which projects the columns ofA onto the span of the subset P of columns: P (P) = A:P ( AT:PA:P )−1 AT:P = A:PB −1 PPA T :P . The second term can be simplified as follows. Let E be an m×n residual matrix which is calculated as: E = A − P (P)A. The sub-matrix E:R can be expressed as:\nE:R = A:R−P (P)A:R = A:R−A:P ( AT:PA:P )−1 AT:PA:R = A:R−A:PB−1PPBPR.\nSince projection matrices are idempotent, then P (P)P (P) = P (P) and the inner-product ET:RE:R can be expressed as:\nET:RE:R = ( A:R − P (P)A:R )T ( A:R − P (P)A:R ) =AT:RA:R −AT:RP (P)A:R −AT:RP (P)A:R +AT:RP (P)P (P)A:R =AT:RA:R −AT:RP (P)A:R .\nSubstituting with P (P) = A:P ( AT:PA:P )−1 AT:P gives\nET:RE:R = A T :RA:R −AT:RA:P ( AT:PA:P )−1 AT:PA:R = BRR −BTPRB−1PPBPR = S .\nSubstituting ( A:PB −1 PPA T :P ) , ( A:R −A:PB−1PPBPR ) and S with P (P), E:R and ET:RE:R respectively, Equation (7) can be expressed as:\nP (S) = P (P) + E:R ( ET:RE:R )−1 ET:R .\nThe second term is the projection matrix which projects the columns of E onto the span of the subset R of columns:\nR(R) = E:R ( ET:RE:R )−1 ET:R . (8)\nThis proves that P (S) can be written in terms of P (P) and R as: P (S) = P (P) +R(R)\nThis means that projection matrix P (S) can be constructed in a recursive manner by first calculating the projection matrix which projects the columns of A onto the span of the subset P of columns, and then calculating the projection matrix which projects the columns of the residual matrix onto the span of the remaining columns. Based on this lemma, a recursive formula can be developed for ÃS .\nCorollary 1 Given a matrix A and a subset of columns S. For any P ⊂ S,\nÃS = ÃP + ẼR ,\nwhere E = A− P (P)A, and ẼR is the low-rank approximation of E based on the subset R = S \\ P of columns.\nProof Using Lemma (1), and substituting with P (S) in Equation (1) gives:\nÃS = P (P)A+ E:R ( ET:RE:R )−1 ET:RA . (9)\nThe first term is the low-rank approximation of A based on P: ÃP = P (P)A. The second term is equal to ẼR as E T :RA = E T :RE. To prove that, multiplying ET:R by E = A− P (P)A gives:\nET:RE = E T :RA− ET:RP (P)A .\nUsing E:R = A:R − P (P)A:R, the expression ET:RP (P) can be written as:\nET:RP (P) = AT:RP (P) −AT:RP (P)P (P) .\nThis is equal to 0 as P (P)P (P) = P (P) (an idempotent matrix). This means that ET:RA = E T :RE. Substituting E T :RA with E T :RE in Equation (9) proves the corollary. This means that the column-based low-rank approximation of A based on the subset S of columns can be calculated in a recursive manner by first calculating the low-rank approximation of A based on the subset P ⊂ S, and then calculating the low-rank approximation of the residual matrix E based on the remaining columns.\nBased on Corollary (1), a recursive formula for the column subset selection criterion can be developed as follows.\nTheorem 1 Given a set of columns S. For any P ⊂ S,\nF (S) = F (P)− ‖ẼR‖2F ,\nwhere E = A− P (P)A, and ẼR is the low-rank approximation of E based on the subset R = S \\ P of columns.\nProof Using Corollary (1), the CSS criterion can be expressed as:\nF (S) = ∥∥∥A− ÃS∥∥∥2 F = ∥∥∥A− ÃP − ẼR∥∥∥2 F\n= ∥∥∥E − ẼR∥∥∥2 F = ∥∥∥E −R(R)E∥∥∥2 F .\nUsing the relation between the Frobenius norm and the trace function,2 the right-hand side can be expressed as:∥∥∥E −R(R)E∥∥∥2\nF = trace\n(( E −R(R)E )T ( E −R(R)E )) = trace ( ETE − 2ETR(R)E + ETR(R)R(R)E ) .\n2 ‖A‖2F = trace ( ATA )\nAs R(R)R(R) = R(R) (an idempotent matrix), F (S) can be expressed as: F (S) = trace ( ETE − ETR(R)R(R)E ) = trace ( ETE − ẼRẼR ) = ‖E‖2F−‖ẼR‖2F .\nReplacing ‖E‖2F with F (P) proves the theorem. The term ‖ẼR‖2F represents the decrease in reconstruction error achieved by adding the subset R of columns to P. In the following section, a novel greedy heuristic is presented to optimize the column subset selection criterion based on this recursive formula.\n4.2 Greedy Selection Algorithm\nThis section presents an efficient greedy algorithm to optimize the column subset selection criterion presented in Section 3.1. The algorithm selects at each iteration one column such that the reconstruction error for the new set of columns is minimized. This problem can be formulated as follows:\nProblem 2 At iteration t, find column p such that,\np = arg min i\nF (S ∪ {i}) (10)\nwhere S is the set of columns selected during the first t− 1 iterations.\nA näıve implementation of the greedy algorithm is to calculate the reconstruction error for each candidate column, and then select the column with the smallest error. This implementation is, however, computationally very complex, as it requires O(m2n2) floating-point operations per iteration. A more efficient approach is to use the recursive formula for calculating the reconstruction error. Using Theorem 3,\nF (S ∪ {i}) = F (S)− ‖Ẽ{i}‖2F ,\nwhere E = A − ÃS and Ẽ{i} is the rank-1 approximation of E based on the candidate column i. Since F (S) is a constant for all candidate columns, an equivalent criterion is:\np = arg max i\n‖Ẽ{i}‖2F (11)\nThis formulation selects the column p which achieves the maximum decrease in reconstruction error. Using the properties that: trace (AB) = trace (BA) and trace (aA) = a trace (A) where a is a scalar, the new objective function∥∥∥Ẽ{i}∥∥∥2\nF can be simplified as follows:∥∥∥Ẽ{i}∥∥∥2\nF = trace\n( ẼT{i}Ẽ{i} ) = trace ( ETR({i})E ) = trace ( ETE:i ( ET:iE:i )−1 ET:iE\n) = 1\nET:iE:i trace\n( ETE:iE T :iE ) = ∥∥ETE:i∥∥2 ET:iE:i .\nThis defines the following equivalent problem.\nProblem 3 (Greedy Column Subset Selection) At iteration t, find column p such that,\np = arg max i ∥∥ETE:i∥∥2 ET:iE:i\n(12)\nwhere E = A− ÃS , and S is the set of columns selected during the first t− 1 iterations.\nThe computational complexity of this selection criterion is O ( n2m ) per iteration, and it requires O (nm) memory to store the residual of the whole matrix, E, after each iteration. In order to reduce these memory requirements, a memory-efficient algorithm can be proposed calculate the column subset selection criterion without explicitly calculating and storing the residual matrix E at each iteration. The algorithm is based on a recursive formula for calculating the residual matrix E.\nLet S(t) denote the set of columns selected during the first t− 1 iterations, E(t) denote the residual matrix at the start of the t-th iteration (i.e., E(t) = A− ÃS(t)), and p(t) be the column selected at iteration t. The following lemma gives a recursive formula for residual matrix at the start of iteration t + 1, E(t+1).\nLemma 2 E(t+1) can be calculated recursively as:\nE(t+1) = ( E − E:pE T :p\nET:pE:p E\n)(t) . (13)\nProof Using Corollary 1, ÃS∪{p} = ÃS + Ẽ{p}. Subtracting both sides from A, and substituting A− ÃS∪{p} and A− ÃS with E(t+1) and E(t) respectively gives:\nE(t+1) = ( E − Ẽ{p} )(t) Using Equations (1) and (2), Ẽ{p} can be expressed as ( E:p(E T :pE:p) −1ET:p ) E. Substituting Ẽ{p} with this formula in the above equation proves the lemma.\nLet G be an n × n matrix which represents the inner-products over the columns of the residual matrix E: G = ETE. The following corollary is a direct result of Lemma 2.\nCorollary 2 G(t+1) can be calculated recursively as:\nG(t+1) = ( G− G:pG T :p\nGpp\n)(t) .\nProof This corollary can be proved by substituting with E(t+1) T (Lemma 2) in G(t+1) = E(t+1) T\nE(t+1), and using the fact that R({p})R({p}) = R({p}) (an idempotent matrix).\nTo simplify the derivation of the memory-efficient algorithm, at iteration t, define δ = G:p and ω = G:p/ √ Gpp = δ/ √ δp. This means that G (t+1) can be calculated in terms of G(t) and ω(t) as follows:\nG(t+1) = ( G− ωωT )(t) , (14)\nor in terms of A and previous ω’s as:\nG(t+1) = ATA− t∑\nr=1\n( ωωT )(r) . (15)\nδ(t) and ω(t) can be calculated in terms of A and previous ω’s as follows:\nδ(t) = ATA:p − t−1∑ r=1 ω(r)p ω (r),\nω(t) = δ(t)/ √ δ(t)p .\n(16)\nThe column subset selection criterion can be expressed in terms of G as:\np = arg max i\n‖G:i‖2\nGii\nThe following theorem gives recursive formulas for calculating the column subset selection criterion without explicitly calculating E or G.\nTheorem 2 Let f i = ‖G:i‖ 2 and gi = Gii be the numerator and denominator of the criterion function for column i respectively, f = [f i]i=1..n, and g = [gi]i=1..n. Then,\nf (t) = ( f − 2 ( ω ◦ ( ATAω −Σt−2r=1 ( ω(r) T ω ) ω (r) )) + ‖ω‖2 (ω ◦ ω) )(t−1) ,\ng(t) = ( g − (ω ◦ ω) )(t−1) .\nwhere ◦ represents the Hadamard product operator.\nProof Based on Equation (14), f (t) i can be calculated as:\nf (t) i = ( ‖G:i‖2 )(t) = ( ‖G:i − ωiω‖2 )(t−1) = ( (G:i − ωiω)T (G:i − ωiω)\n)(t−1) = ( GT:iG:i − 2ωiGT:iω + ω2i ‖ω‖2\n)(t−1) = ( f i − 2ωiGT:iω + ω2i ‖ω‖2 )(t−1) .\n(17)\nAlgorithm 1 Greedy Column Subset Selection Input: Data matrix A, Number of columns l Output: Selected subset of columns S 1: Initialize S = { } 2: Initialize f\n(0) i = ‖A TA:i‖2, g (0) i = A T :iA:i for i = 1 ... n\n3: Repeat t = 1→ l: 4: p = arg max\ni f\n(t) i /g (t) i , S = S ∪ {p}\n5: δ(t) = ATA:p − ∑t−1 r=1 ω (r) p ω (r) 6: ω(t) = δ(t)/ √ δ (t) p 7: Update f i’s, gi’s (Theorem 2)\nSimilarly, g (t) i can be calculated as:\ng (t) i = G (t) ii = ( Gii − ω2i )(t−1) = ( gi − ω2i )(t−1) .\n(18)\nLet f = [f i]i=1..nand g = [gi]i=1..n, f (t) and g(t) can be expressed as:\nf (t) = ( f − 2 (ω ◦Gω) + ‖ω‖2 (ω ◦ ω) )(t−1) , g(t) = (g − (ω ◦ ω))(t−1) , (19)\nwhere ◦ represents the Hadamard product operator, and ‖.‖ is the `2 norm. Based on the recursive formula of G (Eq. 15), the term Gω at iteration (t− 1) can be expressed as:\nGω = ( ATA−Σt−2r=1 ( ωωT )(r)) ω\n= ATAω −Σt−2r=1 ( ω(r) T ω ) ω (r) (20)\nSubstituting with Gω in Equation (19) gives the update formulas for f and g.\nThis means that the greedy criterion can be memory-efficient by only maintaining two score variables for each column, f i and gi, and updating them at each iteration based on their previous values and the columns selected so far.\nAlgorithm 1 shows the complete greedy CSS algorithm."
    }, {
      "heading" : "5 Distributed Column Subset Selection on MapReduce",
      "text" : "This section describes a MapReduce algorithm for the distributed column subset selection problem. Given a big data matrix A whose columns are distributed across different machines, the goal is to select a subset of columns S from A such that the CSS criterion F (S) is minimized.\nOne näıve approach to perform distributed column subset selection is to select different subsets of columns from the sub-matrices stored on different\nmachines. The selected subsets are then sent to a centralized machine where an additional selection step is optionally performed to filter out irrelevant or redundant columns. Let A(i) be the sub-matrix stored at machine i, the näıve approach optimizes the following function.\nc∑ i=1 ∥∥∥A(i) − P (L(i))A(i)∥∥∥2 F , (21)\nwhere L(i) is the set of columns selected from A(i) and c is the number of physical blocks of data. The resulting set of columns is the union of the sets selected from different sub-matrices: L = ∪ci=1L(i). The set L can further be reduced by invoking another selection process in which a smaller subset of columns is selected from A:L.\nThe näıve approach, however simple, is prone to missing relevant columns. This is because the selection at each machine is based on approximating a local sub-matrix, and accordingly there is no way to determine whether the selected columns are globally relevant or not. For instance, suppose the extreme case where all the truly representative columns happen to be loaded on a single machine. In this case, the algorithm will select a less-than-required number of columns from that machine and many irrelevant columns from other machines.\nIn order to alleviate this problem, the different machines have to select columns that best approximate a common representation of the data matrix. To achieve that, the proposed algorithm first learns a concise representation of the span of the big data matrix. This concise representation is relatively small and it can be sent over to all machines. After that each machine can select columns from its sub-matrix that approximate this concise representation. The proposed algorithm uses random projection to learn this concise representation, and proposes a generalized Column Subset Selection (CSS) method to select columns from different machines. The details of the proposed methods are explained in the rest of this section.\n5.1 Random Projection\nThe first step of the proposed algorithm is to learn a concise representation B for a distributed data matrixA. In the proposed approach, a random projection method is employed. Random projection [11] [1] [40] is a well-known technique for dealing with the curse-of-the-dimensionality problem. Let Ω be a random projection matrix of size n × r, and given a data matrix X of size m × n, the random projection can be calculated as Y = XΩ. It has been shown that applying random projection Ω to X preserves the pairwise distances between vectors in the row space of X with a high probability [11]:\n(1− ) ‖Xi: −Xj:‖ ≤ ‖Xi:Ω −Xj:Ω‖ ≤ (1 + ) ‖Xi: −Xj:‖ ,\n(22)\nwhere is an arbitrarily small factor.\nSince the CSS criterion F (S) measures the reconstruction error between the big data matrix A and its low-rank approximation P (S)A, it essentially measures the sum of the distances between the original rows and their approximations. This means that when applying random projection to both A and P (S)A, the reconstruction error of the original data matrix A will be approximately equal to that of AΩ when both are approximated using the subset of selected columns:\n‖A− P (S)A‖2F ≈ ‖AΩ − P (S)AΩ‖2F . (23)\nSo, instead of optimizing ‖A − P (S)A‖2F , the distributed CSS can approximately optimize ‖AΩ − P (S)AΩ‖2F .\nLet B = AΩ, the distributed column subset selection problem can be formally defined as\nProblem 4 (Distributed Column Subset Selection) Given an m × n(i) sub-matrix A(i) which is stored at node i and an integer l(i), find a subset of columns L(i) such that |L(i)| = l(i) and\nL(i) = arg min S ‖B − P (S)B‖2F ,\nwhere B = AΩ, Ω is an n × r random projection matrix, S is the set of the indices of the candidate columns and L(i) is the set of the indices of the selected columns from A(i).\nA key observation here is that random projection matrices whose entries are sampled i.i.d from some univariate distribution Ψ can be exploited to compute random projection on MapReduce in a very efficient manner. Examples of such matrices are Gaussian random matrices [11], uniform random sign (±1) matrices [1], and sparse random sign matrices [40].\nIn order to implement random projection on MapReduce, the data matrix A is distributed in a column-wise fashion and viewed as pairs of 〈i, A:i〉 where A:i is the i-th column of A. Recall that B = AΩ can be rewritten as\nB = n∑ i=1 A:iΩi: (24)\nand since the map function is provided one columns of A at a time, one does not need to worry about pre-computing the full matrix Ω. In fact, for each input column A:i, a new vector Ωi: needs to be sampled from Ψ . So, each input column generates a matrix of size m× r which means that O(nmr) data should be moved across the network to sum the generated n matrices at m independent reducers each summing a row Bj: to obtain B. To minimize that network cost, an in-memory summation can be carried out over the generated m×r matrices at each mapper. This can be done incrementally after processing each column of A. That optimization reduces the network cost to O(cmr),\nAlgorithm 2 Fast Random Projection on MapReduce Input: Data matrix A, Univariate distribution Ψ , Number of dimensions r Output: Concise representation B = AΩ, Ωij ∼ Ψ ∀i, j 1: map:\n2: B̄ = [0]m×r 3: foreach 〈i, A:i〉 4: Generate v = [v1,v2, ...vr], vj ∼ Ψ 5: B̄ = B̄ +A:iv 6: for j = 1 to m 7: emit 〈j, B̄j:〉\n8: reduce: 9: foreach 〈j, [ [B̄(1)]j:, [B̄(2)]j:, ..., [B̄(c)]j: ] 〉\n10: Bj: = ∑c i=1[B̄(i)]j: 11: emit 〈j, Bj:〉\nwhere c is the number of physical blocks of the matrix3. Algorithm 2 outlines the proposed random projection algorithm. The term emit is used to refer to outputting new 〈key, value〉 pairs from a mapper or a reducer.\n5.2 Generalized Column Subset Selection\nThis section presents the generalized column subset selection algorithm which will be used to perform the selection of columns at different machines. While Problem 1 is concerned with the selection of a subset of columns from a data matrix which best represent other columns of the same matrix, Problem 4 selects a subset of columns from a source matrix which best represent the columns of a different target matrix. The objective function of Problem 4 represents the reconstruction error of the target matrix B based on the selected\ncolumns from the source matrix. and the term P (S) = A:S ( AT:SA:S )−1 AT:S is the projection matrix which projects the columns of B onto the subspace of the columns selected from A.\nIn order to optimize this new criterion, a greedy algorithm can be introduced. Let F̄ (S) = ∥∥B − P (S)B∥∥2\nF be the distributed CSS criterion, the\nfollowing theorem derives a recursive formula for F̄ (S).\nTheorem 3 Given a set of columns S. For any P ⊂ S,\nF̄ (S) = F̄ (P)− ∥∥∥F̃R∥∥∥2\nF ,\nwhere F = B − P (P)B, and F̃R is the low-rank approximation of F based on the subset R = S \\ P of columns of E = A− P (P)A.\n3 The in-memory summation can also be replaced by a MapReduce combiner [12].\nProof Using the recursive formula for the low-rank approximation of A: ÃS = ÃP + ẼR, and multiplying both sides with Ω gives\nÃSΩ = ÃPΩ + ẼRΩ .\nLow-rank approximations can be written in terms of projection matrices as\nP (S)AΩ = P (P)AΩ +R(R)EΩ .\nUsing B = AΩ, P (S)B = P (P)B +R(R)EΩ .\nLet F = EΩ. The matrix F is the residual after approximating B using the set P of columns\nF = EΩ = ( A− P (P)A ) Ω = AΩ − P (P)AΩ = B − P (P)B .\nThis means that P (S)B = P (P)B +R(R)F\nSubstituting in F̄ (S) = ∥∥B − P (S)B∥∥2\nF gives F̄ (S) = ∥∥∥B − P (P)B −R(R)F∥∥∥2\nF\nUsing F = B − P (P)B gives F̄ (S) = ∥∥∥F −R(R)F∥∥∥2\nF\nUsing the relation between Frobenius norm and trace, F̄ (S) = trace (( F −R(R)F )T ( F −R(R)F ))\n= trace ( FTF − 2FTR(R)F + FTR(R)R(R)F ) = trace ( FTF − FTR(R)F ) = ‖F‖2F − ∥∥∥R(R)F∥∥∥2 F\nUsing F̄ (P) = ‖F‖2F and F̃R = R(R)F proves the theorem. Using the recursive formula for F̄ (S ∪ {i}) allows the development of a greedy algorithm which at iteration t optimizes\np = arg min i F̄ (S ∪ {i}) = arg max i ∥∥∥F̃{i}∥∥∥2 F\n(25)\nLet G = ETE and H = FTE, the objective function of this optimization problem can be simplified as follows.∥∥∥F̃{i}∥∥∥2 F = ∥∥∥E:i (ET:iE:i)−1ET:iF∥∥∥2 F\n= trace ( FTE:i ( ET:iE:i )−1 ET:iF ) =\n∥∥FTE:i∥∥2 ET:iE:i = ‖H:i‖2 Gii .\n(26)\nThis allows the definition of the following generalized CSS problem.\nAlgorithm 3 Greedy Generalized Column Subset Selection Input: Source matrix A, Target matrix B, Number of columns l Output: Selected subset of columns S 1: Initialize f\n(0) i = ‖B TA:i‖2, g (0) i = A T :iA:i for i = 1 ... n\n2: Repeat t = 1→ l: 3: p = arg max\ni f\n(t) i /g (t) i , S = S ∪ {p}\n4: δ(t) = ATA:p − ∑t−1 r=1 ω (r) p ω (r)\n5: γ(t) = BTA:p − ∑t−1 r=1 ω (r) p υ (r) 6: ω(t) = δ(t)/ √ δ (t) p , υ (t) = γ(t)/ √ δ (t) p 7: Update f i’s, gi’s (Theorem 4)\nProblem 5 (Greedy Generalized CSS) At iteration t, find column p such that\np = arg max i\n‖H:i‖2\nGii\nwhere H = FTE, G = ETE, F = B − P (S)B, E = A − P (S)A and S is the set of columns selected during the first t− 1 iterations.\nFor iteration t, define γ = H:p and υ = H:p/ √ Gpp = γ/ √ δp . The vector γ(t) can be calculated in terms of A, B and previous ω’s and υ’s as\nγ(t) = BTA:p − ∑t−1 r=1 ω (r) p υ(r) .\nSimilarly, the numerator and denominator of the selection criterion at each iteration can be calculated in an efficient manner using the following theorem.\nTheorem 4 Let f i = ‖H:i‖ 2 and gi = Gii be the numerator and denominator of the greedy criterion function for column i respectively, f = [f i]i=1..n, and g = [gi]i=1..n. Then,\nf (t) = ( f − 2 ( ω ◦ ( ATBυ −Σt−2r=1 ( υ(r)Tυ ) ω (r) )) + ‖υ‖2 (ω ◦ ω) )(t−1) ,\ng(t) = ( g − (ω ◦ ω) )(t−1) ,\nwhere ◦ represents the Hadamard product operator.\nAs outlined in Section 5.1, the algorithm’s distribution strategy is based on sharing the concise representation of the data B among all mappers. Then, independent l(b) columns from each mapper are selected using the generalized CSS algorithm. A second phase of selection is run over the ∑c b=1 l(b) (where c is the number of input blocks) columns to find the best l columns to represent B. Different ways can be used to set l(b) for each input block b. In the context of this paper, the set of l(b) is assigned uniform values for all blocks (i.e. l(b) = bl/cc∀b ∈ 1, 2, ..c). Algorithm 4 sketches the MapReduce implementation of the distributed CSS algorithm. It should be emphasized that the proposed MapReduce algorithm requires only two passes over the data set and its moves a very few amount of the data across the network.\nAlgorithm 4 Distributed CSS on MapReduce Input: Matrix A of size m× n, Concise representation B, Number of columns l Output: Selected columns C\n1: map:\n2: A(b) = [ ] 3: foreach 〈i, A:i〉 4: A(b) = [A(b) A:i] 5: S̄ = GeneralizedCSS(A(b), B, l(b)) 6: foreach j in S̄ 7: emit 〈0, [A(b)]:j〉\n8: reduce: 9: For all values {[A(1)]:S̄(1) , [A(2)]:S̄(2) , ...., [A(c)]:S̄(c)}\n10: A(0) = [ [A(1)]:S̄(1) , [A(2)]:S̄(2) , ...., [A(c)]:S̄(c) ] 11: S = GeneralizedCSS (A(0), B, l) 12: foreach j in S 13: emit 〈0, [A(0)]:j〉"
    }, {
      "heading" : "6 Related Work",
      "text" : "Different approaches have been proposed for selecting a subset of representative columns from a data matrix. This section focuses on briefly describing these approaches and their applicability to massively distributed data matrices. The Column Subset Selection (CSS) methods can be generally categorized into randomized, deterministic and hybrid.\n6.1 Randomized Methods\nThe randomized methods sample a subset of columns from the original matrix using carefully chosen sampling probabilities. The main focus of this category of methods is to develop fast algorithms for column subset selection and then derive a bound for the reconstruction error of the data matrix based on the selected columns relative to the best possible reconstruction error obtained using Singular Value Decomposition (SVD).\nFrieze et al. [26] was the first to suggest the idea of randomly sampling l columns from a matrix and using these columns to calculate a rank-k approximation of the matrix (where l ≥ k). The authors derived an additive bound for the reconstruction error of the data matrix. This work of Frieze et al. was followed by different papers [17] [18] that enhanced the algorithm by proposing different sampling probabilities and deriving better error bounds for the reconstruction error. Drineas et al. [19] proposed a subspace sampling method which samples columns using probabilities proportional to the norms of the rows of the top k right singular vectors of A. The subspace sampling method allows the development of a relative-error bound (i.e., a multiplicative error bound relative to the best rank-k approximation). However, the subspace sam-\npling depends on calculating the leading singular vectors of a matrix which is computationally very complex for large matrices.\nDeshpande et al. [16] [15] proposed an adaptive sampling method which updates the sampling probabilities based on the columns selected so far. This method is computationally very complex, as it depends on calculating the residual of the data matrix after each iteration. In the same paper, Deshpande et al. also proved the existence of a volume sampling algorithm (i.e., sampling a subset of columns based on the volume enclosed by their vectors) which achieves a multiplicative (l+ 1)-approximation. However, the authors did not present a polynomial time algorithm for this volume sampling algorithm.\nColumn subset selection with uniform sampling can be easily implemented on MapReduce. For non-uniform sampling, the efficiency of implementing the selection on MapReduce is determined by how easy are the calculations of the sampling probabilities. The calculations of probabilities that depend on calculating the leading singular values and vectors are time-consuming on MapReduce. On the other hand, adaptive sampling methods are computationally very complex as they depend on calculating the residual of the whole data matrix after each iteration.\n6.2 Deterministic Methods\nThe second category of methods employs a deterministic algorithm for selecting columns such that some criterion function is minimized. This criterion function usually quantifies the reconstruction error of the data matrix based on the subset of selected columns. The deterministic methods are slower, but more accurate, than the randomized ones.\nIn the area of numerical linear algebra, the column pivoting method exploited by the QR decomposition [27] permutes the columns of the matrix based on their norms to enhance the numerical stability of the QR decomposition algorithm. The first l columns of the permuted matrix can be directly selected as representative columns. The Rank-Revealing QR (RRQR) decomposition [9] [28] [2] [43] is a category of QR decomposition methods which permute columns of the data matrix while imposing additional constraints on the singular values of the two sub-matrices of the upper-triangular matrix R corresponding to the selected and non-selected columns. It has been shown that the constrains on the singular values can be used to derive an theoretical guarantee for the column-based reconstruction error according to spectral norm [6].\nBesides methods based on QR decomposition, different recent methods have been proposed for directly selecting a subset of columns from the data matrix. Boutsidis et al. [6] proposed a deterministic column subset selection method which first groups columns into clusters and then selects a subset of columns from each cluster. The authors proposed a general framework in which different clustering and subset selection algorithms can be employed to select a subset of representative columns. Çivril and Magdon-Ismail [7] [8]\npresented a deterministic algorithm which greedily selects columns from the data matrix that best represent the right leading singular values of the matrix. This algorithm, however accurate, depends on the calculation of the leading singular vectors of a matrix, which is computationally very complex for large matrices.\nRecently, Boutsidis et al. [3] presented a column subset selection algorithm which first calculates the top-k right singular values of the data matrix (where k is the target rank) and then uses deterministic sparsification methods to select l ≥ k columns from the data matrix. The authors derived a theoretically near-optimal error bound for the rank-k column-based approximation. Deshpande and Rademacher [14] presented a polynomial-time deterministic algorithm for volume sampling with a theoretical guarantee for l = k. Quite recently, Guruswami and Sinop [29] presented a deterministic algorithm for volume sampling with theoretical guarantee for l > k. The deterministic volume sampling algorithms are, however, more complex than the algorithms presented in this paper, and they are infeasible for large data sets.\nThe deterministic algorithms are more complex to implement on MapReduce. For instance, it is time-consuming to calculate the leading singular values and vectors of a massively distributed matrix or to cluster their columns using k-means. It is also computationally complex to calculate QR decomposition with pivoting. Moreover, the recently proposed algorithms for volume sampling are more complex than other CSS algorithms as well as the one presented in this paper, and they are infeasible for large data sets.\n6.3 Hybrid Methods\nA third category of CSS techniques is the hybrid methods which combine the benefits of both the randomized and deterministic methods. In these methods, a large subset of columns is randomly sampled from the columns of the data matrix and then a deterministic step is employed to reduce the number of selected columns to the desired rank.\nFor instance, Boutsidis et al. [5] proposed a two-stage hybrid algorithm for column subset selection which runs in O ( min ( n2m,nm2 )) . In the first stage, the algorithm samples c = O (l log l) columns based on probabilities calculated using the l-leading right singular vectors. In the second phase, a Rankrevealing QR (RRQR) algorithm is employed to select exactly l columns from the columns sampled in the first stage. The authors suggested repeating the selection process 40 times in order to provably reduce the failure probability. The authors proved a good theoretical guarantee for the algorithm in terms of spectral and Frobenius term. However, the algorithm depends on calculating the leading l right singular vectors which is computationally complex for large data sets.\nThe hybrid algorithms for CSS can be easily implemented on MapReduce if the randomized selection step is MapReduce-efficient and the deterministic\nselection step can be implemented on a single machine. This is usually true if the number of columns selected by the randomized step is relatively small.\n6.4 Comparison to Related Work\nThe greedy column subset selection algorithm presented in Section 4 belongs to the category of deterministic algorithms. In comparison to QR-based methods, the greedy CSS algorithm can be implicitly used to calculate a Q-less incomplete QR factorization of the data matrix A:"
    }, {
      "heading" : "A = QW, AΠ = QWΠ = QR",
      "text" : "where Π is a permutation matrix which sorts the first l columns according to their selection order. The permutation of the columns of the embedding matrix W produces an upper triangular matrix.\nThe greedy CSS algorithm differs from the greedy algorithm proposed by Çivril and Magdon-Ismail [7] [8] in that the latter depends on first calculating the Singular Value Decomposition of the data matrix, which is computationally complex, especially for large matrices. The proposed algorithm is also more efficient than the recently proposed volume sampling algorithms [14] [29].\nIn comparison to other CSS methods, the distributed algorithm proposed in this paper is designed to be MapReduce-efficient. In the selection step, representative columns are selected based on a common representation. The common representation proposed in this work is based on random projection. This is more efficient than the work of Çivril and Magdon-Ismail [8] which selects columns based on the leading singular vectors. In comparison to other deterministic methods, the proposed algorithm is specifically designed to be parallelized which makes it applicable to big data matrices whose columns are massively distributed. On the other hand, the two-step of distributed then centralized selection is similar to that of the hybrid CSS methods. The proposed algorithm however employs a deterministic algorithm at the distributed selection phase which is more accurate than the randomized selection employed by hybrid methods in the first phase."
    }, {
      "heading" : "7 Experiments",
      "text" : "Two sets of experiments have been conducted. The first set of experiments has been conducted on medium-sized data sets in order to evaluate the efficiency and effectiveness of the centralized greedy CSS algorithm in comparison to state-of-the-art methods for CSS. The second set of experiments has been conducted on two big data sets to evaluate the efficiency and effectiveness of the distributed CSS algorithm on MapReduce.\nExperiments have been conducted on eight benchmark data sets, whose properties are summarized in Table 1.4 The first six data sets were used to conduct the centralized experiments. The Reuters-21578 is the training set of the Reuters-21578 collection [38]. The Reviews and LA1 are document data sets from TREC collections.5 The pre-processed versions of Reviews and LA1 that are distributed with the CLUTO Toolkit [35] were used. The MNIST-4K is a subset of the MNIST data set of handwritten digits.6 The PIE-20 and YaleB-38 are pre-processed subsets of the CMU PIE [44] and Extended Yale Face [37] data sets respectively. The PIE-20 and YaleB-38 data sets have been used by He et al. [31] to evaluate different face recognition algorithms. Besides, the distributed experiments were conducted on two data sets. The RCV1-200K is a subset of the RCV1 data set [39] which has been prepared and used by Chen et al. [10] to evaluate parallel spectral clustering algorithms. The TinyImages-1M data set contains 1 million images that were sampled from the 80 million tiny images data set [46] and converted to grayscale.\nSimilar to previous work on CSS, the different methods are evaluated according to their ability to minimize the reconstruction error of the data matrix based on the subset of selected columns. In order to quantify the reconstruction error across different data sets, a relative accuracy measure is defined as\nRelative Accuracy = ‖A− ÃU‖F − ‖A− ÃS‖F ‖A− ÃU‖F − ‖A− Ãl‖F × 100% ,\nwhere ÃU is the rank-l approximation of the data matrix based on a random subset U of columns, ÃS is the rank-l approximation of the data matrix based on the subset S of columns and Ãl is the best rank-l approximation of the data matrix calculated using the Singular Value Decomposition (SVD). This measure compares different methods relative to the uniform sampling as a baseline with higher values indicating better performance.\n4 The data sets Reuters-21578, MNIST-4K, PIE-20 and YaleB-38 are available in MAT format at: http://www.cad.zju.edu.cn/home/dengcai/Data/data.html. PIE-20 is a subset of PIE-32x32 with the images of the first 20 persons.\n5 http://trec.nist.gov 6 http://yann.lecun.com/exdb/mnist\n7.1 Evaluation of Centralized Greedy CSS\nIn the medium-scale experiments, the following CSS methods are compared7.\n– UniNoRep: is uniform sampling of columns without replacement. – qr: is the QR decomposition with column pivoting [27] implemented by\nthe MATLAB qr function.8\n– SRRQR: is the strong rank-revealing QR decomposition [28]. Algorithm 4 of [28] was implemented in MATLAB. In this implementation, the MATLAB qr function is first used to calculate the QR decomposition with column pivoting and then the columns are swapped using the criterion specified by Gu and Eisenstat [28].9 – ApproxSVD: is the sparse approximation of Singular Value Decomposition (SVD) [7] [8]. The algorithm was implemented in MATLAB. The generalized CSS algorithm is used to select columns that best approximates the leading singular vectors. The use of the generalized CSS algorithm is equivalent to, but more efficient than, the algorithm proposed by Çivril and Magdon-Ismail [7] [8]. Since the calculation of exact SVD is computationally complex, the Stochastic SVD algorithm [30] is used to approximate the leading singular values and vectors of the data matrix. This significantly reduces the run time of the original algorithm proposed by Çivril and Magdon-Ismail while achieving comparable accuracy. In this experiment, the number of leading singular vectors is set to l. – HybridCSS: is the hybrid column subset selection algorithm proposed by Bousidis et al. [5]. The number of selected columns in the randomized phase is set to l log (l). The algorithm was implemented in MATLAB. In the randomized phase, the Stochastic SVD is first used to calculate the leading singular vectors, and the approximated singular vectors are then used to calculate the sampling probabilities. In the random phase, the number of leading singular vectors is set to l. In the deterministic phase, the MATLAB qr function is used to select columns.10 – GreedyCSS: is the greedy column subset selection method described in Algorithm 1. – RndGreedyCSS: is the greedy algorithm for the generalized column subset selection in which the target matrix is a random subspace obtained using random projection. Similar to ApproxSVD and HybridCSS, the dimension of the random projection matrix is set to l.\n7 The CSS algorithm of Boutsidis et al. [3] was not included in the comparison as its implementation is not available.\n8 Revision: 5.13.4.7 9 In the implemented code, the efficient recursive formulas in Section 4 of [28] are used to implement the update of QR decomposition and the swapping criterion. 10 In [4] (a newer version of [5]), Boutsidis et al. suggested the use of the SRRQR algorithm [28, Algorithm 4] for the deterministic phase. Although the SRRQR algorithm achieves the theoretical guarantee presented in [5], the MATLAB qr function is used in the conducted experiments as it is much faster and it achieves comparable accuracy for the experimented data sets.\nFor all the data sets, the percentage of selected columns l/n is changed from 1% to 25% with increments of 2% and the relative accuracies and run times are measured.11 Experiments with randomness were repeated ten times, and the average and standard deviation of measures were calculated.\nFigures 1 and 2 show the relative accuracy measures and run times for different CSS methods on the six benchmark data sets.12\nIt can be observed from the figures and tables that for all data sets, the GreedyCSS method significantly outperforms the UniNoRep, qr, SR-\n11 For the MNIST4K data set, the range of l/n values is smaller since the rank of the matrix is very low (i.e., less than the number of pixels). 12 The qr and SRRQR methods both depend on the MATLAB qr function. For the document data sets, the MATLAB qr function takes very long times compared to other methods and accordingly they are not reported in the shown figures.\nRQR, and HybridCSS methods in terms of relative accuracy, and it shows comparable accuracy to the ApproxSVD method. In terms of run times, for most of the data sets, the GreedyCSS scales better than the HybridCSS and ApproxSVD methods.\nOn the other hand, the RndGreedyCSS outperforms the UniNoRep, qr, and SRRQR methods in terms of relative accuracy, and shows comparable accuracy to the HybridCSS method. In terms of run times, the RndGreedyCSS is much more efficient than the HybridCSS method and other methods for all data sets. It should also be noted that the SRRQR method achieves comparable accuracy to the qr method and both methods demonstrate lower approximation accuracies than other deterministic and hybrid methods.\n7.2 Evaluation of Distributed Greedy CSS\nThe distributed CSS method has been compared with different state-of-the-art methods. It should be noted that most of these methods were not designed with the goal of applying them to massively-distributed data, and hence their implementation on MapReduce is not straightforward. However, the designed experiments used the best practices for implementing the different steps of these methods on MapReduce to the best of the authors’ knowledge. In specific, the following distributed CSS algorithms were compared.\n– UniNoRep: is uniform sampling of columns without replacement. This is usually the worst performing method in terms on approximation error and it will be used as a baseline to evaluate methods across different data sets. – HybirdUni, HybirdCol and HybirdSVD: are different distributed variants of the hybrid CSS algorithm which can be implemented efficiently on MapReduce. In the randomized phase, the three methods use probabilities calculated based on uniform sampling, column norms and the norms of the leading singular vectors’ rows, respectively. The number of selected columns in the randomized phase is set to l log (l). In the deterministic phase, the centralized greedy CSS is employed to select exactly l columns from the randomly sampled columns. – DistApproxSVD: is an extension of the centralized algorithm for sparse approximation of Singular Value Decomposition (SVD) [8]. The distributed CSS algorithm presented in this paper (Algorithm 4) is used to select columns that best approximate the leading singular vectors (by setting B = UkΣk). The use of the distributed CSS algorithm extends the original algorithm proposed by Çivril and Magdon-Ismail [8] to work on distributed matrices. In order to allow efficient implementation on MapReduce, the number of leading singular vectors is set of 100. – DistGreedyCSS: is the distributed column subset selection method described in Algorithm 4. For all experiments, the dimension of the random projection matrix is set to 100. This makes the size of the concise representation the same as the DistApproxSVD method. Two types of random matrices are used for random projection: (1) a dense Gaussian random matrix (rnd), and (2) a sparse random sign matrix (ssgn).\nFor the methods that require the calculations of Singular Value Decomposition (SVD), the Stochastic SVD (SSVD) algorithm [30] is used to approximate the leading singular values and vectors of the data matrix. The use of SSVD significantly reduces the run time of the original SVD-based algorithms while achieving comparable accuracy. In the conducted experiments, the SSVD implementation of Mahout was used.\nThe distributed experiments were conducted on Amazon EC213 clusters, which consist of 10 instances for the RCV1-200K data set and 20 instances for the TinyImages-1M data set. Each instance has a 7.5 GB of memory and a two-cores processor. All instances are running Debian 6.0.5 and Hadoop\n13 Amazon Elastic Compute Cloud (EC2): http://aws.amazon.com/ec2\nversion 1.0.3. The data sets were converted into a binary format in the form of a sequence of key-value pairs. Each pair consisted of a column index as the key and a vector of the column entries. That is the standard format used in Mahout14 for storing distributed matrices.\nTable 2 shows the run times and relative accuracies for different CSS methods. It can be observed from the table that for the RCV1-200K data set, the DistGreedyCSS methods (with random Gaussian and sparse random sing matrices) outperforms all other methods in terms of relative accuracies. In addition, the run times of both of them are relatively small compared to the DistApproxSVD method which achieves accuracies that are close to the DistGreedyCSS method. Both the DistApproxSVD and DistGreedyCSS methods achieve very good approximation accuracies compared to randomized and hybrid methods. It should also be noted that using a sparse random sign matrix for random projection takes much less time than a dense Gaussian matrix, while achieving comparable approximation accuracies. Based on this observation, the sparse random matrix has been used with the TinyImages-1M data set.\nFor the TinyImages-1M data set, although the DistApproxSVD achieves slightly higher approximation accuracies than DistGreedyCSS (with sparse random sign matrix), the DistGreedyCSS selects columns in almost one-third of the time. The reason why the DistApproxSVD outperforms DistGreedyCSS for this data set is that its rank is relatively small (less than 1024). This means that using the leading 100 singular values to represent the concise representation of the data matrix captures most of the information in the matrix and accordingly is more accurate than random projection. The DistGreedyCSS however still selects a very good subset of columns in a relatively small time."
    }, {
      "heading" : "8 Conclusion",
      "text" : "This paper proposes a novel algorithm which greedily selects a subset of columns from a data matrix such that reconstruction error of the data matrix is minimized. The algorithm depends on a novel recursive formula for the reconstruction error of the data matrix, which allows a greedy selection criterion to be calculated efficiently at each iteration. This paper also presents an accurate and efficient MapReduce algorithm for selecting a subset of columns from a massively distributed matrix. The algorithm starts by learning a concise representation of the data matrix using random projection. It then selects columns from each sub-matrix that best approximate this concise approximation. A centralized selection step is then performed on the columns selected from different sub-matrices. In order to facilitate the implementation of the proposed method, a novel algorithm for greedy generalized CSS is proposed to perform the selection from different sub-matrices. In addition, the different steps of the algorithms are carefully designed to be MapReduce-efficient.\n14 Mahout is an Apache project for implementing Machine Learning algorithms on Hadoop. See http://mahout.apache.org/.\nExperiments on medium and big data sets demonstrate the effectiveness and efficiency of the proposed algorithm in comparison to other CSS methods when implemented on centralized and distributed data."
    } ],
    "references" : [ {
      "title" : "Database-friendly random projections: Johnson-Lindenstrauss with binary coins",
      "author" : [ "D. Achlioptas" ],
      "venue" : "Journal of computer and System Sciences 66(4), 671–687",
      "citeRegEx" : "1",
      "shortCiteRegEx" : null,
      "year" : 2003
    }, {
      "title" : "Computing rank-revealing QR factorizations of dense matrices",
      "author" : [ "C. Bischof", "G. Quintana-Ort́ı" ],
      "venue" : "ACM Transactions on Mathematical Software (TOMS) 24(2), 226–253",
      "citeRegEx" : "2",
      "shortCiteRegEx" : null,
      "year" : 1998
    }, {
      "title" : "Near optimal column-based matrix reconstruction",
      "author" : [ "C. Boutsidis", "P. Drineas", "M. Magdon-Ismail" ],
      "venue" : "Proceedings of the 52nd Annual IEEE Symposium on Foundations of Computer Science (FOCS’11), pp. 305 –314",
      "citeRegEx" : "3",
      "shortCiteRegEx" : null,
      "year" : 2011
    }, {
      "title" : "An improved approximation algorithm for the column subset selection problem",
      "author" : [ "C. Boutsidis", "M.W. Mahoney", "P. Drineas" ],
      "venue" : "CoRR abs/0812.4293",
      "citeRegEx" : "4",
      "shortCiteRegEx" : null,
      "year" : 2008
    }, {
      "title" : "An improved approximation algorithm for the column subset selection problem",
      "author" : [ "C. Boutsidis", "M.W. Mahoney", "P. Drineas" ],
      "venue" : "Proceedings of the Twentieth Annual ACMSIAM Symposium on Discrete Algorithms (SODA’09), pp. 968–977",
      "citeRegEx" : "5",
      "shortCiteRegEx" : null,
      "year" : 2009
    }, {
      "title" : "Clustered subset selection and its applications on it service metrics",
      "author" : [ "C. Boutsidis", "J. Sun", "N. Anerousis" ],
      "venue" : "Proceedings of the Seventeenth ACM Conference on Information and Knowledge Management (CIKM’08), pp. 599–608",
      "citeRegEx" : "6",
      "shortCiteRegEx" : null,
      "year" : 2008
    }, {
      "title" : "Deterministic sparse column based matrix reconstruction via greedy approximation of SVD",
      "author" : [ "A. Çivril", "M. Magdon-Ismail" ],
      "venue" : "Proceedings of the 19th International Symposium on Algorithms and Computation (ISAAC’08), pp. 414–423. Springer-Verlag",
      "citeRegEx" : "7",
      "shortCiteRegEx" : null,
      "year" : 2008
    }, {
      "title" : "Column subset selection via sparse approximation of SVD",
      "author" : [ "A. Çivril", "M. Magdon-Ismail" ],
      "venue" : "Theoretical Computer Science 421(0), 1 – 14",
      "citeRegEx" : "8",
      "shortCiteRegEx" : null,
      "year" : 2012
    }, {
      "title" : "Rank revealing QR factorizations",
      "author" : [ "T. Chan" ],
      "venue" : "Linear Algebra and Its Applications 88, 67–82",
      "citeRegEx" : "9",
      "shortCiteRegEx" : null,
      "year" : 1987
    }, {
      "title" : "Parallel spectral clustering in distributed systems",
      "author" : [ "W.Y. Chen", "Y. Song", "H. Bai", "C.J. Lin", "E. Chang" ],
      "venue" : "Pattern Analysis and Machine Intelligence, IEEE Transactions on 33(3), 568 –586",
      "citeRegEx" : "10",
      "shortCiteRegEx" : null,
      "year" : 2011
    }, {
      "title" : "An elementary proof of a theorem of Johnson and Lindenstrauss",
      "author" : [ "S. Dasgupta", "A. Gupta" ],
      "venue" : "Random Structures and Algorithms 22(1), 60–65",
      "citeRegEx" : "11",
      "shortCiteRegEx" : null,
      "year" : 2003
    }, {
      "title" : "MapReduce: Simplified data processing on large clusters",
      "author" : [ "J. Dean", "S. Ghemawat" ],
      "venue" : "Communications of the ACM 51(1), 107–113",
      "citeRegEx" : "12",
      "shortCiteRegEx" : null,
      "year" : 2008
    }, {
      "title" : "Indexing by latent semantic analysis",
      "author" : [ "S. Deerwester", "S. Dumais", "G. Furnas", "T. Landauer", "R. Harshman" ],
      "venue" : "Journal of the American Society for Information Science and Technology 41(6), 391–407",
      "citeRegEx" : "13",
      "shortCiteRegEx" : null,
      "year" : 1990
    }, {
      "title" : "Efficient volume sampling for row/column subset selection",
      "author" : [ "A. Deshpande", "L. Rademacher" ],
      "venue" : "Proceedings of the 51st Annual IEEE Symposium on Foundations of Computer Science (FOCS’10), pp. 329 –338",
      "citeRegEx" : "14",
      "shortCiteRegEx" : null,
      "year" : 2010
    }, {
      "title" : "Matrix approximation and projective clustering via volume sampling",
      "author" : [ "A. Deshpande", "L. Rademacher", "S. Vempala", "G. Wang" ],
      "venue" : "Theory of Computing 2(1), 225–247",
      "citeRegEx" : "15",
      "shortCiteRegEx" : null,
      "year" : 2006
    }, {
      "title" : "Matrix approximation and projective clustering via volume sampling",
      "author" : [ "A. Deshpande", "L. Rademacher", "S. Vempala", "G. Wang" ],
      "venue" : "Proceedings of the Seventeenth Annual ACM-SIAM Symposium on Discrete Algorithms (SODA’06), pp. 1117–1126. ACM, New York, NY, USA",
      "citeRegEx" : "16",
      "shortCiteRegEx" : null,
      "year" : 2006
    }, {
      "title" : "Clustering large graphs via the singular value decomposition",
      "author" : [ "P. Drineas", "A. Frieze", "R. Kannan", "S. Vempala", "V. Vinay" ],
      "venue" : "Machine Learning 56(1-3), 9–33",
      "citeRegEx" : "17",
      "shortCiteRegEx" : null,
      "year" : 2004
    }, {
      "title" : "Fast Monte Carlo algorithms for matrices II: Computing a low-rank approximation to a matrix",
      "author" : [ "P. Drineas", "R. Kannan", "M. Mahoney" ],
      "venue" : "SIAM Journal on Computing 36(1), 158–183",
      "citeRegEx" : "18",
      "shortCiteRegEx" : null,
      "year" : 2007
    }, {
      "title" : "Subspace sampling and relative-error matrix approximation: Column-based methods",
      "author" : [ "P. Drineas", "M. Mahoney", "S. Muthukrishnan" ],
      "venue" : "Approximation, Randomization, and Combinatorial Optimization. Algorithms and Techniques, pp. 316–326. Springer Berlin / Heidelberg",
      "citeRegEx" : "19",
      "shortCiteRegEx" : null,
      "year" : 2006
    }, {
      "title" : "Embed and conquer: Scalable embeddings for kernel k-means on mapreduce",
      "author" : [ "A. Elgohary", "A.K. Farahat", "M.S. Kamel", "F. Karray" ],
      "venue" : "CoRR abs/1311.2334",
      "citeRegEx" : "20",
      "shortCiteRegEx" : null,
      "year" : 2013
    }, {
      "title" : "Pairwise document similarity in large collections with MapReduce",
      "author" : [ "T. Elsayed", "J. Lin", "D.W. Oard" ],
      "venue" : "Proceedings of the 46th Annual Meeting of the Association for Computational Linguistics on Human Language Technologies: Short Papers (HLT’08), pp. 265–268",
      "citeRegEx" : "21",
      "shortCiteRegEx" : null,
      "year" : 2008
    }, {
      "title" : "Fast clustering using MapReduce",
      "author" : [ "A. Ene", "S. Im", "B. Moseley" ],
      "venue" : "Proceedings of the Seventeenth ACM SIGKDD International Conference on Knowledge Discovery and Data Mining (KDD’11), pp. 681–689",
      "citeRegEx" : "22",
      "shortCiteRegEx" : null,
      "year" : 2011
    }, {
      "title" : "Distributed column subset selection on mapreduce",
      "author" : [ "A.K. Farahat", "A. Elgohary", "A. Ghodsi", "M.S. Kamel" ],
      "venue" : "Proceedings of the Thirteenth IEEE International Conference on Data Mining (ICDM’13)",
      "citeRegEx" : "23",
      "shortCiteRegEx" : null,
      "year" : 2013
    }, {
      "title" : "An efficient greedy method for unsupervised feature selection",
      "author" : [ "A.K. Farahat", "A. Ghodsi", "M.S. Kamel" ],
      "venue" : "Proceedings of the Eleventh IEEE International Conference on Data Mining (ICDM’11), pp. 161 –170",
      "citeRegEx" : "24",
      "shortCiteRegEx" : null,
      "year" : 2011
    }, {
      "title" : "Efficient greedy feature selection for unsupervised learning",
      "author" : [ "A.K. Farahat", "A. Ghodsi", "M.S. Kamel" ],
      "venue" : "Knowledge and Information Systems 35(2), 285–310",
      "citeRegEx" : "25",
      "shortCiteRegEx" : null,
      "year" : 2013
    }, {
      "title" : "Fast Monte-Carlo algorithms for finding low-rank approximations",
      "author" : [ "A. Frieze", "R. Kannan", "S. Vempala" ],
      "venue" : "Proceedings of the 39th Annual IEEE Symposium on Foundations of Computer Science (FOCS’98), pp. 370 –378",
      "citeRegEx" : "26",
      "shortCiteRegEx" : null,
      "year" : 1998
    }, {
      "title" : "Matrix Computations, 3rd edn",
      "author" : [ "G. Golub", "C. Van Loan" ],
      "venue" : "Johns Hopkins Univ Pr",
      "citeRegEx" : "27",
      "shortCiteRegEx" : null,
      "year" : 1996
    }, {
      "title" : "Efficient algorithms for computing a strong rank-revealing QR factorization",
      "author" : [ "M. Gu", "S.C. Eisenstat" ],
      "venue" : "SIAM Journal on Scientific Computing 17(4), 848–869",
      "citeRegEx" : "28",
      "shortCiteRegEx" : null,
      "year" : 1996
    }, {
      "title" : "Optimal column-based low-rank matrix reconstruction",
      "author" : [ "V. Guruswami", "A.K. Sinop" ],
      "venue" : "Proceedings of the 21st Annual ACM-SIAM Symposium on Discrete Algorithms (SODA’12), pp. 1207–1214",
      "citeRegEx" : "29",
      "shortCiteRegEx" : null,
      "year" : 2012
    }, {
      "title" : "An algorithm for the principal component analysis of large data sets",
      "author" : [ "N. Halko", "P.G. Martinsson", "Y. Shkolnisky", "M. Tygert" ],
      "venue" : "SIAM Journal on Scientific Computing 33(5), 2580–2594",
      "citeRegEx" : "30",
      "shortCiteRegEx" : null,
      "year" : 2011
    }, {
      "title" : "Face recognition using Laplacianfaces",
      "author" : [ "X. He", "S. Yan", "Y. Hu", "P. Niyogi", "H. Zhang" ],
      "venue" : "Pattern Analysis and Machine Intelligence, IEEE Transactions on 27(3), 328–340",
      "citeRegEx" : "31",
      "shortCiteRegEx" : null,
      "year" : 2005
    }, {
      "title" : "Algorithms for Clustering Data",
      "author" : [ "A.K. Jain", "R.C. Dubes" ],
      "venue" : "Prentice-Hall, Inc., Upper Saddle River, NJ, USA",
      "citeRegEx" : "32",
      "shortCiteRegEx" : null,
      "year" : 1988
    }, {
      "title" : "Hadi: Fast diameter estimation and mining in massive graphs with hadoop",
      "author" : [ "U. Kang", "C. Tsourakakis", "A. Appel", "C. Faloutsos", "J. Leskovec" ],
      "venue" : "CMU-ML-08-117",
      "citeRegEx" : "33",
      "shortCiteRegEx" : null,
      "year" : 2008
    }, {
      "title" : "A model of computation for MapReduce",
      "author" : [ "H. Karloff", "S. Suri", "S. Vassilvitskii" ],
      "venue" : "Proceedings of the 21st Annual ACM-SIAM Symposium on Discrete Algorithms (SODA’10), pp. 938–948",
      "citeRegEx" : "34",
      "shortCiteRegEx" : null,
      "year" : 2010
    }, {
      "title" : "CLUTO - a clustering toolkit",
      "author" : [ "G. Karypis" ],
      "venue" : "Tech. Rep. #02-017, University of Minnesota, Department of Computer Science",
      "citeRegEx" : "35",
      "shortCiteRegEx" : null,
      "year" : 2003
    }, {
      "title" : "Clustering by means of medoids",
      "author" : [ "L. Kaufman", "P. Rousseeuw" ],
      "venue" : "Tech. rep., Technische Hogeschool, Delft (Netherlands). Department of Mathematics and Informatics",
      "citeRegEx" : "36",
      "shortCiteRegEx" : null,
      "year" : 1987
    }, {
      "title" : "Acquiring linear subspaces for face recognition under variable lighting",
      "author" : [ "K. Lee", "J. Ho", "D. Kriegman" ],
      "venue" : "Pattern Analysis and Machine Intelligence, IEEE Transactions on 27(5), 684–698",
      "citeRegEx" : "37",
      "shortCiteRegEx" : null,
      "year" : 2005
    }, {
      "title" : "Reuters-21578 text categorization test collection distribution",
      "author" : [ "D. Lewis" ],
      "venue" : null,
      "citeRegEx" : "38",
      "shortCiteRegEx" : "38",
      "year" : 1999
    }, {
      "title" : "Rcv1: A new benchmark collection for text categorization research",
      "author" : [ "D.D. Lewis", "Y. Yang", "T.G. Rose", "F. Li" ],
      "venue" : "The Journal of Machine Learning Research 5, 361–397",
      "citeRegEx" : "39",
      "shortCiteRegEx" : null,
      "year" : 2004
    }, {
      "title" : "Very sparse random projections",
      "author" : [ "P. Li", "T.J. Hastie", "K.W. Church" ],
      "venue" : "Proceedings of the Twelfth ACM SIGKDD international conference on Knowledge Discovery and Data Mining (KDD’06), pp. 287–296",
      "citeRegEx" : "40",
      "shortCiteRegEx" : null,
      "year" : 2006
    }, {
      "title" : "Handbook of Matrices",
      "author" : [ "H. Lütkepohl" ],
      "venue" : "John Wiley & Sons Inc",
      "citeRegEx" : "41",
      "shortCiteRegEx" : null,
      "year" : 1996
    }, {
      "title" : "Robust regression on mapreduce",
      "author" : [ "X. Meng", "M. Mahoney" ],
      "venue" : "Proceedings of the 30th International Conference on Machine Learning (ICML-13), pp. 888–896",
      "citeRegEx" : "42",
      "shortCiteRegEx" : null,
      "year" : 2013
    }, {
      "title" : "On the existence and computation of rank-revealing LU factorizations",
      "author" : [ "C. Pan" ],
      "venue" : "Linear Algebra and its Applications 316(1), 199–222",
      "citeRegEx" : "43",
      "shortCiteRegEx" : null,
      "year" : 2000
    }, {
      "title" : "The CMU pose, illumination, and expression database",
      "author" : [ "T. Sim", "S. Baker", "M. Bsat" ],
      "venue" : "Pattern Analysis and Machine Intelligence, IEEE Transactions on 25(12), 1615–1618",
      "citeRegEx" : "44",
      "shortCiteRegEx" : null,
      "year" : 2003
    }, {
      "title" : "Parallel large scale feature selection for logistic regression",
      "author" : [ "S. Singh", "J. Kubica", "S. Larsen", "D. Sorokina" ],
      "venue" : "Proceedings of the SIAM International Conference on Data Mining pp. 1171–1182",
      "citeRegEx" : "45",
      "shortCiteRegEx" : null,
      "year" : 2009
    }, {
      "title" : "80 million tiny images: A large data set for nonparametric object and scene recognition",
      "author" : [ "A. Torralba", "R. Fergus", "W. Freeman" ],
      "venue" : "Pattern Analysis and Machine Intelligence, IEEE Transactions on 30(11), 1958–1970",
      "citeRegEx" : "46",
      "shortCiteRegEx" : null,
      "year" : 2008
    }, {
      "title" : "Hadoop: The Definitive Guide, 1st edn",
      "author" : [ "T. White" ],
      "venue" : "O’Reilly Media, Inc.",
      "citeRegEx" : "47",
      "shortCiteRegEx" : null,
      "year" : 2009
    }, {
      "title" : "Scalable maximum clique computation using mapreduce",
      "author" : [ "J. Xiang", "C. Guo", "A. Aboulnaga" ],
      "venue" : "Data Engineering (ICDE), 2013 IEEE 29th International Conference on, pp. 74–85",
      "citeRegEx" : "48",
      "shortCiteRegEx" : null,
      "year" : 2013
    } ],
    "referenceMentions" : [ {
      "referenceID" : 31,
      "context" : "For instance, the traditional clustering algorithms such as k-means [32] tend to produce centroids which encode information about thousands of data instances.",
      "startOffset" : 68,
      "endOffset" : 72
    }, {
      "referenceID" : 35,
      "context" : "Even clustering methods that use data instances as prototypes, such as k-medoid [36], learn only one representative for each cluster, which is usually not enough to capture the insights of the data instances in that cluster.",
      "startOffset" : 80,
      "endOffset" : 84
    }, {
      "referenceID" : 12,
      "context" : "On the other hand, traditional dimension reduction algorithms such as Latent Semantic Analysis (LSA) [13] tend to learn a few latent concepts in the feature space.",
      "startOffset" : 101,
      "endOffset" : 105
    }, {
      "referenceID" : 22,
      "context" : "1 A preliminary version of this paper appeared as [23]",
      "startOffset" : 50,
      "endOffset" : 54
    }, {
      "referenceID" : 25,
      "context" : "This problem can be generally formulated as the selection of a subset of columns from a data matrix, which is formally known as the Column Subset Selection (CSS) problem [26], [19] [6] [5] [3].",
      "startOffset" : 170,
      "endOffset" : 174
    }, {
      "referenceID" : 18,
      "context" : "This problem can be generally formulated as the selection of a subset of columns from a data matrix, which is formally known as the Column Subset Selection (CSS) problem [26], [19] [6] [5] [3].",
      "startOffset" : 176,
      "endOffset" : 180
    }, {
      "referenceID" : 5,
      "context" : "This problem can be generally formulated as the selection of a subset of columns from a data matrix, which is formally known as the Column Subset Selection (CSS) problem [26], [19] [6] [5] [3].",
      "startOffset" : 181,
      "endOffset" : 184
    }, {
      "referenceID" : 4,
      "context" : "This problem can be generally formulated as the selection of a subset of columns from a data matrix, which is formally known as the Column Subset Selection (CSS) problem [26], [19] [6] [5] [3].",
      "startOffset" : 185,
      "endOffset" : 188
    }, {
      "referenceID" : 2,
      "context" : "This problem can be generally formulated as the selection of a subset of columns from a data matrix, which is formally known as the Column Subset Selection (CSS) problem [26], [19] [6] [5] [3].",
      "startOffset" : 189,
      "endOffset" : 192
    }, {
      "referenceID" : 11,
      "context" : "In order to alleviate these problems, MapReduce [12] was introduced to simplify large-scale data analytics over a distributed environment of commodity machines.",
      "startOffset" : 48,
      "endOffset" : 52
    }, {
      "referenceID" : 46,
      "context" : "Currently, MapReduce (and its open source implementation Hadoop [47]) is considered the most successful and widely-used framework for managing big data processing jobs.",
      "startOffset" : 64,
      "endOffset" : 68
    }, {
      "referenceID" : 5,
      "context" : "The Column Subset Selection (CSS) problem can be generally defined as the selection of the most representative columns of a data matrix [6] [5] [3].",
      "startOffset" : 136,
      "endOffset" : 139
    }, {
      "referenceID" : 4,
      "context" : "The Column Subset Selection (CSS) problem can be generally defined as the selection of the most representative columns of a data matrix [6] [5] [3].",
      "startOffset" : 140,
      "endOffset" : 143
    }, {
      "referenceID" : 2,
      "context" : "The Column Subset Selection (CSS) problem can be generally defined as the selection of the most representative columns of a data matrix [6] [5] [3].",
      "startOffset" : 144,
      "endOffset" : 147
    }, {
      "referenceID" : 25,
      "context" : "Although different criteria for column subset selection can be defined, a common criterion that has been used in much recent work measures the discrepancy between the original matrix and the approximate matrix reconstructed from the subset of selected columns [26] [17] [18] [19] [15] [6] [5] [3] [8].",
      "startOffset" : 260,
      "endOffset" : 264
    }, {
      "referenceID" : 16,
      "context" : "Although different criteria for column subset selection can be defined, a common criterion that has been used in much recent work measures the discrepancy between the original matrix and the approximate matrix reconstructed from the subset of selected columns [26] [17] [18] [19] [15] [6] [5] [3] [8].",
      "startOffset" : 265,
      "endOffset" : 269
    }, {
      "referenceID" : 17,
      "context" : "Although different criteria for column subset selection can be defined, a common criterion that has been used in much recent work measures the discrepancy between the original matrix and the approximate matrix reconstructed from the subset of selected columns [26] [17] [18] [19] [15] [6] [5] [3] [8].",
      "startOffset" : 270,
      "endOffset" : 274
    }, {
      "referenceID" : 18,
      "context" : "Although different criteria for column subset selection can be defined, a common criterion that has been used in much recent work measures the discrepancy between the original matrix and the approximate matrix reconstructed from the subset of selected columns [26] [17] [18] [19] [15] [6] [5] [3] [8].",
      "startOffset" : 275,
      "endOffset" : 279
    }, {
      "referenceID" : 14,
      "context" : "Although different criteria for column subset selection can be defined, a common criterion that has been used in much recent work measures the discrepancy between the original matrix and the approximate matrix reconstructed from the subset of selected columns [26] [17] [18] [19] [15] [6] [5] [3] [8].",
      "startOffset" : 280,
      "endOffset" : 284
    }, {
      "referenceID" : 5,
      "context" : "Although different criteria for column subset selection can be defined, a common criterion that has been used in much recent work measures the discrepancy between the original matrix and the approximate matrix reconstructed from the subset of selected columns [26] [17] [18] [19] [15] [6] [5] [3] [8].",
      "startOffset" : 285,
      "endOffset" : 288
    }, {
      "referenceID" : 4,
      "context" : "Although different criteria for column subset selection can be defined, a common criterion that has been used in much recent work measures the discrepancy between the original matrix and the approximate matrix reconstructed from the subset of selected columns [26] [17] [18] [19] [15] [6] [5] [3] [8].",
      "startOffset" : 289,
      "endOffset" : 292
    }, {
      "referenceID" : 2,
      "context" : "Although different criteria for column subset selection can be defined, a common criterion that has been used in much recent work measures the discrepancy between the original matrix and the approximate matrix reconstructed from the subset of selected columns [26] [17] [18] [19] [15] [6] [5] [3] [8].",
      "startOffset" : 293,
      "endOffset" : 296
    }, {
      "referenceID" : 7,
      "context" : "Although different criteria for column subset selection can be defined, a common criterion that has been used in much recent work measures the discrepancy between the original matrix and the approximate matrix reconstructed from the subset of selected columns [26] [17] [18] [19] [15] [6] [5] [3] [8].",
      "startOffset" : 297,
      "endOffset" : 300
    }, {
      "referenceID" : 5,
      "context" : "Some of the recent work on the CSS problem [6] [5] [3] derives theoretical bounds for both the Frobenius and spectral norms of the residual matrix.",
      "startOffset" : 43,
      "endOffset" : 46
    }, {
      "referenceID" : 4,
      "context" : "Some of the recent work on the CSS problem [6] [5] [3] derives theoretical bounds for both the Frobenius and spectral norms of the residual matrix.",
      "startOffset" : 47,
      "endOffset" : 50
    }, {
      "referenceID" : 2,
      "context" : "Some of the recent work on the CSS problem [6] [5] [3] derives theoretical bounds for both the Frobenius and spectral norms of the residual matrix.",
      "startOffset" : 51,
      "endOffset" : 54
    }, {
      "referenceID" : 26,
      "context" : "The matrix Q can be obtained by applying an orthogonalization algorithm such as the Gram-Schmidt algorithm to the columns of A:S , or by calculating the Singular Value Decomposition (SVD) or the QR decomposition of A:S [27].",
      "startOffset" : 219,
      "endOffset" : 223
    }, {
      "referenceID" : 18,
      "context" : "The selected columns can also be used to calculate a column-based lowrank approximation of A [19].",
      "startOffset" : 93,
      "endOffset" : 97
    }, {
      "referenceID" : 2,
      "context" : "[3] can be used.",
      "startOffset" : 0,
      "endOffset" : 3
    }, {
      "referenceID" : 2,
      "context" : "This procedure results in a rank-k approximation of A within the column space of A:S that achieves the minimum reconstruction error in terms of Frobenius norm [3]: T ∗ = arg min T, rank(T )=k ‖A−A:ST‖2F .",
      "startOffset" : 159,
      "endOffset" : 162
    }, {
      "referenceID" : 11,
      "context" : "MapReduce [12] was presented as a programming model to simplify large-scale data analytics over a distributed environment of commodity machines.",
      "startOffset" : 10,
      "endOffset" : 14
    }, {
      "referenceID" : 41,
      "context" : "Currently, MapReduce has been successfully used for scaling various data analysis tasks such as regression [42], feature selection [45], graph mining [33,48], and most recently kernel k-means clustering [20].",
      "startOffset" : 107,
      "endOffset" : 111
    }, {
      "referenceID" : 44,
      "context" : "Currently, MapReduce has been successfully used for scaling various data analysis tasks such as regression [42], feature selection [45], graph mining [33,48], and most recently kernel k-means clustering [20].",
      "startOffset" : 131,
      "endOffset" : 135
    }, {
      "referenceID" : 32,
      "context" : "Currently, MapReduce has been successfully used for scaling various data analysis tasks such as regression [42], feature selection [45], graph mining [33,48], and most recently kernel k-means clustering [20].",
      "startOffset" : 150,
      "endOffset" : 157
    }, {
      "referenceID" : 47,
      "context" : "Currently, MapReduce has been successfully used for scaling various data analysis tasks such as regression [42], feature selection [45], graph mining [33,48], and most recently kernel k-means clustering [20].",
      "startOffset" : 150,
      "endOffset" : 157
    }, {
      "referenceID" : 19,
      "context" : "Currently, MapReduce has been successfully used for scaling various data analysis tasks such as regression [42], feature selection [45], graph mining [33,48], and most recently kernel k-means clustering [20].",
      "startOffset" : 203,
      "endOffset" : 207
    }, {
      "referenceID" : 20,
      "context" : "For complex analytical tasks, multiple jobs are typically chained together [21] and/or many rounds of the same job are executed on the input data set [22].",
      "startOffset" : 75,
      "endOffset" : 79
    }, {
      "referenceID" : 21,
      "context" : "For complex analytical tasks, multiple jobs are typically chained together [21] and/or many rounds of the same job are executed on the input data set [22].",
      "startOffset" : 150,
      "endOffset" : 154
    }, {
      "referenceID" : 33,
      "context" : "[34] defined a set of computational constraints that ensure the scalability and the efficiency of MapReduce-based analytical tasks.",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 4,
      "context" : "The minimization of this criterion is a combinatorial optimization problem whose optimal solution can be obtained inO ( nmnl ) [5].",
      "startOffset" : 127,
      "endOffset" : 130
    }, {
      "referenceID" : 23,
      "context" : "[24] [25].",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 24,
      "context" : "[24] [25].",
      "startOffset" : 5,
      "endOffset" : 9
    }, {
      "referenceID" : 40,
      "context" : "Let S = BRR − B PRB −1 PPBPR be the Schur complement [41] of BPP in B.",
      "startOffset" : 53,
      "endOffset" : 57
    }, {
      "referenceID" : 40,
      "context" : "Using the block-wise inversion formula [41], B−1 can be calculated as:",
      "startOffset" : 39,
      "endOffset" : 43
    }, {
      "referenceID" : 10,
      "context" : "Random projection [11] [1] [40] is a well-known technique for dealing with the curse-of-the-dimensionality problem.",
      "startOffset" : 18,
      "endOffset" : 22
    }, {
      "referenceID" : 0,
      "context" : "Random projection [11] [1] [40] is a well-known technique for dealing with the curse-of-the-dimensionality problem.",
      "startOffset" : 23,
      "endOffset" : 26
    }, {
      "referenceID" : 39,
      "context" : "Random projection [11] [1] [40] is a well-known technique for dealing with the curse-of-the-dimensionality problem.",
      "startOffset" : 27,
      "endOffset" : 31
    }, {
      "referenceID" : 10,
      "context" : "It has been shown that applying random projection Ω to X preserves the pairwise distances between vectors in the row space of X with a high probability [11]:",
      "startOffset" : 152,
      "endOffset" : 156
    }, {
      "referenceID" : 10,
      "context" : "Examples of such matrices are Gaussian random matrices [11], uniform random sign (±1) matrices [1], and sparse random sign matrices [40].",
      "startOffset" : 55,
      "endOffset" : 59
    }, {
      "referenceID" : 0,
      "context" : "Examples of such matrices are Gaussian random matrices [11], uniform random sign (±1) matrices [1], and sparse random sign matrices [40].",
      "startOffset" : 95,
      "endOffset" : 98
    }, {
      "referenceID" : 39,
      "context" : "Examples of such matrices are Gaussian random matrices [11], uniform random sign (±1) matrices [1], and sparse random sign matrices [40].",
      "startOffset" : 132,
      "endOffset" : 136
    }, {
      "referenceID" : 11,
      "context" : "3 The in-memory summation can also be replaced by a MapReduce combiner [12].",
      "startOffset" : 71,
      "endOffset" : 75
    }, {
      "referenceID" : 25,
      "context" : "[26] was the first to suggest the idea of randomly sampling l columns from a matrix and using these columns to calculate a rank-k approximation of the matrix (where l ≥ k).",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 16,
      "context" : "was followed by different papers [17] [18] that enhanced the algorithm by proposing different sampling probabilities and deriving better error bounds for the reconstruction error.",
      "startOffset" : 33,
      "endOffset" : 37
    }, {
      "referenceID" : 17,
      "context" : "was followed by different papers [17] [18] that enhanced the algorithm by proposing different sampling probabilities and deriving better error bounds for the reconstruction error.",
      "startOffset" : 38,
      "endOffset" : 42
    }, {
      "referenceID" : 18,
      "context" : "[19] proposed a subspace sampling method which samples columns using probabilities proportional to the norms of the rows of the top k right singular vectors of A.",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 15,
      "context" : "[16] [15] proposed an adaptive sampling method which updates the sampling probabilities based on the columns selected so far.",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 14,
      "context" : "[16] [15] proposed an adaptive sampling method which updates the sampling probabilities based on the columns selected so far.",
      "startOffset" : 5,
      "endOffset" : 9
    }, {
      "referenceID" : 26,
      "context" : "In the area of numerical linear algebra, the column pivoting method exploited by the QR decomposition [27] permutes the columns of the matrix based on their norms to enhance the numerical stability of the QR decomposition algorithm.",
      "startOffset" : 102,
      "endOffset" : 106
    }, {
      "referenceID" : 8,
      "context" : "The Rank-Revealing QR (RRQR) decomposition [9] [28] [2] [43] is a category of QR decomposition methods which permute columns of the data matrix while imposing additional constraints on the singular values of the two sub-matrices of the upper-triangular matrix R corresponding to the selected and non-selected columns.",
      "startOffset" : 43,
      "endOffset" : 46
    }, {
      "referenceID" : 27,
      "context" : "The Rank-Revealing QR (RRQR) decomposition [9] [28] [2] [43] is a category of QR decomposition methods which permute columns of the data matrix while imposing additional constraints on the singular values of the two sub-matrices of the upper-triangular matrix R corresponding to the selected and non-selected columns.",
      "startOffset" : 47,
      "endOffset" : 51
    }, {
      "referenceID" : 1,
      "context" : "The Rank-Revealing QR (RRQR) decomposition [9] [28] [2] [43] is a category of QR decomposition methods which permute columns of the data matrix while imposing additional constraints on the singular values of the two sub-matrices of the upper-triangular matrix R corresponding to the selected and non-selected columns.",
      "startOffset" : 52,
      "endOffset" : 55
    }, {
      "referenceID" : 42,
      "context" : "The Rank-Revealing QR (RRQR) decomposition [9] [28] [2] [43] is a category of QR decomposition methods which permute columns of the data matrix while imposing additional constraints on the singular values of the two sub-matrices of the upper-triangular matrix R corresponding to the selected and non-selected columns.",
      "startOffset" : 56,
      "endOffset" : 60
    }, {
      "referenceID" : 5,
      "context" : "It has been shown that the constrains on the singular values can be used to derive an theoretical guarantee for the column-based reconstruction error according to spectral norm [6].",
      "startOffset" : 177,
      "endOffset" : 180
    }, {
      "referenceID" : 5,
      "context" : "[6] proposed a deterministic column subset selection method which first groups columns into clusters and then selects a subset of columns from each cluster.",
      "startOffset" : 0,
      "endOffset" : 3
    }, {
      "referenceID" : 6,
      "context" : "Çivril and Magdon-Ismail [7] [8]",
      "startOffset" : 25,
      "endOffset" : 28
    }, {
      "referenceID" : 7,
      "context" : "Çivril and Magdon-Ismail [7] [8]",
      "startOffset" : 29,
      "endOffset" : 32
    }, {
      "referenceID" : 2,
      "context" : "[3] presented a column subset selection algorithm which first calculates the top-k right singular values of the data matrix (where k is the target rank) and then uses deterministic sparsification methods to select l ≥ k columns from the data matrix.",
      "startOffset" : 0,
      "endOffset" : 3
    }, {
      "referenceID" : 13,
      "context" : "Deshpande and Rademacher [14] presented a polynomial-time deterministic algorithm for volume sampling with a theoretical guarantee for l = k.",
      "startOffset" : 25,
      "endOffset" : 29
    }, {
      "referenceID" : 28,
      "context" : "Quite recently, Guruswami and Sinop [29] presented a deterministic algorithm for volume sampling with theoretical guarantee for l > k.",
      "startOffset" : 36,
      "endOffset" : 40
    }, {
      "referenceID" : 4,
      "context" : "[5] proposed a two-stage hybrid algorithm for column subset selection which runs in O ( min ( nm,nm )) .",
      "startOffset" : 0,
      "endOffset" : 3
    }, {
      "referenceID" : 6,
      "context" : "The greedy CSS algorithm differs from the greedy algorithm proposed by Çivril and Magdon-Ismail [7] [8] in that the latter depends on first calculating the Singular Value Decomposition of the data matrix, which is computationally complex, especially for large matrices.",
      "startOffset" : 96,
      "endOffset" : 99
    }, {
      "referenceID" : 7,
      "context" : "The greedy CSS algorithm differs from the greedy algorithm proposed by Çivril and Magdon-Ismail [7] [8] in that the latter depends on first calculating the Singular Value Decomposition of the data matrix, which is computationally complex, especially for large matrices.",
      "startOffset" : 100,
      "endOffset" : 103
    }, {
      "referenceID" : 13,
      "context" : "The proposed algorithm is also more efficient than the recently proposed volume sampling algorithms [14] [29].",
      "startOffset" : 100,
      "endOffset" : 104
    }, {
      "referenceID" : 28,
      "context" : "The proposed algorithm is also more efficient than the recently proposed volume sampling algorithms [14] [29].",
      "startOffset" : 105,
      "endOffset" : 109
    }, {
      "referenceID" : 7,
      "context" : "This is more efficient than the work of Çivril and Magdon-Ismail [8] which selects columns based on the leading singular vectors.",
      "startOffset" : 65,
      "endOffset" : 68
    }, {
      "referenceID" : 37,
      "context" : "The Reuters-21578 is the training set of the Reuters-21578 collection [38].",
      "startOffset" : 70,
      "endOffset" : 74
    }, {
      "referenceID" : 34,
      "context" : "The pre-processed versions of Reviews and LA1 that are distributed with the CLUTO Toolkit [35] were used.",
      "startOffset" : 90,
      "endOffset" : 94
    }, {
      "referenceID" : 43,
      "context" : "The PIE-20 and YaleB-38 are pre-processed subsets of the CMU PIE [44] and Extended Yale Face [37] data sets respectively.",
      "startOffset" : 65,
      "endOffset" : 69
    }, {
      "referenceID" : 36,
      "context" : "The PIE-20 and YaleB-38 are pre-processed subsets of the CMU PIE [44] and Extended Yale Face [37] data sets respectively.",
      "startOffset" : 93,
      "endOffset" : 97
    }, {
      "referenceID" : 30,
      "context" : "[31] to evaluate different face recognition algorithms.",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 38,
      "context" : "The RCV1-200K is a subset of the RCV1 data set [39] which has been prepared and used by Chen et al.",
      "startOffset" : 47,
      "endOffset" : 51
    }, {
      "referenceID" : 9,
      "context" : "[10] to evaluate parallel spectral clustering algorithms.",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 45,
      "context" : "The TinyImages-1M data set contains 1 million images that were sampled from the 80 million tiny images data set [46] and converted to grayscale.",
      "startOffset" : 112,
      "endOffset" : 116
    }, {
      "referenceID" : 26,
      "context" : "– qr: is the QR decomposition with column pivoting [27] implemented by the MATLAB qr function.",
      "startOffset" : 51,
      "endOffset" : 55
    }, {
      "referenceID" : 27,
      "context" : "– SRRQR: is the strong rank-revealing QR decomposition [28].",
      "startOffset" : 55,
      "endOffset" : 59
    }, {
      "referenceID" : 27,
      "context" : "Algorithm 4 of [28] was implemented in MATLAB.",
      "startOffset" : 15,
      "endOffset" : 19
    }, {
      "referenceID" : 27,
      "context" : "In this implementation, the MATLAB qr function is first used to calculate the QR decomposition with column pivoting and then the columns are swapped using the criterion specified by Gu and Eisenstat [28].",
      "startOffset" : 199,
      "endOffset" : 203
    }, {
      "referenceID" : 6,
      "context" : "– ApproxSVD: is the sparse approximation of Singular Value Decomposition (SVD) [7] [8].",
      "startOffset" : 79,
      "endOffset" : 82
    }, {
      "referenceID" : 7,
      "context" : "– ApproxSVD: is the sparse approximation of Singular Value Decomposition (SVD) [7] [8].",
      "startOffset" : 83,
      "endOffset" : 86
    }, {
      "referenceID" : 6,
      "context" : "The use of the generalized CSS algorithm is equivalent to, but more efficient than, the algorithm proposed by Çivril and Magdon-Ismail [7] [8].",
      "startOffset" : 135,
      "endOffset" : 138
    }, {
      "referenceID" : 7,
      "context" : "The use of the generalized CSS algorithm is equivalent to, but more efficient than, the algorithm proposed by Çivril and Magdon-Ismail [7] [8].",
      "startOffset" : 139,
      "endOffset" : 142
    }, {
      "referenceID" : 29,
      "context" : "Since the calculation of exact SVD is computationally complex, the Stochastic SVD algorithm [30] is used to approximate the leading singular values and vectors of the data matrix.",
      "startOffset" : 92,
      "endOffset" : 96
    }, {
      "referenceID" : 4,
      "context" : "[5].",
      "startOffset" : 0,
      "endOffset" : 3
    }, {
      "referenceID" : 2,
      "context" : "[3] was not included in the comparison as its implementation is not available.",
      "startOffset" : 0,
      "endOffset" : 3
    }, {
      "referenceID" : 27,
      "context" : "7 9 In the implemented code, the efficient recursive formulas in Section 4 of [28] are used to implement the update of QR decomposition and the swapping criterion.",
      "startOffset" : 78,
      "endOffset" : 82
    }, {
      "referenceID" : 3,
      "context" : "10 In [4] (a newer version of [5]), Boutsidis et al.",
      "startOffset" : 6,
      "endOffset" : 9
    }, {
      "referenceID" : 4,
      "context" : "10 In [4] (a newer version of [5]), Boutsidis et al.",
      "startOffset" : 30,
      "endOffset" : 33
    }, {
      "referenceID" : 4,
      "context" : "Although the SRRQR algorithm achieves the theoretical guarantee presented in [5], the MATLAB qr function is used in the conducted experiments as it is much faster and it achieves comparable accuracy for the experimented data sets.",
      "startOffset" : 77,
      "endOffset" : 80
    }, {
      "referenceID" : 7,
      "context" : "– DistApproxSVD: is an extension of the centralized algorithm for sparse approximation of Singular Value Decomposition (SVD) [8].",
      "startOffset" : 125,
      "endOffset" : 128
    }, {
      "referenceID" : 7,
      "context" : "The use of the distributed CSS algorithm extends the original algorithm proposed by Çivril and Magdon-Ismail [8] to work on distributed matrices.",
      "startOffset" : 109,
      "endOffset" : 112
    }, {
      "referenceID" : 29,
      "context" : "For the methods that require the calculations of Singular Value Decomposition (SVD), the Stochastic SVD (SSVD) algorithm [30] is used to approximate the leading singular values and vectors of the data matrix.",
      "startOffset" : 121,
      "endOffset" : 125
    } ],
    "year" : 2013,
    "abstractText" : "In today’s information systems, the availability of massive amounts of data necessitates the development of fast and accurate algorithms to summarize these data and represent them in a succinct format. One crucial problem in big data analytics is the selection of representative instances from large and massively-distributed data, which is formally known as the Column Subset Selection (CSS) problem. The solution to this problem enables data analysts to understand the insights of the data and explore its hidden structure. The selected instances can also be used for data preprocessing tasks such as learning a low-dimensional embedding of the data points or computing a low-rank Ahmed K. Farahat Department of Electrical and Computer Engineering University of Waterloo Waterloo, Ontario, Canada N2L 3G1 Tel.: +1 519-888-4567 E-mail: afarahat@uwaterloo.ca Ahmed Elgohary Department of Electrical and Computer Engineering University of Waterloo Waterloo, Ontario, Canada N2L 3G1 Tel.: +1 519-888-4567 E-mail: aelgohary@uwaterloo.ca Ali Ghodsi Department of Statistics and Actuarial Science University of Waterloo Waterloo, Ontario, Canada N2L 3G1 Tel.: +1 519-888-4567 x37316 E-mail: aghodsib@uwaterloo.ca Mohamed S. Kamel Department of Electrical and Computer Engineering University of Waterloo Waterloo, Ontario, Canada N2L 3G1 Tel.: +1 519-888-4567 x35761 E-mail: mkamel@uwaterloo.ca ar X iv :1 31 2. 68 38 v1 [ cs .D S] 2 4 D ec 2 01 3 2 Ahmed K. Farahat et al. approximation of the corresponding matrix. This paper presents a fast and accurate greedy algorithm for large-scale column subset selection. The algorithm minimizes an objective function which measures the reconstruction error of the data matrix based on the subset of selected columns. The paper first presents a centralized greedy algorithm for column subset selection which depends on a novel recursive formula for calculating the reconstruction error of the data matrix. The paper then presents a MapReduce algorithm which selects a few representative columns from a matrix whose columns are massively distributed across several commodity machines. The algorithm first learns a concise representation of all columns using random projection, and it then solves a generalized column subset selection problem at each machine in which a subset of columns are selected from the sub-matrix on that machine such that the reconstruction error of the concise representation is minimized. The paper demonstrates the effectiveness and efficiency of the proposed algorithm through an empirical evaluation on benchmark data sets.",
    "creator" : "LaTeX with hyperref package"
  }
}