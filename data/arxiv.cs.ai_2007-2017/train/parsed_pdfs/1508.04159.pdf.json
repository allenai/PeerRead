{
  "name" : "1508.04159.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : null,
    "authors" : [ ],
    "emails" : [ ],
    "sections" : [ {
      "heading" : null,
      "text" : "and robotic world models in an SQL-like manner. In this work we have extended the language in two directions. First, we have implemented hierarchical queries; second, we improve efficiency enabling manual design space exploration on different “search” strategies. As depicted in the teaser above, we demonstrate the applicability of such extensions in two application problems; the basic language concepts are explained by solving the classical problem of the Towers of Hanoi and then a common path planning problem in a complex 3D environment is implemented."
    }, {
      "heading" : "1. Introduction",
      "text" : "We have developed SelectScript [1] as a consequence to the growing complexity of (robotic) world models and discrete simulation environments that we are confronted with in our everyday scientific life. If we look at the world of robotics, smart environments, or cyber-physical systems, all of the entities within such newly developing ecologic systems posses their own simulation of the environment. Each of them with a very specific structures and APIs and different semantics. An intermediate language that can be put on top of all these world models with a common semantic, would enable a “real” interoperability between these systems (not in the sense of sharing data, data sheets, or services). An entity could access the required information from another entities “head”, by defining what information it requires and in what representation format. SelectScript therefore adopts\nDate: October 17, 2017.\n1\nar X\niv :1\n50 8.\n04 15\n9v 1\nthe well known SQL syntax for discrete simulations, allowing to query them online and to manually explore the capabilities of the API together with the underlying environment. Within the following, we will use the terms simulation and world models synonymously, since a world model can be interpreted as a simulation of certain aspects of the world, further more we are demonstrating the capabilities of our query language by applying different simulation environments.\nSelectScript is a declarative domain-specific language (DSL) currently embedded in Python, further language implementations are planned. It is called SelectScript because, in contrast to a complete SQL implementation, we only provide the possibility for accessing and querying data, which is based on SELECTstatements, the development and integration of additional functionality is left out to the host programming language, e. g. Python, C++, etc. Additionally, we added new language features that allow to query for application-specific response formats, e. g. maps, sound, projections, etc., integrate temporal aspects, and offer interfaces that enable to extend the language according to different requirements (cf. Sec. 3).\nIn this work we extend the SelectScript DSL to enable hierarchical queries. This does not only allow to solve classical reasoning problems such as the Towers of Hanoi or the Four Color Map problem, but also path planning in a complex 3D environment, as indicated by the teaser figure. Seeking for an appropriate method to resolve such hierarchical queries by implementing different strategies, we shortly realized that is actually possible and even more valuable to integrate different ones. But this requires to implement mechanisms that allow to switch between different strategies and to tweak them. Strategies with their specific details of implementation, memory management, etc. can thus be abstracted and hidden behind the language. The SelectScript DSL allows to define what information is required as well as what “search” strategy to apply. No one would normally apply an SQLlike syntax to solve common reasoning problems, whereby it actually provides a convenient way of expressing problems.\nThe contributions of this paper are:\n• We extend the SelectScript DSL with hierarchical queries, which enable recursion within the language. • We enable manual design space exploration on different “search” strategies. • We demonstrate the language improvements by implementing the Towers\nof Hanoi application and we show that the same concepts can be used in complex 3D environments to solve a common path planning problem.\nOverview. The next section is used to give a brief overview on related approaches. It is followed by an introduction into the basic and original language concept of SelectScript. In Sec. 4 we discuss why a search problem can, in general, be seen as a table containing all possible intermediate steps, such that it becomes apparent that a declarative approach provides a convenient way to identify the relevant “rows” and thus solutions. The same section then introduces hierarchical queries. As already mentioned, the Towers of Hanoi are used to demonstrate stepwise the new concepts behind this work in Sec. 5.1 and a path planning problem in a complex 3D environment is then solved in Sec. 5.2. A short summary is presented and an outlook onto future directions provided."
    }, {
      "heading" : "2. Related Work",
      "text" : "This work is an extension of a previous work from the same authors, an interested reader can find SelectScript explained in [1]. In that work an example of the OPEN robotics automation virtual environment (OpenRAVE) [2] is provided. Nonetheless, we briefly introduce the basics of the SelectScript language in Sec. 3.\nDSLs have been widely used in research and industry to improve expressiveness for a variety of application domains such as robotics, computational science, computational finance, image processing, music, graphics, artificial intelligence [3, 4, 5, 6]. As an example, in [3] the user is able to represent his variational data assimilation application under a specifically designed formalism. The compiler automatically generates code improving user productivity. The functionalities provided allow a user to run simulations in a specific world model representation, namely a structured mesh. A similar approach on unstructured meshes is introduced by [4] where a high-level specification is provided using a syntax close to the mathematics, i. e. the partial differential equations, the software is intended to solve. The SelectScript DSL differs from these examples in the fact that it targets a general interface to world models and simulations.\nAnother class of DSL is given by languages that are performance-oriented. These languages are often called performance DSLs [7, 8, 9]. As an example [8] implements an access-execute model where the user specifies a stencil computation for unstructured meshes; the DSL decides how to execute the computation taking into account manual and automatic performance optimisation techniques. Effective manual design space exploration is also proposed by [6] where the authors provide a mechanism for manually exploring different schedule choices. As we shall see, SelectScript also proposes an effective manual design space exploration.\nThe robotics community has been active on the creation of DSLs for robotics. A compelling example that shares some commonalities with our work is RSG-DSL [10], which is a DSL focusing on robot scene graphs (RSGs) world model representations. The restriction of considering RSGs-only is overcome by SelectScript. Another example is the robot perception specification language (RPSL) [11] which focuses on task knowledge and the variety of sensors a robot has to deal with when implementing a robot perception architecture (RPA). MeshSQL [12] defines queries for mesh-based physics simulations. In contrast to our approach, the results of a simulation are stored within a database, according to time and space. MeshSQL is thus a real extension of SQL1999 and specialized on mesh data only. This query language is intended to enable researchers to interactively explore simulation data, to identify new and interesting effects. MeshSQL therefore offers temporal, spatial, statistical, and similarity queries, which require different types of return values, i. e. simple values, surfaces and slices in different formats. Other approaches adopt the SQL syntax. For example the language integrated query (LINQ) [13] extends some of the .NET languages to apply SQL queries to relational databases as well as to arrays. This is similar to other approaches in the Java world, Java query language (JQL) [14], SQL for Java Objects (JoSQL) [15], etc., but with a reduced syntax. All these approaches are a close match with the actual SQL language and do not meet the requirements of simulations and robotic world models nor the requirements of hierarchical querying."
    }, {
      "heading" : "3. Language Basics",
      "text" : "We will use the interpreter for the open dynamics engine (ODE) [16] on the “chaotic” simulation1 of Fig. 1 to demonstrate the SeleceScript basics and to show that the interpreter can be used on top of multiple environments. All the presented examples within this paper as well as the language implementation can be downloaded at: http://github.com/andre-dietrich/SelectScript Furthermore, there are multiple different screencasts available at our YouTubechannel at: http://www.youtube.com/ivsmagdeburg\nThe example in Fig. 1 depicts a chaotic but configurable simulation2 in ODE. Objects of different size, shape, color, mass, direction, and speed appear within a box. These particles fly around, bump against each other, and colliding objects can explode, giving birth to other “white particles”, or vanish. The more time passes by, the more objects will be present in the box. All of the object parameters and their place of appearance are random values.\nHow would you analyse this? In a traditional way we would use the API of the simulation framework and a programming language with a lot of loops. Instead Fig. 2 shows how such analysis can be led using SelectScript interactively. A user has to attach the ODE space variable, which is the host of the entire simulation environment, to the interpreter to make it accessible under the new variable name \"space\". The SelectScript interpreter for ODE checks the variable type, e.g. whether it is a list, a dictionary, or an ODE space, etc., and applies the appropriate methods.\nAs further depicted in Fig. 2 and in Fig. 3, the \"space\" variable can then be accessed in the FROM, as if it would be an ordinary table. As further visible, the listed “columns” within the SELECT expression are actually function calls, which offer a convenient way to abstract the API. All functions, with the exception of some internals such as eval, help, print, or to, are implemented externally in the host programming language and can be applied everywhere within a script. Functions are linked to the SelectScript interpreter similarly as it was done for variables, see also Lis. 3 on page 9. An additional element, that does not belong to the standard SQL syntax, is the keyword this, which is a pointer pointing to the currently evaluated element in the FROM expression. Since functions can have multiple input parameters, it allows to call them with the correctly placed parameter sets, see the function id in the figure above. If a function is called within the SELECT expression and if it has only one input parameter, the this pointer is automatically passed without the need to write it in brackets, as for the functions mass and velocity in Fig. 2. Everywhere else within a script functions are identified by a function name with following brackets. As already mentioned and depicted in Fig. 2, SelectScript is a language embedded in Python. The source code of a script is compiled at runtime into an intermediate representation and then evaluated. An interaction between Python and our query language is described in more detail in the application of Sec. 5.1.\n1Demo: http://www.youtube.com/watch?v=F1XNch1JC9Y 2Source: http://sourceforge.net/projects/ode-viz\nA SeleceScript script can contain multiple queries, as for the listing in Fig. 3, and queries can be nested. An intermediate results can be stored persistently in variables, allowing to reuse results and to define more complex query scripts. Thereby the last statement of a script is defining the return value and can therefore also be a composition of multiple results, as for example in line 7 of Lis. 1. Additionally SelectScript has also support for temporal variables, which allows previous results to be cached over a certain period of time.\nNext to the basic SELECT . . . FROM . . . WHERE syntax it is also possible to use the common GROUP BY and ORDER BY, but it is also possible to request certain response format. As it is depicted in the previous examples, the keyword AS followed by value, list, or dict, allows a representation format to be chosen. It has to be noted that if a dictionary is requested the function names within the SELECT expression are used to define dictionary IDs. But it is also possible to implement new methods, see therefore the example in Lis. 1. The requested results (plane) are projection matrices that can be further parameterized. The resulting 2D-matrices for mass and velocity that are returned as elements of a list, are afterwards visualized as a heat map and a spectral map (using the Python Matplotlib3), see Fig. 4. In [1] it was further demonstrated for OpenRAVE, that it is possible to request a result AS OccupancyGrid for external planners, AS Prolog to support reasoning tasks, or even AS SensorMap that depicts the current sensor coverage of an area.\nListing 1. SelectScript with a requested visual abstractions of the simulation. The additional parameters for the plane projection are: the plane itself (1st), the starting point (2nd), the width, the height, and the resolution (3rd), and an optional blur (4th) parameter.\n1 # Select 2 dimensional projections ... 2 Mass = SELECT mass FROM space WHERE hasBody(this) 3 AS plane(’XY’, [-5,-5], [100 ,100 ,0.1] , 3); 4 Velocity= SELECT linearVelocity(this , 2) FROM space 5 WHERE hasBody(this) 6 AS plane(’XY’, [-5,-5], [100 ,100 ,0.1] , 3); 7 [Mass , Velocity ]; # return values\n3http://matplotlib.org"
    }, {
      "heading" : "4. DSL Extension",
      "text" : "4.1. Graph and Table Representation Equivalence. As depicted in Fig. 5 most of the common search problems can be represented as either a graph/tree or as a table, containing all possible combinations and thus paths within the graph or tree. It is obvious that a graph-like structure consumes less memory than a table, whereby a graph needs to be traversed every time in order to find an appropriate solution. A table that contains all “paths” can be explored more efficient, whereby different caching or indexing strategies are applied in the background, and filters can be applied, e. g. by directly requesting the row with the last entry cc.\nNevertheless, we only apply the database metaphor onto common search and reasoning problems. The “graph/tree” therefore still has to be created and traversed, but this is handled in the background. Applying an SQL-like syntax offers a more “natural” way to express problems and it furthermore offers a method to\nutilize different search algorithms and methods for optimization, without the need for changing the problem description. Note that the order of rows within the table in Fig. 5b is a result of an applied depth-first search algorithm.\n4.2. Hierarchical Queries. A hierarchical or recursive query in SQL is a special type of query used to handle hierarchical structured data. A common example is a company database, which stores all employees data as well as the ID of the direct supervisor. Thus, reconstructing the leadership structure requires additional capabilities that enable recursion. The Lis. 2 shows an alternative, not standardized, syntax for recursive queries that we implement in SelectScript. It adopts the START WITH . . . CONNECT BY construct that was originally introduced by Oracle [17]. The SQL standard [18] defines a syntax that involves the keywords WITH RECURSIVE and requires to associate query expressions with a name, which allows to reuse them. However, since we are not dealing with tables of finite length but rather with functions that might generate endless results, we had to integrate an additional STOP WITH construct, used to define abort conditions. The START WITH expressions are used, as the name suggests, to define local variables that might be required and to define initial conditions.\nListing 2. Generic syntax to support hierarchical queries in SelectScript.\n1 SELECT ... FROM ... WHERE ... 2 3 START WITH value = ..., ... # start expressions 4 CONNECT BY (NO CYCLE | UNIQUE | MEMORIZE int | MAXIMUM int) 5 value = func(value , ...), ... # recursion 6 STOP WITH value > ... or value ... # stop conditions\nAll of the work is actually done with the help of the central CONNECT BY expressions. It is used to denote which values within the search are affected and how they are changed from iteration to iteration, in this case using a previously defined function. The elements listed above, namely SELECT, FROM, WHERE, START WITH, CONNECT BY, and STOP WITH, are sufficient to describe the entire search problem but, as previously mentioned, we also want to include the possibility to explore different search strategies. The design space exploration can be manually performed using the accompanying keywords in the CONNECT BY expression. Each of them tweaks the current, or applies another, search strategy. The method that is applied at default is a depth-first search algorithm, which in contrast to the table provided in Fig. 5 would generate more results by allowing cycles (cf. Lis. 5). In some situations cycles within the search result might be desired, but to prevent them and therefore to reduce the search space, the NO CYCLE keyword has to be added to the query (cf. Lis. 6). The application of the keyword UNIQUE further reduces the space of possible paths, by allowing a node within the graph to be traversed only once (cf. Lis. 6). The application of MEMORIZE automatically generates a connected graph at first, similar to the one in Fig. 5, which is afterwards traversed with a bidirectional4 search algorithm. This reduces the search space by half trading memory consumption and prevents multiple visits of a node, but it requires an additional stop parameter that determines the maximal length of the resulting paths. This maximal path length is defined by the associated integer value (cf. Lis. 7). The algorithm has a further advantage, it generates all simple paths, namely a path\n4For more information, see our benchmark at: www.aizac.info/bi-graph-search-benchmark\nwith no repeated nodes, ordered by their length, starting with the shortest path. Finally, the keyword MAXIMUM was introduced to denote the maximum number of results that is returned, for example 1000 possible paths for a mobile robot might be a sufficient result (cf. Lis. 8)."
    }, {
      "heading" : "5. Appications",
      "text" : "The following two sub-sections are used to demonstrate the applicability of our approach to solve reasoning problems. Therefore we choose the two examples that were already depicted in the teaser figure on the first page. These are problems that are commonly not solved by applying an SQL-like syntax, but as we will demonstrate it offers a convenient way. The Tower of Hanoi Sec. 5.1 is used to present the previously introduced new parts of our language step by step, while Sec. 5.2 is used as a proof of concept that demonstrates the language is applicable to solve robotic problems in a complex 3D environment.\n5.1. Tower of Hanoi. To present all steps that are required to solve the Towers of Hanoi problem, we start with the basic Python functionality that is required. The code snippet in Lis. 3 is therefore used to load the basic interpreter module (line 1). If needed, a SelectScript user is required to implement additional functions within the host programming language, as it is done at line 3 with the move function. This function is used to execute valid steps, it therefore takes as input the configuration of the towers (a list of lists) and a step to be performed [from, to]. The following examples are used to solve the Tower of Hanoi problem for three disks, which requires at least seven steps. The minimal number of steps can be calculated with the formula 2disks − 1. The list [[3, 2, 1],[ ],[ ]] thus denotes the initial configuration, where the three towers are represented by three lists and the first tower has the three ordered disks, namely 3 large disk, 2 medium disk, and 1 small disk, while [[ ],[ ],[3, 2, 1]] defines the final configuration. The result of the move function is either a new configuration of towers or an empty list in case of an invalid step. This function is made accessible from within SelectScript in line 12. All of the following SelectScript listings that present different solutions to the problem have to be presented as strings, see therefore line 14, before they are compiled at runtime (line 16) and evaluated (line 17).\nListing 3. Basic Python program stub, including all required instructions for the Tower of Hanoi application.\n1 import SelectScript , SelectScript.Interpreter 2 3 def move(step , towers): 4 if not towers or not towers[step [0]]: pass 5 elif not towers[step [1]] or towers[step [1]][-1]> towers[step [0]][ -1]: 6 #append element on top from another tower top 7 towers[step [1]]. append(towers[step [0]]. pop()) 8 return towers 9 return []\n10 11 ss = SelectScript.Interpreter () 12 ss.addFunction(’move’, move) 13 14 problem = \"\"\" insert SelectScript here \"\"\" 15 16 ir = SelectScript.compile(problem) 17 result = ss.eval(ir)\nThe example in Lis. 4 presents a vanilla approach, whereby recursion is applied with the nesting of seven move functions. That means, that this script actually iterates through all possible configurations, which results in a relatively long evaluation time of more than 10 seconds. We report in the listing captions the evaluation time of the scripts, so that the performance of different approaches can be compared. A Intel Core i5-4200U (1.6 GHz 3 MB) machine with 8 GB of RAM is used. The code is running on one core of the machine sequentially. The sequence of resulting steps is printed in the comment in line 7. As introduced in Sec. 3, the this keyword is used as a pointer to specify where to place the elements from the FROM expression, if multiple elements are declared, then the name.this notation is applied to refer to those elements.\nListing 4. Vanilla approach that uses nested move functions to iterate over all possible configurations. (Runtime: 10.09 sec)\n1 moves = [[0,1], [0,2], [1,0], [1,2], [2,0], [2 ,1]]; 2 SELECT m1.this , m2.this , m3.this , m4.this , m5.this , m6.this , m7.this 3 FROM m1=moves , m2=moves , m3=moves , m4=moves , m5=moves , m6=moves , m7=moves 4 WHERE [[],[] ,[3,2,1]] == move(m7.this , move(m6.this , move(m5.this , 5 move(m4.this , move(m3.this , move(m2.this , 6 move(m1.this , [[3 ,2 ,1],[],[]] ))))))) AS list; 7 # result: [[0 ,2] ,[0 ,1] ,[2 ,1] ,[0 ,2] ,[1 ,0] ,[1 ,2] ,[0 ,2]]\nThe application of the newly integrated constructs simplifies the code dramatically and also speeds up the execution. The WHERE expression is still applied to identify the target configuration, whereby new towers are continuously produced by the CONNECT BY expression, as in Lis. 5. The start configuration is defined in line 4 and the generation of new intermediate steps ends if either an invalid step was applied or the depth of the search exceeds the level of seven. In this way it is also possible to generate longer results than seven steps, simply by adapting the stop condition. The evaluation result of the query will then be a list that contains all possible solutions, namely valid sequences with cycles.\nListing 5. Application of the basic hierarchical query. (0.89 sec) 2 SELECT this FROM moves WHERE [[],[] ,[3,2,1]] == move(this , tower) 3 4 START WITH tower = [[3,2,1],[],[]], level=1 5 CONNECT BY tower = move(this , tower), level=level+1 6 STOP WITH level ==7 or []== move(this , tower);\nThe search can be tweaked by additional parameters, as for example in the script Lis. 6. Since the SELECT expression is used to generate the intermediate steps, we have to add additional elements, such as the current tower configuration or the level. Otherwise, no valid results could be generated from the applicable steps only. In the result shown in the last line in Lis. 4, multiple steps have to be repeated in order to reach the target configuration. Nevertheless, both optimization strategies perform better than the previous script.\nListing 6. Application of two additional keywords that result in a reduction of the search space. (NO CYCLE=0.32 sec, UNIQUE=0.19 sec)\n2 SELECT this , tower FROM moves WHERE [[],[] ,[3,2,1]] == move(this , tower) 3 4 START WITH tower = [[3,2,1],[],[]], level = 1 5 CONNECT BY NO CYCLE # or UNIQUE 6 tower = move(this , tower), level = level +1 7 STOP WITH level == 7 or [] == move(mov.this , tower);\nLis. 7 demonstrates the application of the bidirectional4 graph search method, it translates the entire query into an equivalent graph that gets analyzed afterwards. This might reduce evaluation time, but only for larger problems and by sacrificing memory. Since the additional parameter already defines the maximum resulting path length, it makes the application of an additional level variable, to control the length, unnecessary. Note that the problem below now contains four disks, which require at least 15 steps.\nListing 7. Application of a bidirectional graph search algorithm. (0.17 sec)\n2 SELECT this , tower FROM moves WHERE [[],[],[4,3,2,1]] == move(this , tower) 3 4 START WITH tower = [[4,3,2,1],[],[]] 5 CONNECT BY MEMORIZE 15 6 tower = move(this , tower) 7 STOP WITH [] == move(this , tower);\n5.2. Robot Navigation. The following example is used to demonstrate that SelectScript can also be applied to more complex environments when using the improvement described by our work. The teaser figure on the first page shows a screenshot of the path planning task for a mobile YouBot within a complex industrial environment, which can be solved with the script in Lis. 8. A screencast5 showing the running evaluation was also uploaded to our YouTube-Channel. The depicted program structure pretty much reflects the previous examples. The first three lines are used to define relevant parameters, such as the ID of the robot, its target position, and the directions the robot is allowed to move (at each step). The applied functions move, position, distance, and checkCollision were defined externally. The move function here really moves the virtual robot in the virtual environment and checkCollision is used to identify (as its name suggests) if the object that is passed as a parameter is colliding with something within the environment or not.\nThus, the only things that might look a bit unfamiliar in this example are the more complex stop conditions. Within the stop expression the short-cuts of a collision detection and some background knowledge according to the application of the distance function are applied. Thus, paths are cut off from a further search, if the distance from the current position to the target position cannot be reached anymore with the remaining number of steps. The IF6-condition is an additional (experimental) language feature, which is applied at this case to give an acoustic feedback, only if a collision has occurred (listen to the video6).\nThe result of the path search is depicted in Fig. 6, it shows an external view on the situation that was presented at the main page. Although not directly visible, the red lines actually represent the 1000 possible paths that were identified by the algorithm. It has to be note, that the combinatorial amount of possible paths that require less than 20 steps exceeds 107 (we tried it). As mentioned, the applied graph\n5Demo: http://www.youtube.com/watch?v=EFRV0JSdK3M 6It is an expression, that can be used for logging or even to adapt the query, and which can be placed everywhere. The last expression in the then or else block thereby defines the return value. Thus, the previous result of checkCollision can also be changed to False (cf. line 18 in Lis. 8). IF( condition ;\nthen, execute, a, sequence, of, expression ; else, another, sequence, of, expressions )\ntraversing algorithm identifies possible paths according to their length, starting with the shortest ones."
    }, {
      "heading" : "6. Summary & Outlook",
      "text" : "We have introduced SelectScript, a new declarative embedded domain-specific language (DSL), and shown that it can run as an intermediate layer on top of different discrete simulation environments and world models hiding the discrepancies of different APIs. In addition, we have demonstrated that accessing information with an SQL-like syntax provides a more “natural” and elegant mean than extracting the same information the old fashioned way, i. e. looping through the API.\nThe focus of this work lays on the extension of the DSL to better support reasoning and to hide the complexity of applying different strategies and methods. Using hierarchical queries the language can be applied stand alone to solve classical problems, such as the Towers of Hanoi, but also to solve problems in complex 3D environments, whereby constraints are defined by the configuration of the applied model, e. g. walls, obstacles, the geometry and configuration of the robots, etc.\nSelectScript is currently at an early stage, we are exploring different methods, constructs, and ideas, such as including additional search methods by applying heuristics or integrating probabilistic aspects to be able to query for the most likely results. Early development also shows that it is possible to automatically parallelize the result generation. Although relatively small, our currently developed interpreter in pure Python is relatively slow. Thus, our main focus lays in the port of the language to C and in devising a more efficient implementation. By doing so, we hope that it will be easier to make SelectScript applicable to other host programming languages.\nSelectScript is part of a larger research effort, whereby we try to make all information origination from ecologies of smart systems accessible and queryable. In [19] and [20] we had described a methodology that overlays smart and distributed environments with some kind of distributed scene graph (by using cloud based techniques). This enables us to organize and access these environments in a way that world models (for a certain area) on the basis of OpenRAVE can be reconstructed. The next step in our research will cover the area of reasoning on functions. If you look at the Robot Operating System (ROS), it offers a way to access a multitude of transformation, filter, aggregation, fusion, interpretation functionality. But how do we use it? Imperatively! Cynical it can be said that we are still programming assembly, but on far more complex machines. Why not “simply” solving this in a declarative way. Reasoning about the sequential application of “functions” for data transformation is probably quite similar to the identification of action sequences. We know what systems are available (their configuration/pose, data formats, etc.) [start configuration], we have this huge amount of ROS functionality (with known input and output formats) [rules] and we know what kind of information/representation we want to have (as well as a semantic to describe it) [goal]."
    }, {
      "heading" : "Acknowledgments",
      "text" : "We acknowledge funding by the EPSRC grant PAMELA EP/K008730/1."
    } ],
    "references" : [ {
      "title" : "Selectscript: A query language for robotic world models and simulations",
      "author" : [ "A. Dietrich", "S. Zug", "J. Kaiser" ],
      "venue" : "Proceedings of the IEEE International Conference on Robotics and Automation (ICRA). Seattle, Washington, 2015.  14  ANDRÉ DIETRICH, SEBASTIAN ZUG, LUIGI NARDI, AND JÖRG KAISER",
      "citeRegEx" : "1",
      "shortCiteRegEx" : null,
      "year" : 2015
    }, {
      "title" : "Automated construction of robotic manipulation programs",
      "author" : [ "R. Diankov" ],
      "venue" : "Ph.D. dissertation, Carnegie Mellon University, Robotics Institute, 8 2010.",
      "citeRegEx" : "2",
      "shortCiteRegEx" : null,
      "year" : 2010
    }, {
      "title" : "YAO: A Software for Variational Data Assimilation Using Numerical Models.",
      "author" : [ "L. Nardi", "C. Sorror", "F. Badran", "S. Thiria" ],
      "venue" : "Computational Science and Its Applications - ICCSA 2009,",
      "citeRegEx" : "3",
      "shortCiteRegEx" : "3",
      "year" : 2009
    }, {
      "title" : "Firedrake: automating the finite element method by composing abstractions",
      "author" : [ "F. Rathgeber", "D.A. Ham", "L. Mitchell", "M. Lange", "F. Luporini", "A.T. McRae", "G.-T. Bercea", "G.R. Markall", "P.H. Kelly" ],
      "venue" : "Submitted to ACM TOMS, 2015.",
      "citeRegEx" : "4",
      "shortCiteRegEx" : null,
      "year" : 2015
    }, {
      "title" : "Faust: an efficient functional approach to dsp programming",
      "author" : [ "Y. Orlarey", "D. Fober", "S. Letz" ],
      "venue" : "New Computational Paradigms for Computer Music, vol. 290, 2009.",
      "citeRegEx" : "5",
      "shortCiteRegEx" : null,
      "year" : 2009
    }, {
      "title" : "Halide: a language and compiler for optimizing parallelism, locality, and recomputation in image processing pipelines",
      "author" : [ "J. Ragan-Kelley", "C. Barnes", "A. Adams", "S. Paris", "F. Durand", "S. Amarasinghe" ],
      "venue" : "ACM SIGPLAN Notices, vol. 48, no. 6, pp. 519–530, 2013.",
      "citeRegEx" : "6",
      "shortCiteRegEx" : null,
      "year" : 2013
    }, {
      "title" : "YAO: a generator of parallel code for variational data assimilation applications",
      "author" : [ "L. Nardi", "F. Badran", "P. Fortin", "S. Thiria" ],
      "venue" : "IEEE 14th International Conference on High Performance Computing and Communications, HPCC-2012, june 2012, pp. 224 –232.",
      "citeRegEx" : "7",
      "shortCiteRegEx" : null,
      "year" : 2012
    }, {
      "title" : "Pyop2: A high-level framework for performance-portable simulations on unstructured meshes",
      "author" : [ "F. Rathgeber", "G.R. Markall", "L. Mitchell", "N. Loriant", "D.A. Ham", "C. Bertolli", "P.H. Kelly" ],
      "venue" : "High Performance Computing, Networking Storage and Analysis, SC Companion:. Los Alamitos, CA, USA: IEEE Computer Society, 2012, pp. 1116–1123. [Online]. Available: http://dx.doi.org/10.1109/SC.Companion.2012.134",
      "citeRegEx" : "8",
      "shortCiteRegEx" : null,
      "year" : 2012
    }, {
      "title" : "A practical automatic polyhedral parallelizer and locality optimizer",
      "author" : [ "U. Bondhugula", "A. Hartono", "J. Ramanujam", "P. Sadayappan" ],
      "venue" : "PLDI. USA: ACM SIGPLAN, 2008, pp. 101–113.",
      "citeRegEx" : "9",
      "shortCiteRegEx" : null,
      "year" : 2008
    }, {
      "title" : "Towards a domain specific language for a scene graph based robotic world model",
      "author" : [ "S. Blumenthal", "H. Bruyninckx" ],
      "venue" : "arXiv preprint arXiv:1408.0200, 2014.",
      "citeRegEx" : "10",
      "shortCiteRegEx" : null,
      "year" : 2014
    }, {
      "title" : "Towards a robot perception specification language",
      "author" : [ "N. Hochgeschwender", "S. Schneider", "H. Voos", "G.K. Kraetzschmar" ],
      "venue" : "arXiv preprint arXiv:1408.2933, 2014.",
      "citeRegEx" : "11",
      "shortCiteRegEx" : null,
      "year" : 2014
    }, {
      "title" : "MeshSQL: the query language for simulation mesh data",
      "author" : [ "B.S. Lee", "R. Musick" ],
      "venue" : "Information Sciences, vol. 159, no. 3, pp. 177–202, 2004.",
      "citeRegEx" : "12",
      "shortCiteRegEx" : null,
      "year" : 2004
    }, {
      "title" : "Introducing Microsoft R  © LINQ",
      "author" : [ "P. Pialorsi", "M. Russo" ],
      "venue" : null,
      "citeRegEx" : "13",
      "shortCiteRegEx" : "13",
      "year" : 2007
    }, {
      "title" : "Efficient object querying for java",
      "author" : [ "D. Willis", "D.J. Pearce", "J. Noble" ],
      "venue" : "ECOOP 2006– Object-Oriented Programming. Springer, 2006, pp. 28–49.",
      "citeRegEx" : "14",
      "shortCiteRegEx" : null,
      "year" : 2006
    }, {
      "title" : "The Open Dynamics Engine",
      "author" : [ "R. Smith" ],
      "venue" : null,
      "citeRegEx" : "16",
      "shortCiteRegEx" : "16",
      "year" : 2007
    }, {
      "title" : "Recursive query facilities in relational databases: a survey",
      "author" : [ "P. Przymus", "A. Boniewicz", "M. Burzańska", "K. Stencel" ],
      "venue" : "Database Theory and Application, Bio-Science and Bio- Technology. Springer, 2010, pp. 89–99.",
      "citeRegEx" : "17",
      "shortCiteRegEx" : null,
      "year" : 2010
    }, {
      "title" : "SQL: 1999, formerly known as SQL3",
      "author" : [ "A. Eisenberg", "J. Melton" ],
      "venue" : "ACM Sigmod record, vol. 28, no. 1, pp. 131–138, 1999.",
      "citeRegEx" : "18",
      "shortCiteRegEx" : null,
      "year" : 1999
    }, {
      "title" : "Distributed management and representation of data and context in robotic applications",
      "author" : [ "A. Dietrich", "S. Zug", "S. Mohammad", "J. Kaiser" ],
      "venue" : "Proceedings of the IEEE/RSI International Conference on Intelligent Robobts and Systems (IROS), Chicago, Illinois, 2014, accepted.",
      "citeRegEx" : "19",
      "shortCiteRegEx" : null,
      "year" : 2014
    }, {
      "title" : "Ros meets cassandra: Data management in smart environments with nosql",
      "author" : [ "A. Dietrich", "S. Mohammad", "S. Zug", "J. Kaiser" ],
      "venue" : "Proc. of the 11th International Baltic Conference (Baltic DB&IS 2014), Tallinn, Estonia, 2014, pp. 43–54. (André Dietrich, Sebastian Zug, and Jörg Kaiser) Department of Distributed Systems, Otto-von-Guericke-Universität Magdeburg, Magdeburg, Germany E-mail address: {dietrich, zug, kaiser}@ivs.cs.uni-magdeburg.de (Luigi Nardi) Department of Computing, Imperial College, London, United Kingdom E-mail address: l.nardi@imperial.ac.uk",
      "citeRegEx" : "20",
      "shortCiteRegEx" : null,
      "year" : 2014
    } ],
    "referenceMentions" : [ {
      "referenceID" : 0,
      "context" : "We have developed SelectScript [1] as a consequence to the growing complexity of (robotic) world models and discrete simulation environments that we are confronted with in our everyday scientific life.",
      "startOffset" : 31,
      "endOffset" : 34
    }, {
      "referenceID" : 0,
      "context" : "This work is an extension of a previous work from the same authors, an interested reader can find SelectScript explained in [1].",
      "startOffset" : 124,
      "endOffset" : 127
    }, {
      "referenceID" : 1,
      "context" : "In that work an example of the OPEN robotics automation virtual environment (OpenRAVE) [2] is provided.",
      "startOffset" : 87,
      "endOffset" : 90
    }, {
      "referenceID" : 2,
      "context" : "DSLs have been widely used in research and industry to improve expressiveness for a variety of application domains such as robotics, computational science, computational finance, image processing, music, graphics, artificial intelligence [3, 4, 5, 6].",
      "startOffset" : 238,
      "endOffset" : 250
    }, {
      "referenceID" : 3,
      "context" : "DSLs have been widely used in research and industry to improve expressiveness for a variety of application domains such as robotics, computational science, computational finance, image processing, music, graphics, artificial intelligence [3, 4, 5, 6].",
      "startOffset" : 238,
      "endOffset" : 250
    }, {
      "referenceID" : 4,
      "context" : "DSLs have been widely used in research and industry to improve expressiveness for a variety of application domains such as robotics, computational science, computational finance, image processing, music, graphics, artificial intelligence [3, 4, 5, 6].",
      "startOffset" : 238,
      "endOffset" : 250
    }, {
      "referenceID" : 5,
      "context" : "DSLs have been widely used in research and industry to improve expressiveness for a variety of application domains such as robotics, computational science, computational finance, image processing, music, graphics, artificial intelligence [3, 4, 5, 6].",
      "startOffset" : 238,
      "endOffset" : 250
    }, {
      "referenceID" : 2,
      "context" : "As an example, in [3] the user is able to represent his variational data assimilation application under a specifically designed formalism.",
      "startOffset" : 18,
      "endOffset" : 21
    }, {
      "referenceID" : 3,
      "context" : "A similar approach on unstructured meshes is introduced by [4] where a high-level specification is provided using a syntax close to the mathematics, i.",
      "startOffset" : 59,
      "endOffset" : 62
    }, {
      "referenceID" : 6,
      "context" : "These languages are often called performance DSLs [7, 8, 9].",
      "startOffset" : 50,
      "endOffset" : 59
    }, {
      "referenceID" : 7,
      "context" : "These languages are often called performance DSLs [7, 8, 9].",
      "startOffset" : 50,
      "endOffset" : 59
    }, {
      "referenceID" : 8,
      "context" : "These languages are often called performance DSLs [7, 8, 9].",
      "startOffset" : 50,
      "endOffset" : 59
    }, {
      "referenceID" : 7,
      "context" : "As an example [8] implements an access-execute model where the user specifies a stencil computation for unstructured meshes; the DSL decides how to execute the computation taking into account manual and automatic performance optimisation techniques.",
      "startOffset" : 14,
      "endOffset" : 17
    }, {
      "referenceID" : 5,
      "context" : "Effective manual design space exploration is also proposed by [6] where the authors provide a mechanism for manually exploring different schedule choices.",
      "startOffset" : 62,
      "endOffset" : 65
    }, {
      "referenceID" : 9,
      "context" : "A compelling example that shares some commonalities with our work is RSG-DSL [10], which is a DSL focusing on robot scene graphs (RSGs) world model representations.",
      "startOffset" : 77,
      "endOffset" : 81
    }, {
      "referenceID" : 10,
      "context" : "Another example is the robot perception specification language (RPSL) [11] which focuses on task knowledge and the variety of sensors a robot has to deal with when implementing a robot perception architecture (RPA).",
      "startOffset" : 70,
      "endOffset" : 74
    }, {
      "referenceID" : 11,
      "context" : "MeshSQL [12] defines queries for mesh-based physics simulations.",
      "startOffset" : 8,
      "endOffset" : 12
    }, {
      "referenceID" : 12,
      "context" : "For example the language integrated query (LINQ) [13] extends some of the .",
      "startOffset" : 49,
      "endOffset" : 53
    }, {
      "referenceID" : 13,
      "context" : "This is similar to other approaches in the Java world, Java query language (JQL) [14], SQL for Java Objects (JoSQL) [15], etc.",
      "startOffset" : 81,
      "endOffset" : 85
    }, {
      "referenceID" : 14,
      "context" : "We will use the interpreter for the open dynamics engine (ODE) [16] on the “chaotic” simulation of Fig.",
      "startOffset" : 63,
      "endOffset" : 67
    }, {
      "referenceID" : 0,
      "context" : "In [1] it was further demonstrated for OpenRAVE, that it is possible to request a result AS OccupancyGrid for external planners, AS Prolog to support reasoning tasks, or even AS SensorMap that depicts the current sensor coverage of an area.",
      "startOffset" : 3,
      "endOffset" : 6
    }, {
      "referenceID" : 15,
      "context" : "CONNECT BY construct that was originally introduced by Oracle [17].",
      "startOffset" : 62,
      "endOffset" : 66
    }, {
      "referenceID" : 16,
      "context" : "The SQL standard [18] defines a syntax that involves the keywords WITH RECURSIVE and requires to associate query expressions with a name, which allows to reuse them.",
      "startOffset" : 17,
      "endOffset" : 21
    }, {
      "referenceID" : 2,
      "context" : "The list [[3, 2, 1],[ ],[ ]] thus denotes the initial configuration, where the three towers are represented by three lists and the first tower has the three ordered disks, namely 3 large disk, 2 medium disk, and 1 small disk, while [[ ],[ ],[3, 2, 1]] defines the final configuration.",
      "startOffset" : 10,
      "endOffset" : 19
    }, {
      "referenceID" : 1,
      "context" : "The list [[3, 2, 1],[ ],[ ]] thus denotes the initial configuration, where the three towers are represented by three lists and the first tower has the three ordered disks, namely 3 large disk, 2 medium disk, and 1 small disk, while [[ ],[ ],[3, 2, 1]] defines the final configuration.",
      "startOffset" : 10,
      "endOffset" : 19
    }, {
      "referenceID" : 0,
      "context" : "The list [[3, 2, 1],[ ],[ ]] thus denotes the initial configuration, where the three towers are represented by three lists and the first tower has the three ordered disks, namely 3 large disk, 2 medium disk, and 1 small disk, while [[ ],[ ],[3, 2, 1]] defines the final configuration.",
      "startOffset" : 10,
      "endOffset" : 19
    }, {
      "referenceID" : 2,
      "context" : "The list [[3, 2, 1],[ ],[ ]] thus denotes the initial configuration, where the three towers are represented by three lists and the first tower has the three ordered disks, namely 3 large disk, 2 medium disk, and 1 small disk, while [[ ],[ ],[3, 2, 1]] defines the final configuration.",
      "startOffset" : 241,
      "endOffset" : 250
    }, {
      "referenceID" : 1,
      "context" : "The list [[3, 2, 1],[ ],[ ]] thus denotes the initial configuration, where the three towers are represented by three lists and the first tower has the three ordered disks, namely 3 large disk, 2 medium disk, and 1 small disk, while [[ ],[ ],[3, 2, 1]] defines the final configuration.",
      "startOffset" : 241,
      "endOffset" : 250
    }, {
      "referenceID" : 0,
      "context" : "The list [[3, 2, 1],[ ],[ ]] thus denotes the initial configuration, where the three towers are represented by three lists and the first tower has the three ordered disks, namely 3 large disk, 2 medium disk, and 1 small disk, while [[ ],[ ],[3, 2, 1]] defines the final configuration.",
      "startOffset" : 241,
      "endOffset" : 250
    }, {
      "referenceID" : 0,
      "context" : "5 elif not towers[step [1]] or towers[step [1]][-1]> towers[step [0]][ -1]:",
      "startOffset" : 23,
      "endOffset" : 26
    }, {
      "referenceID" : 0,
      "context" : "5 elif not towers[step [1]] or towers[step [1]][-1]> towers[step [0]][ -1]:",
      "startOffset" : 43,
      "endOffset" : 46
    }, {
      "referenceID" : 0,
      "context" : "7 towers[step [1]].",
      "startOffset" : 14,
      "endOffset" : 17
    }, {
      "referenceID" : 0,
      "context" : "1 moves = [[0,1], [0,2], [1,0], [1,2], [2,0], [2 ,1]]; 2 SELECT m1.",
      "startOffset" : 11,
      "endOffset" : 16
    }, {
      "referenceID" : 1,
      "context" : "1 moves = [[0,1], [0,2], [1,0], [1,2], [2,0], [2 ,1]]; 2 SELECT m1.",
      "startOffset" : 18,
      "endOffset" : 23
    }, {
      "referenceID" : 0,
      "context" : "1 moves = [[0,1], [0,2], [1,0], [1,2], [2,0], [2 ,1]]; 2 SELECT m1.",
      "startOffset" : 25,
      "endOffset" : 30
    }, {
      "referenceID" : 0,
      "context" : "1 moves = [[0,1], [0,2], [1,0], [1,2], [2,0], [2 ,1]]; 2 SELECT m1.",
      "startOffset" : 32,
      "endOffset" : 37
    }, {
      "referenceID" : 1,
      "context" : "1 moves = [[0,1], [0,2], [1,0], [1,2], [2,0], [2 ,1]]; 2 SELECT m1.",
      "startOffset" : 32,
      "endOffset" : 37
    }, {
      "referenceID" : 1,
      "context" : "1 moves = [[0,1], [0,2], [1,0], [1,2], [2,0], [2 ,1]]; 2 SELECT m1.",
      "startOffset" : 39,
      "endOffset" : 44
    }, {
      "referenceID" : 1,
      "context" : "1 moves = [[0,1], [0,2], [1,0], [1,2], [2,0], [2 ,1]]; 2 SELECT m1.",
      "startOffset" : 46,
      "endOffset" : 52
    }, {
      "referenceID" : 0,
      "context" : "1 moves = [[0,1], [0,2], [1,0], [1,2], [2,0], [2 ,1]]; 2 SELECT m1.",
      "startOffset" : 46,
      "endOffset" : 52
    }, {
      "referenceID" : 2,
      "context" : "this 3 FROM m1=moves , m2=moves , m3=moves , m4=moves , m5=moves , m6=moves , m7=moves 4 WHERE [[],[] ,[3,2,1]] == move(m7.",
      "startOffset" : 103,
      "endOffset" : 110
    }, {
      "referenceID" : 1,
      "context" : "this 3 FROM m1=moves , m2=moves , m3=moves , m4=moves , m5=moves , m6=moves , m7=moves 4 WHERE [[],[] ,[3,2,1]] == move(m7.",
      "startOffset" : 103,
      "endOffset" : 110
    }, {
      "referenceID" : 0,
      "context" : "this 3 FROM m1=moves , m2=moves , m3=moves , m4=moves , m5=moves , m6=moves , m7=moves 4 WHERE [[],[] ,[3,2,1]] == move(m7.",
      "startOffset" : 103,
      "endOffset" : 110
    }, {
      "referenceID" : 2,
      "context" : "this , [[3 ,2 ,1],[],[]] ))))))) AS list; 7 # result: [[0 ,2] ,[0 ,1] ,[2 ,1] ,[0 ,2] ,[1 ,0] ,[1 ,2] ,[0 ,2]]",
      "startOffset" : 8,
      "endOffset" : 17
    }, {
      "referenceID" : 1,
      "context" : "this , [[3 ,2 ,1],[],[]] ))))))) AS list; 7 # result: [[0 ,2] ,[0 ,1] ,[2 ,1] ,[0 ,2] ,[1 ,0] ,[1 ,2] ,[0 ,2]]",
      "startOffset" : 8,
      "endOffset" : 17
    }, {
      "referenceID" : 0,
      "context" : "this , [[3 ,2 ,1],[],[]] ))))))) AS list; 7 # result: [[0 ,2] ,[0 ,1] ,[2 ,1] ,[0 ,2] ,[1 ,0] ,[1 ,2] ,[0 ,2]]",
      "startOffset" : 8,
      "endOffset" : 17
    }, {
      "referenceID" : 1,
      "context" : "this , [[3 ,2 ,1],[],[]] ))))))) AS list; 7 # result: [[0 ,2] ,[0 ,1] ,[2 ,1] ,[0 ,2] ,[1 ,0] ,[1 ,2] ,[0 ,2]]",
      "startOffset" : 55,
      "endOffset" : 61
    }, {
      "referenceID" : 0,
      "context" : "this , [[3 ,2 ,1],[],[]] ))))))) AS list; 7 # result: [[0 ,2] ,[0 ,1] ,[2 ,1] ,[0 ,2] ,[1 ,0] ,[1 ,2] ,[0 ,2]]",
      "startOffset" : 63,
      "endOffset" : 69
    }, {
      "referenceID" : 1,
      "context" : "this , [[3 ,2 ,1],[],[]] ))))))) AS list; 7 # result: [[0 ,2] ,[0 ,1] ,[2 ,1] ,[0 ,2] ,[1 ,0] ,[1 ,2] ,[0 ,2]]",
      "startOffset" : 71,
      "endOffset" : 77
    }, {
      "referenceID" : 0,
      "context" : "this , [[3 ,2 ,1],[],[]] ))))))) AS list; 7 # result: [[0 ,2] ,[0 ,1] ,[2 ,1] ,[0 ,2] ,[1 ,0] ,[1 ,2] ,[0 ,2]]",
      "startOffset" : 71,
      "endOffset" : 77
    }, {
      "referenceID" : 1,
      "context" : "this , [[3 ,2 ,1],[],[]] ))))))) AS list; 7 # result: [[0 ,2] ,[0 ,1] ,[2 ,1] ,[0 ,2] ,[1 ,0] ,[1 ,2] ,[0 ,2]]",
      "startOffset" : 79,
      "endOffset" : 85
    }, {
      "referenceID" : 0,
      "context" : "this , [[3 ,2 ,1],[],[]] ))))))) AS list; 7 # result: [[0 ,2] ,[0 ,1] ,[2 ,1] ,[0 ,2] ,[1 ,0] ,[1 ,2] ,[0 ,2]]",
      "startOffset" : 87,
      "endOffset" : 93
    }, {
      "referenceID" : 0,
      "context" : "this , [[3 ,2 ,1],[],[]] ))))))) AS list; 7 # result: [[0 ,2] ,[0 ,1] ,[2 ,1] ,[0 ,2] ,[1 ,0] ,[1 ,2] ,[0 ,2]]",
      "startOffset" : 95,
      "endOffset" : 101
    }, {
      "referenceID" : 1,
      "context" : "this , [[3 ,2 ,1],[],[]] ))))))) AS list; 7 # result: [[0 ,2] ,[0 ,1] ,[2 ,1] ,[0 ,2] ,[1 ,0] ,[1 ,2] ,[0 ,2]]",
      "startOffset" : 95,
      "endOffset" : 101
    }, {
      "referenceID" : 1,
      "context" : "this , [[3 ,2 ,1],[],[]] ))))))) AS list; 7 # result: [[0 ,2] ,[0 ,1] ,[2 ,1] ,[0 ,2] ,[1 ,0] ,[1 ,2] ,[0 ,2]]",
      "startOffset" : 103,
      "endOffset" : 109
    }, {
      "referenceID" : 2,
      "context" : "2 SELECT this FROM moves WHERE [[],[] ,[3,2,1]] == move(this , tower)",
      "startOffset" : 39,
      "endOffset" : 46
    }, {
      "referenceID" : 1,
      "context" : "2 SELECT this FROM moves WHERE [[],[] ,[3,2,1]] == move(this , tower)",
      "startOffset" : 39,
      "endOffset" : 46
    }, {
      "referenceID" : 0,
      "context" : "2 SELECT this FROM moves WHERE [[],[] ,[3,2,1]] == move(this , tower)",
      "startOffset" : 39,
      "endOffset" : 46
    }, {
      "referenceID" : 2,
      "context" : "3 4 START WITH tower = [[3,2,1],[],[]], level=1 5 CONNECT BY tower = move(this , tower), level=level+1 6 STOP WITH level ==7 or []== move(this , tower);",
      "startOffset" : 24,
      "endOffset" : 31
    }, {
      "referenceID" : 1,
      "context" : "3 4 START WITH tower = [[3,2,1],[],[]], level=1 5 CONNECT BY tower = move(this , tower), level=level+1 6 STOP WITH level ==7 or []== move(this , tower);",
      "startOffset" : 24,
      "endOffset" : 31
    }, {
      "referenceID" : 0,
      "context" : "3 4 START WITH tower = [[3,2,1],[],[]], level=1 5 CONNECT BY tower = move(this , tower), level=level+1 6 STOP WITH level ==7 or []== move(this , tower);",
      "startOffset" : 24,
      "endOffset" : 31
    }, {
      "referenceID" : 2,
      "context" : "2 SELECT this , tower FROM moves WHERE [[],[] ,[3,2,1]] == move(this , tower)",
      "startOffset" : 47,
      "endOffset" : 54
    }, {
      "referenceID" : 1,
      "context" : "2 SELECT this , tower FROM moves WHERE [[],[] ,[3,2,1]] == move(this , tower)",
      "startOffset" : 47,
      "endOffset" : 54
    }, {
      "referenceID" : 0,
      "context" : "2 SELECT this , tower FROM moves WHERE [[],[] ,[3,2,1]] == move(this , tower)",
      "startOffset" : 47,
      "endOffset" : 54
    }, {
      "referenceID" : 2,
      "context" : "4 START WITH tower = [[3,2,1],[],[]], level = 1 5 CONNECT BY NO CYCLE # or UNIQUE",
      "startOffset" : 22,
      "endOffset" : 29
    }, {
      "referenceID" : 1,
      "context" : "4 START WITH tower = [[3,2,1],[],[]], level = 1 5 CONNECT BY NO CYCLE # or UNIQUE",
      "startOffset" : 22,
      "endOffset" : 29
    }, {
      "referenceID" : 0,
      "context" : "4 START WITH tower = [[3,2,1],[],[]], level = 1 5 CONNECT BY NO CYCLE # or UNIQUE",
      "startOffset" : 22,
      "endOffset" : 29
    }, {
      "referenceID" : 3,
      "context" : "2 SELECT this , tower FROM moves WHERE [[],[],[4,3,2,1]] == move(this , tower)",
      "startOffset" : 46,
      "endOffset" : 55
    }, {
      "referenceID" : 2,
      "context" : "2 SELECT this , tower FROM moves WHERE [[],[],[4,3,2,1]] == move(this , tower)",
      "startOffset" : 46,
      "endOffset" : 55
    }, {
      "referenceID" : 1,
      "context" : "2 SELECT this , tower FROM moves WHERE [[],[],[4,3,2,1]] == move(this , tower)",
      "startOffset" : 46,
      "endOffset" : 55
    }, {
      "referenceID" : 0,
      "context" : "2 SELECT this , tower FROM moves WHERE [[],[],[4,3,2,1]] == move(this , tower)",
      "startOffset" : 46,
      "endOffset" : 55
    }, {
      "referenceID" : 3,
      "context" : "3 4 START WITH tower = [[4,3,2,1],[],[]] 5 CONNECT BY MEMORIZE 15",
      "startOffset" : 24,
      "endOffset" : 33
    }, {
      "referenceID" : 2,
      "context" : "3 4 START WITH tower = [[4,3,2,1],[],[]] 5 CONNECT BY MEMORIZE 15",
      "startOffset" : 24,
      "endOffset" : 33
    }, {
      "referenceID" : 1,
      "context" : "3 4 START WITH tower = [[4,3,2,1],[],[]] 5 CONNECT BY MEMORIZE 15",
      "startOffset" : 24,
      "endOffset" : 33
    }, {
      "referenceID" : 0,
      "context" : "3 4 START WITH tower = [[4,3,2,1],[],[]] 5 CONNECT BY MEMORIZE 15",
      "startOffset" : 24,
      "endOffset" : 33
    }, {
      "referenceID" : 0,
      "context" : "4 5 directions = [[0, 1],[0,-1],[1,-1],[-1,-1],[1, 0],[-1, 0],[-1, 1],[1, 1]];",
      "startOffset" : 18,
      "endOffset" : 24
    }, {
      "referenceID" : 0,
      "context" : "4 5 directions = [[0, 1],[0,-1],[1,-1],[-1,-1],[1, 0],[-1, 0],[-1, 1],[1, 1]];",
      "startOffset" : 32,
      "endOffset" : 38
    }, {
      "referenceID" : 0,
      "context" : "4 5 directions = [[0, 1],[0,-1],[1,-1],[-1,-1],[1, 0],[-1, 0],[-1, 1],[1, 1]];",
      "startOffset" : 47,
      "endOffset" : 53
    }, {
      "referenceID" : 0,
      "context" : "4 5 directions = [[0, 1],[0,-1],[1,-1],[-1,-1],[1, 0],[-1, 0],[-1, 1],[1, 1]];",
      "startOffset" : 62,
      "endOffset" : 69
    }, {
      "referenceID" : 0,
      "context" : "4 5 directions = [[0, 1],[0,-1],[1,-1],[-1,-1],[1, 0],[-1, 0],[-1, 1],[1, 1]];",
      "startOffset" : 70,
      "endOffset" : 76
    }, {
      "referenceID" : 0,
      "context" : "4 5 directions = [[0, 1],[0,-1],[1,-1],[-1,-1],[1, 0],[-1, 0],[-1, 1],[1, 1]];",
      "startOffset" : 70,
      "endOffset" : 76
    }, {
      "referenceID" : 17,
      "context" : "In [19] and [20] we had described a methodology that overlays smart and distributed environments with some kind of distributed scene graph (by using cloud based techniques).",
      "startOffset" : 3,
      "endOffset" : 7
    }, {
      "referenceID" : 18,
      "context" : "In [19] and [20] we had described a methodology that overlays smart and distributed environments with some kind of distributed scene graph (by using cloud based techniques).",
      "startOffset" : 12,
      "endOffset" : 16
    } ],
    "year" : 2017,
    "abstractText" : "SelectScript is an extendable, adaptable, and declarative domainspecific language aimed at information retrieval from simulation environments and robotic world models in an SQL-like manner. In this work we have extended the language in two directions. First, we have implemented hierarchical queries; second, we improve efficiency enabling manual design space exploration on different “search” strategies. As depicted in the teaser above, we demonstrate the applicability of such extensions in two application problems; the basic language concepts are explained by solving the classical problem of the Towers of Hanoi and then a common path planning problem in a complex 3D environment is implemented.",
    "creator" : "LaTeX with hyperref package"
  }
}