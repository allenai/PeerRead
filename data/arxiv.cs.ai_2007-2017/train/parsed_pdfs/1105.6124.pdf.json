{
  "name" : "1105.6124.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : "Reasoning on Interval and Point-based Disjunctive Metric Constraints in Temporal Contexts",
    "authors" : [ "Federico Barber" ],
    "emails" : [ "FBARBER@DSIC.UPV.ES" ],
    "sections" : [ {
      "heading" : null,
      "text" : "© 2000 AI Access Foundation and Morgan Kaufmann Publishers. All rights reserved."
    }, {
      "heading" : "1. Introduction",
      "text" : "Two main lines of research are commonly recognized in the temporal reasoning area. The first approach deals with reasoning about temporal constraints on time-dependent entities. The goal is to determine what consequences (T) follow from a set of temporal constraints, \"{TemporalConstraints}|=T?\", or to determine whether a set of temporal constraints is consistent, with no assumptions about properties of temporal facts. The second approach deals with reasoning about change, events, actions and causality. Here, the goal is to obtain the consequent state from a set of actions or events which are performed on an initial state: \"[Si, {A1, A2, ..., An}]|= Sj?\". Both these approaches constitute active fields of research with applications in several artificial intelligence areas such as reasoning about change, scheduling, temporal planning, knowledge-based systems, natural language understanding, etc. In these areas, time plays a crucial role, problems have a dynamic behavior, and it is necessary to represent and reason about the temporal dimension of information.\nIn this paper, we deal with the first of these approaches. Our goal is reasoning on qualitative and quantitative constraints between intervals or time-points in temporal contexts. Moreover, special cases of non-binary constraints are also managed. These tasks are pending issues in the temporal reasoning area, as well as important features to facilitate modeling of relevant problems in this area (including planning, scheduling, causal or hypothetical reasoning, etc.).\nSeveral temporal reasoning models have been defined in the literature, with a clear trade-off between representation expressiveness and complexity of reasoning algorithms. Qualitative Point Algebra (PA) (Vilain, Kautz & Van Beek, 1986) is a limited subset of interval-based models. Interval\nAlgebra (IA) introduced by Allen (1983) represents symbolic (qualitative) constraints between intervals but metric information, such as 'interval1 starts 2 seconds before interval2', cannot be included. Metric (quantitative) point-based models (Dechter, Meiri & Pearl, 1991) include the 'time line' (metric) in their constraints, but they can only represent a limited subset of disjunctive constraints between intervals. Thus, constraints like 'interval1 {bef, aft} interval2' cannot be represented (Gerevini & Schubert, 1995).\nSome efforts have been made to integrate qualitative and quantitative temporal information on points and intervals (Kautz & Ladkin, 1991; Drakengren & Jonsson, 1997; etc.). Particularly, Meiri (1996) introduces Qualitative Algebra (QA), where each interval is represented by three nodes (one representing the interval and the other two representing its extreme points) such that QA can represent qualitative and metric constraints on points and intervals. Badaloni and Berati (1996) define the Interval Distance Sub Algebra (IDSA), where nodes are intervals. These intervals are related by disjunctive 4-tuple-metric constraints between their ending time points {(I-i, I - j), (I + i, I - j), (I - i, I + j), (I + i, I+j)}. Staab and Hahn (1998) propose a model for reasoning on qualitative and metric boundaries of intervals. However, these models cannot handle constraints on interval durations, which were identified earlier by Allen (1983). Constraints such as 'interval1 lasts 2 seconds more than interval2' require a high-order expression (Dechter et al., 1991), or a duration primitive which should be integrated with interval and point constraints (Allen, 1983; Barber, 1993). Particularly, Barber (1993) proposes two orthogonal networks to relate constraints on durations and time points. Navarrete (1997) and Wetprasit and Sattar (1998) relate disjunctive constraints on durations and time points, but only a limited subset of interval constraints is managed. More recently, Pujari and Sattar (1999) propose a framework for reasoning on points, intervals and durations (PIDN). Here, variables represent points or intervals, and constraints are an ordered set of three intervals representing (Start, End, Duration) subdomains. However, no specialized algorithms for management of PIDN constraints are proposed.\nIn relation to the complexity of reasoning algorithms, the consistency problem is polynomial in PA (Vilain, Kautz & Van Beek, 1986) and in non-disjunctive metric networks (Dechter et al., 1991). However, Vilain, Kautz and Van Beek (1986) also showed that determining the consistency of a general-case temporal network (i.e.: disjunctive qualitative and metric constraints between points, intervals or durations) is NP-hard. Thus, in previous qualitative or quantitative models, the consistency problem is tractable only under some properties on constraints, relationships between variable domains and constraints, or by using restricted subsets of constraints (Dechter et al., 1991; Dechter, 1992; van Beek & Detcher, 1995; Wetprasit & Sattar, 1998; Jeavons et al., 1998; etc.). For instance, tractable subclasses of IA have been identified by Vilain, Kautz and Van Beek (1986), Nebel and Burckert (1995), Drakengren and Jonsson (1997), etc. Moreover, some interesting results have been obtained in identification of tractable subclasses of QA. Specifically, Jonsson et al. (1999) identified the five maximal tractable subclasses of the qualitative point-interval algebra. However, to my knowledge the maximal tractable subclass of PIDN model (maximal tractable subclass of qualitative and quantitative point, interval and duration constraints) is still not identified. In any case, these restricted tractable subclasses are not able to obtain expressiveness of full models, and the problem of reasoning on disjunctive constraints on points and intervals remains NP-complete.\nOn the other hand, these qualitative and metric temporal models do not manage certain types of non-binary constraints, which are important for modeling some problems (scheduling, causal reasoning, etc.). For instance, disjunctive assertions like ‘(interval1 {bef, meets} interval2) ∨ (time-\npoint3 is [10 20] from time-point4)’, or temporal-causal relations like ‘If (interval1 {bef, meets} interval2) then (time-point3 is [10 20] from time-point4)’ should be incorporated in these models (Meiri, 1996). Moreover, the global consistency property introduced by Dechter (1992) is an important property in temporal networks, since it allows us to obtain solutions by backtrack-free search (Dechter, 1992; Freuder, 1982). In particular, a global consistent network would allow us to handle conjunctive queries like ‘does ‘(interval1 {bef, meets} interval2) ∧ (time-point3 is [10 20] from time-point4) hold?’ without propagation of the query, as it is required in (van Beek, 1991). Stergiou and Koubarakis (1996), Jonsson and Bäckström (1996) dealt with the representation of temporal constraints by means of disjunctions of linear constraints (linear inequalities and inequations) also named Disjunctive Linear Relations (DLRs). These expressions are a unifying approach to manage disjunctive constraints on points, intervals and durations, such that these expressions subsume most of the formalism for temporal constraint reasoning (Jonsson & Bäckström, 1998). Moreover, DLRs are able to represent disjunctions of non-disjunctive metric constraints (x1y1≤c1 ∨ x2-y2≤c2 ∨ ....∨ xn-yn≤cn), where xi and yi are time points, ci real numbers and n≥1 (Stergiou & Koubarakis, 1998). Obviously, the satisfiability problem for an arbitrary set of disjunctions of linear constraints is NP-complete. Interesting tractable subclasses of DLRs and conditions on tractability are identified in (Cohen et al., 1996; Jonsson & Bäckström, 1996; and Stergiou & Koubarakis, 1996). The two main tractable subclasses are Horn linear and Ord-Horn linear constraints (Stergiou & Koubarakis, 1996; Jonsson & Bäckström, 1998). However, these subclasses subsume temporal algebras whose management is also polynomial.\nThe management of a set of disjunctions of linear constraints is mainly based on general methods from linear programming, although some specific methods have been defined for tractable subclasses (Stergiou & Koubarakis, 1998; Cohen et al., 1996; etc.). As Pujari and Sattar outline (1999), the linear programming approach, though expressive, does not take advantage of the underlying structures (e.g., domain constraints) of temporal constraints. In addition, usual concepts in temporal reasoning, as composition and intersection operations on constraints, minimal constraints, kconsistency (Freuder, 1982), decomposability (Montanari , 1974), globally consistency (Dechter, 1992), etc., and their consequences should be adapted to reasoning on disjunctive linear constraints, which is not a trivial issue.\nIn spite of the expressive power of the previous models, some problems (including planning, scheduling, hypothetical reasoning, etc.) also need to reason on alternative contexts (situations, intentions or causal projections) and to know what holds in each one of them (Dousson et al., 1993; Gerevini & Schubert, 1995; Garcia & Laborie, 1996; Srivastava & Kambhampati, 1999). This gives rise to the need to reason on context-dependent constraints. This feature is not supported in the usual temporal models in a general way, nor described in the usual expressive power of constraints (Jeavons et al., 1999). Therefore, ad-hoc methods should be used when reasoning on temporal contexts is required.\nThese issues will be addressed in this paper. We describe a temporal model, which integrates qualitative and metric disjunctive constraints on time-points and intervals. The temporal model is based on time-points as primitive, such that intervals are represented by means of their end timepoints. However, the representation of interval constraints seems to imply some kind of relation among endpoint constraints (Gerevini & Schubert, 1995). The proposed temporal model introduces labeled constraints, where each elemental constraint (disjunct) in a disjunctive point-based metric constraint is associated to one unique label. In this way, point-based constraints can be related among\nthem without using hyper-arcs. Therefore, metric and symbolic constraints among intervals and timepoints can be fully integrated, represented and managed by means of a labeled metric point-based Temporal Constraint Network (TCN). Particularly, the model proposed here handles constraints proposed in QA (Meiri, 1996), IDSA (Badaloni & Berati, 1996), and Distance Constraint Arrays model (Staab & Hahn, 1998). Moreover, several added functionalities are also provided:\n• Management of alternative temporal contexts. Each input constraint can be associated to a given context. A hierarchy of alternative temporal contexts can be defined, such that constraints between points and intervals are dependent on each context. To my knowledge, these features improve existing temporal models, where contexts are not managed.\n• Reasoning algorithms on labeled constraints are based on a closure process. These processes guarantee consistency and obtain a minimal disjunctive context-dependent TCN. Additionally, a special type of globally labeled-consistent TCN is obtained. This property allows us to obtain solutions by backtrack-free search (Freuder, 1982).\n• Management of a special type of non-binary constraints. Reasoning algorithms are able to manage disjunctions of disjunctive constraints. This supposes an extension of disjunctions of non-disjunctive metric constraints proposed by Stergiou and Koubarakis (1998). Moreover, given a set of disjunctive constraints, the model can handle logical relations among disjunctions of different constraints. Thus, we can express that a set of atomic disjuncts in disjunctive constraints are mutually disjunctive among them. Therefore, a special type of and/or TCN can be managed as a conjunctive (and) TCN. Likewise, the model can also handle special non-binary constraints representing implications among temporal constraints as were identified by Meiri (1996).\nWith these features, the proposed temporal model is suitable for modeling problems where these requirements appear. The computational cost of reasoning methods is non-polynomial, given the complexity of the underlying problem. However, several improvements are also proposed.\nA brief revision of the main temporal reasoning concepts is presented in Section 2. In Section 3, a temporal algebra for labeled point-based disjunctive metric constraints is described. This temporal algebra introduces the concept of labeled constraints and their temporal operations. Reasoning algorithms for guaranteeing a minimal (and consistent) TCN are specified in Section 4. By using this model, the integration of interval and point-based constraints and management of non-binary constraints are respectively described in Sections 5 and 6. Association of constraints to temporal contexts and management of context-dependent constraints are detailed in Section 7. Finally, Section 8 concludes."
    }, {
      "heading" : "2. Basic Temporal Concepts",
      "text" : "Temporal reasoning deals with reasoning on temporal constraints. The syntax and semantics of constraints are defined by an underlying temporal algebra, which is the basis for performing the reasoning processes. A temporal algebra can be defined according to the following elements:\n• Temporal primitive (or variable) 'xi', usually time-points (ti) or intervals (Ii).\n• Interpretation domain D for primitives xi. The interpretation domain represents the time line.\nTime points are instantiated on D (ti∈D), and temporal intervals can be modelled as pairs of ending time points that can be instantiated on D: Ii = (Ii -, Ii +), Ii∈DxD, Ii-≤Ii+.\n• Temporal constraints between primitives, where each constraint relates n primitives: c1,2..n(x1, x2, ..., xn). As particular cases, the 'empty constraint' {∅} is named the Inconsistent-Constraint and 'U' is the Universal-Constraint. Unary-constraints restrict the interpretation domain D for variables. They are not usually used in symbolic algebras, where an infinite domain is assumed. Binary-constraints are temporal constraints between two variables (xi cij xj), and nary-constraints represent temporal constraints among n variables. By default, binary constraints are assumed in this paper. We can also have qualitative (relative relation) or quantitative (metric relation) constraints, as well as disjunctive (cij is a set of disjunctive basic constraints, |cij|≥1) or non-disjunctive constraints.\n• Operations between constraints. Mainly, Temporal Composition (⊗), Temporal Intersection (⊕), Temporal Union (∪Τ), and Temporal Inclusion (⊆Τ).\nA temporal problem is specified by a set of n variables X= {xi}, an interpretation domain D and a finite set of temporal constraints between variables {(xi cij xj)}. A temporal problem gives rise to a Temporal Constraint Network (TCN) which can be represented as a directed graph where nodes represent temporal primitives (xi) and labeled-directed edges represent the binary constraints between them (cij). The Universal Constraint U is not usually represented in the graph, and each direct edge (representing cij) between xi and xj implies an inverse one (representing cji) between xj and xi. According to the underlying Temporal Algebra, we mainly have IA-TCNs based on the Interval Algebra (Allen, 1983), PA-TCNs based on the Point Algebra (Vilain et al., 1986), or Metric-TCNs based on the Metric Point Algebra (Dechter et al., 1991; Dean & McDermott, 1987). In this later case, disjunctive metric point-based constraints give rise to a Temporal Constraint Satisfaction Problem (TCSP) (Dechter et al., 1991).\nReasoning on temporal constraints can be seen as a Constraint Satisfaction Problem (CSP). An instantiation of the variables X is a n-tuple (v1, v2, v3, ...,vn) / vi∈D which represents the assignments of values {vi} to variables {xi}: (x1=v1, x2=v2, ...,xn=vn). A (global) solution of a TCN is a consistent instantiation of the variables X in their domains such that all TCN constraints are satisfied. A value v is a consistent (or feasible) value for xi if there exists a TCN solution in which xi=v. The set of all feasible values of a variable xi is the minimal domain for the variable. A constraint (xi cij xj) is consistent if there exists a solution in which (xi cij xj) holds. A constraint cij is minimal iff it consists only of consistent elements (or feasible values) that is, those which are satisfied by some interpretation of TCN constraints. A TCN is minimal iff all its constraints are minimal.\nA TCN is consistent (or satisfiable) iff it has at least one solution. Freuder (1982) generalizes the notion of consistency as: 'a network is k-consistent iff (given any instantiation of any k-1 variables satisfying all the direct constraints among those variables) there exists at least one instantiation of any kth variable such that the k values taken together satisfy all the constraints among the k variables'. As consequences: (i) all (k-1)-length paths in the network are consistent, (ii) for each pair or nodes, there exists an interpretation that satisfies each (k-1)-length path between them, and (iii) each sub-TCN of k-nodes is consistent. As particular cases, 1-consistency, 2-consistency and 3-consistency are called node-consistency, arc-consistency and path-consistency, respectively (Mackworth, 1977; Montanari, 1974).\nPath-consistency is a common concept in constraint networks. From Montanari (1974) and Mackworth (1977), ‘a path of k-length through nodes (x1, x2, ..., xk, xj) is path-consistent iff for any value v1∈d1 and vj∈dj such that (x1=v1 c1j xj=vj) holds, there exists a sequence of values v2∈d2, v3∈d3, ..., vk∈dk such that (v1 cl2 v2), (v2 c23 v3),...., and (vk ck,j vj) hold’. A TCN is path-consistent iff all its paths are consistent. Moreover, Montanari (1974) proves that to ensure path-consistency it suffices to check every 2-length path. Thus, path-consistency and 3-consistency are equivalent concepts. Alternatively, Meiri (1996) outlines a path of k-length (xi, x1, x2, ...,xk, xj) is path-consistent iff cij ⊆Τ (ci1 ⊗ c12⊗ ... ⊗ ckj). However, this definition disregards domain constraints, such that it is equivalent to the former definition if variable domains are infinite or the TCN is also node and arc-consistent, as the usual case in symbolic algebras. In metric algebras, path-consistency usually assumes node and arc-consistency. Therefore, taking into account that it is only necessary to test 2-length paths to assure path-consistency, a TCN is path-consistent iff ∀cij,cik,ckj⊆TCN, cij ⊆Τ (cik ⊗ ckj). This condition gives rise to the more usual path-consistent algorithm: the Transitive Closure Algorithm (TCA) which imposes local 3-consistency in each sub-TCN of 3 nodes, such that all 2-length paths become consistent paths (Mackworth, 1977; Montanari , 1974). The TCA algorithm will obtain an equivalent path-consistent TCN if it exists. Otherwise, it fails.\n∀cij,cik,ckj⊆TCN: cij←cij ⊕ (cik ⊗ ckj)\nA network is strong k-consistent iff the network is j-consistent for all j≤k (Freuder, 1982). An nconsistent TCN is a consistent TCN, and a strong n-consistent TCN is a minimal TCN. Alternatively, Dechter (1992) introduces the concepts of local and global consistency: A partial instantiation of variables (x1=v1, x2=v2, ...,xk=vk) / 1≤k<n is locally consistent if it satisfies all the constraints among these variables. A subTCN is globally consistent if any locally consistent instantiation of the variables in the subTCN can be extended to a consistent instantiation of all TCN. A globally consistent TCN is one in which all its subTCNs are globally consistent. Thus, a TCN is strong nconsistent iff it is globally consistent (Dechter, 1992).\nThe first reasoning task on a TCN is to determine whether the TCN is consistent. If the TCN is consistent, we can then obtain the minimal-TCN, all TCN solutions (by assuming a discrete and finite model of time), only one solution, a partial solution (consistent instantiation of a subset of TCN variables, which is a part of a global solution), etc.\nDeductive closure, or propagation, is one of the basic reasoning algorithms. The closure process is a deductive process on a TCN, where new derived constraints are deduced from the explicitly asserted ones by means of the composition (⊗) and intersection (⊕) operations. Thus, the process of determining the consistency and the minimality of a TCN is related to a sound and complete closure process (Vilain et al., 1986). Alternatively, CSP-based methods (with several heuristic search criteria) are also used for guaranteeing consistency and obtaining TCN solutions. In this paper, we are mainly interested in TCN closure processes.\nDetermining the consistency of a general-case TCN is NP-hard, and Minimal TCNs can be obtained by a polynomial number of consistency processes (Vilain et al., 1986). Particularly, Dechter, Meiri and Pearl (1991) showed that determining consistency and obtaining a minimal disjunctive metric TCN can be achieved in O(n3 le), where ‘n’ is the number of TCN nodes, ‘e’ is the number of explicitly asserted (input) constraints, and ‘l’ is the maximum number of intervals in an input constraint. However, specific levels of k-consistency can guarantee consistency and obtain a minimal TCN, depending on the TCN topology or the underlying temporal algebra. For example, path-\nconsistency guarantees consistency and obtains a minimal non-disjunctive metric TCN (Dechter et al., 1991). The path-consistency TCA Algorithm has an O(n3) cost (Allen, 1983; Vilain, Kautz & Van Beek, 1986). However, assuring path-consistency can become a complex task in disjunctive metricTCNs if the variable domain D is large or continuous. As was stated by Dechter, Meiri and Pearl (1991), the number of intervals in |cij ⊗ cjk| is upper bounded by |cij|x|cjk|. Thus, the total number of disjuncts (subintervals) in a path-consistent TCN might be exponential in the number of disjuncts per constraints in the initial (input) TCN. Schwalb and Dechter (1997) call this the fragmentation problem, which does not appear in non-disjunctive metric TCNs. Thus, the TCA algorithm is O(n3 R3) in disjunctive metric-TCNs if time is not dense (Dechter et al., 1991), where the range ‘R’ is the maximum difference between the lowest and highest number specified in any input constraints."
    }, {
      "heading" : "3. A Labeled Temporal Algebra",
      "text" : "The main elements of the point-based disjunctive metric temporal algebra are (Dechter et al., 1991):\n• Time-point (ti) as primitive variable. A continuous variable domain (like Q or ℜ) is usually assumed.\n• Each temporal constraint cij⊆U is a finite set of l mutually exclusive subdomains (or subintervals) of D.\ncij≡{[d-1 d+1], [d-2 d+2], ...., [d-k d+k], ....., [d-l d+l]} , where d-k≤d+k and d-k,d+k∈D,\nand disjunctively restricts the temporal distance between two time-points, ti and tj:\ntj - ti ∈ {[d-1 d+1], [d-2 d+2], ....., [d-l d+l]},\nmeaning that (d-1≤tj-ti≤ d+1) ∨ .... ∨ (d-l≤ tj-ti≤ d+l). Similar conditions can be applied to open (d-k d + k) and semi-open intervals (d - k d + k], [d - k d + k). The Universal-Constraint U is {(-∞ +∞)}. Unary constraints restrict the associated subdomain of a time-point ti∈{[d-1 d+1], [d-2 d+2], ....., [d-l d + l]}. A special time-point T0 is usually included, which represents 'the beginning of the world' (usually, T0=0). Thus, each unary constraint on ti can be represented as a binary one between ti and T0:\nti - T0 ∈ {[d-1 d+1], [d-2 d+2], ..... ,[d-l d+l]} ≡ ti∈[d-1, d+1] ∨ ti∈[d-2, d+2] ∨, ..., ∨ ti∈[d-l, d+l]\nand, by default: ∀ti, (T0 {[0 ∞)} ti).\n• The algebra operations, mainly ⊗, ⊕, ∪Τ and ⊆Τ. From (Meiri, 1996), given two temporal constraints S={[dS-i, dS+i]} and T={[dT-j, dT+j]},\nS ⊗ T = {dk / ∃di∈S ∧ ∃dj∈T / dk= di+dj}.\nThat is, ∀[dS-i, dS+i]∈S, ∀[dT-j, dT+j]∈T, ∪T{[dS-i+dT-j, dS+i+dT+j]}. Here, resulting subdomains in S ⊗ T may not be pairwise disjoint. Therefore, some additional processing may be required to compute a disjoint subdomain set.\nS ⊕ T = {dk / dk∈S ∧ dk∈T}. That is, the set-intersection of their subdomains. S ∪Τ T = {dk / dk∈S ∨ dk∈T}, as the set-union of their subdomains. S⊆ΤT = iff ∀dk∈S, ∃dk∈T.\nOn the basis of the point-based disjunctive metric temporal algebra and its operations, we introduce a labeled point-based disjunctive metric temporal algebra, which gives rise to a labeledTCN."
    }, {
      "heading" : "3.1 Labeled Constraints and Inconsistent Label Sets",
      "text" : "An elemental constraint (ec) is one disjunct in a disjunctive constraint. Similar terms are atomic, basic or canonical constraints. However, let’s use this term due to the special structure of labeled elemental constraints which are introduced further on. Thus, a disjunctive constraint cij can be considered as a disjunctive set of l mutually exclusive elemental constraints {ecij.k}.\necij.k = [d-ij.k d+ij.k] / ∀i,j,k d-ij.k≤d+ij.k\ncij ≡{ecij.1, ec ij.2, ..., ec ij.l} ⊆ U / ∀k,p∈(1,..,l), k≠p, (ecij.k ⊕ ec ij.p)=∅\nDefinition 1 (Labeled constraints). A labeled elemental constraint lecij.k is an elemental constraint ecij.k associated to a set of labels {labelij.k}, where each labelij.k is a symbol. A labeled constraint lcij is a disjunctive set of labeled elemental constraints {lecij.k}. That is,\nlcij ≡ {lecij.1, lecij.2, ..., lecij.l}, where\nlecij.k ≡ (ecij.k{labelij.k}), and {labelij.k}≡{label1, label2, ..., labels} is a set of symbols.◊\nEach label in a labeled-TCN can be considered as a unique symbol. The following cases can occur:\ni) If an input (or explicitly asserted) constraint lcij has only one elemental constraint, that is, only one disjunct, this elemental constraint has the label 'R0'. The labeled UniversalConstraint is {U{R0}}. In a given TCN, the set of all elemental constraints labeled with 'R0' is the ‘common context’. Thus, the label R0 represents the set of elemental constraints which have no other alternatives (disjuncts). All elemental constraints labeled only with R0 should hold since they have no other alternative disjuncts.\nii) If an input constraint lcij has more than one elemental constraint, each elemental constraint lecij.k∈lcij has a single and exclusive label associated to it (|{labelij.k}|=1). Thus, each label in the TCN represents bi-univocally an elemental constraint in an explicitly asserted constraint.\niii) Each derived elemental constraint (obtained by combining (⊗lc) or intersecting (⊕lc) two labeled elemental constraints) has a set of labels associated to it. This set of labels is obtained from the label sets associated to the combined (or intersected) labeled elemental constraints. It will be detailed in the later specification of operations (⊗lc, ⊕lc) in Section 3.2. In consequence, the label set associated to a derived elemental constraint represents the conjunctive support-set of explicitly asserted elemental constraints that imply this derived elemental constraint.\nLet's see a simple example on labeled constraints, which was introduced by Dechter, Meiri and Pearl (1991).\nExample 1: \"John goes to work either by car [30'-40'], or by bus (at least 60'). Fred goes to work either by car [20'-30'], or in a carpool [40'-50']. Today John left home (t1) between 7:10 and 7:20, and Fred arrived (t4) at work between 8:00 and 8:10. We also know that John arrived (t2) at work about 10'-20' after Fred left home (t3).\"\nIn this example, we have the disjunctive labeled constraints in Figure 1, where T0 represents the initial time (7:00) and where the granularity is in minutes. A label 'R0' is associated to elemental constraints belonging to constraints with only one disjunct. In constraints with more than one, mutually exclusive disjuncts, each disjunct is labeled with an exclusive label Rn (n>0). Thus,\n• The label R0 is associated to \"John left home between 7:10 and 7:20\", \"Fred arrived at work between 8:00 and 8:10\", and \"John arrived at work about 10'-20' after Fred left home\". This is the common context.\n• The label R1 is associated to \"John goes by bus\", and R2 to \"John goes by car\".\n• The label R3 is associated to \"Fred goes in a carpool\", and R4 to \"Fred goes by car\".\nDefinition 2 (Inconsistent-Label-Sets). An Inconsistent-Label-Set (I-L-Set) is a set of labels {labeli} and represents a set of overall inconsistent elemental constraints. That is, they cannot all simultaneously hold. ◊\nTheorem 1. Any label set that is a superset of an I-L-Set is also an I-L-Set. The proof is obvious. If a set of elemental constraints is inconsistent, any superset of it is also inconsistent. ◊\nDefinition 3. Elemental constraints {lecij.k} of an input disjunctive constraint lcij are pairwise disjoint. Thus, each 2-length set of labels from each pair of {lecij.k} is added to the set of I-L-Sets. That is, for each input constraint lcij ≡ {lecij.1, lecij.2, ..., lecij.l}, where lecij.k≡(ecij.k{labelij.k}) and |{labelij.k}|=1:\n∀k,p∈(1,..,l) / k≠p, I-L-Sets ← I-L-Sets ∪ ({labelij.k}∪{labelij.p}) ◊\nIn the example of Figure 1, {R1 R2} and {R3 R4} are I-L-Sets. Other I-L-Sets existing in a labeled TCN will be detected in the reasoning processes later detailed in Section 4."
    }, {
      "heading" : "3.2 Operations on Labeled Constraints",
      "text" : "The following points define the main operations on labeled constraints."
    }, {
      "heading" : "3.2.1 TEMPORAL INCLUSION ⊆LC",
      "text" : "The temporal inclusion operation ⊆lc should take into account the inclusion of temporal intervals and the inclusion of associated label sets:\nlecij.k ⊆lc lecij.p = (ecij.k {labelij.k}) ⊆lc (ecij.p {labelij.p}) =def ecij.k ⊆T ecij.p ∧ {labelij.k}⊆ {labelij.p}."
    }, {
      "heading" : "3.2.2 TEMPORAL UNION ∪LC",
      "text" : "Operation ∪lc performs the disjunctive temporal union of labeled constraints as the set-union of their elemental constraints. However, all labeled elemental constraints whose associated labels are I-L-Sets should be rejected.\nlcij ∪lc lc’ij =def ∀lecij.k∈lcij, ∪lc [{lecij.k} lc’ij] , where ∪lc [{lecij.k} lc’ij] = (ecij.k{labelij.k}) ∪lc lc’ij =def\nInconsistent({labelij.k}) : lc’ij\n∃lecij.p∈lc’ij / lecij.p⊆lc lecij.k : lc’ij (s1) Other : ({lc’ij} ∪ {lecij.k}) - ({lecij.p}, ∀lecij.p∈lc’ij ∧ lecij.k⊆lclecij.p) (s2).\nThe function Inconsistent({labelij.k}) returns true if the set {labelij.k} is an I-L-Set or a superset of any existing I-L-Set (Theorem 1). Otherwise, it returns false:\nInconsistent({labelij.k}) =def If ∃{labels}∈Inconsistent-Label-Sets / {labels}⊆{labelij.k} Then True Else False.\nThe operation ∪lc simplifies the resulting constraint. Equal or less-restricted elemental constraints with equal or bigger associated label sets are removed. For instance:\n{([10 30]{R1 R3 R5 R9}), ([40 40]{R6 R7})} ∪lc {([10 20]{R1 R3}), ([40 40]{R6 R7 R8})} = {([10 20]{R1 R3}), ([40 40]{R6 R7})}.\nIn the resulting constraint, ([10 30]{R1 R3 R5 R9}) and ([40 40]{R6 R7 R8}) are eliminated, as examples of the cases s1 and s2, respectively. That is, ([10 20]{R1 R3}) ⊆lc ([10 30]{R1 R3 R5 R9}) and ([40 40]{R6 R7}) ⊆lc ([40 40]{R6 R7 R8}). These simplifications can seem counter-intuitive. However, note that the label set associated to each derived-labeled elemental constraint represents the support set (composed of input elemental constraints) from which the derived-labeled elemental constraint is obtained. Thus, only the minimal associated label set should be represented, for reason of efficiency. Moreover, the more labels are in the associated label set {labelij.k}, the elemental constraint (ecij.k) should be equal or more restricted."
    }, {
      "heading" : "3.2.3 TEMPORAL COMPOSITION ⊗LC",
      "text" : "Operation ⊗lc performs the temporal composition of labeled constraints. It is based in the operation ⊗ of the underlying disjunctive metric point-based algebra.\nlcij ⊗lc lcjk =def ∀lecij.p∈lcij, ∀lecjk.q∈lcjk ∪lc [ (ecij.p ⊗ ecjk.q {labelij.p}∪{labeljk.q})].\nFor instance: {([0 10]{R1}), ([20 30]{R2})} ⊗lc {([100 200]{R3}), ([300 400]{R4})} = {([320 430]{R4 R2}), ([300 410]{R4 R1}), ([100 210]{R3 R1}), ([120 230]{R3 R2})}.\nNote that elemental constraints in a labeled derived constraint may not be pairwise disjoint. However, these labeled derived elemental constraints cannot be simplified. This is related to the fragmentation problem of the disjunctive metric algebra (Schwalb & Dechter, 1997). We have that each derived-labeled elemental constraint should have its own associated label set. In the example, (([320 430]{R4 R2}), ([300 410]{R4 R1})) cannot be simplified to ([300 430]{R4 R2 R1}) since each subinterval depends on a different set of labels (that is, on a different support-set of elemental constraints). If the label set {R4 R2} becomes an I-L-Set, only ([320 430]{R4 R2}) should be removed. On the other hand, if [300 410] becomes an inconsistent interval between the implied time points, only {R4 R1} should be asserted as an I-L-Set."
    }, {
      "heading" : "3.2.4 TEMPORAL INTERSECTION ⊕LC",
      "text" : "Operation ⊕lc performs the temporal intersection of labeled constraints and is based on the operation ⊕.\nlcij ⊕lc lc’ij =def ∀lecij.k∈lcij, ∀lecij.p∈lc’ij , ∪lc [lecij.k ⊕lc lecij.p]\nwhere, lecij.k ⊕lc lecij.p =def If ecij.k ⊕ ecij.p= ∅ Then {∅} ;The Inconsistent-Constraint is returned.\nElse [(ecij.k ⊕ ecij.p) ({labelij.k}∪{labelij.p})] As example:\n{([0 10]{R1}), ([20 25]{R2})} ⊕lc {([0 30]{R3}), ([40 50]{R4})} = {([20 25]{R3 R2}), ([0 10]{R3 R1})}\nIn the operations ⊗lc and ⊕lc, the label set {labelij.r} associated to each derived labeled-elemental constraint (ecij.r) is obtained from the set-union of labels associated to combined (⊗lc) or intersected (⊕lc) labeled-elemental constraints. Therefore, {labelij.r} represents the support set (composed of input elemental constraints) that implies the derived elemental constraint (ecij.r).\nDefinition 4. A set of I-L-Sets is complete if it represents all inconsistent sets of TCN elemental constraints. A set of I-L-Sets is sound if each I-L-Set represents an inconsistent set of elemental constraints. ◊\nTheorem 2. Assuming a complete and sound set of I-L-Sets, a labeled elemental constraint is consistent iff it has an associated label set which is not an I-L-Set. The proof is trivial, since the label set associated to each labeled elemental constraint represents its support-set. ◊\nTheorem 3. Assuming a complete and sound set of I-L-Sets, no inconsistent labeled elemental constraint is obtained in operations ⊗lc and ⊕lc.\nProof: The operations ⊗lc and ⊕lc use the operation ∪lc to obtain their results. This operation ∪lc rejects all labeled elemental constraints whose associated labels are I-L-Sets. Thus, all elemental constraints derived in operations ⊗lc and ⊕lc are consistent (Theorem 2). ◊"
    }, {
      "heading" : "3.3 Distributive Property ⊗lc Over ⊕lc in Disjunctive Labeled Constraints",
      "text" : "Operations ⊗ and ⊕ are distributive (i.e.: ⊗ distributes over ⊕) in non-disjunctive metric TCN, but this property does not hold in disjunctive metric constraints. Dechter, Meiri and Pearl (1991) show the following example. Given the disjunctive metric constraints:\na= {[0 1], [10 20]}, b= {[25 50]}, c= {[0 30], [40 50]}, we have:\n(a ⊗ (b ⊕ c) = {[25 31], [35 70]} (a ⊗ b) ⊕ (a ⊗ c) = {[25 70]}.\nThus, clearly (a ⊗ (b ⊕ c) ≠ (a ⊗ b) ⊕ (a ⊗ c). However, the distributive property holds for operations ⊗lc and ⊕lc in labeled TCN.\nTheorem 4. By using labeled constraints and I-L-Sets, ⊗lc distributes over ⊕lc.\nProof: Let’s consider the labeled constraints lci, lcj and lck. Thus,\n(lci ⊗lc lcj) ⊕lc (lci ⊗lc lck) can be expressed, according to the definition of operation ⊗lc, as:\n(∀lecp∈lci, ∀lecq∈lcj, ∪lc[(lecp ⊗lc lecq)]) ⊕lc (∀lecr∈lci, ∀lecs∈lck, ∪lc[(lecr ⊗lc lecs)]) = ∀lecp∈lci, ∀lecq∈lcj, ∀lecr∈lci, ∀lecs∈lck (∪lc[(lecp ⊗lc lecq)] ⊕lc ∪lc[(lecr ⊗lc lecs)])\nwhich, according to the definition of ⊕lc, can be expressed as: ∀lecp∈lci, ∀lecq∈lcj, ∀lecr∈lci, ∀lecs∈lck (∪lc[(lecp ⊗lc lecq) ⊕lc (lecr ⊗lc lecs)]) (e1)\nIn this expression, lecp and lecr are elemental constraints of the same-labeled constraint lci. However, the set-union of label sets associated to each pair of elemental constraints in any (input or derived) labeled constraint is an I-L-Set (Definition 3). That is, if lecp≠lecr, then {labelp}∪{labelr} is an I-L-Set. Thus, if lecp≠lecr, the label set associated to (lecp ⊗lc lecq) ⊕lc (lecr ⊗lc lecs) is an I-LSet. In consequence, (lecp ⊗lc lecq) ⊕lc (lecr ⊗lc lecs) is rejected in operation ∪lc. That is,\n∀lecp∈lci, ∀lecq∈lcj, ∀lecr∈lci, ∀lecs∈lck / lecp≠lecr (∪lc[(lecp ⊗lc lecq) ⊕lc (lecr ⊗lc lecs)]) = ∅.\nThus, the above expression (e1) results:\n∀lecp∈lci, ∀lecq∈lcj, ∀lecs∈lck (∪lc [(lecp ⊗lc lecq) ⊕lc (lecp ⊗lc lecs)]).\nIn this expression, ⊗lc clearly distributes over ⊕lc for elemental constraints (i.e.: non-disjunctive constraints). Therefore:\n∀lecp∈lci, ∀lecq∈lcj, ∀lecs∈lck (∪lc [(lecp ⊗lc (lecq ⊕lc lecs))]) = ∀lecp∈lci, ∪lc [lecp ⊗lc (∀lecq∈lcj, ∀lecs∈lck, ∪lc [lecq ⊕lc lecs])] = lci ⊗lc (lcj ⊕lc lck).\nThat is, ⊗lc distributes over ⊕lc for labeled constraints.◊\nFor instance, following the previous example:\na= {[0 1]{R1}, [10 20]{R2}}, b= {[25 50]{R0}}, c= {[0 30]{R3}, [40 50]{R4}}\nand {R1 R2}, {R3 R4} are I-L-Sets. Thus, we have:\n(a ⊗lc (b ⊕lc c) = {[0 1]{R1}, [10 20]{R2}} ⊗lc ({[25 50]{R0}} ⊕lc {[0 30]{R3}, [40 50]{R4}}) = {[0 1]{R1}, [10 20]{R2}}⊗lc {[25 30]{R3 R0}, [40 50]{R4 R0}} =\n{[25 31]{R1 R3 R0}, [40 51]{R1 R4 R0}, [35 50]{R3 R2 R0}, [50 70]{R4 R2 R0}}.\nAlso,\n(a ⊗lc b) ⊕lc (a ⊗lc c) = ({[0 1]{R1}, [10 20]{R2}} ⊗lc {[25 50]{R0}}) ⊕lc\n({[0 1]{R1}, [10 20]{R2}} ⊗lc {[0 30]{R3}, [40 50]{R4}}) =\n{[25 51]{R1 R0}, [35 70]{R2 R0}} ⊕lc {[0 31]{R1 R3}, [40 51]{R1 R4} [10 50]{R2 R3}, [50 70]{R2 R4}} =\n∪lc ([25 31]{R1 R3 R0}, [40 51]{R1 R4 R0}, [25 50]{R1 R2 R3 R0}, [50 51]{R1 R2 R4 R0}, [40 51]{R1 R2 R4 R0}, [35 50]{R3 R2 R0}, [50 70]{R4 R2 R0}).\nHowever, {R1 R2}, {R3 R4} are I-L-Sets. Thus, ([25 50]{R1 R2 R3 R0}, [50 51]{R1 R2 R4 R0}, [40 51]{R1 R2 R4 R0}) are removed in operation ∪lc. Therefore,\n(a ⊗lc b) ⊕lc (a ⊗lc c) = {[25 31]{R1 R3 R0}, [40 51]{R1 R4 R0}, [35 50]{R3 R2 R0}, [50 70]{R4 R2 R0}}.\nThat is, (a ⊗lc (b ⊕lc c) = (a ⊗lc b) ⊕lc (a ⊗lc c)."
    }, {
      "heading" : "4. Reasoning Algorithms on Labeled Constraints",
      "text" : "Several algorithms for reasoning on disjunctive constraints can be applied for the management of labeled temporal constraints, by using the ⊗lc, ⊕lc, ∪lc and ⊆lc operations. For instance, the wellknown Transitive Closure Algorithm, general closure algorithms as in (Dechter, 1992; Dechter et al., 1991; van Beek & Dechter, 1997), CSP-based approaches, etc. However, Montanari (1974) shows that when composition operation distributes over intersection, any path-consistent TCN is also a minimal TCN. From Theorem 4, we have that ⊗lc distributes over ⊕lc. Thus, application of a pathconsistent algorithm on the proposed-labeled TCN will obtain a minimal TCN. Thus, the TCA algorithm could be used as the closure process on labeled constraints, in a similar way as Allen (1983) uses it. However, an incremental reasoning process is proposed on the basis of the incremental path-consistent algorithm for non-disjunctive metric constraints described by Barber (1993). An incremental reasoning process is useful when temporal constraints are not initially known but are successively deduced from an independent process; for instance, in an integrated planning and scheduling system (Garrido et al., 1999). The proposed reasoning algorithm is similar to the TCA algorithm. However, updating and closure processes are performed at each new input constraint. Thus, each new input constraint is updated and closured on a previously minimal TCN (Figure 9). Therefore, no further propagation of modified constraints in the closure process is needed. Moreover, the proposed reasoning algorithms will obtain a complete and sound set of I-L-Sets.\nThe specification of reasoning processes is described in Section 4.1. The properties of these processes will be described later in Section 4.2."
    }, {
      "heading" : "4.1 The Updating Process",
      "text" : "Given a previous labeled-TCN, composed by a set of nodes {ni}, a set of labeled constraints {lcij} among them, and a set of I-L-Sets, the updating process of each new c’ij between nodes ni and nj constraint is detailed in Figure 2.\nThe function Put-Labels(c’ij) returns a labeled-constraint lc’ij≡{lec’ij.1, lec’ij.2, ..., lec’ij.l}, associating an exclusive label to each elemental constraint in c’ij. If there is only one disjunct in c’ij, the label in the unique elemental constraint is {R0}. Otherwise, each pair of labels in lc’ij is added to the set of I-L-Sets, since elemental constraints in c’ij are pairwise disjoint (Definition 3). By using the Inverse function on non-labeled constraints, the Inverselc function is:\nInverselc ({(ecij.k{labelij.k})}) =def {(Inverse (ecij.k) {labelij.k})}\nThe described updating process is performed each time that one new input constraint c’ij is asserted on a previous TCN. Thus, an initial TCN with no nodes, no constraints, and no I-L-Sets is assumed (Figure 9). At each new input constraint (c’ij), the TCN is incrementally updated and closured. That is, if c’ij is consistent (Consistency-Test function), the constraint c’ij is added to the TCN, the closure process (Closure function) propagates its effects to all TCN, and the new TCN is obtained. A new updating process can be performed on this new TCN, and so on successively."
    }, {
      "heading" : "4.1.1. THE CONSISTENCY-TEST FUNCTION",
      "text" : "The Consistency-Test function (Figure 3) is based on the operation ⊕lc. A new input constraint lc'ij between nodes ni and nj is consistent if it temporally intersects with the previously existing constraint lcij between these nodes. Moreover, the Consistency-Test function can detect new I-L-Sets:\ni) If the new constraint lc'ij is consistent with the existing constraint lcij, and two elemental constraints ecij.p∈lc'ij, ecij.k∈lcij do not intersect (ecij.k ⊕ ecij.p=∅), then the label set {labelij.k}∪{labelij.p} is an I-L-Set and should be added to the current set of I-L-Sets.\nii) If an existing elemental constraint between nodes ni and nj (lecij.k∈lcij) does not intersect with the new constraint lc'ij, then {labelij.k} is an I-L-Set and should be added to the current set of I-L-Sets.\nFor example,\nConsistency-Test ({([0 10]{R1}), ([20 25]{R2}), ([100 110]{Ra})},\n{([0 30]{R3}), ([40 50]{R4}), ([-50 -40]{Rb})}) = True\nsince\n{{([0 10]{R1}), ([20 25]{R2}), ([100 110]{Ra})} ⊕lc {([0 30]{R3}), ([40 50]{R4}), ([-50 -40]{Rb})} = {([20 25]{R3 R2}), ([0 10]{R3 R1})} ≠ {∅}.\nIn this function, the label sets {R4 R2}, {R4 R1} and {Ra} are detected as I-L-Sets and should be added to the current set of I-L-Sets, since:\n{[20 25]{R2}} ⊕lc {[40 50]{R4}}={∅}, {[0 10]{R1})} ⊕lc {[40 50]{R4})}={∅}, {([100 110]{Ra})} ⊕lc {([0 30]{R3}), ([40 50]{R4}), ([-50 -40]{Rb})}={∅}.\nNote that {Rb} does not need to be detected as an I-L-Set, since the label Rb is not included in the final constraint {([20 25]{R3 R2}), ([0 10]{R3 R1})} to be added to the TCN.\nAny superset of an I-L-Set is also an I-L-Set (Theorem 1). Moreover, note that {R4 R2}, {R4 R1} do not need to be added to the set of I-L-Sets, since the label R4 is not included in the final constraint. Therefore, the following simplifications can also be performed each time a new I-L-Set is added to the current set of I-L-Sets. These simplifications do not modify the results of reasoning processes, but minimize the size of the set of I-L-Sets and improve its management efficiency.\ni) No new I-L-Set that is superset of an existing I-L-Set is added to the set of I-L-Sets.\nii) If an existing I-L-Set is superset of the new I-L-Set, then the existing I-L-Set is removed.\niii) No new I-L-Set that contains a label of lc'ij, which does not appear in the labeled constraint (lcij ⊕lc lc'ij) to be added to the TCN, should be added to the set of I-L-Sets.\nLet’s see an example of the updating and consistency-test processes. Let’s take the labeled-TCN that results from Example 1 once the following constraints have been updated and closured:\n(t1 {[60 ∞)R1, [30 40]R2} t2), (t3 {[40 50]R3, [20 30]R4} t4), (T0 {[10 20]R0} t1), (T0 {[60 70]R0} t4).\nThe resulting labeled-TCN is shown in Figure 4 and the set of I-L-Set is {{R1 R2}, {R3 R4}}. Now, we update (t3 {[10 20]R0} t2). The previously existing constraint between t3 and t2 is (Figure 4):\n{([40 ∞){R1 R3 R0}) ([20 ∞){R1 R4 R0}), ([-10 30]{R2 R4 R0}) ([10 50]{R2 R3 R0})}\nThe Consistency-Test function performs:\n{[10 20]{R0}} ⊕lc {([40 ∞){R1 R3 R0}) ([20 ∞){R1 R4 R0}), ([-10 30]{R2 R4 R0}) ([10 50]{R2 R3 R0})} = {[20 20]{R1 R4 R0}, [10 20]{R2 R0} [∅]{R1 R3 R0}} ≠ {∅} (e1)\nThus, (t2-t3∈{[10 20]{R0}}) is consistent. Moreover, {R1 R3 R0} is detected as an I-L-Set. The elemental constraints associated to {R1 R3 R0} are an inconsistent set of disjuncts that cannot hold simultaneously. That is:\n\"If today John left home between 7:10 and 7:20 (R0), Fred arrived at work between 8:00 and 8:10 (R0) and John arrived at work about 10'-20' after Fred left home (R0), then it is impossible for John to have gone by bus (R1) and Fred to have gone in a carpool (R3).\"\nThe set of I-L-Sets obtained in the reasoning process can be considered as special derived constraints, which express the inconsistency of a set of input elemental constraints. For instance, the I-L-Set {R0 R1 R3} represents (Figure 1):\n¬ ( (T0 [10 20] T1) ∧ (T3 [10 20] T2) ∧ (T0 [60 70] T4) ∧ (T3 [40 50] T4) ∧ (T1 [60 ∞) T2)).\nThis expression is a non-binary constraint. This type of constraints could be represented as a disjunctive linear constraint, as Jonsson and Bäckström (1996), Stergiou and Koubarakis (1996) show. However, input elemental constraints should be represented in derived constraints to be able to derive these inconsistent sets of input elemental constraints. In this model, this is done by means of the label sets associated to labeled elemental constraints."
    }, {
      "heading" : "4.2 The Closure Process",
      "text" : "The closure process (Figure 5) is applied each time a new input constraint (lc'ij) is updated, such that the effects of lc'ij are propagated to all TCN.\nThe closure process has three loops (Figure 6). In these loops the process obtains:\ni) Derived constraints lcik between ni and any node nk, if nk is previously connected with nj (edge 1 of Figure 6).\nii) Derived constraints lcljbetween nj and any node nl, if nl is previously connected with ni (edge 2 of Figure 6).\n1 This loop could be simplified as:\n(*nl → ni → nk*): ∀nl, nk ∈TCN / lcli ≠ {U{R0}}, lcjk ≠ {U{R0}}: lclk ← lclk ⊕lc (lcli ⊗lc lcik), or as (*nl → nj → nk*): ∀nl, nk ∈TCN / lcli ≠ {U{R0}}, lcjk ≠ {U{R0}}: lclk ← lclk ⊕lc (lclj ⊗lc lcjk)\nsince lcik (or lclj) has already been closured in the first (or in the second loop). Moreover, the efficiency of the third loop can be improved if only modified constraints in the first (or in the second loop) are considered.\niii) Derived constraints lclk between any pair of nodes nl and nk, if nl and nk are previously connected with ni and nj respectively (edge 3 of Figure 6).\nLet’s see the previous Example 1 represented in Figure 1 and Figure 4, when the consistent constraint (expression e1):\n(t3 {[20 20]{R1 R4 R0}, [10 20]{R2 R0}} t2)\nis closured. In the first loop of the closure process, we have:\nlc30 ← lc30 ⊕lc ({[20 20]{R1 R4 R0}, [10 20]{R2 R0}} ⊗lc lc20 =\n{[-30 -10]{R3 R0} [-50 -30]{R4 R0}} ⊕lc ({[20 20]{R1 R4 R0}, [10 20]{R2 R0}} ⊗lc {[-60 –40]{R2 R0} (-∞ -70]{R1 R0}}) =\n{[-30 -10]{R3 R0}} [-50 -30]{R4 R0}} ⊕lc {[-40 -20]{R1 R2 R4 R0}, (-∞ -50]{R1 R4 R0} [-50 –20]{R2 R0} (-∞ -50]{R1 R2 R0}}.\nHowever, {{R1 R2}, {R3 R4} {R0 R1 R3}} are I-L-Sets. No labeled elemental constraints whose associated label set is a superset of these I-L-Sets will be derived (Theorem 3). Thus:\nlc30 ←{[-30 -10]{R3 R0}} [-50 -30]{R4 R0}} ⊕lc {(-∞ -50]{R1 R4 R0} [-50 –20]{R2 R0} }= {(-30 -20]{R2 R3 R0} [-50 –50]{R4 R1 R0} [-50 -30]{R4 R2 R0}}.\nSimilarly,\nlc31 ← lc31 ⊕lc ({[20 20]{R1 R4 R0} [10 20]{R2 R0}} ⊗lc lc21 = {[-20 -10]{R3 R2 R0} [-40 -40]{R4 R1 R0} [-30 -10]{R4 R2 R0}}\nlc34 ← lc34 ⊕lc ({[20 20]{R1 R4 R0}, [10 20]{R2 R0}} ⊗lc lc24 = {[40 50]{R3 R2 R0} [20 30]{R4 R2 R0} [20 20]{R4 R1 R0}}.\nAfter the second and third loops, the final labeled-TCN is obtained (Figure 7). The final set of I-LSets is {{R1 R2}, {R3 R4} {R0 R1 R3}}. These sets represent all sets of mutually inconsistent inputelemental constraints that exist in the TCN of Figure 1."
    }, {
      "heading" : "4.3 Properties of Reasoning Algorithms",
      "text" : "In this section, the main properties of the proposed reasoning algorithms are described.\nTheorem 5. The proposed updating and closure processes (Sections 4.1 and 4.2) guarantee a consistent TCN if they are applied on a previous minimal (and consistent) TCN.\nProof: The updating constraint lc’ij is asserted in the TCN if it is consistent with the previous minimal constraint lcij (Consistency-Test function).◊\nTheorem 6. The proposed closure algorithm obtains a path-consistent TCN, if it is applied over a previous minimal TCN.\nProof: This was detailed by Barber (1993) for non-disjunctive TCNs and it is applied here to labeled TCNs. We have:\ni) No derived constraint can exist between a pair of nodes if no path between them combines the asserted constraint lcij.\nii) The closure process computes a derived constraint between any pair of nodes (nl, nk) that become connected by a path across the closured constraint lcij. Let’s assume an existing path between the nodes nx1, ny1 that includes lcij:\nnx1, nx2, nx3, ........, nx, (nj lcij nj), ny......, ny2, ny1\nsuch that a derived constraint between nx1 ny1 should be computed. However, a minimal constraint between (nx1, ni) and between (nj, ny1) should already exist in the previous minimal TCN. In consequence, a derived constraint between (nx1, ny1) is computed in the third loop of the process.\niii) If the previous TCN is minimal, all possible derived constraints that can exist between any pair of nodes (nl, nk) are already computed in the constraint lc’lk derived between these nodes in the proposed closure process. In the third loop, this process obtains:\nlc’lk= lclk ⊕lc (lcli ⊗lc lcij ⊗lc lcjk).\nLet’s suppose there exists another path between (nl, nk) across the updated lcij constraint: (nl, np, ni, nj, nq, nk). This path computes another derived constraint between (nl, nk):\nlc''lk= lclk ⊕lc (lclp ⊗lc lcpi ⊗lc lcij ⊗lc lcjq ⊗lc lcqk).\nHowever, since the previous TCN is minimal, the previously existing minimal constraints lcli and lcjk imply (lclp ⊗lc lcpi) and (lcjq ⊗lc lcqk), respectively. That is, lcli ⊆lc(lclp ⊗lc lcpi) and lcjk ⊆lc(lcjq ⊗lc lcqk) Thus, lc''lk is also implicitly implied by lc’lk (lc’lk⊆lclc''lk). Here, we have assumed the associative property for ⊗lc, which is obvious from its definition.\niv) Derived constraints obtained in the closure process do not need to be closured again if the previous TCN is minimal. That is, no constraint in the TCN would become more restricted if derived constraints were also closured. Let suppose lclk is modified in the third loop of closure process:\nlc’lk= lclk ⊕lc (lcli ⊗lc lcij ⊗lc lcjk)\nsuch that it should be propagated to the (nl, nk, np) subTCN (Figure 8). Thus, the following derived constraints should be obtained:\nlc’lp= lclp ⊕lc (lc’lk ⊗lc lckp) lc’pq= lcpq ⊕lc (lcpl ⊗lc lc’lk).\nFor constraint lc’lp, we have,\nlc’lp = lclp ⊕lc (lc’lk ⊗lc lckp) = lclp ⊕lc ((lclk ⊕lc (lcli ⊗lc lcij ⊗lc lcjk)) ⊗lc lckp).\nHowever, since ⊗lc distributes over ⊕lc, lc’lp = lclp ⊕lc ((lclk ⊗lc lckp) ⊕lc (lcli ⊗lc lcij ⊗lc lcjk ⊗lc lckp)).\nSince the previous TCN is minimal, the minimal constraints lcpi and lcpj should previously exist, such that lclp⊆lc(lclk ⊗lc lckp) and lcjp⊆lc(lcjk ⊗lc lckp). Thus,\nlc’lp ⊆lc lclp ⊕lc (lcli ⊗lc lcij ⊗lc lcjp). However, in the third loop of the closure process, the following derived constraint is computed:\nlc''lp = lclp ⊕lc (lcli ⊗lc lcij ⊗lc lcjp).\nThus, lc’lp is already represented in the obtained constraint lc''lp (that is, lc''lp ⊆lc lc'lp). In a similar way,\nlc''pq = lcpq ⊕lc (lcpi ⊗lc lcij ⊗lc lcjq)\nis also obtained in the proposed closure process, such that lc''pq ⊆lc lc'pq.\nTherefore, each derived constraint (any combinable path across lcij) between any pair of nodes in the TCN is computed, so that the closure process obtains a path-consistent TCN. ◊\nTheorem 7. The proposed reasoning processes obtain a minimal TCN, if the previous TCN is a minimal TCN.\nProof: Montanari (1974) shows that when composition distributes over intersection (i.e.: ⊗ distributes over ⊕), any path-consistent TCN is also a minimal TCN). This is the case in nondisjunctive metric TCNs (Dechter et al., 1991). In our case, ⊗lc distributes over ⊕lc (Theorem 4) and the closure process obtains a path consistent TCN (Theorem 6). Therefore, the proposed reasoning processes also obtain a minimal TCN. ◊\nTheorem 8. At each updating process, reasoning algorithms obtain a complete and a sound new set of I-L-Sets (Definition 4), if they are applied on a previous minimal TCN and a previous sound and complete set of I-L-Sets.\nProof:\ni) The new set of I-L-Sets is complete. The consistency test of the updated constraint lc'ij obtains all possible new I-L-Sets that can appear when lc'ij is added to the TCN, except those I-L-Sets which are related to the mutual exclusion of the disjuncts in lc'ij (which are determined in the Put-Label function):\na) No new I-L-Sets can appear in which some label of lc'ij does not participate. Otherwise, they would have been detected in a previous updating process, since the previous set of I-L-Sets is assumed complete. Thus, some label of lc’ij should always participate in any new I-L-Set that appears when lc’ij is updated.\nb) All new I-L-Sets (in which some label of lc’ij participates) are detected in the consistency test of lc’ij. Let's assume that a new and undetected I-L-Set exists {Rk, R1, R2, ....., Rp} in which some new elemental constraint eck{Rk}∈lc'ij takes part. Thus, the elemental constraints associated to {R1, R2, ....., Rp} compute a derived elemental constraint ecx between the nodes ni and nj:\n(ecx {R1, R2, ....., Rp}) / (ecx {R1, R2, ....., Rp}) ⊕lc (eck{Rk}) =∅\nThis elemental constraint ecx is already represented in the previously existing constraint lcij\nbetween ni and nj since the previous TCN is minimal 2. Thus, eck⊕ecx=∅, such that the I-LSet {Rk, R1, R2, ....., Rp} is detected in the consistency test of lc’ij. In conclusion, all new inconsistent sets of elemental constraints in which lc'ij participates are detected and no other new I-L-Sets can exist. Therefore, the new set of I-L-Sets is complete if the previous set of I-L-Sets is complete.\nii) The new set of I-L-Sets is sound. All new I-L-Sets obtained represent inconsistent sets of elemental constraints. This is trivial, given the consistency test function. ◊\nIn conclusion, the proposed reasoning algorithms obtain a minimal (and consistent) TCN if they are applied to a previous minimal-TCN (Figure 9). Therefore, the reasoning algorithms guarantee TCN consistency and obtain a minimal TCN and a complete and sound set of I-L-Sets at each new input assertion."
    }, {
      "heading" : "4.4 Global Labeled-Consistency",
      "text" : "In a minimal (binary) disjunctive network, every subnetwork of size two is globally consistent (Dechter, 1992). Therefore, any local consistent instantiation of a subset of two variables can be extended to a full consistent instantiation. However, to assure that a local consistent instantiation of a subset of more that two variables is overall consistent, the partial instantiation should be propagated on the whole TCN (van Beek, 1991). Thus, assembling a TCN solution can become a costly propagation process in disjunctive TCNs, even though a minimal TCN was used. The proposed reasoning processes maintain a complete and sound set of I-L-Sets (Theorem 8). Thus, we can deduce if a locally consistent set of elemental constraints is overall consistent by means of label sets associated to labeled elemental constraints and the set of I-L-Sets. Specifically, we can deduce whether any locally consistent instantiation of k variables (1<k<n) is overall consistent. Let’s see the following example, which is based on a previous one proposed by Dechter, Meiri and Pearl (1991):\nExample 2: \"Dave goes walking to work in [25’ 50’]. John goes to work either by car [10’ 30'], or by bus [45’ 60’]. Fred goes to work either by car [15' 20'], or in a carpool [35' 40'], or walking [55’ 60’]. Today, they all left their home between 6:50 and 7:50 (at t1, t2 and t3 time-points), and arrived at work at just the same time (t4) before 8:00.\"\nHere, we have the following labeled disjunctive constraints where, T0 represents the initial time (6:50) and granularity is in minutes:\nt1- T0 ∈ {[0 60]R0}, t2- T0 ∈ {[0 60]R0}, t3- T0 ∈ {[0 60]R0}, t4- T0 ∈ {[0 70]R0},\nt4 - t1 ∈ {[25 50]R0}, t4 – t2 ∈ {[10 30]R1, [45 60]R2}, t4 – t3 ∈ {[15 20]R3, [35 40]R4, [55 60]R5}.\nThe minimal TCN of Example 2 is represented in Figure 10. Here, the binary constraints between each time-point and T0 represent unary constraints and restrict interpretation domains for variables (t1, t2, t3, t4). Obviously, this minimal TCN is not a globally consistent TCN. For instance,\n2 The elemental constraint ecx is already represented in an explicit way, or by means of another elemental constraint ecy (ecy⊆Tecx, {labely}⊆{R1, R2, ....., Rp}) due to the simplification process performed in the operation ∪lc. In both cases, eck⊕ecx=∅, eck⊕ecy=∅.\ninstantiations {(t1=0), (t2=0), (t3=0)} are consistent with the existing constraints involved among (T0, t1, t2, t3), but this partial solution cannot be extended to the overall TCN.\nLet’s consider the TCN with labeled constraints. For reasons of simplicity, we only denote the labeled constraints among (T0, t1, t2, t3):\n(T0 {[5 45]{R0 R5}, [0 45]{R0 R4}, [0 45]{R0 R3}} t1),\n(T0 {[0 25]{R2 R0}, [5 60]{R1 R0 R4}, [25 60]{R1 R0 R5}, [0 60]{R1 R0 R3}} t2),\n(T0 {[25 55]{R0 R2 R3}, [0 15]{R0 R5}, [0 35]{R0 R1 R4}, [5 55]{R0 R1 R3}, [5 35]{R0 R2 R4}} t3),\n(t1 {([-5 35]{R0 R2}, [-40 5]{R0 R1}} t2),\n(t1 {[-15 15]{R0 R4}, [-35 -5]{R0 R3}, [5 35]{R0 R5}} t3),\n(t2 {[5 30]{R1 R0 R4}, [-45 -25]{R2 R0 R3}, [25 50]{R1 R0 R5}, [-15 10]{R1 R0 R3}, [-25 -5]{R2 R0 R4}, [-5 15]{R2 R0 R5}} t3).\nThe set of I-L-Sets is {{R1 R2} {R3 R4} {R3 R5} {R4 R5}}. From this labeled TCN and the set of I-L-Sets, we can deduce that instantiations {(t1=0), (t2=0), (t3=0)} are not overall consistent. These instantiations are not locally consistent with the labeled constraints in the subTCN (T0, t1, t2, t3): All label sets associated to possible simultaneous fulfillment of\n(T0 {[0 0]} t1), (T0 {[0 0]} t2) and (T0 {[0 0]} t3)\nare I-L-Sets. That is, all label sets in the Cartesian product\n{{R0 R4} {R0 R3}} Χ {{R2 R0} {R1 R0 R3}} Χ {{R0 R5} {R0 R1 R4}}\nare I-L-Sets. Thus, the set of I-L-Sets can be used to deduce consistency of a set of labeled elemental constraints and to obtain a globally consistent labeled-TCN.\nTheorem 9. Let’s assume a labeled-TCN of n nodes (and the corresponding complete and sound set of I-L-Sets) and a local set of k (1≤k≤( 2n )) labeled elemental constraints in the TCN, each one of which is between any pair of nodes:\n{lec1, lec2,....., leck} ≡ {(ec1 {label1}), (ec2 {label2}), ..., (eck {labelk})}.\nThe local set of labeled elemental constraints {lec1, lec2, ... , leck}is overall consistent iff the setunion of their associated label sets (∪i=1,k{labeli}) is not an I-L-Set.\nProof: The label set (∪i=1,k{labeli}) is the support-set of the simultaneous fulfillment of {lec1, lec2, --- , leck}. Moreover, the set of I-L-Sets is complete and sound with respect to overall TCN (Theorem 8), such that any label set not in the set of I-L-Set is overall consistent. Therefore (Theorem 2), (∪i=1,k{labeli}) and {lec1, lec2, ... , leck} are overall consistent iff ∪i=1,k{labeli} is not an I-L-Set. ◊\nDefinition 5 (Labeled-consistency3): Let’s assume a labeled-TCN of n nodes (and the corresponding complete set of I-L-Sets) and a set of k (1≤k≤( 2n )) constraints, each one of which is between any pair of nodes in the TCN:\n{cij} / 1≤i≤n, 1≤j≤n, i≠j. The set of constraints {cij} is labeled-consistent with respect to the nodes involved in these\nconstraints, iff:\ni) For each constraint cij, there exists an elemental labeled constraint elcij.x between (ni, nj) in the TCN such that elcij.x satisfies cij. That is: ∀cij, ∃elcij.x∈lcij / cij ⊕ ecij.x ≠ ∅.\nii) The resulting set of the union of label sets associated to these elemental labeled constraints (which satisfy {cij}) is not an I-L-Set: U ij ij.xc }{label∀ is not an I-L-Set. Note that this is the condition of Theorem 9. ◊\nTheorem 10. Let’s assume a labeled-TCN of n nodes (and the corresponding complete set of I-LSets) and a set of k (1≤k≤( 2n )) constraints, each one of which is between any pair of nodes in the TCN:\n{cij} / 1≤i≤n, 1≤j≤n, i≠j.\nThe set of constraints {cij} is overall consistent iff {cij} is labeled-consistent with respect to the nodes involved in constraints {cij}.\nProof: The proof is trivial according to Definition 5 and Theorem 9. We have that the set of constraints {cij} is consistent iff there exists a local set of elemental constraints in the TCN {elcij.x} that makes {cij} labeled-consistent (Definition 5). Thus, the local set {elcij.x} is consistent (Theorem 9), such that {cij} is also consistent. ◊\nFor instance, we can determine whether any pair of constraints c'ij and c'kl can hold simultaneously (that is, they are overall consistent) if:\n∃elcij.x∈lcij / c'ij ⊕ ecij.x≠∅ ∧ ∃elckl.y∈ckl / c'kl ⊕ eckl.y≠∅ ∧ {labelij.x}∪{labelkl.y}\nis not an I-L-Set.\nMoreover, any local instantiation of any k-1 (1<k≤n) variables {t1=v1, t2=v2, ..., t(k-1)=v(k-1)} can be extended to a global solution if:\n∃elc10.x∈lc10 / v1∈ec10.x,...... , ∃elc(k-1)0.y∈lc(k-1)0 / v(k-1)∈ec10.x,\nwhere lci0 is the constraint between ni and T0, and {label10.x}∪{label20.y}∪ .... ∪{label(k-1)0.y}is not and I-L-Set.\n3 We need to introduce the concept of labeled-consistency since it is a different concept from the consistency concept.\nFor instance, in Example 2 of Figure 10, the partial instantiation {(t1=0), (t2=5), (t3=5)} is consistent. We have:\n([0 45]{R0 R3})∈lc10 / 0∈[0 45], ([0 60]{R1 R0 R3})∈lc20 / 5∈[0 60], ([5 55]{R0 R1 R3})∈lc30 / 5∈[5 55],\nand {R0 R3}∪{R0 R1 R3}∪{R0 R1 R3}={R0 R1 R3} is not an IL-Set. Thus, this partial solution can be extended to a global solution. For instance, {(t1=0), (t2=5), (t3=5), (t4=25)}.\nTherefore, a labeled-TCN can be considered as a globally labeled-consistent TCN. That is, on the basis of the concepts introduced by Dechter (1992):\nDefinition 6. (Local Labeled-consistency): A partial instantiation of variables (1≤k<n) {t1=v1, t2=v2, ..., tk=vk} is local labeled-consistent if it is labeled-consistent with respect to (T0, t1, t2, ..., tk) nodes. This also holds for k=n. ◊\nDefinition 7. (Global Labeled-consistency): A labeled sub-TCN (with the global set of I-L-Sets) is global labeled-consistent if any partial instantiation of variables in the sub-TCN, which is local labeled-consistent, can be extended to the overall TCN. A globally labeled-consistent TCN is one in which all its sub-TCNs are globally labeled-consistent. ◊\nTheorem 11. At each new assertion, the proposed reasoning processes obtain a globally labeledconsistent TCN, if they are applied on a previous minimal TCN and a previous sound and complete set of I-L-Sets.\nProof: The proof is trivial according to the previous definitions (Definition 6 and Definition 7) and to the properties of the reasoning processes (Theorem 7 and Theorem 8). Any partial instantiation in any subTCN, which is labeled-consistent with respect to the nodes involved in the partial instantiation, is overall consistent (Theorem 10). ◊\nSimilar expressions can be made for k-labeled-consistency and strong k-labeled-consistency on the basis of the concepts provided by Freuder (1982). Therefore, the set of I-L-Sets in a labeled-TCN provides a useful way to assure whether a local instantiation of variables can be part of a global solution. Moreover, Freuder (1982) shows that in a strong k-consistent TCN, consistent instantiations of variables of any subnetwork of size k can be found in a backtrack-free manner and in any variable ordering. This is also a consequence of the decomposability (Montanari, 1974; Dechter et al., 1991) or globally consistency (Dechter, 1992) properties. Obviously, this feature also holds for labeled TCNs."
    }, {
      "heading" : "4.5 Analysis of Temporal Complexity",
      "text" : "Let’s analyze the computational cost of the proposed reasoning processes. These processes are, basically, an incremental path-consistent algorithm (Barber, 1993). At each updating process of a new input constraint on a TCN with n nodes, the computational cost of updating and closure processes is bounded by 'n2 (O(⊗lc) + O(⊕lc))'. In the proposed reasoning process, the path-consistent algorithm obtains a minimal disjunctive metric TCN. This is possible due to the management of labeled constraints, associated label sets, and I-L-Sets. Thus, the complexity of reasoning processes is mainly due (instead of a complex closure process) to the management of complex data structures (labeled constraints, associated label sets, and I-L-Sets). That is, the complexity of the proposed\nreasoning processes is mainly due to the complexity of operations ⊗lc and ⊕lc. The computational cost of ⊗lc and ⊕lc depends on the number of elemental constraints in labeled constraints, the size of associated label sets, and the size of I-L-Sets in the previous minimal labeled TCN. Let 'n' be the number of nodes, 'l' the maximum number of disjuncts (or labels) in input constraints, and 'e' the number of updated input constraints in the previous TCN. The maximum number of labels in the TCN is l*e, since each disjunct in each updated input labeled constraint has its own, unequivocal label. Moreover, any I-L-Set can have as maximum one label from each input labeled constraint lcij, since: (i) elemental constraints in lcij are pairwise disjoint, such that each pair of labels in lcij is added to the set of I-L-Sets, and (ii) any superset of an existing I-L-Set is also an I-L-Set. Thus, the maximum number of labels in any I-L-Set is e. Furthermore, each label in an I-LSet should be from a different input labeled constraint. There are e input labeled constraints, and each input labeled constraint has as maximum l labels. Thus, the maximum number of I-L-Sets of q-length (1≤q≤e) is (( qe ) lq).\nTherefore, the number of i-length (1≤i≤e) I-L-Sets is Σi=1,e (( ie ) li) = O(2e le). However, any superset of an I-L-Set is already known as inconsistent, such that supersets are not stored in the set of I-L-Sets. Thus, the number of I-L-Set is bounded by O(le). Additionally, we also have e*( 2\n\" ) I-LSets of 2-length, since the l disjuncts in each updated constraint are mutually exclusive among them. Similarly, the maximum number of associated label sets is also bounded by O(le), each one with a maximum of e labels. Thus, the number of elemental constraints (or labeled subintervals) in any labeled constraint is bound by O(le), since each elemental constraint in a labeled constraint has its own associated label set.\nAccording to these parameters, the computational cost of each updating process is bounded by O(n2 l3e). The recovery process of constraints has a constant cost, since a minimal-TCN is always maintained. The computational cost of the proposed algorithms agreed with the computational cost inherent to the problem of the management of disjunctive metric constraints (Dechter, 1991). In fact, the closure process could be considered as an integrated management of the le alternative nondisjunctive TCNs in which a disjunctive TCN can be split, as it is shown by Dechter, Meiri and Pearl (1991). It should be noted that l can be bounded in some typical problems like scheduling, where usually l≤2 (Garrido et al., 1999), or by restricting domain size (range or granularity) in metric algebras. On the other hand, several improvements can be made on the described processes. For example, an efficient management of label sets has a direct influence on the efficiency of the reasoning processes. Thus, each label set (for instance, {R3 R5 R8}) can be considered as a unidimensional array of bits, which is the binary representation of an integer number (for instance (23+25+28)). Therefore, each associated label set is represented by a number and the set of I-L-Sets becomes a set of numbers. Matching and set-union processes on label sets in operations ⊗lc and ⊕lc can be efficiently performed by means of operations on integer numbers with a constant cost. Therefore, the computational cost can be bounded by O(n2 l2e).\nOther alternative implementations are under study. Two different approaches exist for temporal constraint management (Brusoni et al., 1997; Yampratoom, Allen, 1993; Barber, 1993). The first approach is to maintain a closured TCN by recomputing the TCN at each new input constraint and making the derived constraints explicit. Here, queries are answered in constant time, although this implies a high spatial cost. The second approach is to explicitly represent only input constraints, such that the spatial requirements are minimum. However, further computation is needed at query time and when consistency of each new input constraint is tested. The proposed reasoning methods hold\nin the first approach, which seems more appropriate for problems where queries on the TCN are more usual tasks than updating processes.\nIn addition, the proposed reasoning algorithms obtain a sound and complete set of I-L-Sets and a globally labeled-consistent TCN. Regrettably, assembling a solution in a labeled TCN, although backtrack free, is also costly due to the exponential number of I-L-Sets. However, these features offer the capability of representing and managing special types of non-binary disjunctive constraints (later detailed in Section 6).\nOther reasoning algorithms for query processes on a non-closured TCN, as well as CSP approaches can be defined on the basis of the labeled temporal algebra described. Less expensive algorithms can be applied on labeled constraints by using the specified operations ⊗lc, ⊕lc, ∪Τlc and ⊆Τlc. For instance, the TCA algorithm as is applied by Allen (1983), and the k-consistency algorithms like those described in (Cooper, 1990; Freuder, 1978). Moreover, a minimal TCN of labeled constraints can be obtained without enforcing global consistency; for example, by applying the naive backtracking algorithm described by Dechter, Meiri and Pearl (1991), which is O(n3 le)."
    }, {
      "heading" : "5. Interval-Based Constraints Through Labeled Point-Based Constraints",
      "text" : "The integration of quantitative and qualitative information has been the goal of several temporal models, as was described in Section 1. When intervals are represented by means of their ending points Ii + Ii -, integration of constraints on intervals and points seems to require some kind of nonbinary constraints between time-points (Gerevini & Schubert, 1995; Schwalb & Dechter, 1997; Drakengren & Jonsson, 1997). In this section, the proposed temporal model is applied in order to integrate interval and point-based constraints. Constraints on intervals are managed by means of constraints on ending points of intervals and I-L-Sets. Likewise, metric information can also be added to interval constraints such that an expressive way of integrating qualitative and quantitative constraints is obtained."
    }, {
      "heading" : "5.1 Symbolic Interval-Based Constraints",
      "text" : "Symbolic constraints on intervals express the qualitative temporal relation between two intervals. Each symbolic constraint is a disjunctive subset of 13 elemental constraints, which are mutually exclusive among them (Allen, 1983). For example, the following constraint\nI1 {ec1, ec2} I2, ec1, ec2 ∈{b, m, o, d, s, f, e, bi, mi, oi, di, si, fi},\nreally means 'I1 [ (ec1 ∨ ec2) ∧ ¬(ec1 ∧ ec2) ] I2', since ec1 and ec2 are mutually exclusive, and one and only one elemental constraint should hold. For reasons of simplicity, we only consider two disjuncts in the symbolic constraint. However, these expressions can be easily extended for managing from 2 to 13 disjuncts. The above expression can be expressed as:\nI1 [ (ec1 ∧ ¬ec2) ∨ (¬ec1 ∧ ec2) ] I2 ≡ I1 [ (ec1 ∨ ¬ec1) ∧ (ec2 ∨ ¬ec2) ∧ ¬(ec1 ∧ ec2) ∧ ¬ (¬ec1 ∧ ¬ec2) ] I2 (e2).\nIn this way, we have:\ni) The constraints [I1 (ec1 ∨ ¬ec1) I2] and [I1 (ec2 ∨ ¬ec2) I2] can be expressed as disjunctive metric constraints on the same pairs of time-points,\nii) The constraints [I1 ¬(ec1 ∧ ec2) I2] and [I1 ¬(¬ec1 ∧ ¬ec2) I2] can be expressed as a mutual exclusion among the associated labels of the above point-based constraints. That is, as a set of I-L-Sets.\nWe present a simple example to illustrate these conclusions. For instance, (I1 {before after} I2) can be expressed by means of constraints among the time points I1 -, I1 +, I2 - and I2 +, as:\n[I1 {b a} I2] ≡ (I1+ {(0 ∞){Rb1}} I2-) ∨ (I1- {(-∞ 0){Ra1}} I2+).\nThus, when intervals are represented by means of their ending points Ii + Ii -, an interval-based constraint gives rise to disjunctive constraints between different pairs of time points (i.e.: non-binary constraints). These non-binary constraints can be represented as I-L-Sets. Thus, according to the above expression (e2),\n[I1 {b a} I2] ≡ [I1 (b ∨ ¬b) I2] ∧ [I1 (a ∨ ¬a) I2] ∧ [I1 ¬(b ∧ a) I2] ∧ [I1 ¬(¬b ∧ ¬a) I2], we have:\nI1 before I2 ⇔ I1+ {(0 ∞){Rb1}} I2-, I1 ¬before I2 ⇔ I1+ {(-∞ 0]{Rb2}} I2-,\nI1 after I2 ⇔ I1- {(-∞ 0){Ra1}} I2+, I1 ¬after I2 ⇔ I1- {[0 ∞){Ra2}} I2+.\nTherefore, [I1 {b a} I2] can be expressed as:\n[I1 + {(0 ∞){Rb1} (-∞ 0]{Rb2}} I2-] ∧ [I1- {(-∞ 0){Ra1} [0 ∞){Ra2}} I2+] ∧\n¬ [ (I1+ {(0 ∞){Rb1}} I2-) ∧ (I1- {(-∞ 0){Ra1}} I2+) ] ∧\n¬ [ (I1+ {(-∞ 0]{Rb2}} I2-) ∧ (I1- {[0 ∞){Ra2}} I2+) ],\nwhich is equivalent to (by using the labels associated to each elemental constraint):\n[I1 + {(0 ∞){Rb1} (-∞ 0]{Rb2}} I2-] ∧ [I1- {(-∞ 0){Ra1} [0 ∞){Ra2}} I2+]\nand {Rb1 Ra1},{Rb2 Ra2} are I-L-Sets, such that one and only one disjunctive symbolic constraint holds.\nThus, symbolic constraints between intervals can be represented by means of: (i) a set of disjunctive metric constraints between time-points, and (ii) a set of I-L-Sets. In Table 1, the equivalent metric constraints between interval ending time points for each elemental interval-based constraint are detailed. According to this table, the following steps allow us to represent disjunctive symbolic constraints between intervals by means of disjunctive metric constraints between interval ending points and I-L-Sets:\ni) Each interval Ii is represented by means of its ending points Ii +, Ii -. By default, (Ii - {(0, ∞){R0}}\nIi +) holds.\nii) A symbolic constraint between two intervals (Ii cij Ij) is composed of a disjunctive set of (from 1 to 13) elemental symbolic constraints cij={ecij.k}⊆{b, m, o, d, s, f, e, bi, mi, oi, di, si, fi}.\niii) Each elemental symbolic constraint ec∈{b, m, o, d, s, f, e, bi, mi, oi, di, si, fi} is represented\nby a conjunctive set of disjunctive point-based metric constraints (fourth column of Table 1). This conjunctive set of point-based constraints expresses the ‘fulfillment or nonfulfillment’ (ec ∨ ¬ec) of the elemental symbolic constraint ec.\niv) A disjunctive set cij={ecij.k} of elemental symbolic constraints between Ii and Ij is represented by:\n• A conjunctive set of disjunctive point-based metric constraints between the time-points Ii +, Ii -, Ij\n+ and I-j. This conjunctive set is composed by the constraints in the fourth column of Table 1 for each elemental constraint in {ecij.k}.\n• A set of I-L-Sets that expresses the logical relation among elemental symbolic constraints in {ecij.k}. That is, 'one and only one elemental symbolic constraint in {ecij.k} should hold':\niv.a) Only one elemental constraint in {ecij.k} should hold. This condition does not need to be represented since the different sets of point-based constraints that correspond to fulfillment of different elemental symbolic constraints (second column of Table 1) are already mutually exclusive.\niv.b) One of the elemental symbolic constraints in {ecij.k} should hold. Let S be the label sets, where each label set corresponds to the point-based constraints which are related to the non-fulfillment of each elemental symbolic constraint in {ecij.k} (third column of Table 1). Thus, the Cartesian product among the label sets in S is a set of I-L-Sets.\nFor instance, I1 {b m s di} I2 can be represented as:\n(I1 - { (0 ∞){R0}} I1+), (I2- { (0 ∞){R0}} I2+),\nI1 {b ¬b} I2 ⇒ (I1+ {(0 ∞){Rb1} (-∞ 0]{Rb2}} I2-), I1 {m ¬m} I2 ⇒ (I1+ {[0 0]{Rm1} (0 ∞){Rm2} (-∞ 0){Rm3}} I2-),\nI1 {s ¬s} I2 ⇒ (I1- {[0 0]{Rs1} (0 ∞){Rs3} (-∞ 0){Rs4}} I2-) ∧ (I1+ {(0 ∞){Rs2} (-∞ 0]{Rs5}} I2+), I1 {di ¬di} I2 ≡ I2 {d ¬d} I1 ⇒ (I2- {(-∞ 0){Rd1} [0 ∞){Rd3}} I1-) ∧ (I2+ {(0 ∞){Rd2} (-∞ 0]{Rd4}} I1+).\nMoreover, one of the symbolic constraints in {b, m, s, di} should hold. Thus (according to Point iv.b of the method), the Cartesian product of the associated labels related to the non-fulfillment of each elemental symbolic constraints in {b, m, s, di}. That is:\n{{Rb2}Χ{Rm2, Rm3}Χ{Rs3, Rs4, Rs5}Χ{Rd3, Rd4}\nshould be explicitly included in the set of I-L-Sets. By applying this method, qualitative interval-based constraints can be fully integrated in the proposed labeled point-based constraints. In this case, the interpretation domain for time-points {Ii - Ii +} can be restricted to only three values ({D}={(-∞, 0), [0 0], (0 ∞)}), such that, l=3. Therefore, the computational cost of reasoning algorithms is bounded by O(n2 32e). To illustrate the proposed method, let’s show a typical example on symbolic interval-based constraints (Figure 11.a), which was given by Allen (1983). This example shows how interval-based constraints can be represented and managed by means of disjunctive metric point-based constraints and a minimal IA-TCN can be obtained.\nFigure 11.a represents a path-consistent IA-TCN, which has inconsistent values in constraints (Allen, 1983). In Table 2, we have the interval-based symbolic constraints for this example, the corresponding disjunctive metric constraints between their ending time-points (Ii +, Ii -) and the corresponding set of I-L-Sets (according to Table 1). Moreover, we also have:\n(IA-{(0 ∞){R0}}IA+), (IB-{(0 ∞){R0}}IB+), (IC-{(0 ∞){R0}}IC+) and (ID-{(0 ∞){R0}}ID+).\nWhen all these metric constraints among the ending time-points of intervals are updated according the proposed methods in Section 4, the labeled minimal TCN in Table 3 is obtained. The associated labels to each elemental constraint (disjunct) in constraints are not included for reasons of brevity.\nAllen (1983) remarks that the symbolic constraint (IA {f fi} IC) cannot hold given the existing constraints between IA, IB, IC and ID. In the labeled point-based TCN, (IA {f fi} IC) is represented by a set of constraints among ending points of IA and IC. Moreover, the labels associated to each labeled elemental constraint allow us to determine whether a set of elemental constraints between different pairs of time-points can be part of a global solution (Theorem 10). Thus, we can deduce whether (IA {f fi} IC) can hold in the point-based TCN.\nThe existing constraints between the ending time-points of IC and IA, with their associated labelsets are:\nIC+ {(-∞ ∞){R25 R30 R29 R17 R22 R21 R0)∨{R27 R28 R29 R19 R20 R21 R0}, (-∞ 0){R27 R28 R29 R17 R22 R21 R9 R10 R15 R16 R1 R2 R7 R0 R8}, (0 ∞){R25 R30 R29 R19 R20 R21 R11 R12 R13 R14 R3 R4 R5 R0 R6}} IA+\nIC- {(0 ∞){R27 R28 R29 R17 R22 R21 R9 R10 R15 R16 R1 R2 R7 R8 R0}, [0 0]{R25 R30 R29 R17 R22 R21 R0}∨{R27 R28 R29 R19 R20 R21 R0}, (-∞ 0){R25 R30 R29 R19 R20 R21 R11 R12 R13 R14 R3 R4 R5 R6 R0}} IA-\nLet's ask for each disjunct in (IA {f fi} IC):\ni) The constraint (IA {f} IC) implies (IC+ {[0 0]} IA+) ∧ (IC- {(-∞ 0)} IA-). According to Theorem 10, these constraints hold iff the set-union of the label sets associated to (IC+ [0 0] IA+) and to (IC- (-∞ 0) IA-) is not an I-L-Set. We have two possibilities:\ni.1) {R25 R30 R29 R17 R22 R21 R0} ∪ {R25 R30 R29 R19 R20 R21 R11 R12 R13 R14 R3 R4 R5 R6 R0} = {R6 R5 R4 R3 R20 R19 R25 R30 R29 R17 R22 R21 R11 R12 R13 R14 R0 }, or\ni.2) {R27 R28 R29 R19 R20 R21 R0} ∪ {R25 R30 R29 R19 R20 R21 R11 R12 R13 R14 R3 R4 R5 R6 R0} = {R14 R13 R12 R11 R30 R25 R27 R28 R29 R19 R20 R21 R3 R4 R5 R0 R6}.\nHowever, both label sets (i.1, i.2) are I-L-Sets: For instance, {R19 R22} and {R27 R30} are I-LSets (Table 2) and they are subsets of i.1 and i.2, respectively. Thus, (IA {f} IC) does not hold.\nii) The constraint (IA {fi} IC) implies (IC+ {[0 0]} IA+) ∧ (IC- { (0 ∞)} IA-). Similarly: ii.1) {R25 R30 R29 R17 R22 R21 R0} ∪ {R27 R28 R29 R17 R22 R21 R9 R10 R15 R16 R1 R2 R7 R8 R0} =\n{R16 R15 R10 R9 R28 R27 R25 R30 R29 R17 R22 R21 R1 R2 R7 R0 R8}.\nThis label set is an I-L-Set. For instance, {R30 R27} is an I-L-Set. Also,\nii.2) {R27 R28 R29 R19 R20 R21 R0} ∪ {R27 R28 R29 R17 R22 R21 R9 R10 R15 R16 R1 R2 R7 R8 R0} = {R8 R7 R2 R1 R22 R17 R27 R28 R29 R19 R20 R21 R9 R10 R15 R16 R0}.\nBoth these label sets (ii.1, ii.2) are also I-L-Sets. For instance, {R30 R27} and {R19 R22} are I-LSets. Thus, (IA {fi} IC) does not hold either.\nIn conclusion, the symbolic constraint (IA {f fi} IC) cannot hold on the globally labeled-consistent point-based TCN. This conclusion could be also obtained from a minimal IA-TCN (Figure 11.b). Additionally, we have that (IA {f fi} IC) implies (IA+ [0 0] IC+). That is, if the constraint (IA+ [0 0] IC+) holds, we have that the associated constraints to the label sets {R25 R30 R29 R17 R22 R21 R0} or {R27 R28 R29 R19 R20 R21 R0} should also hold. Each one of these label sets implies (IC\n- {[0 0]} IA-). That is: (IA+ [0 0] IC+) → (IC- {[0 0]} IA-). Thus, the only way that (IA+ [0 0] IC+) can hold is if (IA {e} IC) holds. These relations will be detailed in Section 6."
    }, {
      "heading" : "5.2 Metric Constraints on Intervals",
      "text" : "Metric constraints between intervals can also be managed in the described temporal model. From a general point of view, metric information can be added to each elemental interval-based constraint in a standard way (Table 4). These metric constraints on interval boundaries (Table 4) are similar to the ones proposed by Staab and Hahn (1998).\nObviously, the metric constraints of Table 4 can be managed in the proposed model, by means of metric constraints on interval ending points. Thus, symbolic constraints of Interval Algebra can be extended in this way to metric domain. However, since each interval is represented by means of its ending time-points, more flexible metric constraints on intervals can be represented by means of metric constraints on their ending time-points. In this way, the described model also subsumes the Interval Distance Sub Algebra model proposed by Badaloni and Berati (1996). Moreover, ending points of intervals can also be related to the initial time-point T0, and unary metric constraints on interval durations can be expressed by means of metric constraints between the two ending points of each interval:\ndur (Ii) = {[dm1 dM1], [dm2 dM2], ..... [dmn dMn]} ⇒\n(Ii - {[dm1 dM1], [dm2 dM2], ..... [dmn dMn]} Ii +).\nThus, following constraints (Figure 12):\n(I1 {b, o} I2) ∧ (I1- is [[20 30], [50 60]} before I2-) ∧ (I2- is {[140 150], [200 210]} after T0) can be represented as (Table 1):\nBy default: (I1 - { (0 ∞){R0}} I1+), (I2- { (0 ∞){R0}} I2+), and\n(I1 {b, o} I2) ⇒ (I1+ {(0 ∞){Rb1} (-∞ 0]{Rb2}} I2-), (I1+ {(-∞ 0){Ro1} [0 ∞){Ro4}} I2-), (I1+ {(0 ∞){Ro2} (-∞ 0]{Ro5}} I2+), (I1- {(0 ∞){Ro3} (-∞ 0]{Ro6}} I2-),\n(I1- is [[20 30], [50 60]} at the left of I2-) ⇒ (I1- {[50 60]{R1} [20 30]{R2}} I2-),\n(I2- is {[140 150], [200 210]} after T0) ⇒ (T0 {[140 150]{R3} [200 210]{R4}} I2-),\nand {Rb2 Ro4}, {Rb2 Ro5}, {Rb2 Ro6}, {R1 R2} and {R3 R4} are I-L-Sets."
    }, {
      "heading" : "6. Reasoning on Logical Expressions of Constraints",
      "text" : "In the described model, each disjunct in an input constraint is univocally associated to a label. Moreover, the label set associated to each derived elemental constraint represents the support-set of input elemental constraints from which the elemental constraint is derived. I-L-Sets represent inconsistent sets of input elemental constraints. By reasoning on labeled disjunctive constraints, associated label lists and I-L-Sets, the temporal model offers the capability of reasoning on logical expressions of elemental constraints belonging to disjunctive constraints between different pairs of time points. Let's assume the following labeled input constraints:\n(ni lcij nj) ≡ (ni {(lecij.1){Rij.1} (lecij.2) {Rij.2} .....(lecij.p) {Rij.p}} nj), (nk lckl nl) ≡ (nk {(leckl.1) {Rkl.1} (leckl.2) {Rkl.2} .....(leckll.q) {Rkl.q}} nl)\ni) To represent that two elemental constraints4 (elcij.x∈lcij, elckl.y∈lckl) cannot hold simultaneously (that is ¬(elcij.x ∧ elckl.y)) the label set {Rij.x Rkl.y} should be added to the set of I-L-Sets.\nii) To represent a logical dependency between two elemental constraints, such as 'If lecij.x then leckl.y' (where lecij.x∈cij, leckl.y∈ckl), the Cartesian product {Rij.x} Χ {{Rkl.1, Rkl.2, ....., Rkl.q}{Rkl.y}} should be added to the set of I-L-Sets.\niii) To represent that two elemental constraints (elcij.x∈lcij, elckl.y∈lckl) should hold simultaneously (bi-directional logical dependency), the Cartesian products {Rij.x} Χ {{Rkl.1, Rkl.2, ....., Rkl.q}-\n4 For reasons of simplicity, only two elemental constraints are shown. However, more than two disjunctions can be managed in a similar way. Likewise, these features can be also applied to labeled derived constraints.\n{Rkl.y}} and {Rkl.y} Χ {{Rij.1, Rij.2, ....., Rij.p}-{Rij.x}} should be added to the set of I-L-Sets.\nFor instance, let’s see the Example 2 of Section 4.4 (Figure 10):\n• To represent that ‘John goes to work by car and Fred goes to work walking’ is not possible, {R1 R5} should be asserted as an I-L-Set.\n• To represent that ‘if John goes to work by car then Fred goes to work walking’, {R1 R3} and {R1 R4} should be asserted as I-L-Sets.\n• To represent that ‘if John goes to work by car then Fred goes to work walking, and vice versa’, {R1 R3}, {R1 R4} and {R5 R2} should be asserted as I-L-Sets.\nIn a similar way, logical relations among point-based and interval-based elemental constraints can also be represented. For instance, the logical dependence \"the duration of I1 is [5 8] if I2 is before I3 and the duration of I1 is [12 15] if I2 is after I3\" can be represented as:\n(I2 {b, bi} I3) ⇒ (I2+ {(0 ∞){Rb9} (-∞ 0]{Rb10}} I3-), (I3+ {(0 ∞){Rb11} (-∞ 0]{Rb12}} I2-), {Rb10 Rb12} is an I-L-Set,\n(I1 - {[5 8]{R1} [12 15]{R2}} I1 +),\nand {R1 Rb11}, {R2 Rb9} are I-L-Sets, since Rb11 is associated to ‘I2 is after I3’ and Rb9 is associated to ‘I2 is before I3’. Likewise, \"I1 starts at the same time as I2 if t1 occurs after t2\" can be represented as (see Table 1):\nI1 {s, ¬s} I2 ⇒ (I1- {[0 0]{Rs1} (0 ∞){Rs3} (-∞ 0){Rs4}} I2-) , (I1+ {(0 ∞){Rs2} (-∞ 0]{Rs5}} I2+) , (t1 {(-∞ -1]{R1}, [0 0]{R2}, [1 ∞){R3}} t2),\nand {R3 Rs3}, {R3 Rs4}, and {R3 Rs5} are I-L-Sets, since R3 is associated to 't1 occurs after t2' and Rs3, Rs4 and Rs5 are associated to 'I1 does not start at the same time as I2'."
    }, {
      "heading" : "6.1 Disjunctions of Point and Interval-Based Constraints",
      "text" : "Disjunctions of constraints between different pairs of points and intervals can be represented in the proposed model by means of labeled constraints between points and a set of I-L-Sets. This subsumes the related expressiveness in the subset of disjunctive linear constraints proposed by Stergiou and Koubarakis (1998), where only disjunctions of constraints between different pairs of points are managed.\nTo represent a disjunctive set of disjunctive constraints between points, we have5:\n(ni lcij nj) ∨ (nk lckl nl) can be represented as: (ni {lcij ∨¬lcij} nj) ∧ (nk {lckl ∨¬lckl} nl), and some logical relation among lcij, ¬lcij, lckl and ¬lckl. Thus, the disjunctive set of constraints:\n{(ni lcij nj) ∨ (nk lckl nl)} ≡ {(ni {(lecij.1){Rij.1}, (lecij.2){Rij.2}, ...., (lecij.p){Rij.p}} nj) ∨\n(nk {(leckl.1){Rkl.1}, (leckl.2){Rkl.2}, ...., (leckj.q){Rkl.q}} nl)}\n5 For reasons of simplicity, only two constraints are shown. However, more than two disjunctive constraints can be managed in a similar way.\ncan be represented as:\ni) A conjunctive set of constraints between (ni, nj) and between (nk, nl), where, ¬(lecx) can be represented by means of the complementary domain of (lecx):\n(ni {(lecij.1){Rij.1}, (lecij.2){Rij.2}, ...., (lecij.p){Rij.p}, ¬{(lecij.1){Rij.1}, (lecij.2){Rij.2}, ...., (lecij.p){Rij.p}}} nj) ∧ (nk {(leckl.1){Rkl.1}, (leckl.2){Rkl.2}, ..., (leckj.q){Rkl.q}, ¬{(leckl.1){Rkl.1}, (leckl.2){Rkl.2}, ..., (leckj.q){Rkl.q}}} nl)\n≡{(ni {(lecij.1){Rij.1}, (lecij.2){Rij.2}, ..., (lecij.p){Rij.p}, (¬lecij.1){R'ij.1}, (¬lecij.2){R'ij.2}, ..., (¬lecij.p){R'ij.p}} nj) ∧ (nk {(leckl.1){Rkl.1}, (leckl.2){Rkl.2}, .., (leckj.q){Rkl.q}, (¬leckl.1){R'kl.1}, (¬leckl.2){R'kl.2}, ..., ( ¬leckl.q){R'kl.q} } nl)}\nii) A set of I-L-Sets to represent the mutually exclusive disjunction of lcij and lckl (they cannot simultaneously hold):\nii.a) One of the constraints lcij or lckl should hold: The Cartesian product of label sets from complementary domains of lcij and lckl, {R'ij.1, R'ij.2, ...., R'ij.p}Χ{R'kl.1, R'kl.2, ...., R'kl.q}, are I-L-Sets.\nii.b) Only one of the constraints lcij or lckl should hold: The Cartesian product of label sets from lcij and lckl, {Rij.1, Rij.2, ...., Rij.p}Χ{Rkl.1, Rkl.2, ...., Rkl.q} are I-L-Sets.\nThus, disjunctive and conjunctive sets of disjunctive constraints between points can be represented and managed by means of a conjunctive set of disjunctive constraints and a set of I-L-Sets. For example:\n(ti {[5 5]{R1} [10 10]{R2}} tj) ∨ (tk {[0 0]{R3} [20 20]{R4}} tl) ≡\n(ti {[5 5]{R1} [10 10]{R2} (-∞ 5){R5} (5 10){R6} (10 ∞){R7}} tj) ∧ (tk {[0 0]{R3} [20 20]{R4} (-∞ 0){R8} (0 20){R9} (20 ∞){R10}} tl),\nand\n(ii.a) since (ti {[5 5]{R1}, [10 10]{R2}} tj] or [tk {[0 0]{R3}, [20 20]{R4}} tl] should hold:\n{R5 R6 R7}Χ{R8 R9 R10} are I-L-Sets,\n(ii.b) since only one constraint (ti {[5 5]{R1} [10 10]{R2}} tj) or (tk {[0 0]{R3} [20 20]{R4}} tl) should hold:\n{R1 R2}Χ{R3 R4} = {R1 R3}, {R1 R4}, {R2 R3}, {R2 R4} are I-L-Sets.\nSimilarly, disjunctions of interval-based constraints between different pairs of intervals can also be represented. For instance, from Table 1 and Table 5, {(I1 before I2) ∨ (I3 before I4)} can be represented as:\n(I1 + {(0 ∞){Rb1} (-∞ 0]{Rb2}} I2-), (I3+ {(0 ∞){Rb3} (-∞ 0]{Rb4}} I4-),\nand\na) one of the constraints (I1 before I2) or (I3 before I4) should hold. Thus, the Cartesian product of label sets associated to the disjunctive constraints in (Ii ¬ecij Ij) is a set of I-L-Sets: {Rb2, Rb4} is an I-L-Set,\nb) only one of the constraints (I1 before I2) or (I3 before I4) should hold. Thus, the label set associated to the mutual fulfillment of constraints in (Ii ecij Ij) is an I-L-Set: {Rb1, Rb3} is an I-L-Set.\nThus: {(I1 before I2) ∨ (I3 before I4)} ≡\n(I1 + {(0 ∞){Rb1} (-∞ 0]{Rb2}} I2-), (I3+ {(0 ∞){Rb3} (-∞ 0]{Rb4}} I4-),\nand {Rb2, Rb4}, {Rb1, Rb3} are I-L-Sets.\nIn a similar way (Table 6), (I1 during I2) ∨ (I3 starts I4) ≡\n(I1 - {(-∞ 0){Rd1} [0 ∞){Rd3}} I2-), (I1+ {(0 ∞){Rd2} (-∞ 0]{Rd4}} I2+),\n(I3 - {[0 0]{Rs1} (0 ∞){Rs3} (-∞ 0){Rs4}} I4-), (I3+ {(0 ∞){Rs2} (-∞ 0]{Rs5}} I4+),\nand {Rd1 Rd2 Rs1 Rs2} and the Cartesian product {Rd3 Rd4} X {Rs3 Rs4 Rs5} are I-L-Sets. Therefore, logical relations on elemental constraints can be represented by a set of I-L-Sets. Thus, a labeled TCN (and the set of I-L-Sets) can represent a special type of and/or TCN. These types of non-binary constraints enrich the expressiveness of language and allow for the modeling of more complex problems (Meiri, 1996). Stergiou and Koubarakis (1996) and Jonsson and Bäckström (1998) show that Disjunctions of Linear Constraints (DLR) are also able to represent these non-binary constraints. However, Pujari and Sattar (1999) remark that general methods from linear programming should then be applied for DLR management, such that specific temporal concepts (like the ones detailed in Section 2) are not considered in these general methods. In the proposed model, management of these non-binary constraints are performed by the proposed reasoning methods without increasing their computational complexity. The added functionality is of interest in several temporal reasoning problems, including planning, scheduling and temporal constraint databases (Barber et al., 1994; Gerevini & Schubert, 1995; Brusoni et al., 1997; Stergiou & Koubarakis, 1998; etc.) where no general solutions are provided in the specific temporal reasoning area.\nIn addition, the proposed reasoning algorithms obtain a globally labeled-consistent TCN (Theorem 11). This feature allows us to manage hypothetical queries, which is an important requirement in query processes on temporal constraint databases (Brusoni et al., 1997). Thus, queries\nsuch as Does c'ij hold, if c'kl? can be answered without any TCN propagation. The label set associated to each derived elemental constraint represents the set of input elemental constraints that should hold for the fulfillment of this elemental constraint. Therefore,\n(xk c'kl xl)→(xi c'ij xj) holds, if ∀elckl.y∈lckl / eckl.y⊆c'kl then ∃elcij.x∈lcij / ecij.x⊆c'ij and labels(elcij.x)⊆labels(elckl.y) hold.\nFor example, from the labeled minimal TCN in Figure 7, we have:\n(T1 {[40 40]} T3) → (T2 { [0 0] } T4), (T3 { [20 20] } T2) → (T3 { [20 20] } T4).\nHowever, (T3 {[10 20]} T2) does not imply (T1 {[70 70]} T4). Similarly, questions such as ‘Can c'ij hold, if c'kl?’ can also be easily answered by applying Theorem 9 and Theorem 10."
    }, {
      "heading" : "7. Alternative Temporal Contexts",
      "text" : "When we reason on temporal facts, we can simultaneously work on different alternative temporal contexts, situations, trends, plans, intentions or possible worlds (Dousson et al., 1993; Garcia & Laborie, 1996). This is usual in a branching (backward or forward) model of time. Here, we can have alternative past contexts (i.e.: different lines about how facts may have occurred) or alternative future contexts (i.e.: different lines about how facts may occur). Thus, temporal context management is also required in hypothetical or causal reasoning. Also, having different contexts permits a partition of the whole TCN in a set of independent chains in order to decrease the complexity problem size (Gerevini & Schubert, 1995). In this section, we do not deal with hypothetical reasoning issues. Our goal is temporal management of context-dependent constraints. Thus, in general, a hierarchy of alternative temporal contexts can be established, such that constraints can be associated to different temporal contexts. For instance, Figure 13 represents a hierarchy of alternative contexts, where W0 represents the root context and there are different disjunctive constraints between (n1, n2) in each context. Temporal reasoning algorithms detailed in this paper are able to manage these contextdependent constraints:\nInput disjunctive constraints are asserted in different temporal contexts. To do this, the labels associated to input elemental constraints can also be used to represent the context in which the disjunctive is asserted. For instance (Figure 13), if the constraint:\n(n1 {[0 50]{R1}, [200 210]{R2}} n2)\nis asserted in context W1, we have the following input context-dependent labeled constraint:\n(n1 {[0 25]{R1, W1}, [260 280]{R2, W1}} n2).\nHere, each context-dependent label set associated to each elemental constraint represents both the alternative temporal disjunct (i.e.: R1 or R2) and the context in which the elemental constraint is asserted (W1).\nLabel sets associated to context-dependent derived elemental constraints will represent the temporal contexts in which derived elemental constraints hold.\nDefinition 8. A context-dependent disjunctive constraint is a disjunctive constraint where each elemental constraint (i.e.: disjunct) is associated to an alternative temporal context. The universal labeled constraint is {(-∞ ∞){W0 R0}}, where W0 is the root context. ◊\nThe proposed reasoning processes can manage context-dependent disjunctive constraints in a way similar to previously defined labeled disjunctive constraints (Section 3). For instance, according to the constraints and contexts in Figure 13, the following input labeled constraints between nodes n1 n2 should be updated:\n(n1 {[0 100]{R1 W0}, [200 300]{R2 W0}} n2), (n1 {[0 50]{R3 W1}, [200 210]{R4 W1}} n2),\n(n1 {[60 100]{R5 W2}, [290 300]{R6 W2}} n2), (n1 {[0 25]{R7 W3}, [260 280]{R8 W3}} n2),\n(n1 { [0 25]{R0 W11}} n2), (n1 { [30 50]{R9 W12}, [200 205]{R10 W12}} n2),\n(n1 {[0 20]{R0 W31}, [210 215]{R0 W32}} n2), (n1 {[260 280]{R0 W33}} n2).\nThe updating process of each new constraint cij in a given context Wp should assure the consistency of cij in the context Wp, as well as in its predecessor contexts (Figure 13). The consistency of cij with the successor contexts of Wp will be detailed in Section 7.2, since several options can be identified. However, it is not necessary to assure consistency among constraints belonging to contexts of different hierarchies. Successor contexts of a given context represent different alternatives, which are mutually exclusive. Thus, constraints belonging to contexts of different hierarchies can be mutually inconsistent. However, this does not imply that constraints in these contexts should necessarily be mutually disjoint. For instance (Figure 13), the constraints (n1 {[0 50]{R3 W1}, [200 210]{R4 W1}} n2) in context W1 and (n1 {[0 25]{R7 W3}, [260 280]{R8 W3}} n2) in context W3 are not mutually disjoint. However, W1, W2 and W3 are assumed as three mutually exclusive alternatives of W0.\nThe closure process of each new constraint cij in context Wp should downward propagate the new constraint cij to all its successor contexts (Figure 13). Moreover, no propagation should be performed to the predecessor contexts of contextk, nor among contexts of different hierarchies. Elemental constraints belonging to contexts of different hierarchies cannot be simultaneously considered, that is, combined or intersected."
    }, {
      "heading" : "7.1 Context-Dependent Updating and Closure Processes",
      "text" : "The update and closure processes defined in Section 4 should be adapted in order to manage contextdependent disjunctive constraints. The Context-Update process (Figure 14) asserts the constraint c’ij≡{ec’1, ec’2, ..., ec’n} in the context contextk. In a way similar to the updated process described in Section 4, Context-Update should be performed each time a new context-dependent constraint is asserted.\nWhere:\n• Put-label-context (c’ij, contextk) associates an exclusive label set to each elemental constraint ec’ij.p∈c’ij. This label set has two labels {Rij.p contextk}. In this label set, the first label is the label associated to each temporal disjunct. In a way similar to Put-labels function, these labels are mutually exclusive (Definition 3). The second label represents the context in which c’ij is updated. Moreover, each pair of labels associated to successor contexts of the parent context of contextk is added to the I-L-Sets, since all the successor contexts of a given context are mutually exclusive:\n∀contextp / contextp∈Succesor-Contexts(Parent-Context(Contextk)), I-L-Sets ← I-L-Sets ∪ ({contextk}∪{contextp}).\nWhere Parent-Context(contextk) and Successor-Contexts(contextk) return the parent-context and the set of successor-contexts of contextk, respectively. Thus, in Figure 13, {{W1, W2}, {W1, W3}, {W2, W3}, {W11, W12}, {W31, W32}, {W31, W33}, {W32, W33}} are I-L-Sets.\n• get (ni, nj, contextk) returns the set of labeled elemental constraints between ni and nj in the contextk (and in all its successor contexts). That is:\nget (ni, nj, contextk)::= {(ecij.p{labelij.p})∈lcij / contextk∈{labelij.p}}.\nNote that get(ni, nj, contextk) is a subset of lcij. Thus, (lcij - get (ni, nj, contextk)) means the setdifference between lcij and get (ni, nj, contextk). That is, the set of elemental constraints in the context-dependent constraint lcij, which are not in contextk, nor in any of its successor contexts.\nget-upward (ni, nj, contextk), similarly to the previous get function, it returns the existing constraints between ni and nj in the contextk (and in all its successor contexts). However, if there is no constraint between ni and nj in the contextk, then the function returns the constraints between ni and nj that exist in the predecesor context of contextk:\nget-upward (ni, nj, contextk) ::= If get (ni, nj, contextk) ≠ ∅ Then return (get (ni, nj, contextk)) Else\nContextk ← Parent-Context (Contextk) Until get (ni, nj, contextk) ≠ ∅ ∨ Contextk=W0 do\nIf get (ni, nj, contextk) ≠ ∅ Then return (get (ni, nj, contextk)) Else return({(-∞ +∞)}{W0 R0}})\nEnd-get-upward\nThe context-dependent closure (Figure 15) process is similar to the closure process described in Section 4 and it is also performed at each updating process. The closure process of each updated constraint in contextk is downwards performed in contextk and in all its successor contexts.\nThe resulting label set associated to each context-dependent derived elemental constraint represents the contexts where the elemental constraint holds, as well as the hierarchy of predecessor contexts of the elemental constraint. For instance, Figure 16 shows the contextual labeling for the example in Figure 13. Moreover, after successively performing the updating and closure processes for all constraints in this example, we have the following constraint between nodes n1 and n2:\n(n1 lc12 n2): (n1 {[0 100]{R1 W0}, [200 300]{R2 W0}, [0 50]{R3 R1 W1 W0}, [200 210]{R4 R2 W1 W0}, (e3)\n[60 100]{R5 R1 W2 W0}, [290 300]{R6 R2 W2 W0}, [0 25]{R7 R1 W3 W0}, [260 280]{R8 R2 W3 W0},\n[0 25]{R0 R3 R1 W11 W1 W0}, [30 50]{R9 R3 R1 W12 W1 W0}, [200 205]{R10 R2 R4 W12 W1 W0},\n[0 20]{R0 R7 R1 W31 W3 W0}, [210 215]{R0 R2 R8 W32 W3 W0}, [260 280]{R0 R2 R8 W33 W3 W0}} n2)\nNo closure process is performed among constraints belonging to contexts of different hierarchies. According to Put-label-context function, each pair of labels related to the successor contexts of each context is an I-L-Set. Thus, these I-L-Sets prevent deriving elemental constraints from contexts of different hierarchies. That is, each derived elemental constraint obtained (combining or intersecting) from two elemental constraints in contexts of different hierarchy will have an inconsistent associated label set. Therefore, these derived elemental constraints will be rejected in the operation ∪lc. For instance, in the example of Figure 13, {{W1, W2}, {W1, W3}, {W2, W3}, {W11, W12}, {W31, W32}, {W31, W33}, {W32, W33}} are I-L-Sets. Thus, if a constraint is asserted in context W1:\ni) No propagation is performed using constraints in contexts W11 and W12 simultaneously, since {W11, W12} is an I-L-Set.\nii) No propagation is performed in context W2, nor in W3, nor in their successors, since {W1, W2} and {W1 W3} are I-L-Sets.\nLet's see an example of the Context-Update and Context-Closure processes. Let’s assume that the context-dependent constraints in Figure 13 are already updated and closured, such that the previous constraint lc12 (expression e3) exists between n1 and n2. Now, we update (n1 {[20 40]} n2) in context W1. The call to Consistency-Test function in the Context-Update function is:\nConsistency-Test (get-upward (n1, n2, W1), {[20 40]{R0 W1}}).\nGiven the previous constraint lc12 between n1 and n2 (expression e3), the function performs:\n{[0 50]{R3 R1 W1 W0}, [200 210]{R4 R2 W1 W0}, [0 25]{R0 R3 R1 W11 W1 W0},\n[30 50]{R9 R3 R1 W12 W1 W0}, [200 205]{R10 R2 R4 W12 W1 W0}} ⊕lc {[20 40]{R0 W1}}=\n{[20 40]{R3 R1 R0 W1 W0}, [20 25]{R0 R3 R1 W11 W1 W0}, [30 40]{R9 R3 R1 R0 W12 W1 W0}} ≠ ∅\nThus, the new constraint (n1 {[20 40]} n2) is consistent in context W1. Therefore, the constraint between n1 n2 results:\nlc12 ← (lc12 - get (n1, n2, W1)) ∪lc (lc12 ⊕lc {[20 40]{R0 W1}}) =\n{[0 100]{R1 W0}, [200 300]{R2 W0}, [60 100]{R5 R1 W2 W0}, [290 300]{R6 R2 W2 W0},\n[0 25]{R7 R1 W3 W0}, [260 280]{R8 R2 W3 W0}, [0 20]{R0 R7 R1 W31 W3 W0},\n[210 215]{R0 R2 R8 W32 W3 W0}, [260 280]{R0 R2 R8 W33 W3 W0}} ∪lc {[20 40]{R1 R0 W1 W0}, [20 40]{R3 R1 R0 W1 W0}, [20 25]{R0 R3 R1 W11 W1 W0}, [30 40]{R9 R3 R1 R0 W12 W1 W0}}=\n{[0 100]{R1 W0}, [200 300]{R2 W0}, [60 100]{R5 R1 W2 W0}, [290 300]{R6 R2 W2 W0}, [0 25]{R7 R1 W3 W0}, (e4)\n[260 280]{R8 R2 W3 W0}, [0 20]{R0 R7 R1 W31 W3 W0}, [210 215]{R0 R2 R8 W32 W3 W0}, [260 280]{R0 R2 R8 W33 W3 W0},\n[20 40]{R1 R0 W1 W0}, [20 25]{R0 R3 R1 W11 W1 W0}, [30 40]{R9 R3 R1 R0 W12 W1 W0}}.\nNote that the new updated constraint is asserted in context W1 and propagated to all its successor contexts (W11 and W12). However, the new constraint in context W1 does not affect the existing constraints in predecessor contexts of W1 (W0) nor the constraints belonging to contexts of different hierarchies (W2, W3 and their successors).\nIn this update process, no closure process is performed, since no node is related with n1 or n2. Now, let’s update (n3 {[10 20]} n1) in context W1. We have:\nConsistency-Test (get-upward (n3, n1, W1), {[10 20]{R0 W1}}), that performs:\n{(-∞ +∞)}{W0 R0} ⊕lc {[20 40]{R0 W1}} = {[20 40]{R0 W0 W1}} ≠ ∅,\nsince no previous constraint exists between (n3 n1) in context W1. The constraint (n3 {[10 20]} n1) is consistent, and asserted in the TCN:\nlc31 ← {(-∞ +∞)}{W0 R0}, [20 40]{R0 W0 W1}}. (e5)\nAfterwards, this constraint is closured. The call to Context-Closure process is:\nContext-Closure (n3, {(-∞ +∞)}{W0 R0}, [20 40]{R0 W0 W1}}, n1, W1).\nIn this closure process, only the first loop is performed since no node is related to n3. Moreover, only the previous constraint lc12 (expression e4) exists in the current TCN between n1 and n2. Thus, the first loop performs:\nlc'32 ← lc32 ⊕lc ({(-∞ +∞)}{W0 R0}, [20 40]{R0 W0 W1}} ⊗lc lc12) = {(-∞ ∞){W0 R0}} ⊕lc ({(-∞ +∞)}{W0 R0}, [20 40]{R0 W0 W1}} ⊗lc lc12) = {(-∞ +∞)}{W0 R0}, [220 340]{R2 R0 W0 W1}, [40 80]{R1 R0 W1 W0},\n[40 65]{R0 R3 R1 W11 W1 W0}, [50 80]{R9 R3 R1 R0 W12 W1 W0}}, such that,\nlc32 ← (lc32 - get (n3, n2, W1)) ∪lc lc'32 = ({(-∞ ∞){W0 R0}} - {}) ∪lc lc'32 = {(-∞ ∞){W0 R0}, [220 340]{R2 R0 W0 W1}, [40 80]{R1 R0 W1 W0},\n[40 65]{R0 R3 R1 W11 W1 W0}, [50 80]{R9 R3 R1 R0 W12 W1 W0}}. (e6)\nThus, the asserted constraint between (n3, n2) in context W1 is closured in the context W1 and in all its successor contexts (W11 and W12). Likewise, the closure process does not perform any propagation simultaneously using constraints of the contexts W11 and W22, nor any of the context W2, W3, nor any of their successors."
    }, {
      "heading" : "7.2 Complete Versus Incomplete Partition of Contexts",
      "text" : "In each updating process, the consistency of each new constraint lc’ij in a given context is assured in this context and in all its parent contexts. Let’s deal with consistency issues between a context and its successor contexts. Here, we have that constraints in a given context Wi can be either completely covered or only partially covered by the existing constraints in the successor contexts of Wi. That is, the successor contexts of Wi can be either a complete partition or only a partial partition of Wi.\nFor instance, let's assert the constraint (n1 {[210 210]{R0 W1}} n2) in the context W1 of the example in Figure 13. In the Consistency-test function, we have (where the constraint lc12 is the previous expression e2):\nget-upward (n1, n2, W1) ⊕lc {[210 210]{R0 W1}} = {[0 50]{R3 R1 W1 W0}, [200 210]{R4 R2 W1 W0}, [0 25]{R0 R3 R1 W11 W1 W0}, [30 50]{R9 R3 R1 W12 W1 W0},\n[200 205]{R10 R2 R4 W12 W1 W0}} ⊕lc {[210 210]{R0 W1}} = {[210 210]{R0 W1 R4 R2 W0}}.\nThat is, the asserted constraint is consistent with the existing constraints in context W1. However, no resulting elemental constraint is associated to context W11 nor W12. This means that the asserted constraint (n1 {[210 210]{R0 W1}} n2) is consistent in W1, but is inconsistent in W11 and in W12. Here, two alternatives appear:\ni) To assume that existing successor contexts are a complete partition of their parent context. Therefore, a new constraint cij in a context Wi should be rejected, if cij is inconsistent in all successor contexts of Wi. For instance, we can assume that W11 and W12 in Figure 13 are a complete partition of W1. Thus, (n1 {[210 210]{R0 W1}} n2) should be rejected.\nii) To assume that successor contexts are not a complete partition of their parent context. Therefore, successor contexts become inconsistent and they should be removed. In the example, we can assume that contexts W11 and W12 are not a complete partition of the context W1, such that another possible new successor context of W1 would be able to match in the future the asserted constraint (n1 {[210 210]{R0 W1}} n2). In this case, the constraint (n1 {[210 210]{R0 W1}} n2) is assumed to be correct, such that it can be asserted in the TCN. Therefore, the contexts W11 and W12 become inconsistent. {W11} and {W12} should be added to the set of I-L-Sets, such that these contexts (and all their successor contexts and all their constraints) become inconsistent and removed from the TCN. That is, all elemental constraints with an associated label set containing {W11} or {W12} should be removed.\nIn both cases, each context will always be consistent with all its successor contexts. The option to be adopted can depend on the problem type to solve (Garrido et al., 1999). Any of the these options can be easily introduced in the described reasoning processes, since the function Consistency Test can determine which successor contexts (Ws) become inconsistent at each new constraint (lc’ij ) in a context (Wk):\nWs∈Successor-Contexts(Wk) / ∃elcij.p∈get-upward (ni, nj, Wk), Ws∈{labelij.p} ∧ ¬∃elcij.r∈(get-upward (ni, nj, Wk) ⊕lc lc’ij), Ws∈{labelij.r}.\nOn the other hand, when: (i) the successor contexts (Wk1, Wk2, ..., Wkp) of a context Wk are a complete partition of it, and (ii) all constraints in (Wk1, Wk2, ..., Wkp) have been asserted, then constraints in Wk can be restricted according to the final existing constraints in (Wk1, Wk2, ..., Wkp). To do this, the context Wk should be constrained by the temporal union of the constraints in all its successor contexts."
    }, {
      "heading" : "7.3 A Minimal and Consistent Context-Dependent TCN",
      "text" : "Definition 9. A context-dependent TCN is minimal (and consistent) if the constraints in each context are consistent (with respect to constraints in this context, in all its predecessor contexts, and all its successor contexts) and minimal (with respect to constraints in this context and in all its predecessor contexts). ◊\nTheorem 12. At each updating process, the context-dependent reasoning processes obtain a minimal (and consistent) context-dependent TCN if the previous context-dependent TCN is minimal.\nProof: If the previous context-dependent TCN is minimal, the Consistency-Test function guarantees the consistency of each new context-dependent input constraint:\ni) in its context and in all its parent contexts (get-upward function and Theorem 5),\nii) in all its successor contexts (depending of the two identified cases in Section 7.2).\nThe closure process of a new constraint in a given context (Wk) propagates its effects to this context and to all its successor contexts. Therefore (Theorem 7), the process obtains the new minimal constraints in this context (Wk) and in all its successor contexts. ◊\nMoreover, the obtained context-dependent TCN is globally labeled-consistent. Thus, we can deduce whether a set of elemental constraints (between different pairs of time points) is consistent (Theorem 10). That is, this set of elemental constraints holds in some context. For instance, given the previous constraints lc12, lc31 and lc32 (previous expressions e4, e5 and e6), we can deduce that:\n(n1 {[40 40]} n2) ∧ (n3 {[40 40]} n1) ∧ (n3 {[40 40]} n2) is full consistent since:\n∃elc12.x∈lc12, ∃elc31.y∈lc31, ∃elc32.z∈lc32 / ({label12.x} ∪ {label12.x} ∪ {label12.x}) is not an I-L-Set.\nSpecifically, these instantiations hold in {R1 R0 W1 W0} and {R1 R0 W0}. Thus, this set of elemental constraints holds in context W1 (and, obviously, in all its predecessor contexts).\nLikewise, from a minimal context-dependent TCN, the user can retrieve the constraints that hold in each context or the constraints that simultaneously hold in a set of given contexts. To do this, the Context-Constraints function retrieves the constraints that hold between a pair of nodes (ni, nj) in a given context (contextk). That is, the result of Get-upwards(ni, nj, contextk) except those elemental constraints belonging to successor contexts of contextk:\nContext-Constraints (ni, nj, contextk)::= Get-upwards (ni, nj, contextk) –\n{lecij.p∈lcij / ∃contextq∈Succesor-Contexts(contextk), {contextq}∩{labelij.p}≠∅}.\nFor instance, given the context-dependent constraint lc12 in Figure 13 (expression e3), the following constraint would hold between (n1, n2) in both contexts W1 and W3:\nContext-Constraints(n1, n2, W1) ⊕lc Context-Constraint(n1, n2, W3) = {[0 50]{R3 R1 W1 W0}, [200 210]{R4 R2 W1 W0}} ⊕lc {[0 25]{R7 R1 W3 W0}, [260 280]{R8 R2 W3 W0}}=\n{[0 25]{R7 R3 R1 W3 W1 W0}} 6.\nIn addition, we can obtain the constraints, which simultaneously hold in a context and in any of its successor ones. For instance, in context W1 and in any of its successor contexts (W11, W12), the following constraint holds:\nContext-Constrains(n1, n2, W1) ⊕lc [Context-Constraints(n1, n2, W11) ∪lc Context-Constraints(n1, n2, W12)]= {[0 50]{R3 R1 W1 W0}, [200 210]{R4 R2 W1 W0}} ⊕lc\n{[0 25]{R0 R3 R1 W11 W1 W0}}∪lc {[30 50]{R9 R3 R1 W12 W1 W0}, [200 205]{R10 R2 R4 W12 W1 W0}}= {[200 205]{W12 R10 R4 R2 W1 W0}, [0 25]{W11 R0 R3 R1 W1 W0}, [30 50]{W12 R9 R3 R1 W1 W0}}.\nOn the other hand, each alternative context (Wi) can be associated to an alternative hypothesis (Hi). Each hypothesis Hi gives rise to a set of constraints, which will be asserted in the associated context Wi. Thus, the proposed reasoning processes assure minimal constraints in the hierarchy of hypotheses. Moreover, if a hypothesis (Hi) becomes unavailable, then the label set {Wi} should be added to the set of I-L-Sets. Thus, all constraints in context Wi (and in all its successor contexts) will be removed. That is, all constraints that depend on the unavailable hypothesis Hi will be removed."
    }, {
      "heading" : "7.4 Computational Complexity of Temporal Context Management",
      "text" : "The management of temporal context does not increase the complexity of the reasoning processes detailed in Section 4. In fact, we can consider that each label associated to a disjunct (Ri) in labeled disjunctive constraints is also associated to a context (Wi). Thus, the computational cost of each updating process is also bounded by O(n2 l2e), where 'l' is the maximum number of input disjuncts between any pair of nodes in all contexts.\nThe temporal labeled algebra proposed in this paper (Section 3) has been applied on the pointbased disjunctive metric constraints (Dechter, Meiri & Pearl, 1991). However, this labeled algebra can also be applied on other temporal constraints. In this case, the operations ⊕ lc, ⊗ lc, ∪lc and ⊆ lc should be specified (Section 3) on the basis of the operations ⊕, ⊗, ∪T and ⊆T of the underlying algebra. In this way, the management of temporal contexts can also be applied to other types of constraints.\nTheorem 13. The computational complexity of the proposed reasoning process applied to contextdependent non-disjunctive metric constraints is polynomial (O(n2 W2)) in the number W of managed contexts.\n6 However, note that this is an impossible situation, since W1 and W3 are mutually exclusive contexts. That is, {W3, W1} is an I-L-Set.\nProof: Disjunctions in constraints are only related to the contexts in which input constraints are asserted, if non-disjunctive constraints are managed. That is, constraints between each pair of nodes are in the form:\n(ni {(ecij.0{W0 R0}), (ecij.1{W1 R0}), ...... , (ecij.k{Wk R0})} nj) , 0≤k≤W / W=|{Wi}| Thus, the maximum number of disjuncts in constraints is bounded by the maximum number of managed contexts W. Moreover, the maximum length of associated label sets is the maximum depth in the hierarchy of contexts, and the set of I-L-Sets has only 2-length sets (i.e.: pairs of labels associated to each pair of successor contexts of each context). Therefore, the computational cost of operations ⊗lc and ⊕ lc is bounded by O(W2). ◊\nThe methods proposed in Section 7.1 for management of temporal contexts can also be applied to other temporal reasoning algorithms, instead of the reasoning methods detailed in Section 4. This requires that these other reasoning algorithms be based on the operations of composition and intersection of temporal constraints. Thus,\ni) Each elemental constraint should only be associated to the context (Wi) in which it is asserted 7.\nThus, label sets associated to elemental constraints have only one contextual label {Wi}.\nii) The methods for management of temporal contexts described in Section 7.1 should be integrated into the new reasoning algorithms. These algorithms should use the operations ⊕ lc, ⊗lc, get and get-upwards. The computational cost of operations ⊕lc and ⊗lc related to management of temporal contexts is polynomial (O(W2)) in the number (W) of managed contexts. Therefore, the computational cost of the reasoning algorithms is increased by a factor W2 when temporal contexts are managed.\nFor instance, when interval-based constraints are managed, the TCA algorithm can be used to obtain a path-consistent context-dependent IA-TCN, with a O(n3 W2) cost. Similarly, when a contextdependent reasoning is applied to PIDN networks (Pujari & Sattar, 1999), the computational cost of specific reasoning algorithms on PIDN constraints is increased by a factor W2. When the proposed temporal algebra in Section 3 is applied to tractable classes of constraints, the specific reasoning algorithms for management of these classes of constraints can also be applied. The computational cost of these reasoning algorithms (which should be based on combination and intersection operations on constraints) is increased by a polynomial factor W2. For instance, when nondisjunctive metric constraints are managed, the TCA algorithm can be used as the closure algorithm in Section 7.1. This algorithm will obtain a minimal context-dependent TCN with a computational cost O(n3 W2)."
    }, {
      "heading" : "8. Conclusions",
      "text" : "Several problems remain pending in representation and reasoning problems on temporal constraints. In relation to this, we have dealt with reasoning on complex qualitative and quantitative constraints between time-points and intervals, which can be organized in a hierarchy of alternative temporal\n7 That is, there are not labels (Ri) associated to disjunctions in disjunctive constraints. Thus, Definition 3 is not applied in the Put-Label-Context function. Therefore, the distributive property for ⊗lc over ⊕lc does not hold for disjunctive constraints. However, this is not relevant since other reasoning processes will be applied.\ncontexts. We have described a new-labeled temporal algebra, whose main elements are labeled disjunctive metric constraints, label sets associated to elemental constraints, and sets of inconsistent elemental constraints (I-L-Sets). The temporal model presented is able to integrate qualitative and metric constraints on time-points and intervals. In fact, symbolic and metric constraint between intervals can be represented by means of disjunctive metric constraints between time points and a set of I-L-Sets. The model is also able to manage (non-binary) logical relations among elemental constraints. The reasoning algorithms on the described model are based on the distributive property for composition over intersection in labeled constraints, and guarantee consistency and obtain a minimal TCN of disjunctive metric point-based constraints. In addition, a special type of global labeled-consistent TCN is also obtained.\nLabeled constraints can be organized in a hierarchy of alternative temporal contexts, such that temporal reasoning processes can be performed on these contexts. Reasoning algorithms guarantee consistency in each hierarchy of contexts, maintain a minimal context-dependent TCN, and allow us to determine what constraints hold in each context or in a set of alternative contexts. Thus, we can reason on a hierarchy of context-dependent constraints on intervals, points and unary durations (Figure 17).\nThese described features are useful functionalities for modeling important problems in the temporal reasoning area. However, they have not been identified in previous models. Therefore, the temporal model presented here represents a flexible framework for reasoning on complex, contextdependent, metric and qualitative constraints on time-points, intervals and unary durations.\nA path-consistent algorithm can be used as the closure process on labeled TCNs, like the typical TCA algorithm as applied by Allen (1983). This path-consistent algorithm would obtain a minimal context-dependent TCN of disjunctive metric constraints. We have proposed an incremental reasoning process. Thus, a minimal (and consistent) context-dependent TCN is assured at each new assertion. This incremental reasoning allows us to detect whether each new input constraint is inconsistent with the previously existing ones. This can be useful when problem constraints are not\ninitially known but are successively deduced from an incremental independent process (Garrido et al., 1999).\nA prototype of proposed reasoning algorithms has been implemented in Common-Lisp and is available from the author. These reasoning algorithms are being applied to an integrated architecture of planning and scheduling processes (Garrido et al., 1999). Here, the scheduling process should guarantee the consistency of each alternative partial plan (i.e.: temporal constraints and availability of resources for operations) simultaneously as the planner is generating each partial plan (Srivastava & Kambhampati, 1999). Thus, the following main features are needed:\nManagement of disjunctive metric constraints. Particularly, in planning and scheduling problems the number disjuncts in input constraints is generally bounded by l≤2 (i.e.: nonsimultaneous use of resources). However, temporal dependencies between constraints (i.e.: non-binary constraints) can appear. For instance, operation durations can be dependent on the order in which they are scheduled.\nIncremental reasoning. The process should interactively guarantee the consistency of each new input temporal constraint (about resources, plans, ordering, and objects) as each new step is deduced in a partial plan.\nManagement of temporal contexts, where each context is associated to an alternative plan (action or state). Reasoning algorithms simultaneously work over different and alternative partial plans.\nA globally labeled-consistent (and minimal) TCN allows us to determine consistent alternative choices and to obtain optimal solutions in each plan. Additionally, the proposed model can be a useful framework to apply on problems where these features also appear (Dousson et al., 1993; Garcia & Laborie, 1996; Srivastava & Kambhampati, 1999; etc.).\nThe computational cost of reasoning algorithms is exponential, due to the inherent complexity of the management of disjunctive constraints. However, the management of temporal contexts does not increase the complexity of the reasoning processes on disjunctive constraints.\nSome improvements to decrease the empirical cost of reasoning algorithms have been proposed in this paper. The application of algorithms to handle only an explicit TCN (without making the derived constraints explicit) and empirical evaluations on several test cases are under study. Moreover, other reasoning algorithms can be applied to the temporal algebra presented, as proposed in Section 4. On the other hand, it is interesting to identify subclasses of the labeled temporal algebra where the size of label sets can be bounded, and to identify tractable subclasses of IA on the proposed model. It could also be interesting to identify the expressive power of I-L-Sets (and labeled constraints) on the basis of method described by Jeavons, Cohen and Cooper (1999). Here, each I-LSet represents a special derived constraint, which expresses the inconsistency of a set of input elemental constraints; that is, a special type of disjunctive linear constraint (Jonsson & Bäckström, 1996; Stergiou & Koubarakis, 1996).\nThe proposed-labeled algebra (labeled constraints and the operations on them) can be applied to other temporal models (i.e.: to other classes of temporal constraints, operations, and reasoning algorithms). To do this, the operations of the labeled algebra (⊕lc, ⊗lc, ∪lc and ⊆lc) should be defined on the basis of the respective operations (⊕, ⊗, ∪Τ and ⊆Τ) of these models, and the reasoning algorithms should use the operations defined on labeled constraints (⊕lc, ⊗lc, ∪lc and ⊆lc). This\nrequires that these reasoning algorithms be based on the composition and intersection operations. Specifically, the application of the proposed model to tractable temporal constraints -as those identified in Section 1 (Jonsson et al., 1999; Drakengren & Jonsson, 1997; Vilain, Kautz and Van Beek, 1986; etc.)- allows for a tractable reasoning process on a hierarchy of temporal constraint contexts."
    }, {
      "heading" : "Acknowledgements",
      "text" : "This work was partially supported by the Generalitat Valenciana (Research Project #GV-1112/93) and by the Spanish Government (Research Project #CYCIT-TAP-98-0345). The author would sincerely like to thank the JAIR reviewers for their helpful comments and suggestions on previous versions of this paper."
    } ],
    "references" : [ {
      "title" : "Maintaining knowledge about temporal intervals",
      "author" : [ "J. Allen" ],
      "venue" : "Comm of the ACM,",
      "citeRegEx" : "Allen,? \\Q1983\\E",
      "shortCiteRegEx" : "Allen",
      "year" : 1983
    }, {
      "title" : "Hybrid Temporal Reasoning for Planning and Scheduling",
      "author" : [ "S. Badaloni", "M. Berati" ],
      "venue" : "In Proceedings of the 3o Int. Workshop on Temporal Representation and Reasoning (TIME’96)",
      "citeRegEx" : "Badaloni and Berati,? \\Q1996\\E",
      "shortCiteRegEx" : "Badaloni and Berati",
      "year" : 1996
    }, {
      "title" : "A metric time-point and duration-based temporal model",
      "author" : [ "F. Barber" ],
      "venue" : "ACM Sigart Bulletin,",
      "citeRegEx" : "Barber,? \\Q1993\\E",
      "shortCiteRegEx" : "Barber",
      "year" : 1993
    }, {
      "title" : "Temporal reasoning in Reakt: An environment for real-time knowledge-based systems. AICommunications",
      "author" : [ "F. Barber", "V. Botti", "E. Onaindia", "A. Crespo" ],
      "venue" : null,
      "citeRegEx" : "Barber et al\\.,? \\Q1994\\E",
      "shortCiteRegEx" : "Barber et al\\.",
      "year" : 1994
    }, {
      "title" : "Later: Managing temporal information efficiently",
      "author" : [ "V. Brusoni", "L. Console", "P. Terenziani" ],
      "venue" : "IEEE Expert,",
      "citeRegEx" : "Brusoni et al\\.,? \\Q1997\\E",
      "shortCiteRegEx" : "Brusoni et al\\.",
      "year" : 1997
    }, {
      "title" : "Tractable disjunctive constraints",
      "author" : [ "D. Cohen", "P. Jeavons", "M. Koubarakis" ],
      "venue" : "In Proceedings. of the 3rd Int. Conf. on Principles and Practice of Constraint Programming",
      "citeRegEx" : "Cohen et al\\.,? \\Q1996\\E",
      "shortCiteRegEx" : "Cohen et al\\.",
      "year" : 1996
    }, {
      "title" : "An optimal k-consistency algorithm",
      "author" : [ "M.C. Cooper" ],
      "venue" : "E.C. (Ed.). Lecture Notes in Computer Science,",
      "citeRegEx" : "Cooper,? \\Q1990\\E",
      "shortCiteRegEx" : "Cooper",
      "year" : 1990
    }, {
      "title" : "Temporal data base management",
      "author" : [ "T.L. Dean", "D.V. McDermott" ],
      "venue" : "Artificial Intelligence,",
      "citeRegEx" : "Dean and McDermott,? \\Q1987\\E",
      "shortCiteRegEx" : "Dean and McDermott",
      "year" : 1987
    }, {
      "title" : "Temporal constraint networks",
      "author" : [ "Dechter. R", "I. Meiri", "J. Pearl" ],
      "venue" : "Artificial Intelligence,",
      "citeRegEx" : "R. et al\\.,? \\Q1991\\E",
      "shortCiteRegEx" : "R. et al\\.",
      "year" : 1991
    }, {
      "title" : "From local to global consistency",
      "author" : [ "R. Dechter" ],
      "venue" : "Artificial Intelligence,",
      "citeRegEx" : "Dechter,? \\Q1992\\E",
      "shortCiteRegEx" : "Dechter",
      "year" : 1992
    }, {
      "title" : "Situation Recognition: Representation and Algorithms",
      "author" : [ "C. Dousson", "P. Gaborit", "Ghallab M" ],
      "venue" : "In Proceedings of 13th International Joint Conference on Artificial Intelligence (IJCAI’93)",
      "citeRegEx" : "Dousson et al\\.,? \\Q1993\\E",
      "shortCiteRegEx" : "Dousson et al\\.",
      "year" : 1993
    }, {
      "title" : "Eight maximal tractable subclasses of Allen's algebra with metric time",
      "author" : [ "T. Drakengren", "P. Jonsson" ],
      "venue" : "Journal of A.I. Research,",
      "citeRegEx" : "Drakengren and Jonsson,? \\Q1997\\E",
      "shortCiteRegEx" : "Drakengren and Jonsson",
      "year" : 1997
    }, {
      "title" : "Synthesizing constraint expressions",
      "author" : [ "E.C. Freuder" ],
      "venue" : "Comm. of the ACM,",
      "citeRegEx" : "Freuder,? \\Q1978\\E",
      "shortCiteRegEx" : "Freuder",
      "year" : 1978
    }, {
      "title" : "A sufficient condition for backtrack-free search",
      "author" : [ "E.C. 958-965. Freuder" ],
      "venue" : "Journal of the ACM,",
      "citeRegEx" : "Freuder,? \\Q1982\\E",
      "shortCiteRegEx" : "Freuder",
      "year" : 1982
    }, {
      "title" : "Hierarchisation of the Seach Space in Temporal Planning",
      "author" : [ "F. 24-32. Garcia", "P. Laborie" ],
      "venue" : null,
      "citeRegEx" : "Garcia and Laborie,? \\Q1996\\E",
      "shortCiteRegEx" : "Garcia and Laborie",
      "year" : 1996
    }, {
      "title" : "A model for planning and scheduling integration",
      "author" : [ "A. Garrido", "E. Marzal", "L. Sebastiá", "Barber F" ],
      "venue" : "In Proceedings of the 8 th. Conference of Spanish Association of A.I. (CAEPIA’99)",
      "citeRegEx" : "Garrido et al\\.,? \\Q1999\\E",
      "shortCiteRegEx" : "Garrido et al\\.",
      "year" : 1999
    }, {
      "title" : "Efficient algorithms for qualitative reasoning about time",
      "author" : [ "A. Gerevini", "L. Schubert" ],
      "venue" : "Artificial Intelligence,",
      "citeRegEx" : "Gerevini and Schubert,? \\Q1995\\E",
      "shortCiteRegEx" : "Gerevini and Schubert",
      "year" : 1995
    }, {
      "title" : "Constraints, consistency and closure",
      "author" : [ "P. 207-248. Jeavons", "D. Cohen", "Cooper M" ],
      "venue" : null,
      "citeRegEx" : "Jeavons et al\\.,? \\Q1998\\E",
      "shortCiteRegEx" : "Jeavons et al\\.",
      "year" : 1998
    }, {
      "title" : "How to determine the expressive power of constraints",
      "author" : [ "P. 251-268. Jeavons", "D. Cohen", "M. Gyssens" ],
      "venue" : "Constraints: An Int. Journal,",
      "citeRegEx" : "Jeavons et al\\.,? \\Q1999\\E",
      "shortCiteRegEx" : "Jeavons et al\\.",
      "year" : 1999
    }, {
      "title" : "A linear-programming approach to temporal reasoning",
      "author" : [ "P. Jonsson", "C. Bäckström" ],
      "venue" : "In Proceedings of the 13 th. National Conference on Artificial Intelligence",
      "citeRegEx" : "Jonsson and Bäckström,? \\Q1996\\E",
      "shortCiteRegEx" : "Jonsson and Bäckström",
      "year" : 1996
    }, {
      "title" : "A unifying approach to temporal constraint reasoning",
      "author" : [ "P. Press. Jonsson", "C. Bäckström" ],
      "venue" : "Artificial Intelligence,",
      "citeRegEx" : "Jonsson and Bäckström,? \\Q1998\\E",
      "shortCiteRegEx" : "Jonsson and Bäckström",
      "year" : 1998
    }, {
      "title" : "Computational complexity of relating time",
      "author" : [ "P. 143-155. Jonsson", "T. Drakengren", "C. Bäckström" ],
      "venue" : null,
      "citeRegEx" : "Jonsson et al\\.,? \\Q1999\\E",
      "shortCiteRegEx" : "Jonsson et al\\.",
      "year" : 1999
    }, {
      "title" : "Integrating metric and qualitative temporal reasoning",
      "author" : [ "H. Kautz", "P. Ladkin" ],
      "venue" : "In Proceedings of the 9th. National Conference on Artificial Intelligence",
      "citeRegEx" : "Kautz and Ladkin,? \\Q1991\\E",
      "shortCiteRegEx" : "Kautz and Ladkin",
      "year" : 1991
    }, {
      "title" : "Consistency in networks of relations",
      "author" : [ "A.K. Mackworth" ],
      "venue" : "Artificial Intelligence,",
      "citeRegEx" : "Mackworth,? \\Q1977\\E",
      "shortCiteRegEx" : "Mackworth",
      "year" : 1977
    }, {
      "title" : "Networks of constraints: fundamental properties and applications to picture processing",
      "author" : [ "U. 343-385. Montanari" ],
      "venue" : "Information Science,",
      "citeRegEx" : "Montanari,? \\Q1974\\E",
      "shortCiteRegEx" : "Montanari",
      "year" : 1974
    }, {
      "title" : "Qualitative temporal reasoning with points and durations",
      "author" : [ "I. Navarrete", "R. Marin" ],
      "venue" : "In Proceedings of the 15 th. International Joint Conference on Artificial Intelligence (IJCAI-97)",
      "citeRegEx" : "Navarrete and Marin,? \\Q1997\\E",
      "shortCiteRegEx" : "Navarrete and Marin",
      "year" : 1997
    }, {
      "title" : "Reasoning about temporal relations: a maximal tractable subclass of Allen's interval algebra",
      "author" : [ "B. Nebel", "H.J. Burckert" ],
      "venue" : "Journal of the ACM,",
      "citeRegEx" : "Nebel and Burckert,? \\Q1995\\E",
      "shortCiteRegEx" : "Nebel and Burckert",
      "year" : 1995
    }, {
      "title" : "A new framework for reasoning about Points",
      "author" : [ "A. 43-66. Pujari", "A. Sattar" ],
      "venue" : null,
      "citeRegEx" : "Pujari and Sattar,? \\Q1999\\E",
      "shortCiteRegEx" : "Pujari and Sattar",
      "year" : 1999
    }, {
      "title" : "Distance constraint arrays: A model for reasoning on intervals with qualitative and quantitative distances",
      "author" : [ "S. Staab", "U. Hahn" ],
      "venue" : "In Proceedings of the 12th Biennial Conference of the Canadian Society for Computational Studies of Intelligence on Advances in Artificial Intelligence (AI-98),",
      "citeRegEx" : "Staab and Hahn,? \\Q1998\\E",
      "shortCiteRegEx" : "Staab and Hahn",
      "year" : 1998
    }, {
      "title" : "Efficient planning through separate resource scheduling",
      "author" : [ "B. Srivastava", "S. Kambhampati" ],
      "venue" : "In Proceedings of the AAAI Spring Symp. on search strategy under uncertainty and incomplete information",
      "citeRegEx" : "Srivastava and Kambhampati,? \\Q1999\\E",
      "shortCiteRegEx" : "Srivastava and Kambhampati",
      "year" : 1999
    }, {
      "title" : "Tractable disjunctions of Linear Constraints",
      "author" : [ "K. Stergiou", "M. Koubarakis" ],
      "venue" : "In Proceedings of the 2nd Int. Conf. on Principles and Practice of Constraints Programming (CP’96). Freuder, E.C. (Ed.). Lecture Notes in Computer Science,",
      "citeRegEx" : "Stergiou and Koubarakis,? \\Q1996\\E",
      "shortCiteRegEx" : "Stergiou and Koubarakis",
      "year" : 1996
    }, {
      "title" : "Bactracking algorithms for disjunctions of temporal constraints",
      "author" : [ "K. Stergiou", "M. Koubarakis" ],
      "venue" : "In Proceedings of the 15 th. National Conference on Artificial Intelligence (AAAI98)",
      "citeRegEx" : "Stergiou and Koubarakis,? \\Q1998\\E",
      "shortCiteRegEx" : "Stergiou and Koubarakis",
      "year" : 1998
    }, {
      "title" : "1991).Temporal query processing with indefinite information",
      "author" : [ "P. AAAI Press. Van Beek" ],
      "venue" : "Artificial Intelligence",
      "citeRegEx" : "Beek,? \\Q1991\\E",
      "shortCiteRegEx" : "Beek",
      "year" : 1991
    }, {
      "title" : "On the minimality and global consistency of row convex networks",
      "author" : [ "P. Van Beek", "Detcher R" ],
      "venue" : "Journal of the ACM,",
      "citeRegEx" : "Beek and R.,? \\Q1995\\E",
      "shortCiteRegEx" : "Beek and R.",
      "year" : 1995
    }, {
      "title" : "Constraint tightness and looseness versus local and global",
      "author" : [ "P. 543-561. Van Beek", "R. Dechter" ],
      "venue" : null,
      "citeRegEx" : "Beek and Dechter,? \\Q1997\\E",
      "shortCiteRegEx" : "Beek and Dechter",
      "year" : 1997
    }, {
      "title" : "Constraint propagation algorithm for temporal reasoning",
      "author" : [ "M. Vilain", "H. Kautz", "Van Beek P" ],
      "venue" : "In Proceedings of the 5Th. National Conference on Artificial Intelligence",
      "citeRegEx" : "Vilain et al\\.,? \\Q1986\\E",
      "shortCiteRegEx" : "Vilain et al\\.",
      "year" : 1986
    }, {
      "title" : "Temporal representation with qualitative and quantitative information about points and durations",
      "author" : [ "R. Wetprasit", "Sattar A" ],
      "venue" : "In Proceedings of the 15 th. National Conference on Artificial Intelligence (AAAI’98)",
      "citeRegEx" : "Wetprasit and A.,? \\Q1998\\E",
      "shortCiteRegEx" : "Wetprasit and A.",
      "year" : 1998
    }, {
      "title" : "Performance of temporal reasoning systems, ACM Sigart",
      "author" : [ "E. AAAI Press. Yampratoom", "J. Allen" ],
      "venue" : null,
      "citeRegEx" : "Yampratoom and Allen,? \\Q1993\\E",
      "shortCiteRegEx" : "Yampratoom and Allen",
      "year" : 1993
    } ],
    "referenceMentions" : [ {
      "referenceID" : 0,
      "context" : ", 1991), or a duration primitive which should be integrated with interval and point constraints (Allen, 1983; Barber, 1993).",
      "startOffset" : 96,
      "endOffset" : 123
    }, {
      "referenceID" : 2,
      "context" : ", 1991), or a duration primitive which should be integrated with interval and point constraints (Allen, 1983; Barber, 1993).",
      "startOffset" : 96,
      "endOffset" : 123
    }, {
      "referenceID" : 0,
      "context" : "36 Algebra (IA) introduced by Allen (1983) represents symbolic (qualitative) constraints between intervals but metric information, such as 'interval1 starts 2 seconds before interval2', cannot be included.",
      "startOffset" : 30,
      "endOffset" : 43
    }, {
      "referenceID" : 0,
      "context" : "36 Algebra (IA) introduced by Allen (1983) represents symbolic (qualitative) constraints between intervals but metric information, such as 'interval1 starts 2 seconds before interval2', cannot be included. Metric (quantitative) point-based models (Dechter, Meiri & Pearl, 1991) include the 'time line' (metric) in their constraints, but they can only represent a limited subset of disjunctive constraints between intervals. Thus, constraints like 'interval1 {bef, aft} interval2' cannot be represented (Gerevini & Schubert, 1995). Some efforts have been made to integrate qualitative and quantitative temporal information on points and intervals (Kautz & Ladkin, 1991; Drakengren & Jonsson, 1997; etc.). Particularly, Meiri (1996) introduces Qualitative Algebra (QA), where each interval is represented by three nodes (one representing the interval and the other two representing its extreme points) such that QA can represent qualitative and metric constraints on points and intervals.",
      "startOffset" : 30,
      "endOffset" : 731
    }, {
      "referenceID" : 0,
      "context" : "36 Algebra (IA) introduced by Allen (1983) represents symbolic (qualitative) constraints between intervals but metric information, such as 'interval1 starts 2 seconds before interval2', cannot be included. Metric (quantitative) point-based models (Dechter, Meiri & Pearl, 1991) include the 'time line' (metric) in their constraints, but they can only represent a limited subset of disjunctive constraints between intervals. Thus, constraints like 'interval1 {bef, aft} interval2' cannot be represented (Gerevini & Schubert, 1995). Some efforts have been made to integrate qualitative and quantitative temporal information on points and intervals (Kautz & Ladkin, 1991; Drakengren & Jonsson, 1997; etc.). Particularly, Meiri (1996) introduces Qualitative Algebra (QA), where each interval is represented by three nodes (one representing the interval and the other two representing its extreme points) such that QA can represent qualitative and metric constraints on points and intervals. Badaloni and Berati (1996) define the Interval Distance Sub Algebra (IDSA), where nodes are intervals.",
      "startOffset" : 30,
      "endOffset" : 1014
    }, {
      "referenceID" : 0,
      "context" : "36 Algebra (IA) introduced by Allen (1983) represents symbolic (qualitative) constraints between intervals but metric information, such as 'interval1 starts 2 seconds before interval2', cannot be included. Metric (quantitative) point-based models (Dechter, Meiri & Pearl, 1991) include the 'time line' (metric) in their constraints, but they can only represent a limited subset of disjunctive constraints between intervals. Thus, constraints like 'interval1 {bef, aft} interval2' cannot be represented (Gerevini & Schubert, 1995). Some efforts have been made to integrate qualitative and quantitative temporal information on points and intervals (Kautz & Ladkin, 1991; Drakengren & Jonsson, 1997; etc.). Particularly, Meiri (1996) introduces Qualitative Algebra (QA), where each interval is represented by three nodes (one representing the interval and the other two representing its extreme points) such that QA can represent qualitative and metric constraints on points and intervals. Badaloni and Berati (1996) define the Interval Distance Sub Algebra (IDSA), where nodes are intervals. These intervals are related by disjunctive 4-tuple-metric constraints between their ending time points {(Ii, I j), (I + i, I j), (I i, I + j), (I + i, Ij)}. Staab and Hahn (1998) propose a model for reasoning on qualitative and metric boundaries of intervals.",
      "startOffset" : 30,
      "endOffset" : 1269
    }, {
      "referenceID" : 0,
      "context" : "36 Algebra (IA) introduced by Allen (1983) represents symbolic (qualitative) constraints between intervals but metric information, such as 'interval1 starts 2 seconds before interval2', cannot be included. Metric (quantitative) point-based models (Dechter, Meiri & Pearl, 1991) include the 'time line' (metric) in their constraints, but they can only represent a limited subset of disjunctive constraints between intervals. Thus, constraints like 'interval1 {bef, aft} interval2' cannot be represented (Gerevini & Schubert, 1995). Some efforts have been made to integrate qualitative and quantitative temporal information on points and intervals (Kautz & Ladkin, 1991; Drakengren & Jonsson, 1997; etc.). Particularly, Meiri (1996) introduces Qualitative Algebra (QA), where each interval is represented by three nodes (one representing the interval and the other two representing its extreme points) such that QA can represent qualitative and metric constraints on points and intervals. Badaloni and Berati (1996) define the Interval Distance Sub Algebra (IDSA), where nodes are intervals. These intervals are related by disjunctive 4-tuple-metric constraints between their ending time points {(Ii, I j), (I + i, I j), (I i, I + j), (I + i, Ij)}. Staab and Hahn (1998) propose a model for reasoning on qualitative and metric boundaries of intervals. However, these models cannot handle constraints on interval durations, which were identified earlier by Allen (1983). Constraints such as 'interval1 lasts 2 seconds more than interval2' require a high-order expression (Dechter et al.",
      "startOffset" : 30,
      "endOffset" : 1467
    }, {
      "referenceID" : 0,
      "context" : "36 Algebra (IA) introduced by Allen (1983) represents symbolic (qualitative) constraints between intervals but metric information, such as 'interval1 starts 2 seconds before interval2', cannot be included. Metric (quantitative) point-based models (Dechter, Meiri & Pearl, 1991) include the 'time line' (metric) in their constraints, but they can only represent a limited subset of disjunctive constraints between intervals. Thus, constraints like 'interval1 {bef, aft} interval2' cannot be represented (Gerevini & Schubert, 1995). Some efforts have been made to integrate qualitative and quantitative temporal information on points and intervals (Kautz & Ladkin, 1991; Drakengren & Jonsson, 1997; etc.). Particularly, Meiri (1996) introduces Qualitative Algebra (QA), where each interval is represented by three nodes (one representing the interval and the other two representing its extreme points) such that QA can represent qualitative and metric constraints on points and intervals. Badaloni and Berati (1996) define the Interval Distance Sub Algebra (IDSA), where nodes are intervals. These intervals are related by disjunctive 4-tuple-metric constraints between their ending time points {(Ii, I j), (I + i, I j), (I i, I + j), (I + i, Ij)}. Staab and Hahn (1998) propose a model for reasoning on qualitative and metric boundaries of intervals. However, these models cannot handle constraints on interval durations, which were identified earlier by Allen (1983). Constraints such as 'interval1 lasts 2 seconds more than interval2' require a high-order expression (Dechter et al., 1991), or a duration primitive which should be integrated with interval and point constraints (Allen, 1983; Barber, 1993). Particularly, Barber (1993) proposes two orthogonal networks to relate constraints on durations and time points.",
      "startOffset" : 30,
      "endOffset" : 1736
    }, {
      "referenceID" : 0,
      "context" : "36 Algebra (IA) introduced by Allen (1983) represents symbolic (qualitative) constraints between intervals but metric information, such as 'interval1 starts 2 seconds before interval2', cannot be included. Metric (quantitative) point-based models (Dechter, Meiri & Pearl, 1991) include the 'time line' (metric) in their constraints, but they can only represent a limited subset of disjunctive constraints between intervals. Thus, constraints like 'interval1 {bef, aft} interval2' cannot be represented (Gerevini & Schubert, 1995). Some efforts have been made to integrate qualitative and quantitative temporal information on points and intervals (Kautz & Ladkin, 1991; Drakengren & Jonsson, 1997; etc.). Particularly, Meiri (1996) introduces Qualitative Algebra (QA), where each interval is represented by three nodes (one representing the interval and the other two representing its extreme points) such that QA can represent qualitative and metric constraints on points and intervals. Badaloni and Berati (1996) define the Interval Distance Sub Algebra (IDSA), where nodes are intervals. These intervals are related by disjunctive 4-tuple-metric constraints between their ending time points {(Ii, I j), (I + i, I j), (I i, I + j), (I + i, Ij)}. Staab and Hahn (1998) propose a model for reasoning on qualitative and metric boundaries of intervals. However, these models cannot handle constraints on interval durations, which were identified earlier by Allen (1983). Constraints such as 'interval1 lasts 2 seconds more than interval2' require a high-order expression (Dechter et al., 1991), or a duration primitive which should be integrated with interval and point constraints (Allen, 1983; Barber, 1993). Particularly, Barber (1993) proposes two orthogonal networks to relate constraints on durations and time points. Navarrete (1997) and Wetprasit and Sattar (1998) relate disjunctive constraints on durations and time points, but only a limited subset of interval constraints is managed.",
      "startOffset" : 30,
      "endOffset" : 1838
    }, {
      "referenceID" : 0,
      "context" : "36 Algebra (IA) introduced by Allen (1983) represents symbolic (qualitative) constraints between intervals but metric information, such as 'interval1 starts 2 seconds before interval2', cannot be included. Metric (quantitative) point-based models (Dechter, Meiri & Pearl, 1991) include the 'time line' (metric) in their constraints, but they can only represent a limited subset of disjunctive constraints between intervals. Thus, constraints like 'interval1 {bef, aft} interval2' cannot be represented (Gerevini & Schubert, 1995). Some efforts have been made to integrate qualitative and quantitative temporal information on points and intervals (Kautz & Ladkin, 1991; Drakengren & Jonsson, 1997; etc.). Particularly, Meiri (1996) introduces Qualitative Algebra (QA), where each interval is represented by three nodes (one representing the interval and the other two representing its extreme points) such that QA can represent qualitative and metric constraints on points and intervals. Badaloni and Berati (1996) define the Interval Distance Sub Algebra (IDSA), where nodes are intervals. These intervals are related by disjunctive 4-tuple-metric constraints between their ending time points {(Ii, I j), (I + i, I j), (I i, I + j), (I + i, Ij)}. Staab and Hahn (1998) propose a model for reasoning on qualitative and metric boundaries of intervals. However, these models cannot handle constraints on interval durations, which were identified earlier by Allen (1983). Constraints such as 'interval1 lasts 2 seconds more than interval2' require a high-order expression (Dechter et al., 1991), or a duration primitive which should be integrated with interval and point constraints (Allen, 1983; Barber, 1993). Particularly, Barber (1993) proposes two orthogonal networks to relate constraints on durations and time points. Navarrete (1997) and Wetprasit and Sattar (1998) relate disjunctive constraints on durations and time points, but only a limited subset of interval constraints is managed.",
      "startOffset" : 30,
      "endOffset" : 1870
    }, {
      "referenceID" : 0,
      "context" : "36 Algebra (IA) introduced by Allen (1983) represents symbolic (qualitative) constraints between intervals but metric information, such as 'interval1 starts 2 seconds before interval2', cannot be included. Metric (quantitative) point-based models (Dechter, Meiri & Pearl, 1991) include the 'time line' (metric) in their constraints, but they can only represent a limited subset of disjunctive constraints between intervals. Thus, constraints like 'interval1 {bef, aft} interval2' cannot be represented (Gerevini & Schubert, 1995). Some efforts have been made to integrate qualitative and quantitative temporal information on points and intervals (Kautz & Ladkin, 1991; Drakengren & Jonsson, 1997; etc.). Particularly, Meiri (1996) introduces Qualitative Algebra (QA), where each interval is represented by three nodes (one representing the interval and the other two representing its extreme points) such that QA can represent qualitative and metric constraints on points and intervals. Badaloni and Berati (1996) define the Interval Distance Sub Algebra (IDSA), where nodes are intervals. These intervals are related by disjunctive 4-tuple-metric constraints between their ending time points {(Ii, I j), (I + i, I j), (I i, I + j), (I + i, Ij)}. Staab and Hahn (1998) propose a model for reasoning on qualitative and metric boundaries of intervals. However, these models cannot handle constraints on interval durations, which were identified earlier by Allen (1983). Constraints such as 'interval1 lasts 2 seconds more than interval2' require a high-order expression (Dechter et al., 1991), or a duration primitive which should be integrated with interval and point constraints (Allen, 1983; Barber, 1993). Particularly, Barber (1993) proposes two orthogonal networks to relate constraints on durations and time points. Navarrete (1997) and Wetprasit and Sattar (1998) relate disjunctive constraints on durations and time points, but only a limited subset of interval constraints is managed. More recently, Pujari and Sattar (1999) propose a framework for reasoning on points, intervals and durations (PIDN).",
      "startOffset" : 30,
      "endOffset" : 2033
    }, {
      "referenceID" : 0,
      "context" : "36 Algebra (IA) introduced by Allen (1983) represents symbolic (qualitative) constraints between intervals but metric information, such as 'interval1 starts 2 seconds before interval2', cannot be included. Metric (quantitative) point-based models (Dechter, Meiri & Pearl, 1991) include the 'time line' (metric) in their constraints, but they can only represent a limited subset of disjunctive constraints between intervals. Thus, constraints like 'interval1 {bef, aft} interval2' cannot be represented (Gerevini & Schubert, 1995). Some efforts have been made to integrate qualitative and quantitative temporal information on points and intervals (Kautz & Ladkin, 1991; Drakengren & Jonsson, 1997; etc.). Particularly, Meiri (1996) introduces Qualitative Algebra (QA), where each interval is represented by three nodes (one representing the interval and the other two representing its extreme points) such that QA can represent qualitative and metric constraints on points and intervals. Badaloni and Berati (1996) define the Interval Distance Sub Algebra (IDSA), where nodes are intervals. These intervals are related by disjunctive 4-tuple-metric constraints between their ending time points {(Ii, I j), (I + i, I j), (I i, I + j), (I + i, Ij)}. Staab and Hahn (1998) propose a model for reasoning on qualitative and metric boundaries of intervals. However, these models cannot handle constraints on interval durations, which were identified earlier by Allen (1983). Constraints such as 'interval1 lasts 2 seconds more than interval2' require a high-order expression (Dechter et al., 1991), or a duration primitive which should be integrated with interval and point constraints (Allen, 1983; Barber, 1993). Particularly, Barber (1993) proposes two orthogonal networks to relate constraints on durations and time points. Navarrete (1997) and Wetprasit and Sattar (1998) relate disjunctive constraints on durations and time points, but only a limited subset of interval constraints is managed. More recently, Pujari and Sattar (1999) propose a framework for reasoning on points, intervals and durations (PIDN). Here, variables represent points or intervals, and constraints are an ordered set of three intervals representing (Start, End, Duration) subdomains. However, no specialized algorithms for management of PIDN constraints are proposed. In relation to the complexity of reasoning algorithms, the consistency problem is polynomial in PA (Vilain, Kautz & Van Beek, 1986) and in non-disjunctive metric networks (Dechter et al., 1991). However, Vilain, Kautz and Van Beek (1986) also showed that determining the consistency of a general-case temporal network (i.",
      "startOffset" : 30,
      "endOffset" : 2581
    }, {
      "referenceID" : 0,
      "context" : "36 Algebra (IA) introduced by Allen (1983) represents symbolic (qualitative) constraints between intervals but metric information, such as 'interval1 starts 2 seconds before interval2', cannot be included. Metric (quantitative) point-based models (Dechter, Meiri & Pearl, 1991) include the 'time line' (metric) in their constraints, but they can only represent a limited subset of disjunctive constraints between intervals. Thus, constraints like 'interval1 {bef, aft} interval2' cannot be represented (Gerevini & Schubert, 1995). Some efforts have been made to integrate qualitative and quantitative temporal information on points and intervals (Kautz & Ladkin, 1991; Drakengren & Jonsson, 1997; etc.). Particularly, Meiri (1996) introduces Qualitative Algebra (QA), where each interval is represented by three nodes (one representing the interval and the other two representing its extreme points) such that QA can represent qualitative and metric constraints on points and intervals. Badaloni and Berati (1996) define the Interval Distance Sub Algebra (IDSA), where nodes are intervals. These intervals are related by disjunctive 4-tuple-metric constraints between their ending time points {(Ii, I j), (I + i, I j), (I i, I + j), (I + i, Ij)}. Staab and Hahn (1998) propose a model for reasoning on qualitative and metric boundaries of intervals. However, these models cannot handle constraints on interval durations, which were identified earlier by Allen (1983). Constraints such as 'interval1 lasts 2 seconds more than interval2' require a high-order expression (Dechter et al., 1991), or a duration primitive which should be integrated with interval and point constraints (Allen, 1983; Barber, 1993). Particularly, Barber (1993) proposes two orthogonal networks to relate constraints on durations and time points. Navarrete (1997) and Wetprasit and Sattar (1998) relate disjunctive constraints on durations and time points, but only a limited subset of interval constraints is managed. More recently, Pujari and Sattar (1999) propose a framework for reasoning on points, intervals and durations (PIDN). Here, variables represent points or intervals, and constraints are an ordered set of three intervals representing (Start, End, Duration) subdomains. However, no specialized algorithms for management of PIDN constraints are proposed. In relation to the complexity of reasoning algorithms, the consistency problem is polynomial in PA (Vilain, Kautz & Van Beek, 1986) and in non-disjunctive metric networks (Dechter et al., 1991). However, Vilain, Kautz and Van Beek (1986) also showed that determining the consistency of a general-case temporal network (i.e.: disjunctive qualitative and metric constraints between points, intervals or durations) is NP-hard. Thus, in previous qualitative or quantitative models, the consistency problem is tractable only under some properties on constraints, relationships between variable domains and constraints, or by using restricted subsets of constraints (Dechter et al., 1991; Dechter, 1992; van Beek & Detcher, 1995; Wetprasit & Sattar, 1998; Jeavons et al., 1998; etc.). For instance, tractable subclasses of IA have been identified by Vilain, Kautz and Van Beek (1986), Nebel and Burckert (1995), Drakengren and Jonsson (1997), etc.",
      "startOffset" : 30,
      "endOffset" : 3221
    }, {
      "referenceID" : 0,
      "context" : "36 Algebra (IA) introduced by Allen (1983) represents symbolic (qualitative) constraints between intervals but metric information, such as 'interval1 starts 2 seconds before interval2', cannot be included. Metric (quantitative) point-based models (Dechter, Meiri & Pearl, 1991) include the 'time line' (metric) in their constraints, but they can only represent a limited subset of disjunctive constraints between intervals. Thus, constraints like 'interval1 {bef, aft} interval2' cannot be represented (Gerevini & Schubert, 1995). Some efforts have been made to integrate qualitative and quantitative temporal information on points and intervals (Kautz & Ladkin, 1991; Drakengren & Jonsson, 1997; etc.). Particularly, Meiri (1996) introduces Qualitative Algebra (QA), where each interval is represented by three nodes (one representing the interval and the other two representing its extreme points) such that QA can represent qualitative and metric constraints on points and intervals. Badaloni and Berati (1996) define the Interval Distance Sub Algebra (IDSA), where nodes are intervals. These intervals are related by disjunctive 4-tuple-metric constraints between their ending time points {(Ii, I j), (I + i, I j), (I i, I + j), (I + i, Ij)}. Staab and Hahn (1998) propose a model for reasoning on qualitative and metric boundaries of intervals. However, these models cannot handle constraints on interval durations, which were identified earlier by Allen (1983). Constraints such as 'interval1 lasts 2 seconds more than interval2' require a high-order expression (Dechter et al., 1991), or a duration primitive which should be integrated with interval and point constraints (Allen, 1983; Barber, 1993). Particularly, Barber (1993) proposes two orthogonal networks to relate constraints on durations and time points. Navarrete (1997) and Wetprasit and Sattar (1998) relate disjunctive constraints on durations and time points, but only a limited subset of interval constraints is managed. More recently, Pujari and Sattar (1999) propose a framework for reasoning on points, intervals and durations (PIDN). Here, variables represent points or intervals, and constraints are an ordered set of three intervals representing (Start, End, Duration) subdomains. However, no specialized algorithms for management of PIDN constraints are proposed. In relation to the complexity of reasoning algorithms, the consistency problem is polynomial in PA (Vilain, Kautz & Van Beek, 1986) and in non-disjunctive metric networks (Dechter et al., 1991). However, Vilain, Kautz and Van Beek (1986) also showed that determining the consistency of a general-case temporal network (i.e.: disjunctive qualitative and metric constraints between points, intervals or durations) is NP-hard. Thus, in previous qualitative or quantitative models, the consistency problem is tractable only under some properties on constraints, relationships between variable domains and constraints, or by using restricted subsets of constraints (Dechter et al., 1991; Dechter, 1992; van Beek & Detcher, 1995; Wetprasit & Sattar, 1998; Jeavons et al., 1998; etc.). For instance, tractable subclasses of IA have been identified by Vilain, Kautz and Van Beek (1986), Nebel and Burckert (1995), Drakengren and Jonsson (1997), etc.",
      "startOffset" : 30,
      "endOffset" : 3248
    }, {
      "referenceID" : 0,
      "context" : "36 Algebra (IA) introduced by Allen (1983) represents symbolic (qualitative) constraints between intervals but metric information, such as 'interval1 starts 2 seconds before interval2', cannot be included. Metric (quantitative) point-based models (Dechter, Meiri & Pearl, 1991) include the 'time line' (metric) in their constraints, but they can only represent a limited subset of disjunctive constraints between intervals. Thus, constraints like 'interval1 {bef, aft} interval2' cannot be represented (Gerevini & Schubert, 1995). Some efforts have been made to integrate qualitative and quantitative temporal information on points and intervals (Kautz & Ladkin, 1991; Drakengren & Jonsson, 1997; etc.). Particularly, Meiri (1996) introduces Qualitative Algebra (QA), where each interval is represented by three nodes (one representing the interval and the other two representing its extreme points) such that QA can represent qualitative and metric constraints on points and intervals. Badaloni and Berati (1996) define the Interval Distance Sub Algebra (IDSA), where nodes are intervals. These intervals are related by disjunctive 4-tuple-metric constraints between their ending time points {(Ii, I j), (I + i, I j), (I i, I + j), (I + i, Ij)}. Staab and Hahn (1998) propose a model for reasoning on qualitative and metric boundaries of intervals. However, these models cannot handle constraints on interval durations, which were identified earlier by Allen (1983). Constraints such as 'interval1 lasts 2 seconds more than interval2' require a high-order expression (Dechter et al., 1991), or a duration primitive which should be integrated with interval and point constraints (Allen, 1983; Barber, 1993). Particularly, Barber (1993) proposes two orthogonal networks to relate constraints on durations and time points. Navarrete (1997) and Wetprasit and Sattar (1998) relate disjunctive constraints on durations and time points, but only a limited subset of interval constraints is managed. More recently, Pujari and Sattar (1999) propose a framework for reasoning on points, intervals and durations (PIDN). Here, variables represent points or intervals, and constraints are an ordered set of three intervals representing (Start, End, Duration) subdomains. However, no specialized algorithms for management of PIDN constraints are proposed. In relation to the complexity of reasoning algorithms, the consistency problem is polynomial in PA (Vilain, Kautz & Van Beek, 1986) and in non-disjunctive metric networks (Dechter et al., 1991). However, Vilain, Kautz and Van Beek (1986) also showed that determining the consistency of a general-case temporal network (i.e.: disjunctive qualitative and metric constraints between points, intervals or durations) is NP-hard. Thus, in previous qualitative or quantitative models, the consistency problem is tractable only under some properties on constraints, relationships between variable domains and constraints, or by using restricted subsets of constraints (Dechter et al., 1991; Dechter, 1992; van Beek & Detcher, 1995; Wetprasit & Sattar, 1998; Jeavons et al., 1998; etc.). For instance, tractable subclasses of IA have been identified by Vilain, Kautz and Van Beek (1986), Nebel and Burckert (1995), Drakengren and Jonsson (1997), etc.",
      "startOffset" : 30,
      "endOffset" : 3279
    }, {
      "referenceID" : 0,
      "context" : "36 Algebra (IA) introduced by Allen (1983) represents symbolic (qualitative) constraints between intervals but metric information, such as 'interval1 starts 2 seconds before interval2', cannot be included. Metric (quantitative) point-based models (Dechter, Meiri & Pearl, 1991) include the 'time line' (metric) in their constraints, but they can only represent a limited subset of disjunctive constraints between intervals. Thus, constraints like 'interval1 {bef, aft} interval2' cannot be represented (Gerevini & Schubert, 1995). Some efforts have been made to integrate qualitative and quantitative temporal information on points and intervals (Kautz & Ladkin, 1991; Drakengren & Jonsson, 1997; etc.). Particularly, Meiri (1996) introduces Qualitative Algebra (QA), where each interval is represented by three nodes (one representing the interval and the other two representing its extreme points) such that QA can represent qualitative and metric constraints on points and intervals. Badaloni and Berati (1996) define the Interval Distance Sub Algebra (IDSA), where nodes are intervals. These intervals are related by disjunctive 4-tuple-metric constraints between their ending time points {(Ii, I j), (I + i, I j), (I i, I + j), (I + i, Ij)}. Staab and Hahn (1998) propose a model for reasoning on qualitative and metric boundaries of intervals. However, these models cannot handle constraints on interval durations, which were identified earlier by Allen (1983). Constraints such as 'interval1 lasts 2 seconds more than interval2' require a high-order expression (Dechter et al., 1991), or a duration primitive which should be integrated with interval and point constraints (Allen, 1983; Barber, 1993). Particularly, Barber (1993) proposes two orthogonal networks to relate constraints on durations and time points. Navarrete (1997) and Wetprasit and Sattar (1998) relate disjunctive constraints on durations and time points, but only a limited subset of interval constraints is managed. More recently, Pujari and Sattar (1999) propose a framework for reasoning on points, intervals and durations (PIDN). Here, variables represent points or intervals, and constraints are an ordered set of three intervals representing (Start, End, Duration) subdomains. However, no specialized algorithms for management of PIDN constraints are proposed. In relation to the complexity of reasoning algorithms, the consistency problem is polynomial in PA (Vilain, Kautz & Van Beek, 1986) and in non-disjunctive metric networks (Dechter et al., 1991). However, Vilain, Kautz and Van Beek (1986) also showed that determining the consistency of a general-case temporal network (i.e.: disjunctive qualitative and metric constraints between points, intervals or durations) is NP-hard. Thus, in previous qualitative or quantitative models, the consistency problem is tractable only under some properties on constraints, relationships between variable domains and constraints, or by using restricted subsets of constraints (Dechter et al., 1991; Dechter, 1992; van Beek & Detcher, 1995; Wetprasit & Sattar, 1998; Jeavons et al., 1998; etc.). For instance, tractable subclasses of IA have been identified by Vilain, Kautz and Van Beek (1986), Nebel and Burckert (1995), Drakengren and Jonsson (1997), etc. Moreover, some interesting results have been obtained in identification of tractable subclasses of QA. Specifically, Jonsson et al. (1999) identified the five maximal tractable subclasses of the qualitative point-interval algebra.",
      "startOffset" : 30,
      "endOffset" : 3424
    }, {
      "referenceID" : 9,
      "context" : "Moreover, the global consistency property introduced by Dechter (1992) is an important property in temporal networks, since it allows us to obtain solutions by backtrack-free search (Dechter, 1992; Freuder, 1982).",
      "startOffset" : 182,
      "endOffset" : 212
    }, {
      "referenceID" : 13,
      "context" : "Moreover, the global consistency property introduced by Dechter (1992) is an important property in temporal networks, since it allows us to obtain solutions by backtrack-free search (Dechter, 1992; Freuder, 1982).",
      "startOffset" : 182,
      "endOffset" : 212
    }, {
      "referenceID" : 5,
      "context" : "Interesting tractable subclasses of DLRs and conditions on tractability are identified in (Cohen et al., 1996; Jonsson & Bäckström, 1996; and Stergiou & Koubarakis, 1996).",
      "startOffset" : 90,
      "endOffset" : 170
    }, {
      "referenceID" : 13,
      "context" : "In addition, usual concepts in temporal reasoning, as composition and intersection operations on constraints, minimal constraints, kconsistency (Freuder, 1982), decomposability (Montanari , 1974), globally consistency (Dechter, 1992), etc.",
      "startOffset" : 144,
      "endOffset" : 159
    }, {
      "referenceID" : 9,
      "context" : "In addition, usual concepts in temporal reasoning, as composition and intersection operations on constraints, minimal constraints, kconsistency (Freuder, 1982), decomposability (Montanari , 1974), globally consistency (Dechter, 1992), etc.",
      "startOffset" : 218,
      "endOffset" : 233
    }, {
      "referenceID" : 10,
      "context" : ") also need to reason on alternative contexts (situations, intentions or causal projections) and to know what holds in each one of them (Dousson et al., 1993; Gerevini & Schubert, 1995; Garcia & Laborie, 1996; Srivastava & Kambhampati, 1999).",
      "startOffset" : 136,
      "endOffset" : 241
    }, {
      "referenceID" : 18,
      "context" : "This feature is not supported in the usual temporal models in a general way, nor described in the usual expressive power of constraints (Jeavons et al., 1999).",
      "startOffset" : 136,
      "endOffset" : 158
    }, {
      "referenceID" : 8,
      "context" : "Moreover, the global consistency property introduced by Dechter (1992) is an important property in temporal networks, since it allows us to obtain solutions by backtrack-free search (Dechter, 1992; Freuder, 1982).",
      "startOffset" : 56,
      "endOffset" : 71
    }, {
      "referenceID" : 8,
      "context" : "Moreover, the global consistency property introduced by Dechter (1992) is an important property in temporal networks, since it allows us to obtain solutions by backtrack-free search (Dechter, 1992; Freuder, 1982). In particular, a global consistent network would allow us to handle conjunctive queries like ‘does ‘(interval1 {bef, meets} interval2) ∧ (time-point3 is [10 20] from time-point4) hold?’ without propagation of the query, as it is required in (van Beek, 1991). Stergiou and Koubarakis (1996), Jonsson and Bäckström (1996) dealt with the representation of temporal constraints by means of disjunctions of linear constraints (linear inequalities and inequations) also named Disjunctive Linear Relations (DLRs).",
      "startOffset" : 56,
      "endOffset" : 504
    }, {
      "referenceID" : 8,
      "context" : "Moreover, the global consistency property introduced by Dechter (1992) is an important property in temporal networks, since it allows us to obtain solutions by backtrack-free search (Dechter, 1992; Freuder, 1982). In particular, a global consistent network would allow us to handle conjunctive queries like ‘does ‘(interval1 {bef, meets} interval2) ∧ (time-point3 is [10 20] from time-point4) hold?’ without propagation of the query, as it is required in (van Beek, 1991). Stergiou and Koubarakis (1996), Jonsson and Bäckström (1996) dealt with the representation of temporal constraints by means of disjunctions of linear constraints (linear inequalities and inequations) also named Disjunctive Linear Relations (DLRs).",
      "startOffset" : 56,
      "endOffset" : 534
    }, {
      "referenceID" : 5,
      "context" : "Interesting tractable subclasses of DLRs and conditions on tractability are identified in (Cohen et al., 1996; Jonsson & Bäckström, 1996; and Stergiou & Koubarakis, 1996). The two main tractable subclasses are Horn linear and Ord-Horn linear constraints (Stergiou & Koubarakis, 1996; Jonsson & Bäckström, 1998). However, these subclasses subsume temporal algebras whose management is also polynomial. The management of a set of disjunctions of linear constraints is mainly based on general methods from linear programming, although some specific methods have been defined for tractable subclasses (Stergiou & Koubarakis, 1998; Cohen et al., 1996; etc.). As Pujari and Sattar outline (1999), the linear programming approach, though expressive, does not take advantage of the underlying structures (e.",
      "startOffset" : 91,
      "endOffset" : 690
    }, {
      "referenceID" : 13,
      "context" : "This property allows us to obtain solutions by backtrack-free search (Freuder, 1982).",
      "startOffset" : 69,
      "endOffset" : 84
    }, {
      "referenceID" : 30,
      "context" : "This supposes an extension of disjunctions of non-disjunctive metric constraints proposed by Stergiou and Koubarakis (1998). Moreover, given a set of disjunctive constraints, the model can handle logical relations among disjunctions of different constraints.",
      "startOffset" : 93,
      "endOffset" : 124
    }, {
      "referenceID" : 30,
      "context" : "This supposes an extension of disjunctions of non-disjunctive metric constraints proposed by Stergiou and Koubarakis (1998). Moreover, given a set of disjunctive constraints, the model can handle logical relations among disjunctions of different constraints. Thus, we can express that a set of atomic disjuncts in disjunctive constraints are mutually disjunctive among them. Therefore, a special type of and/or TCN can be managed as a conjunctive (and) TCN. Likewise, the model can also handle special non-binary constraints representing implications among temporal constraints as were identified by Meiri (1996).",
      "startOffset" : 93,
      "endOffset" : 613
    }, {
      "referenceID" : 0,
      "context" : "According to the underlying Temporal Algebra, we mainly have IA-TCNs based on the Interval Algebra (Allen, 1983), PA-TCNs based on the Point Algebra (Vilain et al.",
      "startOffset" : 99,
      "endOffset" : 112
    }, {
      "referenceID" : 35,
      "context" : "According to the underlying Temporal Algebra, we mainly have IA-TCNs based on the Interval Algebra (Allen, 1983), PA-TCNs based on the Point Algebra (Vilain et al., 1986), or Metric-TCNs based on the Metric Point Algebra (Dechter et al.",
      "startOffset" : 149,
      "endOffset" : 170
    }, {
      "referenceID" : 23,
      "context" : "As particular cases, 1-consistency, 2-consistency and 3-consistency are called node-consistency, arc-consistency and path-consistency, respectively (Mackworth, 1977; Montanari, 1974).",
      "startOffset" : 148,
      "endOffset" : 182
    }, {
      "referenceID" : 24,
      "context" : "As particular cases, 1-consistency, 2-consistency and 3-consistency are called node-consistency, arc-consistency and path-consistency, respectively (Mackworth, 1977; Montanari, 1974).",
      "startOffset" : 148,
      "endOffset" : 182
    }, {
      "referenceID" : 0,
      "context" : "According to the underlying Temporal Algebra, we mainly have IA-TCNs based on the Interval Algebra (Allen, 1983), PA-TCNs based on the Point Algebra (Vilain et al., 1986), or Metric-TCNs based on the Metric Point Algebra (Dechter et al., 1991; Dean & McDermott, 1987). In this later case, disjunctive metric point-based constraints give rise to a Temporal Constraint Satisfaction Problem (TCSP) (Dechter et al., 1991). Reasoning on temporal constraints can be seen as a Constraint Satisfaction Problem (CSP). An instantiation of the variables X is a n-tuple (v1, v2, v3, ...,vn) / vi∈D which represents the assignments of values {vi} to variables {xi}: (x1=v1, x2=v2, ...,xn=vn). A (global) solution of a TCN is a consistent instantiation of the variables X in their domains such that all TCN constraints are satisfied. A value v is a consistent (or feasible) value for xi if there exists a TCN solution in which xi=v. The set of all feasible values of a variable xi is the minimal domain for the variable. A constraint (xi cij xj) is consistent if there exists a solution in which (xi cij xj) holds. A constraint cij is minimal iff it consists only of consistent elements (or feasible values) that is, those which are satisfied by some interpretation of TCN constraints. A TCN is minimal iff all its constraints are minimal. A TCN is consistent (or satisfiable) iff it has at least one solution. Freuder (1982) generalizes the notion of consistency as: 'a network is k-consistent iff (given any instantiation of any k-1 variables satisfying all the direct constraints among those variables) there exists at least one instantiation of any kth variable such that the k values taken together satisfy all the constraints among the k variables'.",
      "startOffset" : 100,
      "endOffset" : 1412
    }, {
      "referenceID" : 23,
      "context" : "This condition gives rise to the more usual path-consistent algorithm: the Transitive Closure Algorithm (TCA) which imposes local 3-consistency in each sub-TCN of 3 nodes, such that all 2-length paths become consistent paths (Mackworth, 1977; Montanari , 1974).",
      "startOffset" : 225,
      "endOffset" : 260
    }, {
      "referenceID" : 23,
      "context" : "From Montanari (1974) and Mackworth (1977), ‘a path of k-length through nodes (x1, x2, .",
      "startOffset" : 5,
      "endOffset" : 22
    }, {
      "referenceID" : 23,
      "context" : "From Montanari (1974) and Mackworth (1977), ‘a path of k-length through nodes (x1, x2, .",
      "startOffset" : 26,
      "endOffset" : 43
    }, {
      "referenceID" : 23,
      "context" : "From Montanari (1974) and Mackworth (1977), ‘a path of k-length through nodes (x1, x2, ..., xk, xj) is path-consistent iff for any value v1∈d1 and vj∈dj such that (x1=v1 c1j xj=vj) holds, there exists a sequence of values v2∈d2, v3∈d3, ..., vk∈dk such that (v1 cl2 v2), (v2 c23 v3),...., and (vk ck,j vj) hold’. A TCN is path-consistent iff all its paths are consistent. Moreover, Montanari (1974) proves that to ensure path-consistency it suffices to check every 2-length path.",
      "startOffset" : 26,
      "endOffset" : 398
    }, {
      "referenceID" : 23,
      "context" : "From Montanari (1974) and Mackworth (1977), ‘a path of k-length through nodes (x1, x2, ..., xk, xj) is path-consistent iff for any value v1∈d1 and vj∈dj such that (x1=v1 c1j xj=vj) holds, there exists a sequence of values v2∈d2, v3∈d3, ..., vk∈dk such that (v1 cl2 v2), (v2 c23 v3),...., and (vk ck,j vj) hold’. A TCN is path-consistent iff all its paths are consistent. Moreover, Montanari (1974) proves that to ensure path-consistency it suffices to check every 2-length path. Thus, path-consistency and 3-consistency are equivalent concepts. Alternatively, Meiri (1996) outlines a path of k-length (xi, x1, x2, .",
      "startOffset" : 26,
      "endOffset" : 573
    }, {
      "referenceID" : 13,
      "context" : "A network is strong k-consistent iff the network is j-consistent for all j≤k (Freuder, 1982).",
      "startOffset" : 77,
      "endOffset" : 92
    }, {
      "referenceID" : 9,
      "context" : "Thus, a TCN is strong nconsistent iff it is globally consistent (Dechter, 1992).",
      "startOffset" : 64,
      "endOffset" : 79
    }, {
      "referenceID" : 35,
      "context" : "Thus, the process of determining the consistency and the minimality of a TCN is related to a sound and complete closure process (Vilain et al., 1986).",
      "startOffset" : 128,
      "endOffset" : 149
    }, {
      "referenceID" : 35,
      "context" : "Determining the consistency of a general-case TCN is NP-hard, and Minimal TCNs can be obtained by a polynomial number of consistency processes (Vilain et al., 1986).",
      "startOffset" : 143,
      "endOffset" : 164
    }, {
      "referenceID" : 9,
      "context" : "Alternatively, Dechter (1992) introduces the concepts of local and global consistency: A partial instantiation of variables (x1=v1, x2=v2, .",
      "startOffset" : 15,
      "endOffset" : 30
    }, {
      "referenceID" : 9,
      "context" : "Alternatively, Dechter (1992) introduces the concepts of local and global consistency: A partial instantiation of variables (x1=v1, x2=v2, ...,xk=vk) / 1≤k<n is locally consistent if it satisfies all the constraints among these variables. A subTCN is globally consistent if any locally consistent instantiation of the variables in the subTCN can be extended to a consistent instantiation of all TCN. A globally consistent TCN is one in which all its subTCNs are globally consistent. Thus, a TCN is strong nconsistent iff it is globally consistent (Dechter, 1992). The first reasoning task on a TCN is to determine whether the TCN is consistent. If the TCN is consistent, we can then obtain the minimal-TCN, all TCN solutions (by assuming a discrete and finite model of time), only one solution, a partial solution (consistent instantiation of a subset of TCN variables, which is a part of a global solution), etc. Deductive closure, or propagation, is one of the basic reasoning algorithms. The closure process is a deductive process on a TCN, where new derived constraints are deduced from the explicitly asserted ones by means of the composition (⊗) and intersection (⊕) operations. Thus, the process of determining the consistency and the minimality of a TCN is related to a sound and complete closure process (Vilain et al., 1986). Alternatively, CSP-based methods (with several heuristic search criteria) are also used for guaranteeing consistency and obtaining TCN solutions. In this paper, we are mainly interested in TCN closure processes. Determining the consistency of a general-case TCN is NP-hard, and Minimal TCNs can be obtained by a polynomial number of consistency processes (Vilain et al., 1986). Particularly, Dechter, Meiri and Pearl (1991) showed that determining consistency and obtaining a minimal disjunctive metric TCN can be achieved in O(n l), where ‘n’ is the number of TCN nodes, ‘e’ is the number of explicitly asserted (input) constraints, and ‘l’ is the maximum number of intervals in an input constraint.",
      "startOffset" : 15,
      "endOffset" : 1760
    }, {
      "referenceID" : 0,
      "context" : "The path-consistency TCA Algorithm has an O(n) cost (Allen, 1983; Vilain, Kautz & Van Beek, 1986).",
      "startOffset" : 52,
      "endOffset" : 97
    }, {
      "referenceID" : 0,
      "context" : "The path-consistency TCA Algorithm has an O(n) cost (Allen, 1983; Vilain, Kautz & Van Beek, 1986). However, assuring path-consistency can become a complex task in disjunctive metricTCNs if the variable domain D is large or continuous. As was stated by Dechter, Meiri and Pearl (1991), the number of intervals in |cij ⊗ cjk| is upper bounded by |cij|x|cjk|.",
      "startOffset" : 53,
      "endOffset" : 284
    }, {
      "referenceID" : 0,
      "context" : "The path-consistency TCA Algorithm has an O(n) cost (Allen, 1983; Vilain, Kautz & Van Beek, 1986). However, assuring path-consistency can become a complex task in disjunctive metricTCNs if the variable domain D is large or continuous. As was stated by Dechter, Meiri and Pearl (1991), the number of intervals in |cij ⊗ cjk| is upper bounded by |cij|x|cjk|. Thus, the total number of disjuncts (subintervals) in a path-consistent TCN might be exponential in the number of disjuncts per constraints in the initial (input) TCN. Schwalb and Dechter (1997) call this the fragmentation problem, which does not appear in non-disjunctive metric TCNs.",
      "startOffset" : 53,
      "endOffset" : 552
    }, {
      "referenceID" : 9,
      "context" : "Let's see a simple example on labeled constraints, which was introduced by Dechter, Meiri and Pearl (1991).",
      "startOffset" : 75,
      "endOffset" : 107
    }, {
      "referenceID" : 9,
      "context" : "Dechter, Meiri and Pearl (1991) show the following example.",
      "startOffset" : 0,
      "endOffset" : 32
    }, {
      "referenceID" : 9,
      "context" : "For instance, the wellknown Transitive Closure Algorithm, general closure algorithms as in (Dechter, 1992; Dechter et al., 1991; van Beek & Dechter, 1997), CSP-based approaches, etc.",
      "startOffset" : 91,
      "endOffset" : 154
    }, {
      "referenceID" : 15,
      "context" : "An incremental reasoning process is useful when temporal constraints are not initially known but are successively deduced from an independent process; for instance, in an integrated planning and scheduling system (Garrido et al., 1999).",
      "startOffset" : 213,
      "endOffset" : 235
    }, {
      "referenceID" : 7,
      "context" : "For instance, the wellknown Transitive Closure Algorithm, general closure algorithms as in (Dechter, 1992; Dechter et al., 1991; van Beek & Dechter, 1997), CSP-based approaches, etc. However, Montanari (1974) shows that when composition operation distributes over intersection, any path-consistent TCN is also a minimal TCN.",
      "startOffset" : 92,
      "endOffset" : 209
    }, {
      "referenceID" : 0,
      "context" : "Thus, the TCA algorithm could be used as the closure process on labeled constraints, in a similar way as Allen (1983) uses it.",
      "startOffset" : 105,
      "endOffset" : 118
    }, {
      "referenceID" : 0,
      "context" : "Thus, the TCA algorithm could be used as the closure process on labeled constraints, in a similar way as Allen (1983) uses it. However, an incremental reasoning process is proposed on the basis of the incremental path-consistent algorithm for non-disjunctive metric constraints described by Barber (1993). An incremental reasoning process is useful when temporal constraints are not initially known but are successively deduced from an independent process; for instance, in an integrated planning and scheduling system (Garrido et al.",
      "startOffset" : 105,
      "endOffset" : 305
    }, {
      "referenceID" : 19,
      "context" : "This type of constraints could be represented as a disjunctive linear constraint, as Jonsson and Bäckström (1996), Stergiou and Koubarakis (1996) show.",
      "startOffset" : 85,
      "endOffset" : 114
    }, {
      "referenceID" : 19,
      "context" : "This type of constraints could be represented as a disjunctive linear constraint, as Jonsson and Bäckström (1996), Stergiou and Koubarakis (1996) show.",
      "startOffset" : 85,
      "endOffset" : 146
    }, {
      "referenceID" : 2,
      "context" : "Proof: This was detailed by Barber (1993) for non-disjunctive TCNs and it is applied here to labeled TCNs.",
      "startOffset" : 28,
      "endOffset" : 42
    }, {
      "referenceID" : 23,
      "context" : "Proof: Montanari (1974) shows that when composition distributes over intersection (i.",
      "startOffset" : 7,
      "endOffset" : 24
    }, {
      "referenceID" : 9,
      "context" : "In a minimal (binary) disjunctive network, every subnetwork of size two is globally consistent (Dechter, 1992).",
      "startOffset" : 95,
      "endOffset" : 110
    }, {
      "referenceID" : 9,
      "context" : "In a minimal (binary) disjunctive network, every subnetwork of size two is globally consistent (Dechter, 1992). Therefore, any local consistent instantiation of a subset of two variables can be extended to a full consistent instantiation. However, to assure that a local consistent instantiation of a subset of more that two variables is overall consistent, the partial instantiation should be propagated on the whole TCN (van Beek, 1991). Thus, assembling a TCN solution can become a costly propagation process in disjunctive TCNs, even though a minimal TCN was used. The proposed reasoning processes maintain a complete and sound set of I-L-Sets (Theorem 8). Thus, we can deduce if a locally consistent set of elemental constraints is overall consistent by means of label sets associated to labeled elemental constraints and the set of I-L-Sets. Specifically, we can deduce whether any locally consistent instantiation of k variables (1<k<n) is overall consistent. Let’s see the following example, which is based on a previous one proposed by Dechter, Meiri and Pearl (1991):",
      "startOffset" : 96,
      "endOffset" : 1077
    }, {
      "referenceID" : 9,
      "context" : "That is, on the basis of the concepts introduced by Dechter (1992):",
      "startOffset" : 52,
      "endOffset" : 67
    }, {
      "referenceID" : 24,
      "context" : "This is also a consequence of the decomposability (Montanari, 1974; Dechter et al., 1991) or globally consistency (Dechter, 1992) properties.",
      "startOffset" : 50,
      "endOffset" : 89
    }, {
      "referenceID" : 9,
      "context" : ", 1991) or globally consistency (Dechter, 1992) properties.",
      "startOffset" : 32,
      "endOffset" : 47
    }, {
      "referenceID" : 11,
      "context" : "Similar expressions can be made for k-labeled-consistency and strong k-labeled-consistency on the basis of the concepts provided by Freuder (1982). Therefore, the set of I-L-Sets in a labeled-TCN provides a useful way to assure whether a local instantiation of variables can be part of a global solution.",
      "startOffset" : 132,
      "endOffset" : 147
    }, {
      "referenceID" : 11,
      "context" : "Similar expressions can be made for k-labeled-consistency and strong k-labeled-consistency on the basis of the concepts provided by Freuder (1982). Therefore, the set of I-L-Sets in a labeled-TCN provides a useful way to assure whether a local instantiation of variables can be part of a global solution. Moreover, Freuder (1982) shows that in a strong k-consistent TCN, consistent instantiations of variables of any subnetwork of size k can be found in a backtrack-free manner and in any variable ordering.",
      "startOffset" : 132,
      "endOffset" : 330
    }, {
      "referenceID" : 2,
      "context" : "These processes are, basically, an incremental path-consistent algorithm (Barber, 1993).",
      "startOffset" : 73,
      "endOffset" : 87
    }, {
      "referenceID" : 15,
      "context" : "It should be noted that l can be bounded in some typical problems like scheduling, where usually l≤2 (Garrido et al., 1999), or by restricting domain size (range or granularity) in metric algebras.",
      "startOffset" : 101,
      "endOffset" : 123
    }, {
      "referenceID" : 4,
      "context" : "Two different approaches exist for temporal constraint management (Brusoni et al., 1997; Yampratoom, Allen, 1993; Barber, 1993).",
      "startOffset" : 66,
      "endOffset" : 127
    }, {
      "referenceID" : 2,
      "context" : "Two different approaches exist for temporal constraint management (Brusoni et al., 1997; Yampratoom, Allen, 1993; Barber, 1993).",
      "startOffset" : 66,
      "endOffset" : 127
    }, {
      "referenceID" : 6,
      "context" : "The computational cost of the proposed algorithms agreed with the computational cost inherent to the problem of the management of disjunctive metric constraints (Dechter, 1991). In fact, the closure process could be considered as an integrated management of the l alternative nondisjunctive TCNs in which a disjunctive TCN can be split, as it is shown by Dechter, Meiri and Pearl (1991). It should be noted that l can be bounded in some typical problems like scheduling, where usually l≤2 (Garrido et al.",
      "startOffset" : 162,
      "endOffset" : 387
    }, {
      "referenceID" : 6,
      "context" : "For instance, the TCA algorithm as is applied by Allen (1983), and the k-consistency algorithms like those described in (Cooper, 1990; Freuder, 1978).",
      "startOffset" : 120,
      "endOffset" : 149
    }, {
      "referenceID" : 12,
      "context" : "For instance, the TCA algorithm as is applied by Allen (1983), and the k-consistency algorithms like those described in (Cooper, 1990; Freuder, 1978).",
      "startOffset" : 120,
      "endOffset" : 149
    }, {
      "referenceID" : 0,
      "context" : "For instance, the TCA algorithm as is applied by Allen (1983), and the k-consistency algorithms like those described in (Cooper, 1990; Freuder, 1978).",
      "startOffset" : 49,
      "endOffset" : 62
    }, {
      "referenceID" : 0,
      "context" : "For instance, the TCA algorithm as is applied by Allen (1983), and the k-consistency algorithms like those described in (Cooper, 1990; Freuder, 1978). Moreover, a minimal TCN of labeled constraints can be obtained without enforcing global consistency; for example, by applying the naive backtracking algorithm described by Dechter, Meiri and Pearl (1991), which is O(n l).",
      "startOffset" : 49,
      "endOffset" : 355
    }, {
      "referenceID" : 0,
      "context" : "Each symbolic constraint is a disjunctive subset of 13 elemental constraints, which are mutually exclusive among them (Allen, 1983).",
      "startOffset" : 118,
      "endOffset" : 131
    }, {
      "referenceID" : 0,
      "context" : "a), which was given by Allen (1983). This example shows how interval-based constraints can be represented and managed by means of disjunctive metric point-based constraints and a minimal IA-TCN can be obtained.",
      "startOffset" : 23,
      "endOffset" : 36
    }, {
      "referenceID" : 0,
      "context" : "a represents a path-consistent IA-TCN, which has inconsistent values in constraints (Allen, 1983).",
      "startOffset" : 84,
      "endOffset" : 97
    }, {
      "referenceID" : 0,
      "context" : "66 Allen (1983) remarks that the symbolic constraint (IA {f fi} IC) cannot hold given the existing constraints between IA, IB, IC and ID.",
      "startOffset" : 3,
      "endOffset" : 16
    }, {
      "referenceID" : 28,
      "context" : "These metric constraints on interval boundaries (Table 4) are similar to the ones proposed by Staab and Hahn (1998).",
      "startOffset" : 94,
      "endOffset" : 116
    }, {
      "referenceID" : 1,
      "context" : "In this way, the described model also subsumes the Interval Distance Sub Algebra model proposed by Badaloni and Berati (1996). Moreover, ending points of intervals can also be related to the initial time-point T0, and unary metric constraints on interval durations can be expressed by means of metric constraints between the two ending points of each interval:",
      "startOffset" : 99,
      "endOffset" : 126
    }, {
      "referenceID" : 30,
      "context" : "This subsumes the related expressiveness in the subset of disjunctive linear constraints proposed by Stergiou and Koubarakis (1998), where only disjunctions of constraints between different pairs of points are managed.",
      "startOffset" : 101,
      "endOffset" : 132
    }, {
      "referenceID" : 4,
      "context" : "This feature allows us to manage hypothetical queries, which is an important requirement in query processes on temporal constraint databases (Brusoni et al., 1997).",
      "startOffset" : 141,
      "endOffset" : 163
    }, {
      "referenceID" : 24,
      "context" : "Stergiou and Koubarakis (1996) and Jonsson and Bäckström (1998) show that Disjunctions of Linear Constraints (DLR) are also able to represent these non-binary constraints.",
      "startOffset" : 0,
      "endOffset" : 31
    }, {
      "referenceID" : 16,
      "context" : "Stergiou and Koubarakis (1996) and Jonsson and Bäckström (1998) show that Disjunctions of Linear Constraints (DLR) are also able to represent these non-binary constraints.",
      "startOffset" : 35,
      "endOffset" : 64
    }, {
      "referenceID" : 16,
      "context" : "Stergiou and Koubarakis (1996) and Jonsson and Bäckström (1998) show that Disjunctions of Linear Constraints (DLR) are also able to represent these non-binary constraints. However, Pujari and Sattar (1999) remark that general methods from linear programming should then be applied for DLR management, such that specific temporal concepts (like the ones detailed in Section 2) are not considered in these general methods.",
      "startOffset" : 35,
      "endOffset" : 206
    }, {
      "referenceID" : 10,
      "context" : "When we reason on temporal facts, we can simultaneously work on different alternative temporal contexts, situations, trends, plans, intentions or possible worlds (Dousson et al., 1993; Garcia & Laborie, 1996).",
      "startOffset" : 162,
      "endOffset" : 208
    }, {
      "referenceID" : 15,
      "context" : "The option to be adopted can depend on the problem type to solve (Garrido et al., 1999).",
      "startOffset" : 65,
      "endOffset" : 87
    }, {
      "referenceID" : 0,
      "context" : "A path-consistent algorithm can be used as the closure process on labeled TCNs, like the typical TCA algorithm as applied by Allen (1983). This path-consistent algorithm would obtain a minimal context-dependent TCN of disjunctive metric constraints.",
      "startOffset" : 125,
      "endOffset" : 138
    }, {
      "referenceID" : 15,
      "context" : "83 initially known but are successively deduced from an incremental independent process (Garrido et al., 1999).",
      "startOffset" : 88,
      "endOffset" : 110
    }, {
      "referenceID" : 15,
      "context" : "These reasoning algorithms are being applied to an integrated architecture of planning and scheduling processes (Garrido et al., 1999).",
      "startOffset" : 112,
      "endOffset" : 134
    }, {
      "referenceID" : 6,
      "context" : "It could also be interesting to identify the expressive power of I-L-Sets (and labeled constraints) on the basis of method described by Jeavons, Cohen and Cooper (1999). Here, each I-LSet represents a special derived constraint, which expresses the inconsistency of a set of input elemental constraints; that is, a special type of disjunctive linear constraint (Jonsson & Bäckström, 1996; Stergiou & Koubarakis, 1996).",
      "startOffset" : 155,
      "endOffset" : 169
    } ],
    "year" : 2011,
    "abstractText" : "We introduce a temporal model for reasoning on disjunctive metric constraints on intervals and time points in temporal contexts. This temporal model is composed of a labeled temporal algebra and its reasoning algorithms. The labeled temporal algebra defines labeled disjunctive metric pointbased constraints, where each disjunct in each input disjunctive constraint is univocally associated to a label. Reasoning algorithms manage labeled constraints, associated label lists, and sets of mutually inconsistent disjuncts. These algorithms guarantee consistency and obtain a minimal network. Additionally, constraints can be organized in a hierarchy of alternative temporal contexts. Therefore, we can reason on context-dependent disjunctive metric constraints on intervals and points. Moreover, the model is able to represent non-binary constraints, such that logical dependencies on disjuncts in constraints can be handled. The computational cost of reasoning algorithms is exponential in accordance with the underlying problem complexity, although some improvements are proposed.",
    "creator" : "PSCRIPT.DRV versión 4.0"
  }
}