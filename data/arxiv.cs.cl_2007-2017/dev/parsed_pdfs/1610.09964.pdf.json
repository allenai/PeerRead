{
  "name" : "1610.09964.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : "Ontology Verbalization using Semantic-Refinement",
    "authors" : [ ],
    "emails" : [ "vinuev@cse.iitm.ac.in", "psk@cse.iitm.ac.in", "vinuev@cse.iitm.ac.in,", "mvsquare1729@gmail.com" ],
    "sections" : [ {
      "heading" : null,
      "text" : "Keywords: Verbalization, Ontologies, Rule-based system"
    }, {
      "heading" : "1. Introduction",
      "text" : "Web Ontology Language (OWL/DL) ontologies are knowledge representation structures which are based on decidable fragments of first order logic. They model domain knowledge in the form of logical axioms; so that, an intelligent agent with the help of a reasoning system, can make use of them for several applica-\n*Corresponding author. E-mail: vinuev@cse.iitm.ac.in, mvsquare1729@gmail.com\ntions. Ontologies play an important role in the development and deployment of the Semantic Web since they help in enhancing the understanding of the contextual meaning of data. Since the knowledge in the form of an ontology is inherently characterized by complex relational contexts, it is typically inaccessible for nonSemantic Web experts. This problem motivated researchers to work on natural language (NL) verbalization techniques for OWL ontologies. The existing approaches in this direction mainly strive for one-to-one conversion of logical statements to NL texts, and re-\n0000-0000/15/$00.00 © 2015 – IOS Press and the authors. All rights reserved\nar X\niv :1\n61 0.\n09 96\n4v 1\n[ cs\n.A I]\nsult in methods which produce verbatim equivalents of OWL constructs. One of the main and common drawback of these approaches is that, since the generated sentences are verbatim equivalent to the OWL statements, they are likely to have high amount of redundancy. As we show later with examples, it can be very annoying for a human reader to read and understand such sentences. Therefore, in this paper, we explore techniques which can generate NL sentences that do not have redundancies and are semantically equivalent to their OWL counterparts.\nWe will closely look at the problem of verbalization of OWL ontologies from the perspective of using the generated descriptions for validating the formalized knowledge. Typically, ontologies are developed by a group of knowledge engineers with the help of domain experts. The domain experts provide the knowledge to be formalized and the engineers build the ontology out of it. Since an ontology development involves multiple parties (engineers and domain experts), the process usually follows a Spiral model, where suitable feedback mechanisms are involved to improve the structure.\nAs an ontology evolves over a period of time, it can grow in size and complexity. Unless the updates are carefully carried out, the quality of the ontology might degrade. To prevent such quality depletion, usually an ontology development cycle is accompanied by a validation phase, where both the knowledge engineers and domain experts meet to review the content of the ontology.\nIn a typical validation phase, new axioms are included or existing axioms are altered or removed, to maintain the correctness of the ontology. The conventional method for incorporating new axioms and validating the ontology involves a validity check by domain experts. Domain experts, who do the validity check, cannot be expected to be highly knowledgeable on formal methods and notations. For their convenience, the OWL axioms will have to be first converted into corresponding NL texts. Ontology verbalizers and ontology authoring tools such as ACE [9], NaturalOWL [1] and SWAT Tools [12], can be utilized for generating controlled natural language (CNL) descriptions of OWL statements. Restricting our attention to description of individuals and atomic concepts, we find that the approach currently followed in the available tools is that of determining the set of all logical conditions that are satisfied by the given individual/concept name and translate these conditions verbatim into corresponding NL descriptions. But the ver-\nbatim fidelity of such descriptions to the underlying OWL statements, makes them a poor choice for ontology validation. This is because, the descriptions will be confusing to a person who is not familiar with formal constructs, and it will be difficult to correctly understand the meaning from such descriptions. This issue had been previously reported in papers such as [11,12], where the authors tried to overcome the issue by applying operations such as grouping and aggregation on the verbalized text. But, since the issue had been treated at the NL text level, the opportunity for a logical-level refinement of the OWL statements to generate a more meaningful and human-understandable representation has been ignored.\nFor example, consider the following logical axioms (from People & Pets ontology1) represented in the description logic (DL) notation.\n1. Cat_Owner v Person u ∃hasPet.Animal u ∃hasPet.Cat 2. Cat_Owner(sam) 3. Cat v Animal\nThe different variants of the CNL sentences correspond to the individual sam are as follows:\n– A cat-owner is a person. A cat-owner has as pet an animal. A cat-owner has as pet a cat. Sam is a cat-owner. All cats are animals. or (with grouping and aggregation) – A cat-owner is a person . A cat-owner is all of the following: something that has pet an animal, and something that has pet a cat; Example: sam. All cats are animals.\nAs can be easily seen, these descriptions have redundant information and attempting verbatim equivalence to DL constructs has resulted in this situation. The above example illustrates one type of redundancy and several more are identified in the paper later.\nIn this paper, we introduce an approach for removing redundancies from the verbalized definitions of OWL/DL entities, and to generate the so-called redundancy-free representations/descriptions. We propose a technique called semantic-level refinement (or simply semantic-refinement) that helps in removing the redundant (portion of the) restrictions and generating a more semantically comprehensive description of the entity. From an application point of view, in this paper, we particularly focus on generating NL descrip-\n1http://www.cs.man.ac.uk/∼horrocks/ISWC2003/Tutorial /people+pets.owl.rdf\ntions of individuals and concepts for validating ontologies which follow SHIQ description logic.\nOur proposed approach generates NL descriptions of individuals and concepts by giving importance to the semantic conciseness of the content. If we revisit our previous example, we expect our approach to produce a text similar to: Sam: is a cat-owner having at least one cat as pet; such that the redundant portion of the text has as pet an animal (since it clearly follows from having at least one cat as pet) is removed.\nThis paper is arranged as follows: Section 3 and 4 discuss the preliminaries for understanding the work and, newly introduced terminologies in the paper respectively. In Section 5 we elaborate an approach for generating definitions (in the form of logical expressions) of ontology individuals and concepts, and a rulebased method for removing redundancies from the definitions. Section 6 explains the process that we have followed for generating NL sentences from the logical expressions.\nIn Section 7, the empirical evaluation section, we seek to validate the following two propositions using case studies. Firstly, logical-level removal of redundancies and repetitions can significantly improve the clarity of the domain knowledge when expressed in a NL. Secondly, NL definitions of individuals of an ontology can be effectively used for validating the ontology."
    }, {
      "heading" : "2. Related Work",
      "text" : "Over the last decade, several CNLs such as Attempto Controlled English (ACE) [9,8], Ordnance Survey2’s Rabbit (Rabbit) [4], and Sydney OWL Syntax (SOS) [3], have been specifically designed or have been adapted for ontology language OWL. All these languages are meant to make the interactions with formal ontological statements easier and faster for users who are unfamiliar with formal notations. Unlike the other languages [5,7,1] that have been suggested to represent OWL in controlled English, these CNLs are designed to have formal language semantics and bidirectional mapping between NL fragments and OWL constructs. Even though these formal language semantics and bidirectional mapping are helpful in enabling a formal check that the resulting NL expressions are unambiguous, they generate a collection of unordered sentences that are difficult to comprehend.\n2Great Britain’s national mapping agency\nTo use these CNLs as a means for ontology authoring and for knowledge validation purposes, appropriate organization of the verbalized text is necessary. A detailed comparison of the systems that comprehend the NL texts is given in [11]. Among such systems, SWAT tools3 are one of the recent and prominent tools which use standard techniques from computational linguistics to make the verbalized text more readable. They tried to give better clarity to the generated text by grouping, aggregation and elision. The Semantic Web Authoring (SWAT) NL verbalization tools have given much importance to the fluency of the verbalized sentences [12], rather than removing redundancies from their logical forms, hence have deficiencies in interpreting the ontology contents.\n3. Preliminaries\n3.1. SHIQ Ontologies\nThe description logic (DL) SHIQ is based on an extension of the well-known logic ALC [10], with added support for role hierarchies, inverse roles, transitive roles, and qualifying number restrictions [6].\nWe assume NC and NR as countably infinite disjoint sets of atomic concepts and atomic roles respectively. A SHIQ role is either R ∈ NR or an inverse roleR− withR ∈ NR. To avoid considering roles such as (R−)−, we define a function Inv(.) which returns the inverse of a role: Inv(R) = R− and Inv(R−) = R.\nThe set of concepts in SHIQ is recursively defined using the constructors in Table 1, whereA ∈ NC , C,D are concepts, R,S are roles, and n,m are positive integers. A SHIQ based ontology — denoted as a pair O = (T,A), where T denotes terminological axioms (also known as TBox) and A represents assertional axioms (also known as ABox) — is a set of axioms of the type specified in Table 2. A role R in O is transitive if Tran(R) ∈ O or Tran(R−) ∈ O. Given an O, let vO be the smallest transitive reflexive relation between roles R1 and R2, such that R1 v R2 ∈ O impliesR1 vO R2 andR−1 vO R − 2 . For a SHIQ ontologyO, the role S in every concept of the form≥ nS.C and ≤ mS.C in O, should be simple, that is, R vO S holds for no transitive role R [2].\nThe semantics of SHIQ is defined using interpretations. An interpretation is a pair I = (∆I , .I) where ∆I is a non-empty set called the domain of the in-\n3http://mcs.open.ac.uk/nlg/SWAT/\nTable 1 The syntax and semantics of SHIQ concept types\nName Syntax Semantics\natomic concept A AI top concept > ∆I bottom concept ⊥ φ negation ¬C ∆I\\CI conjunction C uD CI ∩DI disjunction C tD CI ∪DI existential restriction ∃R.C {x ∈ ∆I | ∃y.〈x, y〉 ∈ RI ∧ y ∈ CI } universal restriction ∀R.C {x ∈ ∆I | ∀y.〈x, y〉 ∈ RI ⇒ y ∈ CI } min cardinality ≥ nR.C {x ∈ ∆I | #{y | 〈x, y〉 ∈ RI ∧ y ∈ CI} ≥ n } max cardinality ≤ mR.C {x ∈ ∆I | #{y | 〈x, y〉 ∈ RI ∧ y ∈ CI} ≤ m }\nTable 2 The syntax and semantics of SHIQ ontology axioms\nName Syntax Semantics\nrole hierarchy R v S RI ⊆ SI TBox role transitivity Tran(R) RI ◦RI ⊆ RI\nconcept inclusion C v D CI ⊆ DI concept equality C ≡ D CI = DI\nconcept assertion C(a) aI ∈ CI ABox role assertion R(a, b) 〈aI , bI〉 ∈ RI\ninequality assertion a 6≈ b aI 6= bI\nterpretation and .I is the interpretation function. The function .I assigns a set AI ⊆ ∆I to every A ∈ NC , and assigns a relation rI ⊆ ∆I×∆I to every r ∈ NR. The interpretation of the inverse role r− is (r−)I := {〈x, y〉 | 〈y, x〉 ∈ rI}. The interpretation is extended to concepts and axioms according to the rightmost column of Table 1 and Table 2 respectively, where #X denotes the cardinality of the set X .\nWe write I |= α, if the interpretation I satisfies the axiom α (or α is true in I). I is a model of an ontology O (written I |= O) if I satisfies every axiom in O. If we say α is entailed by O, or α is a logical consequence of O (written O |= α), then every model of O satisfies α. A concept C is subsumed by D w.r.t. O if O |= C v D, and C is unsatisfiable w.r.t. O if O |= C v ⊥. Classification is the task of computing all subsumptions A v B between atomic concepts such that A,B ∈ NC and O |= A v B; similarly, property classification of O is the computation of all subsumptions between properties R v S such that R,S ∈ NR and O |= R v S."
    }, {
      "heading" : "3.2. Running Example",
      "text" : "In this section we introduce an example ontology (called the academic (ACAD) ontology) which we follow throughout this chapter. We have formalized vari-\nous concepts in academic domain in this ontology. The ontology is rather small, but serves the purpose well. The TBox and ABox of the ontology is given in Table 3 and 4 respectively."
    }, {
      "heading" : "4. Newly Introduced Terminologies and Definitions",
      "text" : "In this section, we introduce the terminologies and definitions by considering ontologies whose expressivity is bound to SHIQ description logic.\nIn this paper, we use the words “reduction” and “refinement” interchangeably. In the current context, ‘Description’of an ontology entity refers to its domainspecific NL definition generated from the ontology."
    }, {
      "heading" : "4.1. Label-sets",
      "text" : "To generate descriptions of individuals in an ontology, we associate with each individual a set of constraints it satisfies. We call these sets as label-sets in general. A Label-set of an individual is called a nodelabel-set and a label-set of a pair of individuals is called an edge-label-set. The rationale behind generating these label-sets is that, since all the constraints satisfied by an individual are captured at one place, it can easily be looked up for redundancies.\nNode-label-set The node-label-set of an individual is the set which contains all the class expressions and (existential, universal and cardinality) restrictions satisfied by that individual.\nDefinition 1 The node-label-set of an individual x (represented as LO(x)) is defined as:\nLO(x) = {ci | O |= ci(x)}\nwhere ci is of the following form: ci = A | ∃R.C | ∀R.C | ≤ nR.C | ≥ nR.C Here, A is an atomic concept, C is a class expression and R is a role name in ontology O, and m and n are positive integers. C is of the following form: C = A | C1 u C2 | C1 t C2 | ∃R.C1 | ∀R.C1 | ≤ nR.C1 | ≥ nR.C1, where C1 and C2 are also class expressions.\nNote that, in the above definition, the first-level expressions (the cis) are free from disjunctions. If an individual satisfies a disjunctive clause (a set of independent expressions combined using disjunctions), satisfiability of each of these independent expressions can be checked and if found s included as conjunctions in the label-set. Clearly, the conjunction of all the elements in the label-set of an individual will be entailed by the ontology. That is, O |= ( uni=1 ci ) (x)\nAn example of the node-label-set of the individual x = tom from ACAD ontology is: LO(x) = { Student,IITStudent,IIT_MS_Student, ∃enrolledIn.IITProgramme, ≤ 1hasAdvisor. TeachingStaff, ∀hasAdvisor.TeachingStaff, ∃hasAdvisor.Professor }\nEdge-label-set The label-set of a pair of individuals (x, y) is the set that contains all the property relationships (role names) from the first individual to the second individual. It is represented as LO(x, y).\nDefinition 2 LO(x, y) is formally defined as (where NR is the set of all atomic roles in ontology O): LO(x, y) = {R | R ∈ NR ∧ O |= R(x, y)}.\nFrom ACAD ontology, the edge-label-set of the pair (tom,bob) can be written as: LO(tom,bob) = { hasAdvisor }.\nAlthough various approaches can be considered for generating label-sets, the practical method that we have adopted for generating the label-sets is explained in the next subsection."
    }, {
      "heading" : "4.2. Label-set generation technique",
      "text" : "Node-label-set generation. The naive method to find the node-label-set of an individual is by doing satisfiability check for all combinations of roles, concepts and restrictions types; and include them if they are true. Since, this is not a practically adoptable method for large ontologies, we generate the label-set of an individual x from an ontology O as follows.\nFirstly, we create the corresponding inferred ontologyO′(using a reasoner). FromO′, we find all the concept names and (existential, universal and cardinality) restrictions satisfied by the individual as follows:\nStep 1: All the concept names which are satisfied by x are obtained by a simple SPARQL query. We can call it as the seed label-set. For example, the set of concept names, which we obtained from O′, corresponding to the individual tom is { Student,IITStudent, IIT_MS_Student }.\nStep 2: In order to get the restrictions satisfied by x, we access the class definitions and class subsumption axioms corresponding to the concepts which are obtained in the first step, and then consider the existential, universal and cardinality restrictions on the right hand side of those axioms to enrich the label-set.\nThe right hand side of the axioms in their conjunctive normal form (CNF) is used for enriching the labelset. That is, the R.H.S. will be of the form: c1 u c2 u (c3tc4tc5t...tck)uck+1u...uck+n. Those clauses in the CNF which do not contain any disjunction, for examples as in c1, c2 etc. are directly included in the label-set. If a clause contains disjunction of expressions (denoted as D-Clause), such as c3tc4tc5t...tck above, then it is handled in parts, as shown in Algorithm 1.\nContinuing with our example, enrichment of the label-set of tom is done by obtaining existential, universal and cardinality restrictions associated with each of the concept names in the seed label-set. That is, the restrictions ∃enrolledIn.IITProgramme,\nAlgorithm 1 Handling disjunctions of expression 1: procedure LABEL-SET-GEN(x, D-Clause) 2: for each expression exp in D-Clause do 3: if exp is of the form ∃R.C then 4: if O |= ∃R.C(x) then 5: LO(x)← LO(x) ∪ {∃R.C} 6: end if 7: else if exp is of the form ∀R.C then 8: if O |= ∀R.C(x) then 9: LO(x)← LO(x) ∪ {∀R.C} 10: end if 11: else if exp is of the form ≤ nR.C then 12: if O |=≤ nR.C(x) then 13: LO(x)← LO(x) ∪ {≤ nR.C} 14: end if 15: else if exp is of the form ≥ nR.C then 16: if O |=≥ nR.C(x) then 17: LO(x)← LO(x) ∪ {≥ nR.C} 18: end if 19: end if 20: end for 21: end procedure\n≤ 1hasAdvisor.TeachingStaff, ∀hasAdvisor.TeachingStaff, and ∃hasAdvisor.Professor associated with concept names are included in LO(tom).\nIt should be noted that, using this approach, we are generating only those necessary restrictions which can entail the other satisfying combinations as per our label-set definition. For the same reason, we may need to rely on rule-based reasoning (explained later) to generate other restrictions which are of our interest.\nEdge-label-set Generation The edge-label-set of a pair of individuals (x, y) can be easily generated from O′ using a simple SPARQL query."
    }, {
      "heading" : "5. Proposed Method for Generating Descriptions",
      "text" : "Once we get the label-sets of all the individuals (node-label-sets) in a given ontology, we can generate descriptions of individuals and concepts using the following approaches."
    }, {
      "heading" : "5.1. Description of individuals",
      "text" : "Node-label-sets of each individuals are considered for generating their descriptions. Label-sets of all the individuals from ACAD ontology is given in Table 5.\nFor example, by looking at the node-label-set of tom, we will get the set of all restrictions (logical expressions) that are satisfied by the individual. Considering these restrictions together, we can frame a meaningful definition for tom as: “Tom is a student who is enrolled in an IIT Programme, has one professor as advisor, and all his advisors are teaching staffs.” Clearly, not all logical expressions (labels) in the label-set are necessary to generate such a description. That is, those labels that can induce redundancy in the description can be ignored or combined with other restrictions.\nAs noted earlier, some of the labels (mainly role restrictions) in the label-set if verbalized directly may generate confusing descriptions, and hence they should be reduced or combined with other restrictions to get a more refined restriction. For example, if left unrefined, the restrictions ∀hasAdvisor.TeachingStaff and ∀hasAdvisor.>may give rise to the description: “all advisors are some one and all advisors are teaching staffs”, which confuses a human reader.\nGiven a label-set, the naive method to remove redundant labels is by considering combinations of labels and trying to see whether they can be reduced or not. This is indeed a tedious process, since the total number of steps to be taken for complete reduction depends of the combination which we select at each step. To overcome this, we propose a rule-based process where labels of a specific restriction types are handled in a pre-defined order. A systematic method utilizing a set of rules which will always generate stricter (more specific) forms of a given set of restriction, is also proposed to attain complete refinement of the label-sets. Due to the aforementioned property of the rules, we call them as refinement-rules. Since we do this reduction or refinement of labels at the logical-level by considering their semantics, we call this rule-based refinement process as semantic-refinement of label-sets. The refined form of the label-set is called semanticallyrefined label-set.\nThe semantic-refinement is not only done to remove redundant labels in a label-set, but also to avoid ambiguous verbalization of interim logical expressions. For example, ∀hasAdvisor.Professor is a label which can appear in the label-set of an individual of IITStudent due to the axiom: IITStudent v ∀hasAdvisor.Professor. Linguistically this label (along with the axiom) can be interpreted in two ways. That is, either as All advisors of IIT students are teaching staffs or, by considering logical equivalent of the statement, it can be interpreted as Either all advisors of IIT students are teaching staffs or (vacuously-true\nTable 5\nNode-Label-set of individuals in ACAD ontology (intentionally omitted > class from the label-sets)\nLO(tom) = { Student, IITStudent, IIT_MS_Student, ∃enrolledIn.IITProgramme, ≤ 1hasAdvisor.TeachingStaff, ∀hasAdvisor.TeachingStaff, ∃hasAdvisor.Professor } LO(sam) = { Student, IITStudent, IITPhdStudent, ∃isEnrolledIn.IITProgramme, ≥ 2hasAdvisor.TeachingStaff, ≤ 1hasAdvisor.Professor, ∀hasAdvisor.TeachingStaff, ∃hasAdvisor.Professor } LO(bob) = { Professor, TeachingStaff } LO(alice) = { AssistantProf, TeachingStaff } LO(roy) = { Professor, TeachingStaff }\ncase) they do not have an advisor. Clearly, including the latter description in the verbalization may confuse a reader. This is especially the case when it can be inferred from other axioms that vacuously-true case does not arise.\nFor identifying the cases where combinations of conditions involving qualifiers and/or number restrictions occur and to succinctly represent them, we introduce the following new constructors.\n– Non-vacuous role restriction: =R.C =R.CI = {x ∈ ∆I |∃y.〈x, y〉 ∈ RI ∧ y ∈ CI∧ ∀z.〈x, z〉 ∈ RI =⇒ z ∈ CI} – Exactly-one role restriction: ∃=1R.C ∃=1R.CI = {x ∈ ∆I |(∃y1.〈x, y1〉 ∈ RI ∧ y1 ∈ CI∧ ∃y2.〈x, y2〉 ∈ RI ∧ y2 ∈ CI) =⇒ y1 = y2} – Exactly-n role restriction: ∃=nR.C, general case of exactly-one role restriction.\nIn our rule-based refinement process, like any rulebased approach, the order at which the rules are applied is important, as the applicability of one rule may depend on another. We observed that there is a notion of strictness associated with role restrictions which can be effectively utilized for ordering the rules. The notion of strictness can be looked at as: if a role restriction R1 is implied by another role restriction R2 (i.e., R2 =⇒ R1), then R1 can be said as a stricter version of R2. For instance, =R.U can be said as the stricter form of ∃R.U and ∀R.U . Similarly, ∃=nR.U is a sticker form of≤ nR.U and≥ nR.U . Since we intend to find sticker forms of role-restrictions, the obvious way is to apply rules corresponding to less stricter restriction types prior to those of stricter restriction types.\nIn the forthcoming sub-section, we introduce our rule-based refinement algorithm to accomplish com-\nplete reduction, where, we do all the possible reduction of less stricter restrictions prior to reducing stricter ones. Completeness of the refined form of label-set is guaranteed by the construction of the algorithm.\nIn what follows, we discuss how semantic-refinement of label-sets can be achieved."
    }, {
      "heading" : "5.1.1. Semantic-refinement of label-sets",
      "text" : "We propose seven sets of rules for refining a labelset. Each of these rule sets contain carefully chosen rules which are repeatedly applied to the restrictions in the label-set, until no more reduction is possible. On moving from one rule set to another, those labels which have been reduced would be provisionally removed from the label-set. More details about the algorithm is given in the next sub-section.\nThe details of the first five sets of rules are given in Table 6. Each of the rule sets are given names that correspond to the type of restriction they handle. For example, the first rule set is called Concept Refinement rule, where atomic concepts in the label-set are looked at for refinement. More details about the refinement rules are given below.\nConcept Refinement Rule. Here, we consider all the concept name symbols that are present in the label-sets and, check whether their definitions (i.e., the set of restrictions which defines the concept) are included in the label-set. If the defining restrictions of a concept are present in the label-set, the concept name can be removed, since it is a redundant content.\nSuperclass Refinement Rule. Consider the individuals given in Table 5, we can see that their label-sets contain all the concept names which they belong to. Some of the concepts in these label-sets are hierarchically related (in class - super-class relationship) in the ontology, resulting in redundant labels. For example, consider the label-set LO(tom), it contains the\nconcepts IIT_MS_Student and IITStudent. Since it can be inferred from the concept IIT_MS_Student that tom is also a IITStudent, we can say that IITStudent is a redundant information (label) in the label-set. We remove such redundant labels by using most-specific concept notion. Also an individual may be present in 2 or more such subsumption concept chains. In each chain we need to use the most-specific concept.\n(Note that, this refinement rule is applied only after the applications of the concept refinement rule – some specialized concepts may get removed while applying the rules in the first rule set, therefore, it does not always mean that a refined label-set contains only specialized concept names)\nThe presence of redundant concept names in a nodelabel-set is mainly because, we do a classification on the ontology prior to the label-set generation.\nThe upcoming rule sets are meant for reducing the various role restrictions allowed in a SHIQ ontology.\nExistential Role Refinement rule. According to this rule, if a label-set contains two labels of the form: ∃R.U and ∃S.U , and if they satisfy the condition: U v V&R v S, then they can be refined to ∃R.U . In general, all these rules are defined such that given a refined form and the condition which have been used for refinement, the non-refined forms of the restriction(s) can be traced back. This means that, the refinement is done without affecting the semantics/meaning of the\nrestrictions. Formally, the correctness of the rule can be proven as follows:\nProof of Rule 3a. Given an ontology O with R and S as its roles, and U and V are two of its concepts, and O|= U v V,R v S, then ∃R.U u ∃S.V ≡ ∃R.U . To prove this, let us consider an individual x ∈ ∃R.U u ∃S.V , clear it implies x ∈ ∃R.U . Therefore ∃R.U u ∃S.V v ∃R.U . Now, if x ∈ ∃R.U , it implies that there exist an arbitrary a, such that (x, a) ∈ R, a ∈ U . Since U v V , we can say that a ∈ V . It implies, x ∈ ∃S.V . Similarly, since R v S, (x, a) ∈ R =⇒ (x, a) ∈ S Therefore, ∃R.U v ∃R.U u ∃S.V .\nUniversal Role Refinement rules. This rule set contains two rules which help in refining universal role restrictions. If a label-set contains two role restrictions of the form: ∀R.U and ∀S.V , universal role refinement rules can be applied if they satisfy the conditions of the rule. For example, if the label-set contains ∀hasAdvisor.Professor and ∀hasAdvisor. TeachingStaff, and if Professor v TeachingStaff, we can refine those restrictions to ∀hasAdvisor. Professor. The correctness of the two rules can be easily be proven as follows.\nProof of Rule 4a. Given an ontology O which entails U v V and S v R (where R and S are roles, and U and V are concepts), then ∀R.U u ∀S.V ≡ ∀R.U u ∀S.U. Proving ∀R.U u ∀S.U v ∀R.U u ∀S.V is trivial since ∀S.U v ∀S.V (given, U v V ). Now, let x ∈ ∀R.U u ∀S.V , suppose (x, a) ∈ S where a is\nan arbitrary individual. Since S v R, (x, a) ∈ R. It implies a ∈ U (since x ∈ ∀R.U ). Therefore, we get x ∈ ∀S.U. Hence, ∀R.U u ∀S.V v ∀R.U u ∀S.U.\nProof of Rule 4b. Given an ontology O which entails V v U (where R is a role and, U and V are concepts), then ∀R.U u ∀R.V ≡ ∀R.V . Proving ∀R.U u ∀R.V ≡ ∀R.V is trivial, since the L.H.S. can be written as ∀R.(U u V ), and it is equivalent to ∀R.V, since V v U .\nFurther in this section, we refrain from giving the proof of correctness of the rules in the succeeding rule sets. An appendix is provided at the end of the paper with all the required proofs.\nIII & IV Combination rules. In this rule set, we refine the existential and universal role restrictions which are present in the label-set.\nThe details of the next set of rule sets are given in Table 7.\nQualified Number Restriction Refinement rules. In this set there are four rules. Here we mainly try to refine qualified number restriction restrictions (of the form ≤ nR.U or ≥ mS.V ) to stricter version of the same form or to a exactly-n restrictions.\nExactly-n Role Restriction rules. In this rule set, we reduce the exactly-n role restrictions which are generated using the preceding rule-sets. The rule set is named so because, this is the only rule set where we try to reduce exactly-n role restrictions."
    }, {
      "heading" : "5.1.2. Algorithm for semantic-refinement",
      "text" : "As we mentioned before, semantic-refinement helps in refining restrictions, which are present in a label-set, to their stricter forms by combining them using a set of\nrules. The rules are applied sequentially from rule-set 1 to 7. While applying the rules, on moving from one rule-set to another, provisional removal of reduced restrictions is done to reduce computational complexity. In our algorithm, we will mark such restrictions as PRs (Provisionally Reduced ones), so that at a later stage we can remove them permanently from the label-set.\nAlgorithm-2 describes the steps that has to be followed for applying the rules. This algorithm works by taking pairs of restrictions from the label-set, and looking for the applicability of the rules. If a rule is applicable, the restrictions will be checked for the following set of conditions, to decide whether to resume the reduction or not. These conditions are followed mainly to ensure quick reduction.\nCondition-1. No need to further reduce two provisionally reduced (PR) restrictions. (This is because, the rule-sets are designed in such a way that if a particular combination of restriction types is reduced by a rule in one rule-set, the same combination will not occur in the succeeding rule-sets)\nCondition-2. If a rule combines two restrictions (R1 andR2) and generates eitherR1 orR2, then thatR1 or R2 should not be marked as a PR. ( This is because, in the rules such as 4a, 5c, 6a etc., one of their antecedent term gets repeated in the consequent part of the rule to ensure reverse implication (i.e., for preserving semantics). On applying such rules, if the regenerated terms are marked as PR, they may get permanently removed during the course of the algorithm, which is not acceptable.)\nCondition-3. If the restrictions of a particular form are not used in successive rule-sets, the PR restrictions of that form can be removed. (Either they can be removed after the applications of rules in all the rule-sets\nAlgorithm 2 Semantic-refinement of label-sets 1: procedure SEMANTIC_REFINEMENT(LO(x)) 2: Mark all u ∈ LO(x) as not PRs 3: Apply Concept Refinement rule and remove\nappropriate concept names from LO(x) 4: R← Rule-sets 2-7 . list of pre-defined rules 5: for each rule-set rs ∈ R do 6: Set M,REF ← φ 7: for each (u, v) ∈ LO(x)× LO(x) AND u 6= v do 8: if (NOT(MARKED_AS_PR(u)) AND NOT(MARKED_AS_PR(v))) then 9: for each (r ∈ rs) do 10: if r is applicable on (u, v) then 11: M ← APPLY_RULE(r, u, v) 12: LO(x)←LO(x) ∪M 13: REF ← REF ∪ {u,v} 14: if u ∈M then 15: REF ← REF\\{u} 16: end if 17: if v ∈M then 18: REF ← REF\\{v} 19: end if 20: end if 21: end for 22: end if 23: end for 24: MARK_AS_PR(REF ) 25: LO(x)←LO(x) ∪ REF 26: for each u ∈LO(x) do 27: if the restn. type of u is not used in the successive rule-sets AND MARKED_AS_PR(u) then 28: LO(x)←LO(x)\\{u} 29: end if 30: end for 31: end for 32: end procedure\nor they can be removed at specific points where it can be determined that they will not be used by any rules from then on. The latter is computationally efficient)\nFor illustration, let us consider the node-label-set of the individual sam. Fig 1 shows the refinement steps and the rules in the rule sets which are used for the refinement.LO(sam) is represented vertically. In the figure, the arrows represent the application of rules. Rule numbers are represented in italics. A refinement of two restrictions may sometimes result in more than one restrictions, to represent them, the arrows are followed by brace brackets ({...}) to show the resultant restrictions.\nInitially, the algorithm marks all the labels in the label-set as not PR. Then the algorithm looks for the applicability of the rule 1a (concept refinement rule). In the figure, LO(sam) contains the labels IITStudent and IITPhdStudent whose definitions are present in the label-set. Therefore, the Rule 1a is applied on those labels and remove them from the label-set. In the algorithm, lines 5-31 take the rest of the rule-set one at a time, and look for possible application of rules on pairs of restrictions in the label-set. In our example label-set, since no rules in the rule-sets 2,3, and 4 are applicable, we move to the rule set 5. Now, the algorithm applies the rule 5c on two of the restrictions as shown in the figure and refine them to the two restrictions given in the brackets. Application of a rule will be done only if the restrictions in the pair are not marked as PR (checked using the function MARKED_AS_PR(.)). The if condition in the line-8 of the algorithm will take care of this. After the application of a rule (using the function APPLY_RULE(.)), the details of the reduced restrictions will be stored in the set variable REF . Based on the condition-2, ap-\npropriate changes have to be done on the contents of REF (lines 14-20). Once all the possible rules in a particular rule set are applied, the reduced restrictions will be marked as PRs (lines 24). Once the algorithm considers all pairs of labels and checks them for the applicability of all the rules in the current rule-set, the condition-3 will be checked for possible permanent removal of the PRs. The entire process will be repeated for all the succeeding rule-sets.\nComing back to our example label-set, after the application of Rule 5c, one of the reduced restriction is marked as PR (represented using √ ), while the other restriction is not marked as PR due to the condition-2. On changing the rule-set, since no other rules in ruleset 5 are applicable, the one which is marked as PR can be permanently removed since the condition-3 is satisfied. In the forthcoming iterations of the for loop (line 5), rules in the rule-set 6 and 7 are applied in similar fashion. In the last iteration, we will get the most refined set of labels, along with a set of restrictions which are marked as PRs. The restrictions which are marked as PRs are removed to get the refined label-set.\nIllustration of the usefulness of the approach. The usefulness of semantic refinement can be illustrated by looking at the sentences that can be generated from the node-label-set before and after refinement. Considering the original node-label-set, sam can be defined as “A student, an IIT student, an IIT PhD student, who is enrolled in an IIT programme, has more than two advisors who is a teaching staff, has less than one and at least one advisor who is a professor, and all advisors are teaching staff ”. By making use of the refined node-label-set, we can generate a smaller and easilyunderstandable definition: “A student who is enrolled in an IIT programme, has exactly one advisor who is a professor and has at least one more advisor who is a teaching staff but not a professor”. More examples and evaluation results to support the usefulness of this approach are presented in Section 7."
    }, {
      "heading" : "5.2. Description of Concepts",
      "text" : "A concept can be defined in a similar fashion as that of an individual using label-sets. To generate the description of a concept, we introduce a new individual as its member. It is important that the new individual should be assigned as the member of only the concept whose definition has to be found. Now, label-set corresponding to this newly introduced individual is utilized to generated the concept’s definition. The rationale be-\nhind introducing a new individual is that, in order to find the definition of a concept (say Concept A), we only need restrictions which are associated with it and its super-classes. Considering an existing individual may result in a case where it may belong to concepts which are sub-classes of the concept A; this results in including the restrictions associated with the specificclasses also in the label-set, which is undesirable. Introducing a new individual will overcome this issue; in addition, the approach will even work smoothly for those concepts which do not have an individual.\nLet us look at an illustration of generating definition of IITPhdStudent from ACAD ontology. At first, we introduce the individual ips as a member of IITPhdStudent. Now we will find the label-set of ips.\nWe get LO(ips) as {Student, IITStudent, IITPhdStudent, ∃isEnrolledIn.IITProgramme, ≥ 2 hasAdvisor.TeachingStaff, ≤ 1 hasAdvisor.Professor, ∀hasAdvisor. TeachingStaff, ∃hasAdvisor.Professor }\nIn the next step, we remove the concept name, whose definition has to be found, from the obtained label-set. That is, LO(ips)\\{IITPhdStudent}. This new label-set is semantically-refined and verbalized to get the redundant-free description of the concept.\nTherefore, IITPhdStudent can be defined as: { Student, ∃isEnrolledIn.IITProgramme, ∃=1hasAdvisor.Professor, =hasAdvisor. TeachingStaff, ≥ 1hasAdvisor.(TeachingStaff u¬Professor)}\nEven though this approach works well for those concepts whose (axiomatized) definitions contain only conjunctive clauses, it may generate incomplete descriptions when the definition contains a disjunctive clause. For example, if the definition of the concept IITStudent is of the form IITStudent ≡\n∃isEnrolledIn.IITProgramme u(IITPhdStudent t IIT_MS_Student), the label-set of a newly introduced individual of IITStudent (say, stud) should be {IITPhdStudent t IIT_MS_Student, ∃isEnrolledIn.IITProgramme}. However, our current label-set generation method will not include disjunctive clauses as such in the label-set, instead it will look for the satisfiability of each of the expression in the disjunctive clause (that is, IITPhdStudent(stud) and IIT_MS_Student(stud)), and include them in the label-set, if they are true. But, for stud, they will not be true as we are not explicitly adding any other facts into the ontology other than IITStudent(stud). Therefore, we will get the label-set as {IITStudent, ∃isEnrolledIn.IITProgramme} which is an incomplete label-set of the concept. On doing the next steps – removing the concept name itself from the label-set, and doing a semantic-refinement over it – the incompleteness persists. To overcome issue, after semantic refinement step, we will enrich the refined label-set with the previously encountered disjunctive clause(s). That is, we get the new refined label-set of stud as {IITPhdStudent t IIT_MS_Student, ∃isEnrolledIn.IITProgramme}."
    }, {
      "heading" : "6. Natural Language Descriptions from the Refined Label-sets",
      "text" : "In this paper, prime focus is given for the generation of redundancy-free descriptions of ontology entities represented in the form of logical expressions. Appropriate NL sentence generation of these logical forms is yet to be fully explored. However, for the completeness of the paper, we present a simple method which we have adopted to generate NL descriptions of individuals and concepts from their refined label-sets.\nNL description of an entity is defined as the set of NL fragments which describes the class names and\nrole restrictions it satisfies. An example of a description of tom is:\ntom: is a student, enrolled in at least one IIT programme, and has exactly one professor as advisor\nWe consider a template similar to the following regular expression (abbreviated as regex) for generating descriptions of individuals and concepts. Individual/concept: (“is”) ( (“a”) ClassName\n(“,” | “and”)? )+ ( RoleRestriction (“,” | “and”)? )+\nIn the above regex, ClassName specifies the concept names in the label-set. We use the rdfs:label role values of the class names as the ClassName. If rdfs:label role is not available, the local names of the URIs are used as the ClassName. For RoleRestriction, the role restrictions in the label-set are utilized. The role restrictions are treated in parts. We first tokenize the role names in the constraints. Tokenizing includes word-segmentation and processing of camel-case, underscores, spaces, punctuations etc. Then, we identify and tag the verbs4 and nouns in the segmented phase — as R-verb, R-noun respectively — using the Natural Language Tool Kit5. We then incorporate these segmented words in a constraintspecific template, to form a RoleRestriction. For instance, the restriction ∃hasAdvisor.Professor is verbalized to “has at least 1 professor as advisor”, using the template: <R-verb> at least <n><C> as <R-noun> (where C corresponds to the concept present in the restriction). Constraint-specific templates corresponding to the possible restrictions in a label-set are listed in Table-8. In our studies, we have also tried out variants of these constraint-specific templates to further tune\n4In the absence of a proper verb, the phrase “related to” is used in its place.\n5Python NLTK: http://www.nltk.org/\nthe NL output. Since the empirical study (see the next section) is done for a different intention, involving only a carefully chosen participants, we refrain from further enhancing the fluency of the NL texts.\nIf the C equivalent portion of the restriction is not a concept name (atomic concept), that is, if it a conjunction or disjunction of restrictions, Table 8 will be recursively looked up for possible templates, and the conjunctions and disjunctions will be replaced with ‘and’and ‘or’ respectively.\nWhen it comes to generating concept definitions, we can expect clauses containing disjunctions (independent expressions combined using disjunctions) in the refined label-set. They are handled in parts by taking\neach of those independent expressions in the clause separately for NL generation, and, they are then combined using ‘or’."
    }, {
      "heading" : "7. Empirical Evaluation",
      "text" : "We present two case studies to explore the applicability of the redundancy-free description of individuals and concepts in validating the domain knowledge. Rather than choosing an ontology under development, we study the cases of validating two previously built ontologies.\nIn the study, domain experts were presented with two representations of the same knowledge: one is by\ndirect verbalization of the label-sets and the other is by verbalizing them after finding the corresponding refined label-sets. Direct verbalization of a label-set generates texts (or descriptions) which are similar to those texts which are produced by an existing ontology verbalizer — we call this method as traditional approach, and the other as the proposed approach. Examples for the description texts that are generated using the proposed approach and traditional approach, from the Plant Disease (PD) ontology6, HarryPotter (HP) ontology7 and Geographical Entity8 (GEO) ontologies are given in Table 10. One can clearly see that those descriptions which are generated using the proposed approach are compact, precise and easy-to-understand when compared to those which are generated using the traditional approach.\nScope of the study. We have done the empirical study mainly for two reasons. Firstly, for finding whether the process of semantic-refinement is helpful in generating useful texts for describing the ontology. For this purpose, the experts were asked to rate their degree of understanding of the knowledge in the scale: (1) poor; (2) medium; (3) Good.\nSecondly, to measure the usefulness of the generated sentences (i.e., the descriptions of individuals and concepts) in validating the domain knowledge, domain experts were told to choose from the options: (1) Valid (2) Invalid (3) Don’t know (4) Cannot be determined. Significance of these options is that, if a participant is choosing the 4th option, it is likely that she finds it difficult to reach a conclusion on the validity of the sentence presented. In addition, feedbacks are collected from the experts to get suggestions on improving the system.\nDataset used. We used two ontologies for generating descriptions. The first ontology is Plant-Disease ontology (PD ontology) developed by International Center of Agricultural Research in the Dry Areas (ICARDA), and the second one is a synthetic ontology, Data structures and Algorithms (DSA) ontology, developed by ORG group9 at IIT Madras10. More details about these ontologies are available at our project website11. The\n6http://wiki.plantontology.org/index.php/Plant_Disease_Ontology 7https://sites.google.com/site/ontoworks/ontologies 8https://bitbucket.org/uamsdbmi/geographical-entity-\nontology/src (last accessed: 27/11/2015) 9https://sites.google.com/site/ontoworks/home 10https://www.iitm.ac.in/ 11https://sites.google.com/site/ontoworks/projects\ncurrent version of PD ontology has 546 individuals, 105 concepts and 15 object properties. The DSA ontology has 333 individuals, 23 concepts, 33 object properties and 21 datatype properties.\nExperimental setup. For each of the individuals and concepts in the two ontologies we have generated corresponding NL descriptions from their node label-sets as well as from their refined label-sets, using an implemented prototype of the system. Since manual evaluation of all the generated descriptions is difficult, a selected number of descriptions were utilized for the study. The set of descriptions of individuals for the study were selected by grouping the entire descriptions based on their label-sets and randomly choosing one individual’s description from each group. The set of descriptions of concepts were selected from those set of descriptions (generated from refined label-sets) which are highly different from their counterparts that are generated from their non-refined label-sets. From PD ontology, 31 descriptions of individuals and 10 descriptions of concepts have been considered for evaluation. Similarly, for DSA ontology, 14 descriptions of individuals and 17 descriptions of concepts were chosen for evaluation. Then, experts of the two domains were asked to review the verbalized descriptions. Majority ratings of the sentences were considered for finding the statistics.\nExpert selection. Seven experts of plant disease areas and fourteen experts of data structures and algorithms were involved in the study. The seven experts of PD domain have either a masters degree or a doctorate degree in the plant disease or agriculture related areas. The fourteen experts of DSA domain have successfully completed the advanced data structures and algorithms course offered at IIT Madras."
    }, {
      "heading" : "7.1. Results and Discussions",
      "text" : "Fig 2-5 show the statistics w.r.t. the ratings given by the domain experts. Based on these statistics, we have answered the following two questions."
    }, {
      "heading" : "7.1.1. How does the semantic refinement help in improving the understandability of the verbalized knowledge?",
      "text" : "The degree of understanding of each of these descriptions to the domain experts can be identified by looking at the ratings (i.e., poor, medium or good) which they had chosen during the empirical study. If there exists an ambiguity in the description (due to\nits verbatim fidelity to OWL statements), they are expected to choose poor or medium as the level of understanding. To confine the reasons for ambiguity to the fidelity to OWL constructs alone, possible (manual) grammatical error corrections had been done on the generated text — as we were not using any sophisticated NL generation techniques. Grammatical errors such as subject-verb agreement errors, verb tense errors, verb form errors, singular/plural noun ending errors and sentence structure errors had been corrected.\nFig 2 shows the overall responses which we received from the seven domain experts for the descriptions of PD ontology. We call it as the overall response because, ratings are calculated by looking at the majority responses; that is, only if a description is rated as ‘good’ by at least 4 participants, it will be considered as a good description; similar is the case with poor and medium ratings. The dotted-bars represent the count of the descriptions of a particular rating which are generated using the proposed approach and the strippedbars denote the count of those which are generated us-\ning the traditional approach. Similarly, Fig 3 shows the statistics of the responses received for DSA ontology. For PD ontology, out of 41 descriptions which are generated using the proposed approach, 34 were rated as ‘good’, whereas for those which are generated using the traditional approach, only 6 out of 41 texts were rated as ‘good’. For DSA ontology, 24 out of 31 descriptions generated by proposed approach are ‘good’, only 11 descriptions that are generated using the traditional approach were rated as ‘good’. These results highlight the significance of the semantic-refinement process in domain knowledge understanding."
    }, {
      "heading" : "7.1.2. How does the semantic refinement helpful in knowledge validation?",
      "text" : "Fig 4 and 5 show the statistics to determine the usefulness of the generated descriptions in validating the two domain ontologies, where, as before, the dotted-bars represent the ratings of the descriptions that are generated from the proposed approach and the stripped-bars denote rating of the descriptions gener-\nated by the traditional approach. Usefulness of the generated descriptions in validating an ontology are obtained by looking at the number of descriptions which are marked as ‘Cannot be determined’. The three options: Valid, Invalid and Don’t know, imply that the text is useful in getting into a conclusion, whereas the option ‘Cannot be determined’indicates that there is some problem in the representation. From Fig 4 and Fig 5, in case of the proposed approach, only 7 out of 41 descriptions from PD ontology and 4 out of 31 descriptions from DSA ontology were not useful in determining the quality of the ontology, whereas in case of the traditional approach, approximately 50 percentage of the descriptions were not helpful. This clearly indicates that, verbalization after semantic-refinement is more effective in applications such as ontology validation."
    }, {
      "heading" : "7.1.3. Discussion",
      "text" : "The participants of our empirical study agree with the fact that, by reducing the redundancies in a description, the amount of time required for validating an individual description is reduced to a great extent.\nValidation of an ontology also involves verifying the truthfulness of the property relationships in it, which is not addressed in this paper. This issue can be addressed in future by making use of the edge-labelsets (label-sets for pairs of individuals – see Section 4.1), and mapping them to the respective constraint(s) in the node-label-set of the first individual. For e.g., LO(a) = {C1, C2,∃hasFriend.C3}, and LO(a, b) = {hasFriend}, then hasFriend in LO(a, b) can be mapped to ∃hasFriend.C3 inLO(a). The description of a can be generated as “a: is a C1 and C2, and has some C3, like b, as Friend.” Further investigation has to be done in this direction.\nAccording to the domain experts, a persisting problem with any validation phase (especially when it involves descriptions ontology entities and experts validating the verbalized knowledge) is that, when the ontology becomes very large and complex, validation phase becomes a bottleneck for the entire development cycle. One way to overcome this issue is by considering only a relevant subset of individuals and concepts and their descriptions for validity check, so that, a rough estimate of the erroneous formalisms in the ontology can be identified quickly. Another direction of future work is a study on the order at which the descriptions are to be presented to an expert so that an early detection of invalid knowledge can be made possible."
    }, {
      "heading" : "8. Conclusion",
      "text" : "A novel method for verbalizing the definitions (called natural language descriptions) of ontology entities is presented in the paper. The descriptions are not merely verbatim translations of logical axioms of the ontology. Instead, they are generated from the set of logical restrictions satisfied by individuals and concepts of the ontology on which semantic simplification had been carried out. We propose a rule-based reduction approach for this purpose. We find that the proposed method indeed gives redundancy-free descriptions of individuals and concepts.\nOur empirical studies based on two ontologies have shown that the redundancy-free description of the domain knowledge is helpful in understanding the formalized knowledge more effectively and also useful in validating them."
    }, {
      "heading" : "Acknowledgements",
      "text" : "This project is funded by Ministry of Human Resource Development, Gov. of India. We express our fullest gratitude to the participants of our evaluation process: Dr. S.Gnanasambadan (Director of Plant Protection, Quarantine & Storage), Ministry of Agriculture, Gov. of India; Mr. J. Delince and Mr. J. M. Samraj, Department of Social Sciences AC & RI, Killikulam, Tamil Nadu, India; Ms. Deepthi.S (Deputy Manager), Vegetable and Fruit Promotion Council Keralam (VFPCK), Kerala, India; Dr. K.Sreekumar (Professor) and students, College of Agriculture, Vellayani, Trivandrum, Kerala, India. We also thank all the undergraduate and post-graduate students of Indian Institute of Technology, Madras, who have participated in the empirical study."
    }, {
      "heading" : "Appendix A",
      "text" : "Proofs for the rules in the rule-sets 5 to 7\nHere we use proof-by-contradiction as the proof method. Given a rule of the form P ≡ Q, we prove P v Q u Q v P, by negating it and proving (P u ¬Q) t (Q u ¬P ) as false.\nConsider that all the following rules are defined on an ontology O with R and S as its roles, and U and V are two of its concepts.\nRule 5a: Given the ontology O, ∃R.U u ∀R.U ≡ =R.U . The proof is trivial, and can be easily derived from the definition of =R.U .\nRule 5b: IfO |= UvV, SvR, then for ∀R.U u ∃S.V ≡ =R.U u =S.U.\nAssume that ∀R.U u ∃S.V u ¬(=R.U u =S.U) is true. We can write it as: ∀R.U u ∃S.V u ¬((∃R.U u ∀R.U)u(∃S.Uu∀S.U))≡∀R.U u ∃S.V u (∀R.¬Ut\n∃R.¬Ut∀S.¬Ut∃S.¬U) =⇒ ∀R.U u ∀S.U u ∃S.V u (∀R.¬U t ∃R.¬U t ∀S.¬U t ∃S.¬U) (since S v R,∀R.U =⇒ ∀S.U )≡ ∀R.U u ∀S.U u ∃S.V u (∀R.¬U t ∃R.¬U t ∀S.¬U t ∃S.¬U) ≡ (∀R.U u ∀S.U u ∃S.V u ∀R.¬U)t(∀R.U u ∀S.U u ∃S.V u ∃R.¬U) t(∀R.U u ∀S.U u ∃S.V u ∀S.¬U) t (∀R.U u ∀S.U u ∃S.V u ∃S.¬U), contradiction.\nNow, assume that (∃R.U u∀R.U u∃S.U u∀S.U)u ¬(∀R.U u ∃S.V ) is true. ≡ ∃R.U u∀R.U u∃S.U u ∀S.U u (∃R.¬U t ∀S.¬V ) ≡ (∃R.U u ∀R.U u ∃S.U u∀S.U u∃R.¬U) t (∃R.U u∀R.U u∃S.U u ∀S.U u ∀S.¬V ) ≡ (∃R.U u ∀R.U u ∃S.U u ∀S.U u ∃R.¬U) t (∃R.U u∀R.U u∃S.U u∀S.U u∀S.¬V u ∀S.¬U ), (Since, U v V,) contradiction.\nRule 5c: IfO |= V vU, SvR, then for ∀R.U u ∃S.V ≡ =R.U u ∃S.V.\nAssume that ∀R.U u ∃S.V u ¬(=R.U u ∃S.V ) is true. We can write it as: ≡ ∀R.U u ∃S.V u ¬(∃R.U u ∀R.U u ∃S.V ) (by the deftn. of =R.U ) ≡ ∀R.U u ∃S.V u (∀R.¬U t ∃R.¬U t ∀S.¬V ) ≡ ∀R.U u ∃S.V u ∀R.¬Ut∀R.U u ∃S.V u ∃R.¬Ut ∀R.U u ∃S.V u ∀S.¬V.\nNow, assume that (=R.Uu∃S.V )u¬(∀R.U u ∃S.V ) is true.≡ ∀R.U u∃R.U u∃S.V u (∃R.¬U t∀S.¬V ) ≡ ∀R.U u∃R.U u∃S.V u∃R.¬U t∀R.U u∃R.U u ∃S.V u ∀S.¬V.\nRule 6a: If O |= U v V,R v S, then for n ≥ m, ≥nR.U u ≥mS.V ≡≥nR.U.\nAssume that, ≥nR.U u ≥ mS.V u ¬(≥ nR.U) is true. We can write it as: ≥nR.U u ≥ mS.V u ≤(n− 1)R.U, Contradiction.\nNow assume that,≥nR.U u ¬(≥nR.U u ≥mS.V ) is true. We can write it as: ≥nR.U u (≤(n− 1)R.U t ≤ (m − 1)S.V ) ≡ (≥nR.U u ≤(n− 1)R.U) t (≥nR.U u ≤(m− 1)S.V ), contradiction. In the second conjunctive clause ≥ nR.U =⇒ ≥ nS.V (since U v V&R v S) , for n ≥ m, ≥ nR.U u ≤(m− 1)S.V is a contradiction.\nRule 6b: If O |= V v U, S v R, then for n ≥ 1, ∃R.U u ≥nS.V ≡≥nS.V.\nAssume that, n ≥ 1, ∃R.U u ≥ nS.V u ¬(≥ nS.V ) is true. We can write it as: ∃R.U u ≥nS.V u ≤(n− 1)S.V , contradiction.\nNow, assume that ≥ nS.V u ¬(∃R.U u ≥ nS.V ) is true. We can write it as: ≥ nS.V u (∀R.¬U t ≤ (n − 1)S.V ) ≡ (≥nS.V u ∀R.¬U) t (≥nS.V u\n≤(n− 1)S.V ), contradiction. The contradiction in the first conjunctive expression is because: ≥ nS.V =⇒ ∃S.V =⇒ ∃R.U which contradicts with ∀R.¬U.\nRule 6c: If O |= U v V , then for n = 1, ∃R.U u ≤ nR.V ≡ ∃=1R.U u ∃=1R.V.\nAssume that, ∃R.U u ≤ nR.V u ¬(∃=1R.U u ∃=1R.V ) is true. We can write it as: ∃R.U u ≤ nR.V u ¬(∃R.Uu ≤ 1R.U u ∃=1R.V ) ≡ (∃R.U u ≤1R.V u ∀R.¬U)t (∃R.U u ≤1R.V u≥ 2R.U)t (∃R.U u ≤ 1R.V u ¬∃=1R.V ), contradiction. The second conjunctive clause is a contradiction because: ≤ 1R.V =⇒ ≤ 1R.U (since U v V ), which contradicts with≥ 2R.U. In the third conjunctive expression, ∃R.U =⇒ ∃R.V , now, ¬(∃=1R.V ) u ∃R.V =⇒ ≥ 2R.V, which contradicts with ≤ 1R.V.\nNow, assume that ∃=1R.Uu∃=1R.V u¬(∃R.U u ≤ 1R.V ) is true. We can write it as: ∃=1R.Uu∃=1R.V u (∀R.¬U t ≥ 2R.V ) ≡ (∃=1R.U u ∃=1R.V u ∀R.¬U)t (∃=1R.U u∃=1R.V u≥2R.V ), contradiction.\nRule 6d: If O |= UvV,RvS, then for a whole number n, ≥ nR.U u ≤nS.V ≡ ∃=nR.U u ∃=nS.V.\nAssume that, ≥ nR.U u ≤nS.V u ¬(∃=nR.U u ∃=nS.V ) is true. We can write it as: ≥ nR.U u ≤ nS.V u ¬(≤ nR.Uu ≥ nR.Uu ≤ nS.V u ≥ nS.V ) ≡ ≥ nR.U u ≤ nS.V u (≥ (n + 1)R.Ut ≤ (n − 1)R.Ut ≥ (n + 1)S.V t ≤ (n − 1)S.V ) ≡ (≥ nR.U u ≤ nS.V u ≥ (n+ 1)R.U) t (≥ nR.U u ≤nS.V u ≤ (n− 1)R.U) t (≥ nR.U u ≤nS.V u≥ (n+ 1)S.V )t(≥ nR.U u ≤ nS.V u ≤ (n− 1)S.V ), contradiction. In the third conjunctive expression, ≥ nR.U u ≤ nS.V =⇒ ∃=nS.V, which contradicts with ≥ (n+ 1)S.U.\nNow, assume that ∃=nR.U u ∃=nS.V u ¬(≥ nR.U u ≤ nS.V ) is true. We can write it as: ≤ R.U u ≥ nR.Uu ≤ nS.V u nS.V u (≤ (n− 1)R.U t≥ (n+ 1)S.V ) ≡ (≤ R.U u ≥ nR.U u ≤ nS.V u nS.V u ≤ (n− 1)R.U) t(≤ R.Uu ≥ nR.U u ≤ nS.V u nS.V u ≥ (n+ 1)S.V ), contradiction.\nRule 7a: If O|= U v V,R v S, then ∃R.U u ∃=1S.V ≡ ∃=1R.U u ∃=1S.V.\nAssume that, ∃R.U u ∃=1S.V u ¬(∃=1R.U u ∃=1S.V ) is true. That is, ∃R.Uu ≤ 1S.V u ≥ 1S.V u (≥ 2R.Ut ≤ 0R.Ut ≥ 2S.V t ≥ 0S.V ) ≡ (∃R.U u∃=1S.V u≥ 2R.U)t (∃R.U u∃=1S.V u ≤ 0R.U)t (∃R.U u ∃=1S.V u ≥ 2S.V )t (∃R.U u\n∃=1S.V u ≤ 0S.V ), Contradiction. The contradiction in the first clause is because: since U v V&R v S;≥ 2R.U =⇒ ≥ 2S.V ; ≥ 2S.V contradicts with ∃=1S.V.\nNow assume that ∃=1R.U u ∃=1S.V u ¬(∃R.U u ∃=1S.V ) is true. We can write it as: ∃=1R.U u ∃=1S.V u (∀R.¬U t ¬(∃=1S.V )) ≡ (∃=1R.U u ∃=1S.V u∀R.¬U)t(∃=1R.Uu∃=1S.V u¬(∃=1S.V )), Contradiction.\nRule 7b: If O|= U v V,R v S, then =R.U u ∃=1S.V ≡ ∃=1R.U u ∃=1S.V u =R.U.\nAssume that, =R.U u ∃=1S.V u ¬(∃=1R.U u ∃=1S.V u =R.U) is true. ≡ ∃R.U u ∀R.U u ∃=1S.V u (¬(∃=1R.U) t ¬(∃=1S.V )t¬(=R.U))≡ (∃R.Uu∀R.Uu∃=1S.V u ¬(∃=1R.U))t(∃R.Uu∀R.Uu∃=1S.V u¬(∃=1S.V ))t (∃R.U u ∀R.U u ∃=1S.V u ¬(=R.U))), Contradiction. The contradiction in the first conjunctive clause is because: given x ∈ ∃R.U u ¬(∃=1R.U), it implies x ∈≥ 1R.U =⇒ x ∈≥ 1S.V (since R v S and U v V ) which contradicts with ∃=1S.V . In the third conjunctive clause, ¬(=R.U) ≡ ¬(∀R.U u ∃R.U) ≡ ∃R.¬U t ∀R.¬U , both these cases contradict with ∃R.U u ∀R.U .\nNow assume that, ∃=1R.U u ∃=1S.V u =R.U u ¬(=R.U u ∃=1S.V ) is true. ≡ ∃=1R.U u∃=1S.V u=R.U u¬(∀R.U u∃R.U u ∃=1S.V )≡ (∃=1R.U u∃=1S.V u=R.U u∃R.¬U)t (∃=1R.U u∃=1S.V u=R.U u∀R.¬U)t (∃=1R.U u ∃=1S.V u =R.U u ¬(∃=1S.V )), Contradiction.\nRule 7c: If O|= U v V , then ∃=nR.U u ≥ mR.V ≡ ∃=nR.U u ≥ (m− n)R.(V t ¬U) for m ≥ n.\nAssuming that ∃=nR.U u ≥ mR.V u ¬(∃=nR.U u ≥ (m− n)R.(V t ¬U)) is true. ≡ ∃=nR.U u ≥ mR.V u ¬(≤ nR.U u ≥ nR.U u ≥ (m− n)R.(V t ¬U)) ≡ ∃=nR.U u ≥ mR.V u (≥ (n + 1)R.U t ≤ (n− 1)R.U t ≤ (m− n− 1)R.(V t ¬U)) ≡ ∃=nR.U u ≥ mR.V u ≥ (n+ 1)R.U t ∃=nR.U u ≥ mR.V u ≤ (n− 1)R.U t ∃=nR.U u ≥ mR.V u ≤ (m − n − 1)R.(V t ¬U) The contradictions in the first two conjunctive clauses are trivial, in the third clause, ∃=nR.U u ≥ mR.V implies≥ (m−n)R.(V t¬U) which contradicts with ≤ (m− n− 1)R.(V t ¬U).\nNow, assume that, ∃=nR.U u ≥ (m − n)R.(V t ¬U) u ¬(∃=nR.U u ≥ mR.V ) is true.\n≡ ∃=nR.U u ≥ (m−n)R.(V t¬U)u (¬(∃=nR.U) t ≤ m− 1R.V ) ≡ (∃=nR.U u ≥ (m−n)R.(V t¬U)u¬(∃=nR.U))t (∃=nR.U u ≥ (m− n)R.(V t ¬U) u ≤ (m− 1)R.V ) In the second conjunctive clause, contradiction can be found as follows: an x ∈≥ (m − n)R.(V t ¬U)\nimplies x has more than m−n R relations to ¬U uV , since x ∈ ∃=nR.U, we can say that x has more than m − n + n R relations to V, which can be written as x ∈≥ mR.V . Clearly, this contradicts with ≤ (m − 1)R.V ."
    } ],
    "references" : [ {
      "title" : "Generating natural language descriptions from OWL ontologies: the naturalowl system",
      "author" : [ "Ion Androutsopoulos", "Gerasimos Lampouras", "Dimitrios Galanis" ],
      "venue" : "CoRR, abs/1405.6164,",
      "citeRegEx" : "1",
      "shortCiteRegEx" : "1",
      "year" : 2014
    }, {
      "title" : "The description logic handbook: theory, implementation, and applications",
      "author" : [ "Franz Baader", "Diego Calvanese", "Deborah L. McGuinness", "Daniele Nardi", "Peter F. Patel-Schneider", "editors" ],
      "venue" : null,
      "citeRegEx" : "2",
      "shortCiteRegEx" : "2",
      "year" : 2003
    }, {
      "title" : "Sydney owl syntax - towards a controlled natural language syntax for owl 1.1",
      "author" : [ "Anne Cregan", "Rolf Schwitter", "Thomas Meyer" ],
      "venue" : "CEUR Workshop Proceedings. CEUR-WS.org,",
      "citeRegEx" : "3",
      "shortCiteRegEx" : "3",
      "year" : 2007
    }, {
      "title" : "Lege feliciter: Using structured english to represent a topographic hydrology ontology",
      "author" : [ "Glen Hart", "Catherine Dolbear", "John Goodwin" ],
      "venue" : "CEUR Workshop Proceedings. CEUR-WS.org,",
      "citeRegEx" : "4",
      "shortCiteRegEx" : "4",
      "year" : 2007
    }, {
      "title" : "Effective nl paraphrasing of ontologies on the semantic web",
      "author" : [ "Daniel Hewlett", "Aditya Kalyanpur", "Vladimir Kolovski", "Christian Halaschek-wiener" ],
      "venue" : "In End User Semantic Web Interaction Workshop",
      "citeRegEx" : "5",
      "shortCiteRegEx" : "5",
      "year" : 2015
    }, {
      "title" : "Reasoning with individuals for the description logic shiq",
      "author" : [ "Ian Horrocks", "Ulrike Sattler", "Stephan Tobies" ],
      "venue" : "CoRR, cs.LO/0005017,",
      "citeRegEx" : "6",
      "shortCiteRegEx" : "6",
      "year" : 2000
    }, {
      "title" : "Multilingual verbalization of orm conceptual models and axiomatized ontologies",
      "author" : [ "Mustafa Jarrar", "C. Maria", "Keet Paolo Dongilli" ],
      "venue" : "Technical report,",
      "citeRegEx" : "7",
      "shortCiteRegEx" : "7",
      "year" : 2006
    }, {
      "title" : "Attempto Controlled English as a Semantic Web Language",
      "author" : [ "Kaarel Kaljurand" ],
      "venue" : "PhD thesis, Faculty of Mathematics and Computer Science, University of Tartu,",
      "citeRegEx" : "8",
      "shortCiteRegEx" : "8",
      "year" : 2007
    }, {
      "title" : "Verbalizing owl in attempto controlled english",
      "author" : [ "Kaarel Kaljurand", "Norbert E Fuchs" ],
      "venue" : "In OWLED,",
      "citeRegEx" : "9",
      "shortCiteRegEx" : "9",
      "year" : 2007
    }, {
      "title" : "Attributive concept descriptions with complements",
      "author" : [ "M. Schmidt-Schau", "G. Smolka" ],
      "venue" : "Artificial Intelligence,",
      "citeRegEx" : "10",
      "shortCiteRegEx" : "10",
      "year" : 1991
    }, {
      "title" : "Automating generation of textual class definitions from owl to english",
      "author" : [ "Robert Stevens", "James Malone", "Sandra Williams", "Richard Power", "Allan Third" ],
      "venue" : "J. Biomedical Semantics,",
      "citeRegEx" : "11",
      "shortCiteRegEx" : "11",
      "year" : 2011
    } ],
    "referenceMentions" : [ {
      "referenceID" : 8,
      "context" : "Ontology verbalizers and ontology authoring tools such as ACE [9], NaturalOWL [1] and SWAT Tools [12], can be utilized for generating controlled natural language (CNL) descriptions of OWL statements.",
      "startOffset" : 62,
      "endOffset" : 65
    }, {
      "referenceID" : 0,
      "context" : "Ontology verbalizers and ontology authoring tools such as ACE [9], NaturalOWL [1] and SWAT Tools [12], can be utilized for generating controlled natural language (CNL) descriptions of OWL statements.",
      "startOffset" : 78,
      "endOffset" : 81
    }, {
      "referenceID" : 10,
      "context" : "This issue had been previously reported in papers such as [11,12], where the authors tried to overcome the issue by applying operations such as grouping and aggregation on the verbalized text.",
      "startOffset" : 58,
      "endOffset" : 65
    }, {
      "referenceID" : 8,
      "context" : "Over the last decade, several CNLs such as Attempto Controlled English (ACE) [9,8], Ordnance Survey2’s Rabbit (Rabbit) [4], and Sydney OWL Syntax (SOS) [3], have been specifically designed or have been adapted for ontology language OWL.",
      "startOffset" : 77,
      "endOffset" : 82
    }, {
      "referenceID" : 7,
      "context" : "Over the last decade, several CNLs such as Attempto Controlled English (ACE) [9,8], Ordnance Survey2’s Rabbit (Rabbit) [4], and Sydney OWL Syntax (SOS) [3], have been specifically designed or have been adapted for ontology language OWL.",
      "startOffset" : 77,
      "endOffset" : 82
    }, {
      "referenceID" : 3,
      "context" : "Over the last decade, several CNLs such as Attempto Controlled English (ACE) [9,8], Ordnance Survey2’s Rabbit (Rabbit) [4], and Sydney OWL Syntax (SOS) [3], have been specifically designed or have been adapted for ontology language OWL.",
      "startOffset" : 119,
      "endOffset" : 122
    }, {
      "referenceID" : 2,
      "context" : "Over the last decade, several CNLs such as Attempto Controlled English (ACE) [9,8], Ordnance Survey2’s Rabbit (Rabbit) [4], and Sydney OWL Syntax (SOS) [3], have been specifically designed or have been adapted for ontology language OWL.",
      "startOffset" : 152,
      "endOffset" : 155
    }, {
      "referenceID" : 4,
      "context" : "Unlike the other languages [5,7,1] that have been suggested to represent OWL in controlled English, these CNLs are designed to have formal language semantics and bidirectional mapping between NL fragments and OWL constructs.",
      "startOffset" : 27,
      "endOffset" : 34
    }, {
      "referenceID" : 6,
      "context" : "Unlike the other languages [5,7,1] that have been suggested to represent OWL in controlled English, these CNLs are designed to have formal language semantics and bidirectional mapping between NL fragments and OWL constructs.",
      "startOffset" : 27,
      "endOffset" : 34
    }, {
      "referenceID" : 0,
      "context" : "Unlike the other languages [5,7,1] that have been suggested to represent OWL in controlled English, these CNLs are designed to have formal language semantics and bidirectional mapping between NL fragments and OWL constructs.",
      "startOffset" : 27,
      "endOffset" : 34
    }, {
      "referenceID" : 10,
      "context" : "A detailed comparison of the systems that comprehend the NL texts is given in [11].",
      "startOffset" : 78,
      "endOffset" : 82
    }, {
      "referenceID" : 9,
      "context" : "The description logic (DL) SHIQ is based on an extension of the well-known logic ALC [10], with added support for role hierarchies, inverse roles, transitive roles, and qualifying number restrictions [6].",
      "startOffset" : 85,
      "endOffset" : 89
    }, {
      "referenceID" : 5,
      "context" : "The description logic (DL) SHIQ is based on an extension of the well-known logic ALC [10], with added support for role hierarchies, inverse roles, transitive roles, and qualifying number restrictions [6].",
      "startOffset" : 200,
      "endOffset" : 203
    }, {
      "referenceID" : 1,
      "context" : "C in O, should be simple, that is, R vO S holds for no transitive role R [2].",
      "startOffset" : 73,
      "endOffset" : 76
    } ],
    "year" : 2016,
    "abstractText" : "In this paper, we propose a rule-based technique to generate redundancy-free natural language (NL) descriptions of Web Ontology Language (OWL) entities. The existing approaches which address the problem of verbalizing OWL ontologies generate NL text segments which are close to their counterpart statements in the ontology. Some of these approaches also perform grouping and aggregating of these NL text segments to generate a more fluent and comprehensive form of the content. Restricting our attention to description of individuals and atomic concepts, we find that the approach currently followed in the available tools is that of determining the set of all logical conditions that are satisfied by the given individual/concept name and translate these conditions verbatim into corresponding NL descriptions. Human-understandability of such descriptions is affected by the presence of repetitions and redundancies, as they have high fidelity to the OWL representation of the entities. In the literature, no efforts had been taken to remove redundancies and repetitions at the logical level before generating the NL descriptions of entities and we find this to be the main reason for lack of readability of the generated text. In this paper, we propose a technique called semantic-refinement to generate meaningful and easily-understandable (what we call redundancy-free) text descriptions of individuals and concepts of a given OWL ontology. We identify the combinations of OWL/DL constructs that lead to repetitive/redundant descriptions and propose a series of refinement rules to rewrite the conditions that are satisfied by an individual/concept in a meaning-preserving manner. The reduced set of conditions are then employed for generating textual descriptions. Our experiments show that, semantic-refinement technique leads to significantly improved descriptions of ontology entities. We also test the effectiveness and usefulness of the the generated descriptions for the purpose of validating the ontologies and find that the proposed technique is indeed helpful in the context. The details of an empirical study to support the claim are provided in the paper.",
    "creator" : "LaTeX with hyperref package"
  }
}