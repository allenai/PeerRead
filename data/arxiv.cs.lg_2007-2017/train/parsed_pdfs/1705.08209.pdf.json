{
  "name" : "1705.08209.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : "Unbiasing Truncated Backpropagation Through Time",
    "authors" : [ "Corentin Tallec", "Yann Ollivier" ],
    "emails" : [ ],
    "sections" : [ {
      "heading" : null,
      "text" : "Truncated Backpropagation Through Time (truncated BPTT, [Jae05]) is a widespread method for learning recurrent computational graphs. Truncated BPTT keeps the computational benefits of Backpropagation Through Time (BPTT [Wer90]) while relieving the need for a complete backtrack through the whole data sequence at every step. However, truncation favors short-term dependencies: the gradient estimate of truncated BPTT is biased, so that it does not benefit from the convergence guarantees from stochastic gradient theory. We introduce Anticipated Reweighted Truncated Backpropagation (ARTBP), an algorithm that keeps the computational benefits of truncated BPTT, while providing unbiasedness. ARTBP works by using variable truncation lengths together with carefully chosen compensation factors in the backpropagation equation. We check the viability of ARTBP on two tasks. First, a simple synthetic task where careful balancing of temporal dependencies at different scales is needed: truncated BPTT displays unreliable performance, and in worst case scenarios, divergence, while ARTBP converges reliably. Second, on Penn Treebank character-level language modelling [MSD+12], ARTBP slightly outperforms truncated BPTT.\nBackpropagation Through Time (BPTT) [Wer90] is the de facto standard for training recurrent neural networks. However, BPTT has shortcomings when it comes to learning from very long sequences: learning a recurrent network with BPTT requires unfolding the network through time for as many timesteps as there are in the sequence. For long sequences this represents a heavy computational and memory load. This shortcoming is often overcome heuristically, by arbitrarily splitting the initial sequence into subsequences, and only backpropagating on the subsequences. The resulting algorithm is often referred to as Truncated Backpropagation Through Time (truncated BPTT, see for instance [Jae05]). This comes at the cost of losing long term dependencies.\nWe introduce Anticipated Reweighted Truncated BackPropagation (ARTBP), a variation of truncated BPTT designed to provide an unbiased gradient estimate, accounting for long term dependencies. Like truncated BPTT, ARTBP splits the initial training sequence into subsequences, and only\nar X\niv :1\n70 5.\n08 20\n9v 1\n[ cs\n.N E\n] 2\n3 M\nay 2\n01 7\nbackpropagates on those subsequences. However, unlike truncated BPTT, ARTBP splits the training sequence into variable size subsequences, and suitably modifies the backpropagation equation to obtain unbiased gradients.\nUnbiasedness of gradient estimates is the key property that provides convergence to a local optimum in stochastic gradient descent procedures. Stochastic gradient descent with biased estimates, such as the one provided by truncated BPTT, can lead to divergence even in simple situations and even with large truncation lengths (Fig. 3).\nARTBP is experimentally compared to truncated BPTT. On truncated BPTT failure cases, typically when balancing of temporal dependencies is key, ARTBP achieves reliable convergence thanks to unbiasedness. On small-scale but real world data, ARTBP slightly outperforms truncated BPTT on the test case we examined.\nARTBP formalizes the idea that, on a day-to-day basis, we can perform short term optimization, but must reflect on long-term effects once in a while; ARTBP turns this into a provably unbiased overall gradient estimate. Notably, the many short subsequences allow for quick adaptation to the data, while preserving overall balance."
    }, {
      "heading" : "1 Related Work",
      "text" : "BPTT [Wer90] and its truncated counterpart [Jae05] are nearly uncontested in the recurrent learning field. Nevertheless, BPTT is hardly applicable to very long training sequences, as it requires storing and backpropagating through a network with as many layers as there are timesteps [Sut13]. Storage issues can be partially addressed as in [GMD+16], but at an increased computational cost. Backpropagating through very long sequences also implies performing fewer gradient descent steps, which significantly slows down learning [Sut13].\nTruncated BPTT heuristically solves BPTT deficiencies by chopping the initial sequence into evenly sized subsequences. Truncated BPTT truncates gradient flows between contiguous subsequences, but maintains the recurrent hidden state of the network. Truncation biases gradients, removing any theoretical convergence guarantee. Intuitively, truncated BPTT has trouble learning dependencies above the range of truncation. 1\nNoBackTrack [OTC15] and Unbiased Online Recurrent Optimization (UORO) [TO17] both scalably provide unbiased online recurrent learning algorithms. They take the more extreme point of view of requiring memorylessness, thus forbidding truncation schemes and any storage of past states. NoBackTrack and UORO’s fully online, streaming structure comes at the price of noise injection into the gradient estimates via a random rank-one\n1 Still, as the hidden recurrent state is not reset between subsequences, it may contain hidden information about the distant past, which can be exploited [Sut13].\nreduction. ARTBP’s approach to unbiasedness is radically different: ARTBP is not memoryless but does not inject artificial noise into the gradients, instead, compensating for the truncations directly inside the backpropagation equation."
    }, {
      "heading" : "2 Background on recurrent models",
      "text" : "The goal of recurrent learning algorithms is to optimize a parametric dynamical system, so that its output sequence, or predictions, is as close as possible to some target sequence, known a priori. Formally, given a dynamical system with state s, inputs x, parameter θ, and transition function F ,\nst+1 = F (xt+1, st, θ) (1)\nthe aim is to find a θ minimizing a total loss with respect to target outputs o∗t at each time,\nLT = T∑ t=1 `t = T∑ t=1 `(st, o∗t ). (2)\nA typical case is that of a standard recurrent neural network (RNN). In this case, st = (ot, ht), where ot are the activations of the output layer (encoding the predictions), and ht are the activations of the hidden recurrent layer. For this simple RNN, the dynamical system takes the form\nht+1 = tanh(Wx xt+1 +Wh ht + b) (3) ot+1 = Woht+1 (4) `t+1 = `(ot+1, o∗t+1) (5)\nwith parameters θ = (Wx,Wh, b). Commonly, θ is optimized via a gradient descent procedure, i.e. iterating\nθ ← θ − η∂LT ∂θ\n(6)\nwhere η is the learning rate. The focus is then to efficiently compute ∂LT /∂θ. Backpropagation through time is a method of choice to perform this computation. BPTT computes the gradient by unfolding the dynamical system through time and backpropagating through it, with each timestep corresponding to a layer. BPTT decomposes the gradient as a sum, over timesteps t, of the effect of a change of parameter at time t on all subsequent losses. Formally,\n∂LT ∂θ = T∑ t=1 δ`t ∂F ∂θ (xt, st−1, θ) (7)\nwhere δ`t := ∂LT∂st is computed backward iteratively according to the backpropagation equation δ`T = ∂` ∂s (sT , o∗T )\nδ`t = δ`t+1 ∂F\n∂s (xt+1, st, θ) +\n∂` ∂s (st, o∗t ).\n(8)\nThese backpropagation equations extend the classical ones [Jae05], which deal with the case of a simple RNN for F .\nUnfortunately, BPTT requires processing the full sequence both forward and backward. This requires maintaining the full unfolded network, or equivalently storing the full history of inputs and activations (though see [GMD+16]). This is impractical when very long sequences are processed with large networks: processing the whole sequence at every gradient step slows down learning.\nPractically, this is alleviated by truncating gradient flows after a fixed number of timesteps, or equivalently, splitting the input sequence into subsequences of fixed length, and only backpropagating through those subsequences. 2 This algorithm is referred to as Truncated BPTT. With truncation length L < T , the corresponding equations just drop the recurrent term δ`t+1 ∂F ∂s (xt+1, st, θ) every L time steps, namely,\nδˆ̀t :=  ∂` ∂s (st, o∗t ) if t is a multiple of L\nδˆ̀t+1 ∂F\n∂s (xt+1, st, θ) +\n∂` ∂s (st, o∗t ) otherwise.\n(9)\nThis also allows for online application: for instance, the gradient estimate from the first subsequence t = 1 . . . , L does not depend on anything at time t > L.\nHowever, this gradient estimation scheme is heuristic and provides biased gradient estimates. In general the resulting gradient estimate can be quite far from the true gradient even with large truncations L (Section 6). Undesired behavior, and, sometimes, divergence can follow when performing gradient descent with truncated BPTT (Fig. 3)."
    }, {
      "heading" : "3 Anticipated Reweighted Backpropagation Through Time: unbiasedness through reweighted stochastic truncation lengths",
      "text" : "Like truncated BPTT, ARTBP splits the initial sequence into subsequences, and only performs backpropagation through time on subsequences. However,\n2Usually the internal state st is maintained from one subsequence to the other, not reset to a default value.\ncontrary to the latter, it does not split the sequence evenly. The length of each subsequence is sampled according to a specific probability distribution. Then the backpropagation equation is modified by introducing a suitable reweighting factor at every step to ensure unbiasedness. Figure 1 demonstrates the difference between BPTT, truncated BPTT and ARTBP.\nSimply sampling arbitrarily long truncation lengths does not provide unbiasedness. Intuitively, it still favors short term gradient terms over long term ones. When using full BPTT, gradient computations flow back 3 from every timestep t to every timestep t′ < t. In truncated BPTT, gradients do not flow from t to t′ if t− t′ exceeds the truncation length. In ARTBP, since random truncations are introduced, gradient computations flow from t to t′ with a certain probability, decreasing with t− t′. To restore balance, ARTBP rescales gradient flows by their inverse probability. Informally, if a flow has a probability p to occur, multiplication of the flow by 1p restores balance on average.\nFormally, at each training epoch, ARTBP starts by sampling a random sequence of truncation points, that is (Xt)1≤t≤T ∈ {0, 1}T . A truncation will occur at all points t such that Xt = 1. Here Xt may have a probability law that depends on X1, . . . , Xt−1, and also on the sequence of states (st)1≤t≤T of the system. The reweighting factors that ARTBP introduces in the backpropagation equation depend on these truncation probabilities. (Unbiasedness is not obtained just by global importance reweighting between the various truncated subsequences: indeed, the backpropagation equation inside each subsequence has to be modified at every time step, see (11).)\nThe question of how to choose good probability distributions for the truncation points Xt is postponed till Section 4. Actually, unbiasedness holds for any choice of truncation probabilities (Prop 1), but different choices for Xt lead to different variances for the resulting gradient estimates.\nProposition 1. Let (Xt)t=1...T be any sequence of binary random variables, chosen according to probabilities\nct := P(Xt = 1 | Xt−1, . . . , X1) (10)\nand assume ct 6= 1 for all t. 3 Gradient flows between timesteps t and t′ if there are no truncations occuring between t and t′.\nDefine ARTBP to be backpropagation through time with a truncation between t and t+ 1 iff Xt = 1, and a compensation factor 11−ct when Xt = 0, namely:\nδ˜̀t :=  ∂` ∂s (st, o∗t ) if Xt = 1 or t = T\n1 1− ct δ˜̀t+1 ∂F ∂s (xt+1, st, θ) + ∂` ∂s (st, o∗t ) otherwise.\n(11)\nLet g̃ be the gradient estimate obtained by using δ˜̀t instead of δ`t in ordinary BPTT (7), namely\ng̃ := T∑ t=1 δ˜̀t ∂F ∂θ (xt, st−1, θ) (12)\nThen, on average over the ARTBP truncations, this is an unbiased gradient estimate of the total loss:\nEX1,...,XT [ g̃ ] = ∂LT ∂θ . (13)\nThe core of the proof is as follows: With probability ct (truncation), δ˜̀t+1 does not contribute to δ˜̀t. With probability 1− ct (no truncation), it contributes with a factor 11−ct . So on average, δ ˜̀ t+1 contributes to δ˜̀t with a factor 1, and ARTBP (11) reduces to standard, non-truncated BPTT (8) on average. The detailed proof is given in Section 8.\nWhile the ARTBP gradient estimate above is unbiased, some noise is introduced due to stochasticity of the truncation points. It turns out that ARTBP trades off memory consumption (larger truncation lengths) for variance, as we now discuss."
    }, {
      "heading" : "4 Choice of ct and memory/variance tradeoff",
      "text" : "ARTBP requires specifying the probability ct of truncating at time t given previous truncations. Intuitively the c’s regulate the average truncation lengths. For instance, with a constant ct ≡ c, the lengths of the subsequences between two truncations follow a geometric distribution, with average truncation length 1c . Truncated BPTT with fixed truncation length L and ARTBP with fixed c = 1L are thus comparable memorywise.\nSmall values of ct will lead to long subsequences and gradients closer to the exact value, while large values will lead to shorter subsequences but larger compensation factors 11−ct and noisier estimates. In particular, the product of the 11−ct factors inside a subsequence can grow quickly. For instance, a constant ct leads to exponential growth of the cumulated 11−ct factors when iterating (11).\nTo mitigate this effect, we suggest to set ct to values such that the probability to have a subsequence of length L decreases like L−α. The variance of the lengths of the subsequences will be finite if α > 3. Moreover we might want to control the average truncation length L0. This is achieved via\nct = P(Xt = 1 | Xt−1, . . . , X1) = α− 1\n(α− 2)L0 + δt (14)\nwhere δt is the time elapsed since the last truncation, δt = t− sup{s | s < t,Xs = 1}. Intuitively, the more time spent without truncating, the lower the probability to truncate. This formula is chosen such that the average truncation length is approximately L0, and the standard deviation from this average length is finite. The parameter α controls the regularity of the distribution of truncation lengths: all moments lower than α− 1 are finite, the others are infinite. With larger α, large lengths will be less frequent, but the compensating factors 11−ct will be larger.\nWith this choice of ct, the product of the 11−ct factors incurred by backpropagation inside each subsequence grows polynomially like Lα−1 in a subsequence of length L. If the dynamical system has geometrically decaying memory, i.e., if the operator norm of the transition operator ∂F∂s is less than 1 − ε most of the time, then the value of δ˜̀t will stay controlled, since (1 − ε)L · Lα stays bounded. On the other hand, using a constant ct ≡ c provides bounded δ˜̀t only for small values c < ε.\nIn the experiments below, we use the ct from (14) with α = 4 or α = 6."
    }, {
      "heading" : "5 Online implementation",
      "text" : "Importantly, ARTBP can be directly applied online, thus providing unbiased gradient estimates for recurrent networks.\nIndeed, not all truncation points have to be drawn in advance: ARTBP can be applied by sampling the first truncation point, performing both forward and backward passes of BPTT up until this point, and applying a partial gradient descent update based on the resulting gradient on this subsequence. Then one moves to the next subsequence and the next truncation point, etc. (Fig. 1c)."
    }, {
      "heading" : "6 Experimental validation",
      "text" : "The experimental setup below aims both at illustrating the theoretical properties of ARTBP compared to truncated BPTT, and at testing the soundness of ARTBP on real world data."
    }, {
      "heading" : "6.1 Influence balancing",
      "text" : "The influence balancing experiment is a synthetic example demonstrating, in a very simple model, the importance of being unbiased. Intuitively, a parameter has a positive short term influence, but a negative long term one that surpasses the short term effect. Practically, we consider a row of agents, numbered from left to right from 1 to p + n who, at each time step, are provided with a signal depending on the parameter, and diffuse part of their current state to the agent directly to their left. The p leftmost agents receive a positive signal at each time step, and the n rightmost agents a negative signal. The training goal is to control the state of the leftmost agent. The first p agents contribute positively to the first agent state, while the next n contribute negatively. However, agent 1 only feels the contribution from agent k after k timesteps. If optimization is blind to dependencies above k, the effect of k is never felt. A typical instantiation of such a problem would be that of a drug whose effect varies after various delays; the parameter to be optimized is the quantity of drug to be used daily.\nSuch a model can be formalized as [TO17]\nst+1 = Ast + (θ, . . . , θ,−θ, . . . ,−θ)> (15)\nwith A a square matrix of size p+ n with Ak,k = 1/2, Ak,k+1 = 1/2, and 0 elsewhere; skt corresponds to the state of the k-th agent. θ ∈ R is a scalar parameter corresponding to the intensity of the signal observed at each time step. The right-hand-side has p positive-θ entries and n negative-θ entries. The loss considered is an arbitrary target on the leftmost agent s1,\n`t = 12(s 1 t − 1)2. (16)\nThe dynamics is illustrated schematically in Figure 2. Fixed-truncation BPTT is experimentally compared with ARTBP for this problem. The setting is online: starting at t = 1, a first truncation length L is selected (fixed for BPTT, variable for ARTBP), forward and backward passes are performed on the subsequence t = 1, . . . , L, a vanilla\ngradient step is performed with the resulting gradient estimate, then the procedure is repeated with the next subsequence starting at t = L+ 1, etc..\nOur experiment uses p = 10 and n = 13, so that after 23 steps the signal should have had time to travel through the network. Truncated BPTT is tested with various truncations L = 10, 100, 200. (As the initial θ is fixed, truncated BPTT is deterministic in this experiment, thus we only provide a single run for each L.) ARTBP is tested with the probabilities (14) using L0 = 16 (average truncation length) and α = 6. ARTBP is stochastic: five random runs are provided to test reliability of convergence.\nThe results are displayed in Fig. 3. We used decreasing learning rates ηt = η0√1+t where η0 = 3 × 10\n−4 is the initial learning rate and t is the timestep. We plot the average loss over timesteps 1 to t, as a function of t.\nTruncated BPTT diverges even for truncation ranges largely above the intrinsic temporal scale of the system. This is an expected result: due to bias, truncated BPTT ill-balances temporal dependencies and estimates the overall gradient with a wrong sign. In particular, reducing the learning rate will not prevent divergence. On the other hand, ARTBP reliably converges on every run.\nNote that for the largest truncation L = 200, truncated BPTT finally converges, and does so at a faster rate than ARTBP. This is because this particular problem is deterministic, so that a deterministic gradient scheme will converge (if it does converge) geometrically like O(e−λt), whereas ARTBP is stochastic due to randomization of truncations, and so will not converge faster than O(t−1/2). This difference would disappear, for instance, with noisy targets or a noisy system.\nCharacter-level Penn Treebank language model. We compare ARTBP to truncated BPTT on the character-level version of the Penn Treebank dataset, a standard set of case-insensitive, punctuation-free English text [MSM93]. Character-level language modelling is a common benchmark for recurrent models.\nThe dataset is split into training, validation and test sets following [MSD+12]. Both ARTBP and truncated BPTT are used to train an LSTM model [HS97] with a softmax classifier on its hidden state, on the character prediction task. The training set is batched into 64 subsets processed in parallel to increase computing speed. Before each full pass on the training set, the batched training sequences are split into subsequences:\n• for truncated BPTT, of fixed size 50; • for ARTBP, at random following the scheme (14) with α = 4 and L0 = 50.\nTruncated BPTT and ARTBP process these subsequences sequentially, 4 as in Fig. 1. The parameter is updated after each subsequence, using the Adam [KB14] stochastic gradient scheme, with learning rate 10−4. The biases of the LSTM unit forget gates are set to 2, to prevent early vanishing gradients [GSC00]. Results (in bits per character, bpc) are displayed in Fig. 4. Six randomly sampled runs are plotted, to test reliability.\nIn this test, ARTBP slightly outperforms truncated BPTT in terms of validation and test error, while the reverse is true for the training error (Fig. 4).\n4 Subsequences are not shuffled, as we do not reset the internal state of the network between subsequences.\nEven with ordinary truncated BPTT, we could not reproduce reported state of the art results, and do somewhat worse. We reach a test error of 1.43 bpc with standard truncated BPTT and 1.40 bpc with ARTBP, while reported values with similar LSTM models range from 1.38 bpc [CBLC16] to 1.26 bpc [Gra13] (the latter with a different test/train split). This may be due to differences in the experimental setup: we have applied truncated BPTT without subsequence shuffling or gradient clipping [Gra13] (incidentally, both would break unbiasedness). Arguably, the numerical issues solved by gradient clipping are model specific, not algorithm specific, while the point here was to compare ARTBP to truncated BPTT for a given model."
    }, {
      "heading" : "7 Conclusion",
      "text" : "We have shown that the bias introduced by truncation in the backpropagation through time algorithm can be compensated by the simple mathematical trick of randomizing the truncation points and introducing compensation factors in the backpropagation equation. The algorithm is experimentally viable, and provides proper balancing of the effects of different time scales when training recurrent models."
    }, {
      "heading" : "8 Proof of Proposition 1",
      "text" : "First, by backward induction, we show that for all t ≤ T , for all x1, . . . , xt−1 ∈ {0, 1},\nE [ δ˜̀t | X1:t−1 = x1:t−1 ] = δ`t (17)\nwhere δ`t is the value obtained by ordinary BPTT (8). Here x1:k is short for (x1, . . . , xk).\nFor t = T , this holds by definition: δ˜̀T = ∂`∂s(sT , o ∗ T ) = δ`T .\nAssume that the induction hypothesis (17) holds at time t + 1. Note that the values st do not depend on the random variables Xt, as they are computed during the forward pass of the algorithm. In particular, the various derivatives of F and ` in (11) do not depend on X1:T .\nThus\nE [ δ˜̀t | X1:t−1 = x1:t−1 ] =\nP(Xt = 1 | X1:t−1 = x1:t−1)E [ δ˜̀t | X1:t−1 = x1:t−1, Xt = 1 ] + (18)\nP(Xt = 0 | X1:t−1 = x1:t−1)E [ δ˜̀t | X1:t−1 = x1:t−1, Xt = 0 ] (19)\n= ct E [ δ˜̀t | X1:t−1 = x1:t−1, Xt = 1 ] + (1− ct)E [ δ˜̀t | X1:t−1 = x1:t−1, Xt = 0 ] (20)\nIf Xt = 1 then δ˜̀t = ∂`∂s(st, o ∗ t ). If Xt = 0, then δ˜̀t = ∂`∂s(st, o ∗ t ) +\n1 1−ct δ ˜̀ t+1 ∂F ∂s (xt+1, st, θ). Therefore, substituting into (20),\nE [ δ˜̀t | X1:t−1 = x1:t−1 ] = ∂` ∂s (st, o∗t ) + E [ δ˜̀t+1 | X1:t−1 = x1:t−1, Xt = 0 ] ∂F ∂s\n(xt+1, st, θ) (21)\nbut by the induction hypothesis at time t + 1, this is exactly ∂`∂s(st, o ∗ t ) + δ`t+1 ∂F ∂s (xt+1, st, θ), which is δ`t.\nTherefore, E [ δ˜̀t ] = δ`t unconditionally. Plugging the δ˜̀’s into (7), and\naveraging\nEX1,...,XT [ g̃ ] = T∑ t=1 EXt,...,XT [ δ˜̀t ] ∂F ∂θ (xt, st−1, θ) (22)\n= T∑ t=1 δ`t ∂F ∂θ (xt, st−1, θ) (23) = ∂LT ∂θ (24)\nwhich ends the proof."
    } ],
    "references" : [ {
      "title" : "Memory-efficient backpropagation through time",
      "author" : [ "Audrunas Gruslys", "Rémi Munos", "Ivo Danihelka", "Marc Lanctot", "Alex Graves" ],
      "venue" : null,
      "citeRegEx" : "Gruslys et al\\.,? \\Q2016\\E",
      "shortCiteRegEx" : "Gruslys et al\\.",
      "year" : 2016
    }, {
      "title" : "Generating sequences with recurrent neural networks",
      "author" : [ "Alex Graves" ],
      "venue" : "CoRR, abs/1308.0850,",
      "citeRegEx" : "Graves.,? \\Q2013\\E",
      "shortCiteRegEx" : "Graves.",
      "year" : 2013
    }, {
      "title" : "Learning to forget: Continual prediction with LSTM",
      "author" : [ "Felix A. Gers", "Jürgen A. Schmidhuber", "Fred A. Cummins" ],
      "venue" : "Neural Comput.,",
      "citeRegEx" : "Gers et al\\.,? \\Q2000\\E",
      "shortCiteRegEx" : "Gers et al\\.",
      "year" : 2000
    }, {
      "title" : "Long short-term memory",
      "author" : [ "Sepp Hochreiter", "Jürgen Schmidhuber" ],
      "venue" : "Neural Comput.,",
      "citeRegEx" : "Hochreiter and Schmidhuber.,? \\Q1997\\E",
      "shortCiteRegEx" : "Hochreiter and Schmidhuber.",
      "year" : 1997
    }, {
      "title" : "A tutorial on training recurrent neural networks, covering BPPT, RTRL, EKF and the \"echo state network",
      "author" : [ "Herbert Jaeger" ],
      "venue" : null,
      "citeRegEx" : "Jaeger.,? \\Q2005\\E",
      "shortCiteRegEx" : "Jaeger.",
      "year" : 2005
    }, {
      "title" : "Adam: A method for stochastic optimization",
      "author" : [ "Diederik P. Kingma", "Jimmy Ba" ],
      "venue" : "CoRR, abs/1412.6980,",
      "citeRegEx" : "Kingma and Ba.,? \\Q2014\\E",
      "shortCiteRegEx" : "Kingma and Ba.",
      "year" : 2014
    }, {
      "title" : "Subword language modeling with neural networks",
      "author" : [ "Tomás̆ Mikolov", "Ilya Sutskever", "Anoop Deoras", "Le Hai-Son", "Stefan Kombrink", "Jan C̆ernocký" ],
      "venue" : null,
      "citeRegEx" : "Mikolov et al\\.,? \\Q2012\\E",
      "shortCiteRegEx" : "Mikolov et al\\.",
      "year" : 2012
    }, {
      "title" : "Building a large annotated corpus of English: The Penn Treebank",
      "author" : [ "Mitchell P. Marcus", "Beatrice Santorini", "Mary Ann Marcinkiewicz" ],
      "venue" : "Computational Linguistics,",
      "citeRegEx" : "Marcus et al\\.,? \\Q1993\\E",
      "shortCiteRegEx" : "Marcus et al\\.",
      "year" : 1993
    }, {
      "title" : "Training recurrent networks online without backtracking",
      "author" : [ "Yann Ollivier", "Corentin Tallec", "Guillaume Charpiat" ],
      "venue" : "arXiv preprint arXiv:1507.07680,",
      "citeRegEx" : "Ollivier et al\\.,? \\Q2015\\E",
      "shortCiteRegEx" : "Ollivier et al\\.",
      "year" : 2015
    }, {
      "title" : "Unbiased online recurrent optimization",
      "author" : [ "Corentin Tallec", "Yann Ollivier" ],
      "venue" : "arXiv preprint arXiv:1702.05043,",
      "citeRegEx" : "Tallec and Ollivier.,? \\Q2017\\E",
      "shortCiteRegEx" : "Tallec and Ollivier.",
      "year" : 2017
    }, {
      "title" : "Backpropagation through time: what does it do and how to do it",
      "author" : [ "P. Werbos" ],
      "venue" : "In Proceedings of IEEE,",
      "citeRegEx" : "Werbos.,? \\Q1990\\E",
      "shortCiteRegEx" : "Werbos.",
      "year" : 1990
    } ],
    "referenceMentions" : [ ],
    "year" : 2017,
    "abstractText" : "Truncated Backpropagation Through Time (truncated BPTT, [Jae05]) is a widespread method for learning recurrent computational graphs. Truncated BPTT keeps the computational benefits of Backpropagation Through Time (BPTT [Wer90]) while relieving the need for a complete backtrack through the whole data sequence at every step. However, truncation favors short-term dependencies: the gradient estimate of truncated BPTT is biased, so that it does not benefit from the convergence guarantees from stochastic gradient theory. We introduce Anticipated Reweighted Truncated Backpropagation (ARTBP), an algorithm that keeps the computational benefits of truncated BPTT, while providing unbiasedness. ARTBP works by using variable truncation lengths together with carefully chosen compensation factors in the backpropagation equation. We check the viability of ARTBP on two tasks. First, a simple synthetic task where careful balancing of temporal dependencies at different scales is needed: truncated BPTT displays unreliable performance, and in worst case scenarios, divergence, while ARTBP converges reliably. Second, on Penn Treebank character-level language modelling [MSD+12], ARTBP slightly outperforms truncated BPTT. Backpropagation Through Time (BPTT) [Wer90] is the de facto standard for training recurrent neural networks. However, BPTT has shortcomings when it comes to learning from very long sequences: learning a recurrent network with BPTT requires unfolding the network through time for as many timesteps as there are in the sequence. For long sequences this represents a heavy computational and memory load. This shortcoming is often overcome heuristically, by arbitrarily splitting the initial sequence into subsequences, and only backpropagating on the subsequences. The resulting algorithm is often referred to as Truncated Backpropagation Through Time (truncated BPTT, see for instance [Jae05]). This comes at the cost of losing long term dependencies. We introduce Anticipated Reweighted Truncated BackPropagation (ARTBP), a variation of truncated BPTT designed to provide an unbiased gradient estimate, accounting for long term dependencies. Like truncated BPTT, ARTBP splits the initial training sequence into subsequences, and only 1 ar X iv :1 70 5. 08 20 9v 1 [ cs .N E ] 2 3 M ay 2 01 7 backpropagates on those subsequences. However, unlike truncated BPTT, ARTBP splits the training sequence into variable size subsequences, and suitably modifies the backpropagation equation to obtain unbiased gradients. Unbiasedness of gradient estimates is the key property that provides convergence to a local optimum in stochastic gradient descent procedures. Stochastic gradient descent with biased estimates, such as the one provided by truncated BPTT, can lead to divergence even in simple situations and even with large truncation lengths (Fig. 3). ARTBP is experimentally compared to truncated BPTT. On truncated BPTT failure cases, typically when balancing of temporal dependencies is key, ARTBP achieves reliable convergence thanks to unbiasedness. On small-scale but real world data, ARTBP slightly outperforms truncated BPTT on the test case we examined. ARTBP formalizes the idea that, on a day-to-day basis, we can perform short term optimization, but must reflect on long-term effects once in a while; ARTBP turns this into a provably unbiased overall gradient estimate. Notably, the many short subsequences allow for quick adaptation to the data, while preserving overall balance.",
    "creator" : "LaTeX with hyperref package"
  }
}