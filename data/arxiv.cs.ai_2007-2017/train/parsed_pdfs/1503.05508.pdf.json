{
  "name" : "1503.05508.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : "Exploration of the scalability of LocFaults approach for error localization with While-loops programs",
    "authors" : [ "Mohammed Bekkouche" ],
    "emails" : [ "bekkouch@i3s.unice.fr" ],
    "sections" : [ {
      "heading" : null,
      "text" : "ar X\niv :1\n50 3.\n05 50\n8v 1\n[ cs\n.A I]\n1 8\nM ar\n2 01"
    }, {
      "heading" : "Categories and Subject Descriptors",
      "text" : "D.3.3 [Language Constructs and features]: Constraints; D.2.5 [Testing and Debugging]: Debugging aids, Diagnostics, Error handling and recovery"
    }, {
      "heading" : "General Terms",
      "text" : "Verification, Algorithms, Experimentation"
    }, {
      "heading" : "Keywords",
      "text" : "Error localization, LocFaults, BugAssist, Off-by-one bug, Minimal Correction Deviations, Minimal Correction Subsets"
    }, {
      "heading" : "1. INTRODUCTION",
      "text" : "Errors are inevitable in a program, they can harm proper operation and have extremely serious financial consequences.\nPermission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page. To copy otherwise, to republish, to post on servers or to redistribute to lists, requires prior specific permission and/or a fee. ESEC/FSE’15 August 31-September 4, 2015, Bergamo, Italy. Copyright 2015 ACM X-XXXXX-XX-X/XX/XX ...$15.00.\nThus it poses a threat to human well-being [17]. This link [3] cites recent stories of software bugs. Consequently, the debugging process (detection, localization and correction of errors) is essential. The location of errors is the step that costs the most. It consists of identifying the exact locations of suspicious instructions [18] to help the user to understand why the program failed, which facilitates him in the task of error correction. Indeed, when a program P is not conformed with its specification (P contains errors), a model checker can produce a trace of a counterexample, which is often long and difficult to understand even for experienced programmers. To solve this problem, we have proposed an approach [5] (named LocFaults) based on constraints that explores the paths of CFG (Control Flow Graph) of the program from the counterexample, to calculate the minimal subsets to restore the program’s compliance with its postcondition. Ensuring that our method is highly scalable to meet the enormous complexity of software systems is an important criterion for its quality [9].\nDifferent statistical approaches for error localization have been proposed; e.g.: Tarantula [11] [10], Ochiai [1], AMPLE [1], Pinpoint [6]. The most famous is Tarantula, which uses different metrics to calculate the degree of suspicion of each instruction in the program while running a battery of tests. The weakness of these approaches is that they require a lot of test cases, while our approach uses one counterexample. Another critical point in statistical approaches is that they require an oracle to decide if the result of a test case is correct or not. To overcome this problem, we consider the framework of Bounded Model Checking (BMC) which only requires a postcondition or assertion to check.\nThe idea of our approach is to reduce the problem of error localization to the one which is to compute a minimal set which explains why a CSP (Constraint Satisfaction Problem) is infeasible. The CSP represents the union of constraints of the counterexample, the program, and the assertion or the postcondition violated. The calculated set can be a MCS (Minimal Correction Subset) or a MUS (Minimal Unsatisfiable Subset). In general, test the feasibility of a CSP over a finite domaine is a NP-complete problem (intractable)1, one of the most difficult NP problems. This means, explaining the infeasibility in a CSP is as hard or more (it can be classified as NP-hard problem). BugAssist [13] [12] is a BMC method of error localization using a Max-SAT solver to calculate the merger of MCSs of the\n1If this problem could be solved in polynomial time, then all NP-complete problems would be too.\nBoolean formula of the entire program with the counterexample. It becomes inefficient for large programs. LocFaults also works from a counterexample to calculate MCSs.\nIn this paper, we explore the scalability of LocFaults on programs with While-loops unfolded b times, and a number of deviated conditions ranging from 0 to 3.\nThe contribution of our approach against BugAssist can be summarized in the following points:\n* We do not transform the entire program in a system of constraints, but we use the CFG of the program to collect the constraints of the path of counterexample and paths derivatives thereof, assuming that at most k conditionals may contain errors. We calculate MCSs only on the path of counterexample and paths that correct the program;\n* We do not translate the program instructions into a SAT formula, instead numerical constraints that will be handled by constraint solvers;\n* We do not use MaxSAT solvers as black boxes, instead a generic algorithm to calculate MCSs by the use of a constraint solver;\n* We limit the size of the generated MCSs and the number of deviated conditions;\n* We can work together more solvers during the localization process and take the most efficient according to the category of CSP constructed. For example, if the CSP of the path detected is of type linear over integers, we use a MIP (Mixed Integer Programming) solver; if it is nonlinear, we use a CP (Constraint Programming) solver and/or as well as MINLP (Mixed Integer Nonlinear Programming).\nOur practical experience has shown that all these restrictions and distinctions enable LocFaults to be faster and more expressive.\nThe paper is organized as follows. Section 2 introduces the definition of MUS and MCS. In Section 3, we define the problem ≤ k-MCD. We explain a paper contribution for the treatment of erroneous loops, including the Off-by-one bug, in Section 4. A brief description of our LocFaults algorithm is provided in Section 5. The experimental evaluation is presented in Section 6. Section 7 talks about the conclusion and future work."
    }, {
      "heading" : "2. DEFINITIONS",
      "text" : "In this section, we introduce the definition of an IIS/MUS and MCS."
    }, {
      "heading" : "CSP.",
      "text" : "A CSP (Constraint Satisfaction Problem) P is defined as a triple < X,D,C >, where:\n* X a set of n variables x1, x2, ..., xn.\n* D the tuple < Dx1 , Dx2 , ..., Dxn >. The set Dxi contains the values of the variable xi.\n* C={c1, c2, ..., cn} is the set of constraints.\nA solution for P is an instantiation of the variables I ∈ D that satisfies all the constraints in C. P is infeasible if it has\nno solutions. A sub-set of constraints C′ in C is also said infeasible for the same reason except that it is limited to the constraints in C′. We denote as:\n• Sol(< X,C′, D >) = ∅, to specify that C′ has no solutions, so it is unfeasible.\n• Sol(< X,C′, D >) 6= ∅, to specify that C′ has at least one solution, so it is feasible.\nWe say that P is linear and denote LP (Linear Program) iff all constraints in C are linear equations/inequalities, it is continuous if the domain all variables is real. If at least one of the variables in X is integer or binary (Special cases of an integer), and the constraints are linear, P is called a program linear mixed MIP (Mixed-integer linear program). If the constraints are nonlinear, we say that P is a program nonlinear NLP (NonLinear Program).\nLet P =< X,D,C > an infeasible CSP , we define for P :"
    }, {
      "heading" : "IS.",
      "text" : "An IS (Inconsistent Set) is an infeasible subset of constraints in the constraint set infeasible C. C′ is an IS iff:\n* C′ ⊆ C.\n* Sol(< X,C′, D >) = ∅."
    }, {
      "heading" : "IIS or MUS.",
      "text" : "An IIS (Irreducible Inconsistent Set) or MUS (Minimal Unsatisfiable Subset) is an infeasible subset of constraints of C, and all its strict subsets are feasible. C′ is an IIS iff :\n* C′ is an IS.\n* ∀ C′′ ⊂ C′.Sol(< X,C′′, D >) 6= ∅, (each of its parts contributes to the infeasibility), C′ is called irreducible."
    }, {
      "heading" : "MCS.",
      "text" : "C′ is a MCS(Minimal Correction Set) iff :\n* C′ ⊆ C.\n* Sol(< X,C\\C′, D >) 6= ∅.\n* ∄ C′′ ⊂ C′ such as Sol(< X,C\\C′′, D >) 6= ∅.\n3. THE PROBLEM ≤ K-MCD Given an erroneous program modeled in CFG2 G = (C,A,E): C is the set of conditional nodes; A is the set of assignment blocks; E is the set of arcs, and a counterexample. A MCD (Minimal Correction Deviation) is a set D ⊆ C such as the propagation of the counterexample on all the instructions of G from the root, while having denied each condition3 in D, allows the output to satisfy the postcondition. It is called minimal (or irreducible) in the sense that no element can be removed from D without losing this property. In other\n2We use Dynamic Single Assignment (DSA) form [2] transformation that ensures that each variable is assigned only once on each path of the CFG. 3The condition is denied to take the branch opposite to that where we had to go.\nwords, D is a minimal program correctness in the set of conditions. The size of minimal deviation is its cardinal. The problem ≤ k-MCD is to find all MCDs of size smaller or equal to k.\nFor example, the CFG of the program AbsMinus (see fig. 2) has one minimal size deviation 1 for the counterexample {i = 0, j = 1}. Certainly, the deviation {i0 ≤ j0,k1 = 1 ∧ i0 6= j0} corrects the program, but it is not minimal; only one minimal correction deviation for this program is {k1 = 1 ∧ i0 6= j0}.\n1 c l a s s AbsMinus { 2 /∗@ ensures 3 @ (( i<j )==>(\\r e s u l t==j−i ) )&& 4 @ (( i>=j )==>(\\r e s u l t==i− j ) ) ; ∗/ 5 in t AbsMinus ( i n t i , i n t j ){ 6 in t r e s u l t ; 7 in t k = 0; 8 i f ( i <= j ) { 9 k = k+2;// e r ro r :\nshould be k=k+1 10 } 11 i f (k == 1 && i != j ) { 12 r e s u l t = j−i ; 13 } 14 e l s e { 15 r e s u l t = i−j ; 16 } 17 } 18 }\nFigure 1: The program AbsMinus\nk0 = 0\ni0 ≤ j0\nk1 = k0 + 2 Error k1 = k0\nk1 = 1 ∧ i0! = j0\nr1 = j0 − i0 r1 = i0 − j0\nPOST:{r1 == |i − j|}\nIf Else\nIf Else\nFigure 2: The CFG in DSA of AbsMinus\n{(i0 == 0) ∧ (j0 == 1)}\nk0 = 0\ni0 ≤ j0\nk1 = k0 + 2 k1 = k0\nk1 = 1 ∧ i0! = j0\nr1 = j0 − i0 r1 = i0 − j0\n{r1 == |i − j|}\nIf Else\nIf Else\nFigure 3: The path of the counterexample\n{(i0 == 0) ∧ (j0 == 1)}\nk0 = 0\ni0 ≤ j0\nk1 = k0 + 2 k1 = k0\nk1 = 1 ∧ i0! = j0\nr1 = j0 − i0 r1 = i0 − j0\n{r1 == |i − j|} is UNSAT\nIf Else\nIf Else\nFigure 4: The path obtained by deviating the condition i0 ≤ j0\nThe table 1 summarizes the progress of LocFaults for the program AbsMinus, with at most 2 conditions deviated from the following counterexample {i = 0, j = 1}.\nWe display the conditions deviated, if they are minimal deviation or non minimal, and the calculated MCSs from the constructed constraint system : see respectively the columns 1, 2 and 3. Column 4 shows the figure illustrating the path explored for each deviation. In the first and the third column we show in addition of the instruction, its line in the program. For example, the first line in the table shows that there is a single MCS found ({r1 = i0−j0 : 15}) on the path of the counterexample."
    }, {
      "heading" : "4. ERROR LOCALIZATION IN LOOPS",
      "text" : "As part of Bounded Model Checking (BMC) for programs, unfolding can be applied to the entire program or it can be applied to loops separately [9]. Our algorithm LocFaults [4] [5] for error localization is placed in the second approach; that is to say, we use a bound b to unfold loops by replacing them with conditional statements nested of depth b. Consider for instance the program Minimum (see fig. 7), containing a single loop, that calculates the minimum in an array of integers. The effect on control flow graph of the program Minimum before and after unfolding is illustrated in Figures 7 and 8 respectively. The While-loop is unfolded 3 times, as 3 is the number of iterations needed for the loop to calculate the minimum value in an array of size 4 in the worst case. LocFaults takes as input the CFG of the erroneous program, CE a counterexample, bmcd: a bound on the number of deviated conditions, bmcs: a bound on the size of MCSs calculated. It allows to explore the CFG in depth by diverting at most bmcd conditions from the path of the counterexample:\n* It propagates CE on the CFG until the postcondition. Then it calculates the MCSs on the CSP of the path generated to locate errors on the path of counterexample.\n* It seeks to enumerate the sets ≤ bmcd-MCD. For each found MCD, it calculates the MCSs on the path that arrives at the last deviated condition and allows to take the path of the deviation.\nAmong the most common errors associated with loops according to [14], the Off-by-one bug, i.e. loops that iterate one too many or one too few times. This may be due to improper initialization of the loop control variables, or an erroneous condition of the loop. The program Minimum presents a case of this type of error. It is erroneous because of its loop While, the falsified instruction is on the condition of the loop (line 9): the correct condition should be (i < tab.length) (tab.length is the number of elements of the table tab). From the following counterexample\n{tab[0] = 3, tab[1] = 2, tab[2] = 1, tab[3] = 0}, we illustrated in Figure 8 the initial faulty path (see the colorful path in red) and the deviation for which the postcondition is satisfiable (the deviation and the path above the deviated condition are shown in green).\n1 c l a s s Minimum { 2 /∗ The minimum in an array o f n i n t e g e r s ∗/ 3 /∗@ ensures 4 @ (\\ f o r a l l in t k ; ( k >= 0\n&& k < tab . l ength ) ; tab [ k ] >= min) ;\n5 @∗/ 6 in t Minimum ( in t [ ] tab ) { 7 in t min=tab [ 0 ] ; 8 in t i = 1; 9 whi l e ( i<tab . length −1)\n{ /∗ e rror , the cond i t i on should be ( i<tab . l ength ) ∗/\n10 i f ( tab [ i ]<=min){ 11 min=tab [ i ] ; 12 } 13 i = i +1; 14 } 15 return min ; 16 } 17 }\nmin = tab[0] i = 1\ni <\ntab.length − 1\ntab[i] ≤ min\nmin = tab[i]\ni = i + 1\nPostcondition\nIf\nIf\nElse\nElse Goto\nFigure 7: The program Minimum and its normal CFG (non unfolded). The postcondition is {∀ int k; (k ≥ 0 ∧ k < tab.length); tab[k] ≥ min}\nWe show in table 2 erroneous paths generated (column PATH) and the MCSs calculated (column MCSs) for at most 1 condition deviated from the conduct of the counterexample. The first line concerns the path of counterexample; the second for the path obtained by deviating the condition {i2 ≤ tab0.length− 1}.\nLocFaults identifies a single MCS on the path of counterexample that contains the constraint min2 = tab0[i1], the instruction of the line 11 in the second iteration of the loop unfolded. With a deviated condition, the algorithm suspects the third condition of the unfolded loop i2 < tab0.length−1; in other words, we need a new iteration to satisfy the postcondition.\nThis example shows a case of a program with an incorrect loop: the error is on the stopping criterion, it does not allow the program to iterate until the last element of the array input. LocFaults with its deviation mechanism is able to detect this type of error accurately. It provides the user not only suspicious instructions in the loop not unfolded on the original program, but also information about the iterations where they are in the unfolded loop. This information could\nCE:{tab0[0] == 3 ∧ tab0[1] == 2 ∧ tab0[2] == 1 ∧ tab0[3] == 0}\nmin0 = tab0[0] i0 = 1\ni0 < tab0 .length−\n1\ntab0[i0] ≤ min0\nmin4 = min0 i4 = i0\nmin1 = tab0[i0] min1 = min0\ni1 = i0 + 1\ni1 < tab0 .length−\n1\ntab0[i1] ≤ min1\nmin4 = min1 i4 = i1\nmin2 = tab0[i1] min2 = min1\ni2 = i1 + 1\ni2 < tab0 .length−\n1\ntab0[i2] ≤ min2\nmin4 = min2 i4 = i2\nmin3 = tab0[i] min3 = min2\ni3 = i2 + 1\nmin4 = min3 i4 = i3\nPOST : {∀ int k; (k ≥ 0 ∧ k < tab0.length); tab0[k] ≥ min4}\nIf Else\nIf Else\nIf Else\nIf Else\nIf(deviation) Else\nIf Else\nFigure 8: Figure showing the CFG in DSA form of the program Minimum by unfolding its loop 3 times, with the path of a counterexample (shown in red) and a deviation satisfying the postcondition (shown in green).\nbe very useful for the programmer to understand the errors in the loop."
    }, {
      "heading" : "5. ALGORITHM",
      "text" : "Our goal is to find MCDs of size less than a bound k ; in other words, we try to give a solution to the problem posed above (≤ k-MCD). For this, our algorithm (named LocFaults) explores in depth the CFG and generates the paths where at most k conditions are deviated from the conduct of the counterexample.\nTo improve efficiency, our heuristic solution proceeds incrementally. It successively deviates from 0 to k conditions and search the MCSs for the corresponding paths. However, if in step k LocFaults deviates a condition ci and that it has corrected the program, it does not explore in step k′ with k′ > k paths that involve a deviation from the condition ci. For this, we add the cardinality of the found minimum deviation (k) as information on the node of ci.\nWe will illustrate with an example of our approach, as seen in the graph in Figure 9. Each circle in the graph represents a conditional node visited by the algorithm. The example does not show the block of assignments because we want to\nillustrate just how we find the minimal correction deviations of a bounded size as mentioned above. An arc connecting a condition c1 to another c2 illustrates that c2 is reached by the algorithm. There are two ways related to the behavior of the counterexample, where LocFaults reaches the condition c2:\n1. by following the branch induced by the condition c1 ;\n2. by following the opposite branch.\nThe value of the label of arcs for case (1) (resp. (2)) is ”next” (resp. ”devie”).\n• At the step k = 5, our algorithm has identified two MCDs of size equal to 5:\n1. D1 = {1, 2, 3, 4, 7}, the node ”7” is marked by the value 5 ;\n2. D2 = {8, 9, 11, 12, 7}, it was allowed because the value of the marke of the node ”7” is equal to the cardinality of D2.\n• At the step k = 6, the algorithm has suspended the following deviation D3 = {8, 13, 14, 15, 16, 7}, because the cardinality of D3 is strictly greater than the value of the label of the node ”7”."
    }, {
      "heading" : "6. PRACTICAL EXPERIENCE",
      "text" : "To evaluate the scalability of our method, we compared its performance with that of BugAssist4 on two sets benchmarks5.\n* The first benchmark is illustrative, it contains a set of programs without loops;\n* The second benchmark includes 19, 48 and 91 variations for respectively the programs BubbleSort, Sum and SquareRoot. These programs contain loops to study the scalability of our approach compared to BugAssist. To increase the complexity of a program, we increase the number of iterations in loops in the execution of each tool; we use the same bound of unfolding loops for LocFaults and BugAssist.\nTo generate the CFG and the counterexample, we use the tool CPBPV [8] (Constraint-Programming Framework for Bounded Program Verification). LocFaults and BugAssist work respectively on Java and C programs. For a fair comparison, we built two equivalent versions for each program:\n* a version in Java annotated by a JML specification;\n* a version in ANSI-C annotated by the same specification but in ACSL.\nBoth versions have the same numbers of lines of instructions, including errors. The precondition specifies the counterexample used for the program.\nTo calculate the MCSs, we used IBM ILOG MIP6 and CP7 solvers of CPLEX. We adapted and implemented the algorithm of Liffiton and Sakallah [15], see alg. 1. This implementation takes as input the infeasible set of constraints corresponding to the identified path (C), and bmcs: the bound on the size of calculated MCSs. Each constraint ci in the system built C is augmented by an indicator yi for giving yi → ci in the new system of constraints C\n′. Assign to yi the value True implies the constraint ci; however, assign to yi value False implies the removal of the constraint ci. A MCS is obtained by seeking an assignment that satisfies the constraint system with a minimal set of constraints indicators affected with False. To limit the number of constraints indicators that can be assigned with False, we use the constraint AtMost(¬y1,¬y2, ...,¬yn, k) (see the line 5), the created system is noted in the algorithm C′k (line 5). Each iteration of the While-loop (lines 6 − 19) is allowed to find all MCSs of size k, k is incremented by 1 after each iteration. After finding each MCS (lines 8− 13), a blocking constraint is added to C′k and C\n′ to prevent finding this new MCS in the next iterations (lines 15 − 16). The first loop (lines 4 − 19) is iterated until all MCSs of C are generated (C′ becomes infeasible); it can also stop if the MCSs of size smaller or equal to bmcs are obtained (k > bmcs).\n4The tool BugAssist is available at : http://bugassist. mpi-sws.org/ 5The source code for all programs is available at : http: //www.i3s.unice.fr/~bekkouch/Benchs_Mohammed.html 6IBM ILOG MIP is available at http://www01.ibm.com/software/commerce/optimization/cplexoptimizer/ 7IBM ILOG CP OPTIMIZER is available at http://www01.ibm.com/software/commerce/optimization/cplex-cpoptimizer/\n1 Function MCS(C,bmcs) Data: C: Infeasible set of constraints, bmcs: Integer Result: MCS: List of MCSs in C of a cardinality less than bmcs 2 begin 3 C′ ← AddYVars(C); MCS ← ∅; k ← 1; 4 while SAT(C′) ∧ k ≤MCSb do 5 C′k ← C ′ ∧ AtMost({¬y1,¬y2, ...,¬yn},k) 6 while SAT(C′k) do 7 newMCS ← ∅ 8 forall the indicator yi do 9 % yi indicator of the constraint ci ∈ C, and\nval(yi) is the value of yi in the solution calculated for C′k.\n10 si val(yi) = 0 alors 11 newMCS ← newMCS ∪ {ci}. 12 fin 13 end 14 MCS.add(newMCS). 15 C′k ← C ′ k ∧ BlockingClause(newMCS) 16 C′ ← C′ ∧ BlockingClause(newMCS) 17 end 18 k ← k + 1 19 end 20 return MCS 21 end\nAlgorithm 1: The algorithm of Liffiton and Sakallah\nBugAssist uses the tool CBMC [7] to generate the faulty trace and input data. For Max-SAT solver, we used MSUnCore2 [16].\nThe experiments were performed with a processor Intel Core i7-3720QM 2.60 GHz with 8 GO of RAM."
    }, {
      "heading" : "6.1 Benchmark without loops",
      "text" : "This part serves to illustrate the improvement in LocFaults to reduce the number of subsets of suspects instructions provided to the user: at a given step of the algorithm, the node in the CFG of the program that allows detect a MCD will be marked by the cardinality of the latter; in the next steps, the algorithm will not allow scanning an adjacency list of this node.\nOur results8 show that LocFaults misses errors only for TritypeKO6. While BugAssist misses errors for AbsMinusKO2, AbsMinusKO3, AbsMinusV2KO2 , TritypeKO , TriPerimetreKO, TriMultPerimetreKO and one of two errors in TritypeKO5. The times 9 of our tool are better compared to BugAssist for programs with numerical calculation; they are close for the rest of programs.\nWe randomly take three programs as examples. And we consider the implementation of two versions of our algorithm with and without marking nodes named respectively LocFaultsV1 and LocFaultsV2.\n• Tables 3 and 4 show respectively the suspects sets and times of LocFaultsV1 ;\n• Tables 5 and 6 show respectively the suspects sets and times of LocFaultsV2.\nIn tables 3 and 5, we display the list of calculated MCSs and MCDs. The line number corresponding to the condition\n8The table that shows the calculated MCSs by LocFaults for the programs without loops are available at http://www. i3s.unice.fr/~bekkouch/Benchs_Mohammed.html#rsb 9The tables that give the times of LocFaults and BugAssist for the programs without loops are available at http://www. i3s.unice.fr/~bekkouch/Benchs_Mohammed.html#rsba.\nis underlined. Tables 4 and 6 give calculation times: P is the pretreatment time which includes the translation of Java program into an abstract syntax tree with JDT tool (Eclipse Java devlopment tools), as well as the construction of CFG; L is the time of the exploration of CFG and calculation of MCSs. LocFaultsV2 has significantly reduced the deviations generated and the time summing exploration of the CFG and calculation of MCSs by LocFaultsV1, without losing the error; the localizations provided by LocFaultsV2 are more relevant. The eliminated lines of the table 5 are colored blue in the table3. The improved time are shown in bold in the table 4. For example, for the program TritypeKO2, at step 1 of the algorithm, LocFaultsV2 marks the node of condition 26, 35 and 53 (from the counterexample, the program becomes correct by deviating each of these three conditions). This allows, at step 2, to cancel the following deviations: {26, 29}, {26, 35}, {29, 35}, {32, 35}. Always in step 2, LocFaultsV2 detects two minimal correction deviations more: {29, 57}, {32, 44}, the nodes 57 and 44 will be marked (the value of the mark is 2). At step 3, no deviation is selected; for example, {29, 32, 44} is not considered because its cardinal is strictly superior to the mark value of the node 44."
    }, {
      "heading" : "6.2 Benchmarks with loops",
      "text" : "These benchmarks are used to measure the scalability of LocFaults compared to BugAssist for programs with loops, depending on the increase of unfolding b. We took three programs with loops : BubbleSort, Sum, and SquareRoot. We have caused the Off-by-one bug in each of them. The benchmark for each program is created by increasing the number of unfolding b. b is equal to the number of iterations through the loop in the worst case. We also vary the number of deviated conditions for LocFaults from 0 to 3.\nWe used the MIP solver of CPLEX for BubbleSort. For Sum and SquareRoot, we collaborate the two solvers of CPLEX (CP and MIP) during the localization process. Indeed, during the collection of constraints, we use a variable to keep the information on the type of building CSP. When LocFaults detects an erroneous path10 and prior to the calculation of MCSs, it takes the good solver depending on the type of CSP corresponding to this path : if it is non-linear, it uses the CP OPTIMIZER solver; otherwise it uses the MIP solver.\n10An erroneous path is the one on which we identify MCSs.\nFor each benchmark, we presented an extract of the table containing the computation time11 (columns P and L show respectively the time of pretreatment and calculating of MCSs), and the graph which corresponds to the time of calculation of MCSs.\n6.2.1 BubbleSort benchmark BubbleSort is an implementation of the bubble sort algo-\nrithm. This program contains two nested loops; its average complexity is O(n2), where n is the size of the table sorted : the bubble sort is considered among the worst sort algorithms. The erroneous statement in the program causes the program to sort input array by considering only its n − 1 first elements. The malfunction of BubbleSort is due to the insufficient number of iterations performed by the loop. This is due to the faulty initialization of the variable i : i = tab.length - 1; the instruction should be i = tab.length."
    }, {
      "heading" : "Sort",
      "text" : "11Full tables are available at http://www.i3s.unice.fr/ ~bekkouch/Benchs_Mohammed.html#ravb, the sources of these results are available at http://www.i3s.unice.fr/ ~bekkouch/Benchs_Mohammed.html#sr\nThe times of LocFaults and BugAssist for the benchmark BubbleSort are presented in the table 7. The graph illustrates the increase in times of different versions of LocFaults and of BugAssist depending on the number of unfolding is given in Figure 10.\nThe runtime of LocFaults and of BugAssist grows exponentially with the number of unfoldings; the times of BugAssist are always the greatest. We can consider that BugAssist is ineffective for this benchmark. The different versions of LocFaults (with at most 3, 2, 1, and 0 conditions deviated) remain usable up to a certain unfolding. The number of unfolding beyond which growth time of BugAssist becomes redhibitory is lower than that of LocFaults, that of LocFaults with at most 3 conditions diviated is lower than that of LocFaults with at most 2 conditions diviated which is also lower than that of LocFaults with at most 1 conditions diviated. The times of LocFaults with at most 1 and 0 conditions diviated are almost the same.\n6.2.2 SquareRoot and Sum benchmarks The program SquareRoot (see fig. 11) permits to find the\ninteger part of the square root of the integer 50. An error is injected at the line 13, which leads to return the value 8; while the program must return 7. This program has been used in the paper describing the approach BugAssist, it contains a linear numerical calculation in its loop and nonlinear in its postcondition.\nWith an unwinding limit of 50, BugAssist calculates for this program the following suspicious instructions: {9, 10, 11 , 13}. The time of localization is 36, 16s and the pretreatment time is 0, 12s. LocFaults displays a suspicious instruction by indicating both its location in the program (instruction line), the line of the condition and the iteration of each loop leading to this instruction. For example, {9 : 2.11} corresponds to the instruction that is on line 11 in the program, the latter is in a loop whose line of the stop condition is 9 and the iteration number is 2. The sets suspected by LocFaults are provided in the table 8.\nThe pretreatment time is 0, 769s. The time during the exploration of the CFG and the calculation of MCSs is 1, 299s. We studied the times of LocFaults and BugAssist of values of val ranging from 10 to 100 (the number of unfolding b used is equal to val), to study the combinatorial behavior of each tool for this program.\nThe program Sum takes a positive integer n from the user, and it calculates the value of ∑ n\ni=1 i. The postcondition\nspecifies that sum. The error in Sum is in the condition of its loop. It causes to calculate the sum ∑ n−1\ni=1 i instead of∑\nn i=1 i. This program contains linear numerical instructions in the core of the loop, and a nonlinear postcondition. The results in time for SquareRoot and Sum benchmarks are shown in the tables respectively 9 and 10. We also designed the graph that corresponds to the result of each benchmark, see respectively the graphs in Figure 12 and 13. The execution time of BugAssist grows rapidly; the times of LocFaults are almost constant. The times of LocFaults with at most 0, 1, and 2 conditions deviated are similar to those of LocFaults with at most 3 conditions deviated."
    }, {
      "heading" : "7. CONCLUSION",
      "text" : "The method LocFaults detects the suspicious subsets by analyzing the paths of the CFG to find the MCDs and MCSs from each MCD; it uses constraint solvers. The method BugAssit calculates the merger of MCSs of the program by transforming the whole program into a Boolean formula; it uses Max-SAT solvers. Both methods work by starting from a counterexample. In this paper, we presented an exploration of scalability of LocFaults, particularly on the treatment of loops with the Off-by-one bug. The first results show that LocFaults is more effective than BugAssist on\nprograms with loops. The times of BugAssist rapidly increase with the number of unfolding.\nAs part of our future work, we plan to validate our results on programs with more complex loops. We envisage to compare the performance of LocFaults with existing statistical methods. To improve our tool, we develop an interactive ver-\nsion that provides the suspect subsets, one after the other : we want to take advantage of the user’s knowledge to select the conditions that should be deviated. We also reflect on how to extend our method to treat numerical instructions with calculation on floating-point."
    }, {
      "heading" : "8. ACKNOWLEDGMENTS",
      "text" : "Thanks to Bertrand Neveu for his careful reading and helpful comments on this paper. Thanks to Michel Rueher and Hélène Collavizza for their interesting remarks. Thanks to You Li for his remarks on English mistakes."
    }, {
      "heading" : "9. REFERENCES",
      "text" : "[1] R. Abreu, P. Zoeteweij, and A. J. Van Gemund. On\nthe accuracy of spectrum-based fault localization. In Testing: Academic and Industrial Conference Practice and Research Techniques-MUTATION, 2007. TAICPART-MUTATION 2007, pages 89–98. IEEE, 2007.\n[2] M. Barnett and K. R. M. Leino. Weakest-precondition of unstructured programs. In ACM SIGSOFT Software Engineering Notes, volume 31, pages 82–87. ACM, 2005.\n[3] M. Bekkouche. Bug stories. In http: //www.i3s.unice.fr/~bekkouch/Bug_stories.html, 2015.\n[4] M. Bekkouche, H. Collavizza, and M. Rueher. Une approche csp pour l’aide à la localisation d’erreurs. arXiv preprint arXiv:1404.6567, 2014.\n[5] M. Bekkouche, H. Collavizza, and M. Rueher. Locfaults: A new flow-driven and constraint-based error localization approach*. In SAC’15, SVT track, 2015.\n[6] M. Y. Chen, E. Kiciman, E. Fratkin, A. Fox, and E. Brewer. Pinpoint: Problem determination in large, dynamic internet services. In Dependable Systems and Networks, 2002. DSN 2002. Proceedings. International Conference on, pages 595–604. IEEE, 2002.\n[7] E. Clarke, D. Kroening, and F. Lerda. A tool for checking ansi-c programs. In Tools and Algorithms for the Construction and Analysis of Systems, pages 168–176. Springer, 2004.\n[8] H. Collavizza, M. Rueher, and P. Van Hentenryck. Cpbpv: a constraint-programming framework for bounded program verification. Constraints, 15(2):238–264, 2010.\n[9] V. D’silva, D. Kroening, and G. Weissenbacher. A survey of automated techniques for formal software verification. Computer-Aided Design of Integrated Circuits and Systems, IEEE Transactions on, 27(7):1165–1178, 2008.\n[10] J. A. Jones and M. J. Harrold. Empirical evaluation of the tarantula automatic fault-localization technique. In Proceedings of the 20th IEEE/ACM international Conference on Automated software engineering, pages 273–282. ACM, 2005.\n[11] J. A. Jones, M. J. Harrold, and J. Stasko. Visualization of test information to assist fault localization. In Proceedings of the 24th international conference on Software engineering, pages 467–477. ACM, 2002.\n[12] M. Jose and R. Majumdar. Bug-assist: assisting fault localization in ansi-c programs. In Computer Aided Verification, pages 504–509. Springer, 2011.\n[13] M. Jose and R. Majumdar. Cause clue clauses: error localization using maximum satisfiability. ACM SIGPLAN Notices, 46(6):437–446, 2011.\n[14] K.-M. Leung. Debugging loops. In http://cis.poly. edu/~mleung/CS1114/s08/ch02/debug.htm.\n[15] M. H. Liffiton and K. A. Sakallah. Algorithms for computing minimal unsatisfiable subsets of constraints. Journal of Automated Reasoning, 40(1):1–33, 2008.\n[16] J. Marques-Silva. The msuncore maxsat solver. SAT, page 151, 2009.\n[17] Wikipedia. List of software bugs — wikipedia, the free encyclopedia. http://en.wikipedia.org/w/index.php?title=\nList_of_software_bugs&oldid=648559652, 2015. [Online; accessed 3-March-2015].\n[18] W. E. Wong and V. Debroy. A survey of software fault localization. Department of Computer Science, University of Texas at Dallas, Tech. Rep. UTDCS-45, 9, 2009."
    } ],
    "references" : [ {
      "title" : "On the accuracy of spectrum-based fault localization",
      "author" : [ "R. Abreu", "P. Zoeteweij", "A.J. Van Gemund" ],
      "venue" : "Testing: Academic and Industrial Conference Practice and Research Techniques-MUTATION, 2007. TAICPART-MUTATION 2007, pages 89–98. IEEE,",
      "citeRegEx" : "1",
      "shortCiteRegEx" : null,
      "year" : 2007
    }, {
      "title" : "Weakest-precondition of unstructured programs",
      "author" : [ "M. Barnett", "K.R.M. Leino" ],
      "venue" : "ACM SIGSOFT Software Engineering Notes, volume 31, pages 82–87. ACM,",
      "citeRegEx" : "2",
      "shortCiteRegEx" : null,
      "year" : 2005
    }, {
      "title" : "Bug stories",
      "author" : [ "M. Bekkouche" ],
      "venue" : "http: //www.i3s.unice.fr/~bekkouch/Bug_stories.html,",
      "citeRegEx" : "3",
      "shortCiteRegEx" : null,
      "year" : 2015
    }, {
      "title" : "Une approche csp pour l’aide à la localisation d’erreurs",
      "author" : [ "M. Bekkouche", "H. Collavizza", "M. Rueher" ],
      "venue" : "arXiv preprint arXiv:1404.6567,",
      "citeRegEx" : "4",
      "shortCiteRegEx" : null,
      "year" : 2014
    }, {
      "title" : "Locfaults: A new flow-driven and constraint-based error localization approach",
      "author" : [ "M. Bekkouche", "H. Collavizza", "M. Rueher" ],
      "venue" : "SAC’15, SVT track,",
      "citeRegEx" : "5",
      "shortCiteRegEx" : null,
      "year" : 2015
    }, {
      "title" : "Pinpoint: Problem determination in large, dynamic internet services",
      "author" : [ "M.Y. Chen", "E. Kiciman", "E. Fratkin", "A. Fox", "E. Brewer" ],
      "venue" : "Dependable Systems and Networks, 2002. DSN 2002. Proceedings. International Conference on, pages 595–604. IEEE,",
      "citeRegEx" : "6",
      "shortCiteRegEx" : null,
      "year" : 2002
    }, {
      "title" : "A tool for checking ansi-c programs",
      "author" : [ "E. Clarke", "D. Kroening", "F. Lerda" ],
      "venue" : "Tools and Algorithms for the Construction and Analysis of Systems, pages 168–176. Springer,",
      "citeRegEx" : "7",
      "shortCiteRegEx" : null,
      "year" : 2004
    }, {
      "title" : "Cpbpv: a constraint-programming framework for bounded program verification",
      "author" : [ "H. Collavizza", "M. Rueher", "P. Van Hentenryck" ],
      "venue" : "Constraints, 15(2):238–264,",
      "citeRegEx" : "8",
      "shortCiteRegEx" : null,
      "year" : 2010
    }, {
      "title" : "A survey of automated techniques for formal software verification",
      "author" : [ "V. D’silva", "D. Kroening", "G. Weissenbacher" ],
      "venue" : "Computer-Aided Design of Integrated Circuits and Systems, IEEE Transactions on,",
      "citeRegEx" : "9",
      "shortCiteRegEx" : "9",
      "year" : 2008
    }, {
      "title" : "Empirical evaluation of the tarantula automatic fault-localization technique",
      "author" : [ "J.A. Jones", "M.J. Harrold" ],
      "venue" : "Proceedings of the 20th IEEE/ACM international Conference on Automated software engineering, pages 273–282. ACM,",
      "citeRegEx" : "10",
      "shortCiteRegEx" : null,
      "year" : 2005
    }, {
      "title" : "Visualization of test information to assist fault localization",
      "author" : [ "J.A. Jones", "M.J. Harrold", "J. Stasko" ],
      "venue" : "Proceedings of the 24th international conference on Software engineering, pages 467–477. ACM,",
      "citeRegEx" : "11",
      "shortCiteRegEx" : null,
      "year" : 2002
    }, {
      "title" : "Bug-assist: assisting fault localization in ansi-c programs",
      "author" : [ "M. Jose", "R. Majumdar" ],
      "venue" : "Computer Aided Verification, pages 504–509. Springer,",
      "citeRegEx" : "12",
      "shortCiteRegEx" : null,
      "year" : 2011
    }, {
      "title" : "Cause clue clauses: error localization using maximum satisfiability",
      "author" : [ "M. Jose", "R. Majumdar" ],
      "venue" : "ACM SIGPLAN Notices, 46(6):437–446,",
      "citeRegEx" : "13",
      "shortCiteRegEx" : null,
      "year" : 2011
    }, {
      "title" : "Algorithms for computing minimal unsatisfiable subsets of constraints",
      "author" : [ "M.H. Liffiton", "K.A. Sakallah" ],
      "venue" : "Journal of Automated Reasoning, 40(1):1–33,",
      "citeRegEx" : "15",
      "shortCiteRegEx" : null,
      "year" : 2008
    }, {
      "title" : "The msuncore maxsat solver",
      "author" : [ "J. Marques-Silva" ],
      "venue" : "SAT, page 151,",
      "citeRegEx" : "16",
      "shortCiteRegEx" : null,
      "year" : 2009
    }, {
      "title" : "A survey of software fault localization",
      "author" : [ "W.E. Wong", "V. Debroy" ],
      "venue" : "Department of Computer Science, University of Texas at Dallas, Tech. Rep. UTDCS-45, 9,",
      "citeRegEx" : "18",
      "shortCiteRegEx" : null,
      "year" : 2009
    } ],
    "referenceMentions" : [ {
      "referenceID" : 2,
      "context" : "This link [3] cites recent stories of software bugs.",
      "startOffset" : 10,
      "endOffset" : 13
    }, {
      "referenceID" : 15,
      "context" : "It consists of identifying the exact locations of suspicious instructions [18] to help the user to understand why the program failed, which facilitates him in the task of error correction.",
      "startOffset" : 74,
      "endOffset" : 78
    }, {
      "referenceID" : 4,
      "context" : "To solve this problem, we have proposed an approach [5] (named LocFaults) based on constraints that explores the paths of CFG (Control Flow Graph) of the program from the counterexample, to calculate the minimal subsets to restore the program’s compliance with its postcondition.",
      "startOffset" : 52,
      "endOffset" : 55
    }, {
      "referenceID" : 8,
      "context" : "Ensuring that our method is highly scalable to meet the enormous complexity of software systems is an important criterion for its quality [9].",
      "startOffset" : 138,
      "endOffset" : 141
    }, {
      "referenceID" : 10,
      "context" : ": Tarantula [11] [10], Ochiai [1], AMPLE [1], Pinpoint [6].",
      "startOffset" : 12,
      "endOffset" : 16
    }, {
      "referenceID" : 9,
      "context" : ": Tarantula [11] [10], Ochiai [1], AMPLE [1], Pinpoint [6].",
      "startOffset" : 17,
      "endOffset" : 21
    }, {
      "referenceID" : 0,
      "context" : ": Tarantula [11] [10], Ochiai [1], AMPLE [1], Pinpoint [6].",
      "startOffset" : 30,
      "endOffset" : 33
    }, {
      "referenceID" : 0,
      "context" : ": Tarantula [11] [10], Ochiai [1], AMPLE [1], Pinpoint [6].",
      "startOffset" : 41,
      "endOffset" : 44
    }, {
      "referenceID" : 5,
      "context" : ": Tarantula [11] [10], Ochiai [1], AMPLE [1], Pinpoint [6].",
      "startOffset" : 55,
      "endOffset" : 58
    }, {
      "referenceID" : 12,
      "context" : "BugAssist [13] [12] is a BMC method of error localization using a Max-SAT solver to calculate the merger of MCSs of the",
      "startOffset" : 10,
      "endOffset" : 14
    }, {
      "referenceID" : 11,
      "context" : "BugAssist [13] [12] is a BMC method of error localization using a Max-SAT solver to calculate the merger of MCSs of the",
      "startOffset" : 15,
      "endOffset" : 19
    }, {
      "referenceID" : 1,
      "context" : "We use Dynamic Single Assignment (DSA) form [2] transformation that ensures that each variable is assigned only once on each path of the CFG.",
      "startOffset" : 44,
      "endOffset" : 47
    }, {
      "referenceID" : 8,
      "context" : "ERROR LOCALIZATION IN LOOPS As part of Bounded Model Checking (BMC) for programs, unfolding can be applied to the entire program or it can be applied to loops separately [9].",
      "startOffset" : 170,
      "endOffset" : 173
    }, {
      "referenceID" : 3,
      "context" : "Our algorithm LocFaults [4] [5] for error localization is placed in the second approach; that is to say, we use a bound b to unfold loops by replacing them with conditional statements nested of depth b.",
      "startOffset" : 24,
      "endOffset" : 27
    }, {
      "referenceID" : 4,
      "context" : "Our algorithm LocFaults [4] [5] for error localization is placed in the second approach; that is to say, we use a bound b to unfold loops by replacing them with conditional statements nested of depth b.",
      "startOffset" : 28,
      "endOffset" : 31
    }, {
      "referenceID" : 0,
      "context" : "PATH MCSs {CE : [tab0[0] = 3 ∧ tab0[1] = 2 ∧ tab0[2] = 1",
      "startOffset" : 35,
      "endOffset" : 38
    }, {
      "referenceID" : 1,
      "context" : "PATH MCSs {CE : [tab0[0] = 3 ∧ tab0[1] = 2 ∧ tab0[2] = 1",
      "startOffset" : 49,
      "endOffset" : 52
    }, {
      "referenceID" : 2,
      "context" : "{min2 = tab0[i1]} ∧tab0[3] == 0], min0 = tab0[0], i0 = 1, min1 = tab0[i0],i1 = i0 + 1,min2 = tab0[i1], i2 = i1 + 1,min3 = min2, i3 = i2, POST : [(tab[0] ≥ min3) ∧ (tab[1] ≥ min3) ∧(tab[2] ≥ min3) ∧ (tab[3] ≥ min3)]} {CE : [tab0[0] = 3 ∧ tab0[1] = 2 ∧ tab0[2] = 1 {i0 = 1}, ∧tab0[3] == 0], min0 = tab0[0], i0 = 1, {i1 = i0 + 1}, min1 = tab0[i0],i1 = i0 + 1,min2 = tab0[i1], {i2 = i1 + 1} i2 = i1 + 1,[¬(i2 ≤ tab0.",
      "startOffset" : 23,
      "endOffset" : 26
    }, {
      "referenceID" : 0,
      "context" : "{min2 = tab0[i1]} ∧tab0[3] == 0], min0 = tab0[0], i0 = 1, min1 = tab0[i0],i1 = i0 + 1,min2 = tab0[i1], i2 = i1 + 1,min3 = min2, i3 = i2, POST : [(tab[0] ≥ min3) ∧ (tab[1] ≥ min3) ∧(tab[2] ≥ min3) ∧ (tab[3] ≥ min3)]} {CE : [tab0[0] = 3 ∧ tab0[1] = 2 ∧ tab0[2] = 1 {i0 = 1}, ∧tab0[3] == 0], min0 = tab0[0], i0 = 1, {i1 = i0 + 1}, min1 = tab0[i0],i1 = i0 + 1,min2 = tab0[i1], {i2 = i1 + 1} i2 = i1 + 1,[¬(i2 ≤ tab0.",
      "startOffset" : 167,
      "endOffset" : 170
    }, {
      "referenceID" : 1,
      "context" : "{min2 = tab0[i1]} ∧tab0[3] == 0], min0 = tab0[0], i0 = 1, min1 = tab0[i0],i1 = i0 + 1,min2 = tab0[i1], i2 = i1 + 1,min3 = min2, i3 = i2, POST : [(tab[0] ≥ min3) ∧ (tab[1] ≥ min3) ∧(tab[2] ≥ min3) ∧ (tab[3] ≥ min3)]} {CE : [tab0[0] = 3 ∧ tab0[1] = 2 ∧ tab0[2] = 1 {i0 = 1}, ∧tab0[3] == 0], min0 = tab0[0], i0 = 1, {i1 = i0 + 1}, min1 = tab0[i0],i1 = i0 + 1,min2 = tab0[i1], {i2 = i1 + 1} i2 = i1 + 1,[¬(i2 ≤ tab0.",
      "startOffset" : 184,
      "endOffset" : 187
    }, {
      "referenceID" : 2,
      "context" : "{min2 = tab0[i1]} ∧tab0[3] == 0], min0 = tab0[0], i0 = 1, min1 = tab0[i0],i1 = i0 + 1,min2 = tab0[i1], i2 = i1 + 1,min3 = min2, i3 = i2, POST : [(tab[0] ≥ min3) ∧ (tab[1] ≥ min3) ∧(tab[2] ≥ min3) ∧ (tab[3] ≥ min3)]} {CE : [tab0[0] = 3 ∧ tab0[1] = 2 ∧ tab0[2] = 1 {i0 = 1}, ∧tab0[3] == 0], min0 = tab0[0], i0 = 1, {i1 = i0 + 1}, min1 = tab0[i0],i1 = i0 + 1,min2 = tab0[i1], {i2 = i1 + 1} i2 = i1 + 1,[¬(i2 ≤ tab0.",
      "startOffset" : 202,
      "endOffset" : 205
    }, {
      "referenceID" : 0,
      "context" : "{min2 = tab0[i1]} ∧tab0[3] == 0], min0 = tab0[0], i0 = 1, min1 = tab0[i0],i1 = i0 + 1,min2 = tab0[i1], i2 = i1 + 1,min3 = min2, i3 = i2, POST : [(tab[0] ≥ min3) ∧ (tab[1] ≥ min3) ∧(tab[2] ≥ min3) ∧ (tab[3] ≥ min3)]} {CE : [tab0[0] = 3 ∧ tab0[1] = 2 ∧ tab0[2] = 1 {i0 = 1}, ∧tab0[3] == 0], min0 = tab0[0], i0 = 1, {i1 = i0 + 1}, min1 = tab0[i0],i1 = i0 + 1,min2 = tab0[i1], {i2 = i1 + 1} i2 = i1 + 1,[¬(i2 ≤ tab0.",
      "startOffset" : 241,
      "endOffset" : 244
    }, {
      "referenceID" : 1,
      "context" : "{min2 = tab0[i1]} ∧tab0[3] == 0], min0 = tab0[0], i0 = 1, min1 = tab0[i0],i1 = i0 + 1,min2 = tab0[i1], i2 = i1 + 1,min3 = min2, i3 = i2, POST : [(tab[0] ≥ min3) ∧ (tab[1] ≥ min3) ∧(tab[2] ≥ min3) ∧ (tab[3] ≥ min3)]} {CE : [tab0[0] = 3 ∧ tab0[1] = 2 ∧ tab0[2] = 1 {i0 = 1}, ∧tab0[3] == 0], min0 = tab0[0], i0 = 1, {i1 = i0 + 1}, min1 = tab0[i0],i1 = i0 + 1,min2 = tab0[i1], {i2 = i1 + 1} i2 = i1 + 1,[¬(i2 ≤ tab0.",
      "startOffset" : 255,
      "endOffset" : 258
    }, {
      "referenceID" : 2,
      "context" : "{min2 = tab0[i1]} ∧tab0[3] == 0], min0 = tab0[0], i0 = 1, min1 = tab0[i0],i1 = i0 + 1,min2 = tab0[i1], i2 = i1 + 1,min3 = min2, i3 = i2, POST : [(tab[0] ≥ min3) ∧ (tab[1] ≥ min3) ∧(tab[2] ≥ min3) ∧ (tab[3] ≥ min3)]} {CE : [tab0[0] = 3 ∧ tab0[1] = 2 ∧ tab0[2] = 1 {i0 = 1}, ∧tab0[3] == 0], min0 = tab0[0], i0 = 1, {i1 = i0 + 1}, min1 = tab0[i0],i1 = i0 + 1,min2 = tab0[i1], {i2 = i1 + 1} i2 = i1 + 1,[¬(i2 ≤ tab0.",
      "startOffset" : 278,
      "endOffset" : 281
    }, {
      "referenceID" : 0,
      "context" : "{tab[0] = 3, tab[1] = 2, tab[2] = 1, tab[3] = 0}, we illustrated in Figure 8 the initial faulty path (see the colorful path in red) and the deviation for which the postcondition is satisfiable (the deviation and the path above the deviated condition are shown in green).",
      "startOffset" : 16,
      "endOffset" : 19
    }, {
      "referenceID" : 1,
      "context" : "{tab[0] = 3, tab[1] = 2, tab[2] = 1, tab[3] = 0}, we illustrated in Figure 8 the initial faulty path (see the colorful path in red) and the deviation for which the postcondition is satisfiable (the deviation and the path above the deviated condition are shown in green).",
      "startOffset" : 28,
      "endOffset" : 31
    }, {
      "referenceID" : 2,
      "context" : "{tab[0] = 3, tab[1] = 2, tab[2] = 1, tab[3] = 0}, we illustrated in Figure 8 the initial faulty path (see the colorful path in red) and the deviation for which the postcondition is satisfiable (the deviation and the path above the deviated condition are shown in green).",
      "startOffset" : 40,
      "endOffset" : 43
    }, {
      "referenceID" : 0,
      "context" : "This information could CE:{tab0[0] == 3 ∧ tab0[1] == 2 ∧ tab0[2] == 1 ∧ tab0[3] == 0}",
      "startOffset" : 46,
      "endOffset" : 49
    }, {
      "referenceID" : 1,
      "context" : "This information could CE:{tab0[0] == 3 ∧ tab0[1] == 2 ∧ tab0[2] == 1 ∧ tab0[3] == 0}",
      "startOffset" : 61,
      "endOffset" : 64
    }, {
      "referenceID" : 2,
      "context" : "This information could CE:{tab0[0] == 3 ∧ tab0[1] == 2 ∧ tab0[2] == 1 ∧ tab0[3] == 0}",
      "startOffset" : 76,
      "endOffset" : 79
    }, {
      "referenceID" : 7,
      "context" : "To generate the CFG and the counterexample, we use the tool CPBPV [8] (Constraint-Programming Framework for Bounded Program Verification).",
      "startOffset" : 66,
      "endOffset" : 69
    }, {
      "referenceID" : 13,
      "context" : "We adapted and implemented the algorithm of Liffiton and Sakallah [15], see alg.",
      "startOffset" : 66,
      "endOffset" : 70
    }, {
      "referenceID" : 6,
      "context" : "BugAssist uses the tool CBMC [7] to generate the faulty trace and input data.",
      "startOffset" : 29,
      "endOffset" : 32
    }, {
      "referenceID" : 14,
      "context" : "For Max-SAT solver, we used MSUnCore2 [16].",
      "startOffset" : 38,
      "endOffset" : 42
    } ],
    "year" : 2015,
    "abstractText" : "A model checker can produce a trace of counterexample, for an erroneous program, which is often long and difficult to understand. In general, the part about the loops is the largest among the instructions in this trace. This makes the location of errors in loops critical, to analyze errors in the overall program. In this paper, we explore the scalability capabilities of LocFaults, our error localization approach exploiting paths of CFG(Control Flow Graph) from a counterexample to calculate the MCDs (Minimal Correction Deviations), and MCSs (Minimal Correction Subsets) from each found MCD. We present the times of our approach on programs with While-loops unfolded b times, and a number of deviated conditions ranging from 0 to n. Our preliminary results show that the times of our approach, constraint-based and flow-driven, are better compared to BugAssist which is based on SAT and transforms the entire program to a Boolean formula, and further the information provided by LocFaults is more expressive for the user.",
    "creator" : "dvips(k) 5.991 Copyright 2011 Radical Eye Software"
  }
}