{
  "name" : "1411.4379.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : "FGPGA: An Efficient Genetic Approach for Producing Feasible Graph Partitions",
    "authors" : [ "Md. Lisul Islam", "Novia Nurain", "Swakkhar Shatabda", "M Sohel Rahman" ],
    "emails" : [ "swakkhar}@cse.uiu.ac.bd,", "msrahman@cse.buet.ac.bd" ],
    "sections" : [ {
      "heading" : "1 Introduction",
      "text" : "Graph partitioning, a well-known problem of computer science and engineering, is widely used and studied in diversified practical and theoretical applications. Applications include parallel/distributed computing (load balancing of computations), scientific computing (fill-reducing matrix re-orderings), EDA algorithms for VLSI CAD (placement), data mining (clustering), social network analysis (community discovery), pathological and biological network analysis (detection of cliques), pattern recognition, and relationship network analysis. The goal of graph partitioning problem is to divide the vertices of a graph into sets of specified sizes, so that few edges cross between sets (i.e., minimizes a cut metric).\nRecently, the graph partition problem has gained importance due to its gleaming applications in mobile cloud computing such as offloading parts of a software from the mobile hand set to a more resourceful server (Fig. 1). Such offloading poses challenges to both cloud user and cloud vendor while allocating different software components to machines in the cloud minimizing the required bandwidth. A special case of such deployment optimization occurs in cloudlet [1,2], where multiple mobile devices access nearby static resourceful computers linked to a distant cloud through high speed wired connections. A global optimization is required taking into account all the software\n∗†On a Sabbatical leave from BUET.\nar X\niv :1\n41 1.\n43 79\nv1 [\ncs .N\nE ]\n1 7\ncomponents of all devices. Moreover, a fast algorithm would also be required to adopt with the changes of optimal software deployment in the cloud with respect to time.\nSuch problem can be modeled as graph partitioning problem. Here, the weighted graph of software components has to be partitioned into a number of partitions, and each partition will be deployed in the available machines of the cloud. In this paper, we focus on determining an efficient graph partition approach to partition the different components of a software application to deploy on a number of machines with different capacities in the cloud. Here, our goal is to determine partitions such that each partition minimizes the cost of communication between the components. This problem can be viewed as an ILP (Integer Linear Programming) problem. ILP solver (IBM ILOC CPLEX [3]) could be used to determine an optimal partition of the graph. However, the time and resource requirement depend on the cardinality of the graph. Both computation time and resource utilization grows exponentially with the increase in the graph size. Therefore, heuristic approaches are needed to find a good solution faster. Many heuristics of different nature (spectral [4], combinatorial [5], evolutionist [6, 7], etc.) have been developed to provide an approximate result in a reasonable (and, one hopes, linear) computational time. Others existing approaches of graph partitioning such as Kernighan-Lin algorithm [9] fails to scale to large scale graph data. Beside, all the existing methods partition the graph in to a predefined number of parts of equal sizes. In the context of mobile cloud computing, the number of partitions (i.e., the number of machines on which the components of the software will be deployed) is not predefined. Moreover, we need to take into account the diverse capacity of the machines in the cloud while deploying the software components. Therefore, existing graph partitioning algorithms cannot be directly applied to resolve such problem.\nThe authors of [8] have introduced a graph partitioning algorithm based on simulated annealing [14] for software deployment in the cloud. However, they consider only the homogeneous machines. Moreover, their proposed solution tends to give infeasible solution in some cases. Therefore, in this paper, we introduce an efficient genetic approach for producing feasible graph partitions. We name our approach as FGPGA. To resemble real scenarios of mobile cloud computing, our proposed method takes into account the existence of heterogeneity of machines along with different capacities of machines in the cloud. Moreover, feasible partitions of the components of software are ensured by discarding over sized partitions generated during the search. To summarize, in this paper, we make the following contributions:\n• We introduce an efficient genetic approach for producing feasible graph partitions named FGPGA to partition different components of a software application on to a number interconnected machines in the cloud minimizing the communication cost\n• We consider heterogeneity and capacity constraint of the machines to resemble real scenarios\n• We guarantee feasible partition by disallowing over-sized partitions during the search, and\n• Finally, we perform extensive experiments to prove the efficacy and efficiency of our proposed approach.\nSection 2 formally describes our problem and necessary background required. Section 3 reviews related works. In Section 4, we describe our proposed FGPGA method. Section 5 provides a detailed experimental evaluation of our algorithm compared with some existing simulated annealing algorithm and tests the efficacy and efficiency of our method. And finally in Section 6, we draw a conclusion with future work."
    }, {
      "heading" : "2 Preliminaries",
      "text" : "In this section, we provide a formal definition of the graph partitioning problem addressed in this paper and a brief description of genetic algorithms."
    }, {
      "heading" : "2.1 Problem Model",
      "text" : "We adopted the problem model described in [8]. However, the authors in [8] used only homogeneous machines and assumed the machine graph to be complete and all edges in the machine graph to have same weight. In our problem, we are given two graphs: application graph GA and the machine graph GM . The application graph, GA = (V,E) is an undirected weighted graph where the vertices of the graph represents distributed software units of deployment in the system and the edges corresponds to the communication cost between pair of software units. The vertices of this graph are also weighted. Each vertex vi ∈ V is associated with an weight ri. Weight of a vertex corresponds to the amount of resource required for this unit deployment. Examples of such resource is CPU power. The adjacency matrix W for this graph GA contains the weights for the edges, For each wij ∈ W , wij represents communication overhead between software component vi and software component vj .\nThe infrastructure of the distributed system is also modeled as an weighted undirected graph GM = (M,L), where M is the set of heterogeneous machines and L represents the communication links between each machines. Each machine, mi ∈M has a maximum capacity Ci that represents the capacity of machine mi in terms of resources (i.e. CPU power). Communication link costs are found from the adjacency matrix B for this graph GM . For a link lij between machine mi and machine mj corresponds to a communication cost, bij ∈ B.\nNow, the problem is to find a mapping φ : V → M of the vertices in V of GA to the vertices in M of GM . The mapping φ assigns each of the software component v ∈ V to a machine m ∈ M . The objective of this mapping or partition is to minimize the graph cut size (GCS) defined as following:\nGCS = Σ i,j wij × bφ(vi)φ(vj) × hij (1)\nHere, hij defined depending whether two deployment units i and j are assigned to same machine or different. The definition is as follows:\nhij =\n{ 0, if φ(vi) = φ(vj)\n1, if φ(vi) 6= φ(vj) (2)\nSince the machines to which the units are deployed have a maximum capacity, we need another constraint that defines the feasibility of the partitions. This is a hard constraint defined in the following equation:\n∀k : Σ i ri × Φ(i, k) ≤ Ck (3)\nHere Φ(i,m) is a binary valued function that returns true only if software unit, i is assigned to machine m. Formally,\nΦ(i, k) = { 0, if , φ(vi) 6= mk 1, if , φ(vi) = mk\nIn this model, Equation 1 defines the objective function for a balanced partition and the hard constraint defined in Equation 3 ensures feasibility of the partitions."
    }, {
      "heading" : "2.2 Genetic Algorithms",
      "text" : "Genetic Algorithms are population-based search methods that resemble the natural phenomena of biological evolution. Genetic Algorithms are widely used for different search optimization problems in different fraternity. Genetic algorithms maintains a set of solutions known as population. Generally, it starts with a pool of initial random solutions which is called the initial population. Each individual in the population are encoded by a set of properties which are called chromosome or genotype which can be altered for attaining diversification in the population. It then follows an iterative process in which each of these iteration is called a generation. In each generation, the population are then allowed to evolve using different operators which also mimics the natural process of biological evolution like mutation, recombination or crossover and survival of the fittest. In each generation, the fitness of each individual is evaluated. Generally the fitness is the value of the optimization function being considered to be solved. The more fit individuals are usually selected to breed and generate new fitter individuals in the population. Thus a new generation of population is ‘breeded’ and are used in the next generation. This process of evolution are continues until a sufficient number of generations has been produced or a satisfactory level of fitness value has been attained."
    }, {
      "heading" : "3 Related work",
      "text" : "Graph partitioning has variuos applications in diversified research areas, such as parallel computing, circuit layout and the design of many serial algorithms. The term graph partitioning refers to partition the vertices of a graph into a certain number of disjoint sets of approximately the same size, so that a cut metric is minimized. Graph partitioning is a NP-complete [11] problem and that there is no approximation algorithm with a constant ratio factor for general graphs [11]. Because of this theoretical limitation, numerous heuristic algorithms for graph partitioning have been developed during the past decades that generate high-quality partitions in very little time.\nMotivated by the problem of partitioning electronic circuits onto boards a heuristic method is produced in [9]. This method is known as the Kernighan-Lin (KL) algorithm. The Kernighan-Lin algorithm subsequently improved in terms of running time by Fiduccia and Mattheyses [12]. The spectral bisection method is another popular method, which is based on the spectrum of the graphs Laplacian matrix [7, 13]. However, this method has chances to stuck in local optima. In order to escape from the local optima these methods can be combined with different stochastic methods such as simulated annealing [14], particle swarm optimization [15], or ant colony optimization [16]. Besides, all these methods do not scale to large scale graph data.\nOne recent approach that has greatly accelerated the partitioning of large graphs is the use of multilevel techniques [10]. In multilevel approach, the graph is approximated by a sequence of increasingly smaller graphs. This graph is then partitioned using a spectral method [17] and this partition is propagated back through the hierarchy of graphs.\nA variant of the Kernighan-Lin algorithm is applied periodically to refine the partition. Well-known software packages based on this approach include Jostle [18], Metis [19], and Scotch [20].\nRecently graph partitioning algorithms are combined with different known techniques to develop new heuristics. Chardaire et al. use a PROBE (Population Reinforced Optimization Based Exploration) heuristic [21]. Here, the authors combine greedy algorithms and genetic algorithms with KL refinement. Besides, Loureiro and Amaral introduce a greedy graph growing heuristic deploying a local refinement algorithm [22].\nAll these above graph partition methods consider a fixed and predefined size of partitions while partitioning the graphs. This characteristic restricts the usages of traditional methods directly for cloud computing. Hence, the authors of [8], proposed a graph partitioning algorithm based on simulated annealing for mobile cloud computing. Here, the authors consider the different capacities of machines along with the variation in the number of the machines on which the components of software are to be deployed. However, their approach provides infeasible solution for some cases.\nIn this paper, we propose an efficient genetic algorithm for producing feasible graph partitions considering both the number and capacities of heterogeneous machines in the cloud. Extensive experimental result proves the efficacy and efficiency of our proposed method."
    }, {
      "heading" : "4 FGPGA: Our Proposed Method",
      "text" : "Our proposed FGPGA algorithm is formally presented in Algorithm 5. The population of the first generation in our algorithm contains only feasible individuals which are initialized randomly. Our algorithm will terminate at convergence and convergence is achieved when, for a given span of generation, there has been noticed no substantial amount of improvement on the quality of the global best solutions. For each generation, our algorithm selects individuals using tournament selection to take part in the recombination(also known as cross-over) to produce offspring to be included in the next generation. A probabilistic mutation is also performed on each of the newly breed individual. Individual with best fitness value is always retained to the next generation to ensure elitism. To maintain diversification among the individuals in the search space and to recover from stagnation along the process of evolution, we initiate twin removal and random restart procedure periodically. Rest of this section are devoted to describe various components of FGPGA. Table 1 summarizes all the necessary parameters along with their values."
    }, {
      "heading" : "4.1 Encoding",
      "text" : "In our method, we have encoded every individual in a population by V number of genes. Here, V is the number of component in a software application. Each of these genes in an individual is initialized randomly from an uniform distribution of the range [1,M ] where M is the total number of heterogeneous machines in machine graph. So,\nan individual X can be represented as the ordered list of V number of genes, where each gene Xi represents an assignment of a software component into a machine.\nX = {X1, X2, X3, . . . , XV }\nHere, Xi represents the machine to which componenti has been assigned."
    }, {
      "heading" : "4.2 Initialization",
      "text" : "Each individual in the population represents an assignment of component of the application software into a physical heterogeneous machine which has got some capacity constraints. So, if a machine is assigned to host a component or set of components whose aggregated capacity requirement is more than the capacity of the respective machine, then we can call such set of assignment invalid or declare that individual as an non-feasible solution of the graph partitioning problem. So, during the initialization of the population, we looked for solutions or individuals in the feasible search space only, thus creating a population consisting feasible individuals only. For each gene in the genotype of an individual, we repeatedly looked for a machine with enough capacity to host the ith component of the application software. A sketch of the pseudo-code for initialization procedure is given below:\nAlgorithm 1: Initialization (Individual X)\n1 M = total number of machines in the infrastructure 2 for each gene X(i) in the genotype of X do 3 find a machine m randomly chosen from U(1,M) such that free(m) ≥W (i) 4 set X(i) to m\n5 return X"
    }, {
      "heading" : "4.3 Greedy Mutation",
      "text" : "In our proposed algorithm, we adopted and introduced a greedy mutation strategy where we choose the new value of a particular gene of an individual optimally. We randomly alter a particular gene by trying out r different values for that gene and finally retain the value from those r different values that makes the individual fittest while still keeping it in the feasible region of search space. An example of greedy mutation is demonstrated in Figure 2. Here, r is set to the number of machines in the infrastructure. As greedy mutation is computationally cumbersome, we make selection between the random mutation and greedy mutation with a probability, GreedyMutationRate(= 0.8). If no feasible individual is found by mutating the currently selected gene, we then try out a different gene in the chromosome to mutate. The algorithm for greedy mutation is given in Algorithm 2.\nAlgorithm 2: Greedy Mutation (individual X)\n1 set r = number of machines 2 for each gene X(i) in the genotype of X do 3 S = set of r random values for gene X(i) from the range [1, r] 4 find v ∈ S for which fitness(X) is minimum and X(i = v) will be a feasible solution 5 set, X(i) = v\n6 return X\nBefore mutation"
    }, {
      "heading" : "4.4 Cross-over",
      "text" : "Cross-over operator aids the genetic evolution to exploit the fitter solutions found in the previous generations and generates new individuals by allowing fitter individuals to breed among themselves. To select individuals that will act as parents and take part in the recombination to produce offspring, we adopted tournament selection with the tournament size being equal to 5. Then, genes of the two parents are recombined using One-Point Crossover to generate a new set of gene for each of the newly formed offspring. Figure 3 depicts an example of cross-over process. We tried out different cross-over point until we end up feasible offspring. If no feasible off-springs are found using the current parents, we then try out different parents by using tournament selection to generate feasible offspring. The algorithm is outlined in Algorithm 3.\nAlgorithm 3: Cross-Over (individual X1, individual X2)\n1 Xnew1 and Xnew2 be two new offspring 2 for i=1 to number of genes in the chromosome of X1 do 3 randomly choose a crossover point k 4 generate Xnew1 and Xnew2 considering k as crossover point 5 if atleast one of Xnew1 or Xnew2 is feasible then 6 return Xnew1, Xnew2 7 return null"
    }, {
      "heading" : "4.5 Fitness Evaluation",
      "text" : "We have ensured feasibility in the initialization, mutation and crossover. So, the search process will always explore within the feasible search space region. We have evaluated the fitness of an individual X by using equation 1."
    }, {
      "heading" : "4.6 Twin Removal",
      "text" : "We have removed and reinitialized individuals with identical genetic information. We have defined the similarity measure between two individuals as the hamming distance of their corresponding genotype. Similarity between individual X1 and X2, Similarity(X1,X2) is defined below as:\nnumber of i such that X1(i) not equal to X2(i)\nsize of the genotype\nWe declare X1 and X2 as twins, if they have more than 95% similarity in their genotype and reinitialize randomly one of them to a feasible solution. We have run the this Twin Removal procedure after every 100 generations of evolution.\nAlgorithm 4: Twin Removal\n1 similarityThreshold = 0.95 2 for each pair of individuals (Xi, Xj) in the population do 3 if Similarity(Xi, Xj) ≥ similarityThreshold then 4 declare Xi and Xj as Twins 5 reinitialize Xj"
    }, {
      "heading" : "4.7 Random Restart",
      "text" : "If the algorithm does not improve the fitness of the best individual within a significant number of generations, we reinitialize 50% individuals of the population with random values within the feasible search space. We have evaluated the improvement over the immediate past 50 generations. If the improvement in the last 50 generations is less than or equal to a threshold, t = 0.001, we initiate the random restart procedure.\nAlgorithm 5: FGPGA()\n1 nonDiverseSteps = 0 2 nonImprovingSteps = 0 3 GreedyMutationRate = 0.8 4 Intialize the population, P randomly 5 while Termination criterion are met do 6 Pnew = {globalBest} 7 for each Individual X ∈ P do 8 〈X1, X2〉 = tournamentSelection(P ) 9 Xnew = crossOver(X1, X2)\n10 if Fitness(Xnew1) ≥ Fitness(Xnew2)X then 11 add Xnew1 to Pnew 12 else 13 add Xnew2 to Pnew 14 for each Individual X in Pnew do 15 if rand(0, 1) ≤ GreedyMutationRate then 16 greedyMutate(X) 17 else 18 randomMutate(X) 19 find the individual Xbest ∈ Pnew with best fitness 20 if fitness(globalBest) < fitness(Xbest) then 21 globalBest = Xbest 22 nonImprovingSteps = 0\n23 else 24 nonImprovingSteps+ + 25 if nonDiverseSteps ≥ twinRemovalInterval then 26 activate twinRemoval(Pnew) procedure 27 nonDiverseSteps = 0\n28 else 29 nonDiverseSteps+ + 30 if nonImprovingSteps ≥ randomRestartInterval then 31 activate randomRestart(Pnew) procedure 32 nonImprovingSteps = 0\n33 P = Pnew 34 return globalBest"
    }, {
      "heading" : "5 Experimental Results",
      "text" : "We have implemented FGPGA in Java programming language using JDK 1.6 and have run our experiments on an Intel(R) Core(TM)2 Quad CPU @ 2.40 GHz with 4GB RAM running Windows 7 operating system."
    }, {
      "heading" : "5.1 Dataset Generation",
      "text" : "To evaluate the performance of our algorithm we generate test graphs following method similar to described in [8]. However, the authors in [8] assumed the infrastructure to be homogeneous. As a result, they considered ∀i, jbi,j = 1, which means the communication between the machines in the cloud infrastructure are all uniform and the machine graph is a complete graph. Such instances are not realistic since they do not consider the heterogeneity of the infrastructure. We modify the graph generation technique to generate test cases that generates graphs with different node sizes and machine graph with heterogeneous communication links between them.\nWe generated sparse graphs with the Eppstein power law generator. The weights of the vertices and edges are taken from exponential distributions with the parameter, λ equal to 0.1 and 0.005 respectively. For the machine graph, first we determined the capacity needed for the deployment and multiply it by 1.5 to ensure feasible infrastructure. Then machines were generated with capacity chosen randomly from {100, 200, · · · , 800}. Machine graph is also generated as a sparse graph with edge weights generated using an exponential distribution with parameter, λ = 0.005."
    }, {
      "heading" : "5.2 Algorithm Comparison",
      "text" : "We compared our method with the simulated annealing method proposed in [8]. In [8], a number of algorithms was proposed and applied to solve the graph partitioning problem. Among all the algorithms simulated annealing algorithm produced higher quality solutions for most of the graph instances that they used. We implemented the simulated annealing procedure described in their paper and compared it with FGPGA. In their simulated annealing [8], they allow infeasible moves or assignments fo vertices to partitions that are already over-sized and allow the capacity constraint to be violated. In their paper, they [8] mention that due to the decrease in temperature in later epochs the rate of taking infeasible moves will decrease also and thus produce valid solution when the algorithm terminates. However, there is no guarantee for producing feasible solutions, once an infeasible move is taken. We observed that, our implementation of simulated annealing algorithm failed to produce any feasible solutions for most of the graph instances. It allows an infeasible solution at a higher temperature and further moves are not able to alter that solution to revert back to feasibility. To tackle this problem, we slightly modified the simulated annealing algorithm by not allowing the moves that turns any particular partition or machine to be over-loaded or the capacity constraint to be violated. Rather, a random move is allowed with the same metropolis condition instead of the infeasible move. Detail of the rest of the algorithm can be found in [8]. Rest of the parameters were kept similar as described in the original paper. Since simulated annealing take long to converge, we allowed it to finish the epochs as described in [8]. However, FGPGA were run for 6000 generations for smaller instances (≤ 500 nodes) and for 3000 generations for largers instances (≥ 600 nodes)."
    }, {
      "heading" : "5.3 Results",
      "text" : "We report best and average graph cut size for the best partitions found by two algorithms simulated annealing and FGPGA in Table 2. Each algorithms were run 10 times for each of the graph instances and the average is reported in the table. Each row corresponds to the results for a particular graph instance. Values in bold faced fonts indicates the better quality partitions with lower graph cut size. Table 2 clearly shows that FGPGA is able to produce better quality partitions in all the cases.\nTo show the significance of improvement of FGPGA over simulated annealing we plot the best and average of graph cut size of the best partitions found by both of the algorithms for each of the graph instances in Figure 4 and Figure 5 . We could see the difference in the quality of the partitions generated by both algorithms. Note that both algorithms produce partitions with relatively high cost for the graph instances with larger number of vertices. Both graph shows that the cut size increases with the increase in the number of vertices in an instance and the improvement of FGPGA also increases compared to the simulated annealing algorithm."
    }, {
      "heading" : "5.4 Convergence",
      "text" : "Strength of our genetic approach is that it converges quickly compared to the simulated annealing algorithm. Search progress for two algorithms are shown in Figure 6. We plot graph cut size of the best partition in each iteration of simulated annealing algorithms over the epochs and for each generation of genetic algorithms until they converge and terminate.\nThe curves in Figure 6 indicates the earlier convergence of FGPGA. FGPGA converges quickly and terminates while simulated annealing fails to improve the quality of the partition even if the temperature is higher. This plot is showing the behavior of the algorithms for the graph instance 1 with number of vertices 100. Other graph instances show similar behavior."
    }, {
      "heading" : "5.5 Effect of Greedy Mutation",
      "text" : "To show the effect of greedy mutation operator we prepare another version of the FGPGA algorithm by turning the greedy mutation off. In this version of FGPGA, the greedy mutation operator is replaced by a traditional random mutation operator. This operator selects the first valid mutation possible for any randomly selected gene value. The plot of logarithm of graph cut size is shown for each of the versions in Figure 7. Figure 7 clearly shows the early convergence of greedy mutation operator."
    }, {
      "heading" : "6 Conclusion",
      "text" : "The recent emergence of mobile cloud computing leads to a new domain of challenges such as optimal deployment of software applications on the more resourceful infrastructure in the cloud instead of mobile hand set. Such problems can easily be modeled as a graph partitioning problem where a weighted graph of software components needed to be partitioned in a number of parts representing the available infrastructures (i.e., machines) in the cloud. Therefore, in this paper, we have introduced FGPGA, an efficient genetic approach for producing feasible graph partitions. Our method takes into account the heterogeneity and capacity constraints of the partitions that resemble real scenario of mobile cloud computing. Feasibility of the partitions generated is ensured by discarding over-sized partitions during the search. Experimental results exhibit the superiority of our proposed method on standard benchmark datasets over the state-of-the-art methods in terms of quality of partitions and feasibility of the solutions. Our algorithm is light weight and hence suitable for use in cloud architecture. In future we would like to deploy our algorithm to real architecture to investigate the performance of our proposed method for real world data."
    } ],
    "references" : [ {
      "title" : "The Case for VM-Based Cloudlets in Mobile Computing",
      "author" : [ "M. Satyanarayanan", "P. Bahl", "R. Caceres", "N. Davies" ],
      "venue" : "IEEE Pervasive Computing,",
      "citeRegEx" : "1",
      "shortCiteRegEx" : "1",
      "year" : 2009
    }, {
      "title" : "Cloudlets: bringing the cloud to the mobile user",
      "author" : [ "T. Verbelen", "P. Simoens", "F. De. Turck", "B. Dhoedt" ],
      "venue" : "In Proceedings of the 3 ACM workshop on Mobile Cloud Computing and Services,",
      "citeRegEx" : "2",
      "shortCiteRegEx" : "2",
      "year" : 2012
    }, {
      "title" : "Partitioning sparse matrices with eigenvectors of graphs",
      "author" : [ "A. Pothen", "H.D. Simon", "K.-P. Liou" ],
      "venue" : "SIAM J. Matrix Anal. Appl.,",
      "citeRegEx" : "4",
      "shortCiteRegEx" : "4",
      "year" : 1990
    }, {
      "title" : "A Linear-Time Heuristic for Improving Network Partitions",
      "author" : [ "C.M. Fiduccia", "R.M. Mattheyses" ],
      "venue" : "In 19 Conference on Design Automation,",
      "citeRegEx" : "5",
      "shortCiteRegEx" : "5",
      "year" : 1982
    }, {
      "title" : "Genetic algorithm and graph partitioning",
      "author" : [ "T.N. Bui", "B.R. Moon" ],
      "venue" : "IEEE Trans. Comput.,",
      "citeRegEx" : "6",
      "shortCiteRegEx" : "6",
      "year" : 1996
    }, {
      "title" : "Spectral techniques for graph bisection in genetic algorithms",
      "author" : [ "J.G. Martin" ],
      "venue" : "IEEE In Proceedings GECCO’06,",
      "citeRegEx" : "7",
      "shortCiteRegEx" : "7",
      "year" : 2006
    }, {
      "title" : "Graph partitioning algorithms for optimizing software deployment in mobile cloud computing",
      "author" : [ "T. Verbelen", "T. Stevens", "F. De. Turck", "B. Dhoedt" ],
      "venue" : "Future Gener. Comput. Syst.,",
      "citeRegEx" : "8",
      "shortCiteRegEx" : "8",
      "year" : 2013
    }, {
      "title" : "An effcient heuristic procedure for partitioning graphs",
      "author" : [ "B.W. Kernighan", "S. Lin" ],
      "venue" : "The Bell System Technical Journal,",
      "citeRegEx" : "9",
      "shortCiteRegEx" : "9",
      "year" : 1970
    }, {
      "title" : "Parallel multilevel k-way partitioning scheme for irregular graphs",
      "author" : [ "G. Karypis", "V. Kumar" ],
      "venue" : "In Supercomputing,",
      "citeRegEx" : "10",
      "shortCiteRegEx" : "10",
      "year" : 1996
    }, {
      "title" : "Finding good approximate vertex and edge partitions is NP-hard",
      "author" : [ "T.N. Bui", "C. Jones" ],
      "venue" : "Inf. Process. Lett.,",
      "citeRegEx" : "11",
      "shortCiteRegEx" : "11",
      "year" : 1992
    }, {
      "title" : "A linear-time heuristic for improving network partitions",
      "author" : [ "C. Fiduccia", "R. Mattheyses" ],
      "venue" : "In Design Automation,",
      "citeRegEx" : "12",
      "shortCiteRegEx" : "12",
      "year" : 1982
    }, {
      "title" : "Pmrsb: Parallel multilevel recursive spectral bisection",
      "author" : [ "S. Barnard" ],
      "venue" : "In Supercomputing,",
      "citeRegEx" : "13",
      "shortCiteRegEx" : "13",
      "year" : 1995
    }, {
      "title" : "An effective multi-level algorithm based on simulated annealing for bisecting graph",
      "author" : [ "L. Sun", "M. Leng" ],
      "venue" : "Lecture notes in Computer Science",
      "citeRegEx" : "14",
      "shortCiteRegEx" : "14",
      "year" : 2007
    }, {
      "title" : "A new multi-level algorithm based on particle swarm optimization for bisecting graph",
      "author" : [ "L. Sun", "M. Leng" ],
      "venue" : "Lecture notes in Computer Science",
      "citeRegEx" : "15",
      "shortCiteRegEx" : "15",
      "year" : 2007
    }, {
      "title" : "A effective multi-level algorithm based on ant colony optimization for bisecting graph",
      "author" : [ "L. Sun", "M. Leng" ],
      "venue" : "Lecture notes in Computer Science",
      "citeRegEx" : "16",
      "shortCiteRegEx" : "16",
      "year" : 2007
    }, {
      "title" : "Partitioning spase matrices with eigenvectors of graphs",
      "author" : [ "A. Pothen", "H.D. Simon", "K.P. Liou" ],
      "venue" : "SIAM Journal on Matrix analysis and applications",
      "citeRegEx" : "17",
      "shortCiteRegEx" : "17",
      "year" : 1990
    }, {
      "title" : "JOSTLE: Parallel Multilevel Graph-Partitioning Software : An Overview",
      "author" : [ "C. Walshaw", "M. Cross" ],
      "venue" : "In F. Magoules, editor, Mesh Partitioning Techniques and Domain Decomposition Techniques,",
      "citeRegEx" : "18",
      "shortCiteRegEx" : "18",
      "year" : 2007
    }, {
      "title" : "Graph partitioning for high performance scientific simulations",
      "author" : [ "K. Schloegel", "G. Karypis", "V. Kumar" ],
      "venue" : "In J. Dongarra et al., editor, CRPC Par. Comp. Handbook",
      "citeRegEx" : "19",
      "shortCiteRegEx" : "19",
      "year" : 2000
    }, {
      "title" : "Mckeown, A PROBE-based heuristic for graph partitioning",
      "author" : [ "P. Chardaire", "M. Barake", "G.P" ],
      "venue" : "IEEE Transaction on Computers,",
      "citeRegEx" : "21",
      "shortCiteRegEx" : "21",
      "year" : 2007
    }, {
      "title" : "An efficient approach for large scale graph partitioning",
      "author" : [ "R. Loureiro", "A. Amaral" ],
      "venue" : "Journal of Combinatorial Optimization,",
      "citeRegEx" : "22",
      "shortCiteRegEx" : "22",
      "year" : 2007
    } ],
    "referenceMentions" : [ {
      "referenceID" : 0,
      "context" : "A special case of such deployment optimization occurs in cloudlet [1,2], where multiple mobile devices access nearby static resourceful computers linked to a distant cloud through high speed wired connections.",
      "startOffset" : 66,
      "endOffset" : 71
    }, {
      "referenceID" : 1,
      "context" : "A special case of such deployment optimization occurs in cloudlet [1,2], where multiple mobile devices access nearby static resourceful computers linked to a distant cloud through high speed wired connections.",
      "startOffset" : 66,
      "endOffset" : 71
    }, {
      "referenceID" : 2,
      "context" : "Many heuristics of different nature (spectral [4], combinatorial [5], evolutionist [6, 7], etc.",
      "startOffset" : 46,
      "endOffset" : 49
    }, {
      "referenceID" : 3,
      "context" : "Many heuristics of different nature (spectral [4], combinatorial [5], evolutionist [6, 7], etc.",
      "startOffset" : 65,
      "endOffset" : 68
    }, {
      "referenceID" : 4,
      "context" : "Many heuristics of different nature (spectral [4], combinatorial [5], evolutionist [6, 7], etc.",
      "startOffset" : 83,
      "endOffset" : 89
    }, {
      "referenceID" : 5,
      "context" : "Many heuristics of different nature (spectral [4], combinatorial [5], evolutionist [6, 7], etc.",
      "startOffset" : 83,
      "endOffset" : 89
    }, {
      "referenceID" : 7,
      "context" : "Others existing approaches of graph partitioning such as Kernighan-Lin algorithm [9] fails to scale to large scale graph data.",
      "startOffset" : 81,
      "endOffset" : 84
    }, {
      "referenceID" : 6,
      "context" : "The authors of [8] have introduced a graph partitioning algorithm based on simulated annealing [14] for software deployment in the cloud.",
      "startOffset" : 15,
      "endOffset" : 18
    }, {
      "referenceID" : 12,
      "context" : "The authors of [8] have introduced a graph partitioning algorithm based on simulated annealing [14] for software deployment in the cloud.",
      "startOffset" : 95,
      "endOffset" : 99
    }, {
      "referenceID" : 6,
      "context" : "1 Problem Model We adopted the problem model described in [8].",
      "startOffset" : 58,
      "endOffset" : 61
    }, {
      "referenceID" : 6,
      "context" : "However, the authors in [8] used only homogeneous machines and assumed the machine graph to be complete and all edges in the machine graph to have same weight.",
      "startOffset" : 24,
      "endOffset" : 27
    }, {
      "referenceID" : 9,
      "context" : "Graph partitioning is a NP-complete [11] problem and that there is no approximation algorithm with a constant ratio factor for general graphs [11].",
      "startOffset" : 36,
      "endOffset" : 40
    }, {
      "referenceID" : 9,
      "context" : "Graph partitioning is a NP-complete [11] problem and that there is no approximation algorithm with a constant ratio factor for general graphs [11].",
      "startOffset" : 142,
      "endOffset" : 146
    }, {
      "referenceID" : 7,
      "context" : "Motivated by the problem of partitioning electronic circuits onto boards a heuristic method is produced in [9].",
      "startOffset" : 107,
      "endOffset" : 110
    }, {
      "referenceID" : 10,
      "context" : "The Kernighan-Lin algorithm subsequently improved in terms of running time by Fiduccia and Mattheyses [12].",
      "startOffset" : 102,
      "endOffset" : 106
    }, {
      "referenceID" : 5,
      "context" : "The spectral bisection method is another popular method, which is based on the spectrum of the graphs Laplacian matrix [7, 13].",
      "startOffset" : 119,
      "endOffset" : 126
    }, {
      "referenceID" : 11,
      "context" : "The spectral bisection method is another popular method, which is based on the spectrum of the graphs Laplacian matrix [7, 13].",
      "startOffset" : 119,
      "endOffset" : 126
    }, {
      "referenceID" : 12,
      "context" : "In order to escape from the local optima these methods can be combined with different stochastic methods such as simulated annealing [14], particle swarm optimization [15], or ant colony optimization [16].",
      "startOffset" : 133,
      "endOffset" : 137
    }, {
      "referenceID" : 13,
      "context" : "In order to escape from the local optima these methods can be combined with different stochastic methods such as simulated annealing [14], particle swarm optimization [15], or ant colony optimization [16].",
      "startOffset" : 167,
      "endOffset" : 171
    }, {
      "referenceID" : 14,
      "context" : "In order to escape from the local optima these methods can be combined with different stochastic methods such as simulated annealing [14], particle swarm optimization [15], or ant colony optimization [16].",
      "startOffset" : 200,
      "endOffset" : 204
    }, {
      "referenceID" : 8,
      "context" : "One recent approach that has greatly accelerated the partitioning of large graphs is the use of multilevel techniques [10].",
      "startOffset" : 118,
      "endOffset" : 122
    }, {
      "referenceID" : 15,
      "context" : "This graph is then partitioned using a spectral method [17] and this partition is propagated back through the hierarchy of graphs.",
      "startOffset" : 55,
      "endOffset" : 59
    }, {
      "referenceID" : 16,
      "context" : "Well-known software packages based on this approach include Jostle [18], Metis [19], and Scotch [20].",
      "startOffset" : 67,
      "endOffset" : 71
    }, {
      "referenceID" : 17,
      "context" : "Well-known software packages based on this approach include Jostle [18], Metis [19], and Scotch [20].",
      "startOffset" : 79,
      "endOffset" : 83
    }, {
      "referenceID" : 18,
      "context" : "use a PROBE (Population Reinforced Optimization Based Exploration) heuristic [21].",
      "startOffset" : 77,
      "endOffset" : 81
    }, {
      "referenceID" : 19,
      "context" : "Besides, Loureiro and Amaral introduce a greedy graph growing heuristic deploying a local refinement algorithm [22].",
      "startOffset" : 111,
      "endOffset" : 115
    }, {
      "referenceID" : 6,
      "context" : "Hence, the authors of [8], proposed a graph partitioning algorithm based on simulated annealing for mobile cloud computing.",
      "startOffset" : 22,
      "endOffset" : 25
    }, {
      "referenceID" : 6,
      "context" : "To evaluate the performance of our algorithm we generate test graphs following method similar to described in [8].",
      "startOffset" : 110,
      "endOffset" : 113
    }, {
      "referenceID" : 6,
      "context" : "However, the authors in [8] assumed the infrastructure to be homogeneous.",
      "startOffset" : 24,
      "endOffset" : 27
    }, {
      "referenceID" : 6,
      "context" : "2 Algorithm Comparison We compared our method with the simulated annealing method proposed in [8].",
      "startOffset" : 94,
      "endOffset" : 97
    }, {
      "referenceID" : 6,
      "context" : "In [8], a number of algorithms was proposed and applied to solve the graph partitioning problem.",
      "startOffset" : 3,
      "endOffset" : 6
    }, {
      "referenceID" : 6,
      "context" : "In their simulated annealing [8], they allow infeasible moves or assignments fo vertices to partitions that are already over-sized and allow the capacity constraint to be violated.",
      "startOffset" : 29,
      "endOffset" : 32
    }, {
      "referenceID" : 6,
      "context" : "In their paper, they [8] mention that due to the decrease in temperature in later epochs the rate of taking infeasible moves will decrease also and thus produce valid solution when the algorithm terminates.",
      "startOffset" : 21,
      "endOffset" : 24
    }, {
      "referenceID" : 6,
      "context" : "Detail of the rest of the algorithm can be found in [8].",
      "startOffset" : 52,
      "endOffset" : 55
    }, {
      "referenceID" : 6,
      "context" : "Since simulated annealing take long to converge, we allowed it to finish the epochs as described in [8].",
      "startOffset" : 100,
      "endOffset" : 103
    } ],
    "year" : 2014,
    "abstractText" : "Graph partitioning, a well studied problem of parallel computing has many applications in diversified fields such as distributed computing, social network analysis, data mining and many other domains. In this paper, we introduce FGPGA, an efficient genetic approach for producing feasible graph partitions. Our method takes into account the heterogeneity and capacity constraints of the partitions to ensure balanced partitioning. Such approach has various applications in mobile cloud computing that include feasible deployment of software applications on the more resourceful infrastructure in the cloud instead of mobile hand set. Our proposed approach is light weight and hence suitable for use in cloud architecture. We ensure feasibility of the partitions generated by not allowing over-sized partitions to be generated during the initialization and search. Our proposed method tested on standard benchmark datasets significantly outperforms the state-of-the-art methods in terms of quality of partitions and feasibility of the solutions.",
    "creator" : "LaTeX with hyperref package"
  }
}