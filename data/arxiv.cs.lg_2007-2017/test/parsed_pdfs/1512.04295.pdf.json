{
  "name" : "1512.04295.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : "Origami: A Convolutional Network Accelerator",
    "authors" : [ "L. Cavigelli", "D. Gschwend", "C. Mayer", "S. Willi", "B. Muheim", "L. Benini" ],
    "emails" : [ "benini}@iis.ee.ethz.ch,", "muheim}@ee.ethz.ch" ],
    "sections" : [ {
      "heading" : null,
      "text" : "complexity are being deployed in a growing number of application scenarios with strong real-time and power constraints. Current trends in CV clearly show a rise of neural network-based algorithms, which have recently broken many object detection and localization records. These approaches are very flexible and can be used to tackle many different challenges by only changing their parameters. In this paper, we present the first convolutional network accelerator which is scalable to network sizes that are currently only handled by workstation GPUs, but remains within the power envelope of embedded systems. The architecture has been implemented on 3.09 mm2 core area in UMC 65 nm technology, capable of a throughput of 274 GOp/s at 369 GOp/s/W with an external memory bandwidth of just 525 MB/s full-duplex – a decrease of more than 90% from previous work.\nCategories and Subject Descriptors B.7.1 [Integrated Circuits]: Types and Design Styles – Algorithms implemented in hardware, VLSI. I.2.6 [Artificial Intelligence]: Learning – Connectionism and neural nets.\nKeywords Machine learning, pattern recognition, classification, computer vision, signal processing, accelerator, VLSI design."
    }, {
      "heading" : "1. INTRODUCTION",
      "text" : "Today computer vision technologies are used with great success in many application areas, solving real-world problems in entertainment systems, robotics and surveillance [1]. More and more researchers and engineers are tackling action and object recognition problems with the help of brain-inspired algorithms, featuring many stages of feature detectors and classifiers, with lots of parameters that are optimized using the wealth of data that has recently become available. These “deep learning” techniques are achieving record-breaking results on very challenging problems and datasets, outperforming more mature concepts trying to model the specific problem at hand [2]–[4] or joining forces with them [5]. Convolutional Networks (ConvNets) are a prime example of this powerful, yet conceptually simple paradigm. They can be applied to various data sources and perform best when the information is spatially or temporally well-localized, but still has to be seen in a more global context such as in images.\nAs a testimony of the success of deep learning approaches, several\nresearch programs have been launched, even by major global industrial players (e.g. Facebook, Google, Baidu, Microsoft, IBM), pushing towards deploying services based on braininspired machine learning to their customers within a production environment [3], [5], [6]. These companies are mainly interested in running such algorithms on powerful compute clusters in large data centers.\nWith the increasing number of imaging devices the importance of digital signal processing in imaging continues to grow. The amount of on- and near-sensor computation is rising to thousands of operations per pixel, requiring powerful energy-efficient digital signal processing solutions, often co-integrated with the imaging circuitry itself to reduce overall system cost and size. Such embedded vision systems that extract meaning from imaging data are enabled by more and more energy-efficient, low-cost integrated parallel processing engines (multi-core DSPs, GPUs, platform FPGAs). This permits a new generation of distributed computer vision systems, which can bring huge value to a vast range of applications by reducing the costly data transmission, forwarding only the desired information [1], [7].\nMany opportunities for challenging research and innovative applications will pan out from the evolution of advanced embedded video processing and future situational awareness systems. As opposed to conventional visual monitoring systems (CCTVs, IP cameras) that send the video data to a data center to be stored and processed, embedded smart cameras process the image data directly on board. This can significantly reduce the amount of data to be transmitted and the required human intervention – the sources of the two most expensive aspects of video surveillance [8]. Embedding convolutional network classifiers in distributed computer vision systems, seems a natural direction of evolution, However, deep neural networks are commonly known for their demand of computing power, making it challenging to bring this computational load within the power envelope of embedded systems – in fact, most state-of-the-art neural networks are currently not only trained, but also evaluated on workstations with powerful GPUs to achieve reasonable performance.\nIn this paper we present Origami, a convolution network accelerator ASIC, featuring a new architecture which is scalable to TOp/s performance while remaining area- and energy-efficient and keeping I/O throughput within the limits of economical packages and low power budgets.\nOrganization of the Paper: Section 2 shortly introduces convolutional networks and highlights the need for acceleration. Previous work is investigated in Section 3, discussing available software, FPGA and ASIC implementations and explaining the selection of our design objectives. In Section 4 we present our architecture and its properties. We discuss our results in Section 5 and subsequently conclude the paper with Section 6."
    }, {
      "heading" : "2. CONVOLUTIONAL NETWORKS",
      "text" : "Convolutional Networks are always built from the same few basic building blocks: Convolution layers, activation layers and pooling layers. One sequence of convolution, activation and pooling is considered a stage, and modern, deep networks often consist of multiple stages. The convolutional network itself is used as a feature extractor, transforming raw data into a higherdimensional, more meaningful representation. ConvNets particularly preserve locality through their limited filter size, which makes them very suitable for visual data (e.g., in a street scene the pixels in the top left corner contain little information on what is going on in the bottom right corner of an image, but if there are pixels showing the sky all around some segment of the image, this segment is certainly not a car). The feature extraction is then followed by a classifier, such as a normal neural network or a support vector machine.\nA stage of a ConvNet can be captured mathematically as\n( ) ( ( ) ( )) ( ) ( ) ( ( ( )))\n( ) ( ) ∑ ∑ ( ) ( )\n( )\nwhere indexes the stages, indexes the output channels and indexes the input channels . The pixel is identified by the tuple ( ) and denotes the support of the filters. In recently published networks, the pooling operation determines the maximum in a small neighborhood for each channel, often on areas and with a stride of . The activation function is applied point-wise for every pixel and every channel. A currently popular choice is the rectified linear unit (ReLU), which designates the function ( ). The activation function introduces non-linearity into neural networks, giving them the potential to be more powerful than linear methods. Typical filter sizes range from to , sometimes even [2], [4], [9].\nIn order to compare the complexity of various networks and the throughput of different implementations, we need a common measure. Evaluating convolutions requires performing many multiply-add operations. We count each multiply-add as two operations to remain compatible with the rest of the literature. For the convolution layer we thus have the number of operations\n( )( )\nwhere is the number of output channels | |, is the number of | |, is the size of the image and is the size of the filter in spatial domain. This measure is the most common in neural network literature.\nSoftware and hardware implementations alike often come with a throughput dependent on the actual size of the convolutional layer. While we keep our implementation runtime-configurable to a large extent, we use the ConvNet presented in [10] as a reference for performance evaluation. It has three stages and we\nassume input images of size . The resulting sizes and complexities of the individual layers are summarized in Table 1 and use a filter of size for all of them. The total number of operations required is 7.57 GOp/frame."
    }, {
      "heading" : "2.1 Computational Effort",
      "text" : "The evaluation of most convolutional networks for real applications is computationally very demanding. With the aforementioned scene labeling ConvNet, real-time use at 30 frame/s amounts to 227 GOp/s, which is not possible with any available implementation even on the most recent commercially procurable mobile processors.\nWhen considering hardware acceleration of algorithms in a rapidly changing field such as deep learning, the long-term usability has to be considered as well. While the structure of the networks changes from application to application and over time, better activation functions and pooling operations are found every year. So an overall accelerator is soon outdated, but we can accelerate the commonality among all networks: the convolution operation. Fortunately, this is also the most time consuming part for well-optimized software implementations at 89% of the total computation time for CPU and 79% for GPU implementations, as shown in Figure 1."
    }, {
      "heading" : "3. PREVIOUS WORK",
      "text" : ""
    }, {
      "heading" : "3.1 Software Implementations",
      "text" : "Acceleration of convolutional neural networks has been discussed in many papers. There are very fast and user-friendly frameworks publicly available such as Torch [11], Caffe [12] and cuDNN [13], in particular also due to the need to train the networks efficiently. These and other optimized implementations can be used to obtain a performance baseline on desktop workstations and CUDA-compatible embedded processors, such as the Tegra K1. On a GTX780 desktop GPU, the performance can reach up to 3059 GOp/s for some special problems and about 1800 GOp/s on meaningful ConvNets. On the Tegra K1 up to 96 GOp/s can be achieved, with 76 GOp/s being achieved with an actual ConvNet. On both platforms an energy-efficiency of about 7 GOp/s/W considering the power of the entire platform and 14.4 GOp/s/W with differential power measurements can be obtained [10]."
    }, {
      "heading" : "3.2 FPGA Implementations",
      "text" : "The issues of embeddability and power-efficiency have been addressed by many researchers using FPGA implementations. A popular architecture is the one which started as CNP [14] and was further improved and renamed to NeuFlow [15], [16] and later on nn-X [17].\nThe CNP was published in 2009 and achieved 12 GOp/s at 15W on a Spartan 3A DSP 3400 FPGA using 18 bit fixed-point arithmetic for the multiplications. It is worth mentioning that it is self-contained, being able to perform all operations necessary in ConvNets and coming with a soft CPU. It also features a\ncompiler, converting network implementations with Torch directly to CNP instructions.\nNeuFlow scaled up CNP to multiple convolution engines following the dataflow paradigm and allowing for runtime reconnection of the various processing blocks. The work published in 2011 features a Virtex 6 VLX240T to achieve 147 GOp/s at 11W using 16 bit fixed-point arithmetic.\nIn 2014, neuFlow was ported to a Zynq XC7Z045 as nn-X, making use of the hard-wired ARM cores. It achieves a throughput of about 200 GOp/s at 4W (FPGA, memory and host) and uses MB/s full-duplex memory interfaces."
    }, {
      "heading" : "3.3 ASIC Implementations",
      "text" : "In 2012 an ASIC implementation of NeuFlow was published [16]. It was implemented in IBM 45nm SOI technology, using a chip area of 12.5 mm2. It achieves a performance of about 300 GOp/s at 0.6W operating at 400 MHz with an external memory bandwidth of GB/s full-duplex.\nTo push the limits of what is possible in terms of energy efficiency, simulation (pre-silicon) results in ST 28nm FDSOI have recently been published [18]. The processing core was evaluated for single convolutions of various sizes suitable for ConvNets, achieving 37 GOp/s with 206 GOp/s/W at 0.8V and 1.39 GOp/s with 1375 GOp/s/W at 0.4V with the same implementation."
    }, {
      "heading" : "3.4 Discussion",
      "text" : "These existing implementations show that hardware accelerators for ConvNets are feasible with high energy efficiency, giving significant improvements over software implementations.\nHowever, none of the architectures are suitable for highperformance applications due to memory interface limits. The ASIC implementation of neuFlow comes with 299 I/O pins to achieve 300 GOp/s. Applying the aforementioned scene labeling ConvNet to larger images such as full-HD frames requires 5190 GOp/s to get 20 frame/s and there is also a trend towards even more complex ConvNets. Simply scaling this architecture up would require more than 5000 I/O pins or about 110GB/s fullduplex memory bandwidth when based on the nn-X architecture. This problem is not specific to the neuFlow/nn-X implementation, but common to all architectures we are aware of.\nIn this work we specifically address this issue, reducing the memory bandwidth required to achieve a high computational throughput."
    }, {
      "heading" : "4. ARCHITECTURE & IMPLEMENTATION",
      "text" : "A top-level diagram of the ASIC architecture is shown in Figure 2. It is composed of data provider entities for the filter weights and an image window, and four processing channels computing the sum of products and accumulating the results. The data providing circuitry largely runs at a slower frequency compatible with the I/O drivers, while the data processing units run with a faster clock .\nIn previous work, convolutions have been performed by loading one filter, loading one input image, and performing a single convolution to produce one output image. With our architecture we want to minimize I/O bandwidth by exploiting the fact that we\ncan load filters, load images, and perform convolutions, to produce output images after summing up the results – effectively reducing the I/O to computation ratio by a factor of almost ⁄ ."
    }, {
      "heading" : "4.1 Concept of Operation",
      "text" : "As we still want to keep the throughput per area high, we need to ensure the required amount of SRAM and register field memory is kept as small as possible without significant impact on performance. We thus store only a moving, pixel wide and maximum pixel high spatial window of all input images in SRAM, as shown in Figure 4. The resulting memory has words of length bit. The present working area of pixel is always kept in registers and is moved down by one pixel row for one input image after the other, loading new pixels from SRAM every cycle. Once it reaches the bottom of the image, it jumps back to the top and one pixel to the right, stalling the processing units for ( ) cycles.\nThe actual computations take place in ⁄ processing chains running at . Each processing chain comes with a sum-\nof-products (SoP) unit and a channel summer (ChSum). A SoP unit has 12-bit multipliers with 23 bit outputs and an adder tree summing up all the results, finally truncating the results to 12 bit. The channel summer then accumulates the data for two output channels, switching between those channels every cycle of the fast\nclock, such that the input image patch has to be changed at the slower frequency only. Each channel summer updates its output every cycles of the fast clock. The results are then transferred off-chip, fully utilizing the 12 bit bus.\nFor the implementation, we fixed the filter size and chose . Smaller filters have to be zero-padded and larger filters have to be decomposed into multiple filters and added up. To keep the cycles lost during column changes low also for larger image, we chose . For the SRAM, the technology libraries we used did not provide a fast enough module to accommodate words of bit at 350 MHz. Therefore the SRAM was split into 4 modules of 1024 words each."
    }, {
      "heading" : "4.2 Fixed-Point Analysis",
      "text" : "Previous work is not conclusive on the required precision for ConvNets, 16 and 18 bit are the most common values [14], [15], [17], [18]. To determine the optimal data width for our design, we performed a fixed-point analysis based on our reference ConvNet. We replaced all the convolution operations in our software model with fixed-point versions thereof and evaluated the resulting precision depending on the input, output and weight data width. The quality was analyzed based on the per-pixel classification accuracy of 150 test images omitted during training. We used the other 565 images of the Stanford backgrounds dataset [19] to train the network.\nOur results have shown that an output length of 12 bit is sufficient to keep the implementation loss below a drop of 0.5% in accuracy. Since the convolution layers are applied repeatedly with little processing between them, we chose the same signal width for the input, although we could have reduced them further. For the filter weights a signal width of 12 bit was selected as well."
    }, {
      "heading" : "4.3 Throughput",
      "text" : "The peak throughput of this architecture is given by\nwith ⁄ . At the borders of an image no valid convolution results can be calculated, so the core has to wait for the necessary data to be transferred to the device. These waiting periods occur at the beginning for columns and at the\nbeginning of each new row for cycles. The effective throughput thus depends on the size of the image:\n( )( )\nFor our reference network and the chosen implementation parameters, this factor is 0.96, 0.91 and 0.82 for stages 1…3, respectively in case of a pixel input image. For larger images this is significantly improved, e.g. for a image the Stage 3 will get an efficiency factor of 0.91. However, the height of the input image is limited to 512 pixel due to the memory size of the image bank. If larger images are to be processed, they have to be split into horizontal stripes with an overlap of rows.\nBefore the image transmission can start, the filters have to be loaded through the same bus used to transmit the image data. This causes a loss of a few more cycles. The total number of filter coefficients is , which amounts to 2.4k, 50.2k and 802.8k for the three stages. This results in an additional efficiency factor of\nwhich evaluates to 0.98, 0.97 and 0.91 for the three stages.\nThe number of output and input channels usually does not correspond to the number of output and input channels processed\nin parallel by this core. This can be overcome by partitioning the output and input channels into blocks of and filling in all-zero filters for the unused cases. The outputs of these blocks then have to be summed up pixel-wise off-chip.\nThis processing in blocks can have a strong additional impact on the efficiency when not fully utilizing the core. While stages 2 and 3 of our reference ConvNet can be perfectly split into blocks and thus no performance is lost, Stage 1 has only 3 input channels and can load the core only with . However, stages with a small number of input or output channels also perform much less operations and efficiency in these cases is thus not that important.\nThe total throughput with the reference ConvNet running on our implementation is summarized in Table 2, alongside details on the efficiency of the individual stages."
    }, {
      "heading" : "4.4 Implementation Summary",
      "text" : "The ASIC has been named ORIGAMI and has been sent for tapeout in UMC 65nm CMOS technology. The design includes several design for test measures, including scan chains and builtin self-tests for the SRAM. The fast clock was generated by XORing two phase-shifted 350 MHz clock signals. The key values of the ASIC have been compiled in Table 3.\nAfter all these design choices, the resulting final area breakdown is shown in Figure 5."
    }, {
      "heading" : "5. RESULTS & DISCUSSION",
      "text" : "We have focused on multiple design aspects in our architecture: I/O bandwidth, throughput per area and power efficiency.\nWe have achieved a peak throughput of 274 GOp/s and an actual throughput of 203 GOp/s on only 3.09 mm2 core area in 65 nm technology with a routing density of 69%. Our implementation thus achieves 66 GOp/s/mm2, compared to 24 GOp/s/mm2 of the neuFlow chip. This is very important, considering that such an accelerator has to be co-integrated with a processor and potentially many more devices within a SoC.\nThis ASIC comes with only one input and one output bus of 12 bit each and 3 control pins operating at 350 MHz. This architecture’s data I/O bandwidth of 525 MB/s full-duplex for 203 GOp/s, 2.58 MB/GOp, is far better than the results shown in previous work, such as 24.7 MB/GOp for the neuFlow ASIC [16] or 20 MB/GOp for nn-X [17].\nThe power efficiency of our chip is 369 GOp/s/W without the pads and 220 GOp/s/W if we include the pads. Better results have been reported in literature, e.g. 490 GOp/s/W for the NeuFlow ASIC, and 207 GOp/s/W or even 1375 GOp/s/W in [18]. There are three main aspects influencing energy efficiency: First, we have a higher switching activity in the core, since we change the filter weights at the multiplier inputs with MHz and\nchange also the image input at MHz. Second, we use small shift registers and SRAM instead of large shift registers to store a stripe of the image. This saves some area and increases energy efficiency. Last but most important, technology scaling also has a significant positive impact, particularly with such a high utilization.\nBesides that, it is important to stress the fact that the power to access external memory is not considered in the above estimate. Given the significant I/O bandwidth, this is the dominating factor for the overall system power and energy efficiency. If we consider only the energy used for the data interface of these architectures and assume LPDDR3 memory and a 28 nm implementation, an energy usage of 21 pJ/bit for memory module and PHY with a reasonable output load is realistic with a very high page hit rate and a perfectly-dimensioned memory (based on [20] and the Micron System Power Calculator2 with values for LPDDR3).\nIf we scale to 28 nm, our core power would decrease to about 142 mW and the LPDDR3 memory including the PHY would add 180 mW to make a total of 322 mW or 630 GOp/s/W. The neuFlow implementation would use approximately 239 mW, and memory and PHY would require 2.14 W, totaling 2.38 W or 126 GOp/s/W. The implementation of [18] suffers from the same issues, their superior energy efficiency in the processing core is gained with FDSOI technology which could also be applied to our architecture. However, the UMC 65 nm process is currently a more reasonable and accessible choice for a low-cost implementation and has a fast turn-around time.\n1 The power usage was simulated running with real data.\n2 www.micron.com/products/support/power-calc"
    }, {
      "heading" : "6. CONCLUSION & FUTURE WORK",
      "text" : "We have presented the first ConvNet accelerator scalable to multiTOp/s performance by significantly improving on the external memory bottleneck of previous architectures. Further, it is more area efficient than previously reported results and comes with the lowest-ever reported power consumption when including I/O power and external memory.\nFurther work with newer technologies, programmable logic and further configurability to build an entire high-performance lowpower system are planned alongside investigations into the ConvNet learning-phase to adapt networks for very-low precision accelerators during training."
    }, {
      "heading" : "ACKNOWLEDGMENTS",
      "text" : "This work was funded by Armasuisse Science & Technology and the ERC MultiTherman project (ERC-AdG-291125)."
    } ],
    "references" : [ {
      "title" : "Video surveillance: past, present, and now the future [DSP Forum",
      "author" : [ "F. Porikli", "F. Bremond", "S.L. Dockstader", "J. Ferryman", "A. Hoogs", "B.C. Lovell", "S. Pankanti", "B. Rinner", "P. Tu", "P.L. Venetianer" ],
      "venue" : "IEEE Signal Process. Mag., vol. 30, pp. 190–198, 2013.",
      "citeRegEx" : "1",
      "shortCiteRegEx" : null,
      "year" : 2013
    }, {
      "title" : "Imagenet classification with deep convolutional neural networks",
      "author" : [ "A. Krizhevsky", "I. Sutskever", "G.E. Hinton" ],
      "venue" : "Proc. NIPS’12, 2012.",
      "citeRegEx" : "2",
      "shortCiteRegEx" : null,
      "year" : 2012
    }, {
      "title" : "Going Deeper with Convolutions",
      "author" : [ "C. Szegedy", "W. Liu", "Y. Jia", "P. Sermanet", "S. Reed", "D. Anguelov", "D. Erhan", "V. Vanhoucke", "A. Rabinovich" ],
      "venue" : "arXiv:1409.4842, 2014.",
      "citeRegEx" : "3",
      "shortCiteRegEx" : null,
      "year" : 2014
    }, {
      "title" : "OverFeat: Integrated Recognition, Localization and Detection using Convolutional Networks",
      "author" : [ "P. Sermanet", "D. Eigen", "X. Zhang", "M. Mathieu", "R. Fergus", "Y. LeCun" ],
      "venue" : "arXiv:1312.6229, 2013.",
      "citeRegEx" : "4",
      "shortCiteRegEx" : null,
      "year" : 2013
    }, {
      "title" : "Deepface: Closing the gap to human-level performance in face verification",
      "author" : [ "Y. Taigman", "M. Yang" ],
      "venue" : "Proc. IEEE CVPR’13, 2013.",
      "citeRegEx" : "5",
      "shortCiteRegEx" : null,
      "year" : 2013
    }, {
      "title" : "Microsoft COCO: Common Objects in Context",
      "author" : [ "T.-Y. Lin", "M. Maire", "S. Belongie", "J. Hays", "P. Perona", "D. Ramanan", "P. Dollár", "C.L. Zitnick" ],
      "venue" : "arXiv:1405.0312, 2014.",
      "citeRegEx" : "6",
      "shortCiteRegEx" : null,
      "year" : 2014
    }, {
      "title" : "Internet inter-domain traffic",
      "author" : [ "C. Labovitz", "S. Iekel-Johnson", "D. McPherson", "J. Oberheide", "F. Jahanian" ],
      "venue" : "ACM SIGCOMM Computer Communication Review, vol. 40. p. 75, 2010.",
      "citeRegEx" : "7",
      "shortCiteRegEx" : null,
      "year" : 2010
    }, {
      "title" : "Learning hierarchical features for scene labeling",
      "author" : [ "C. Farabet", "C. Couprie", "L. Najman", "Y. LeCun" ],
      "venue" : "IEEE Trans. PAMI, 2013.  Figure 6: Post-layout chip graphic",
      "citeRegEx" : "9",
      "shortCiteRegEx" : null,
      "year" : 2013
    }, {
      "title" : "Accelerating Real-Time Embedded Scene Labeling with Convolutional Networks",
      "author" : [ "L. Cavigelli", "M. Magno", "L. Benini" ],
      "venue" : "Proc. DAC’15, 2015.",
      "citeRegEx" : "10",
      "shortCiteRegEx" : null,
      "year" : 2015
    }, {
      "title" : "Torch7: A matlab-like environment for machine learning",
      "author" : [ "R. Collobert" ],
      "venue" : "Proc. NIPSW’11, 2011.",
      "citeRegEx" : "11",
      "shortCiteRegEx" : null,
      "year" : 2011
    }, {
      "title" : "Caffe: An Open Source Convolutional Architecture for Fast Feature Embedding.",
      "author" : [ "Y. Jia" ],
      "venue" : null,
      "citeRegEx" : "12",
      "shortCiteRegEx" : "12",
      "year" : 2013
    }, {
      "title" : "cuDNN: Efficient Primitives for Deep Learning",
      "author" : [ "S. Chetlur", "C. Woolley", "P. Vandermersch", "J. Cohen", "J. Tran", "B. Catanzaro", "E. Shelhamer" ],
      "venue" : "arXiv:1410.0759, 2014.",
      "citeRegEx" : "13",
      "shortCiteRegEx" : null,
      "year" : 2014
    }, {
      "title" : "CNP: An FPGA-based processor for Convolutional Networks",
      "author" : [ "C. Farabet", "C. Poulet", "J.Y. Han", "Y. LeCun" ],
      "venue" : "Proc. IEEE FPL’09, 2009, vol. 1, no. 1, pp. 32–37.",
      "citeRegEx" : "14",
      "shortCiteRegEx" : null,
      "year" : 2009
    }, {
      "title" : "NeuFlow: A runtime reconfigurable dataflow processor for vision",
      "author" : [ "C. Farabet", "B. Martini", "B. Corda", "P. Akselrod", "E. Culurciello", "Y. LeCun" ],
      "venue" : "Proc. IEEE CVPRW’11, 2011, pp. 109–116.",
      "citeRegEx" : "15",
      "shortCiteRegEx" : null,
      "year" : 2011
    }, {
      "title" : "NeuFlow: Dataflow vision processing system-on-a-chip",
      "author" : [ "P.H. Pham", "D. Jelaca", "C. Farabet", "B. Martini", "Y. LeCun", "E. Culurciello" ],
      "venue" : "Midwest Symposium on Circuits and Systems, 2012, pp. 1044–1047.",
      "citeRegEx" : "16",
      "shortCiteRegEx" : null,
      "year" : 2012
    }, {
      "title" : "A 240 G-ops/s Mobile Coprocessor for Deep Neural Networks",
      "author" : [ "V. Gokhale", "J. Jin", "A. Dundar", "B. Martini", "E. Culurciello" ],
      "venue" : "Proc. IEEE CVPR’14, 2014, pp. 682–687.",
      "citeRegEx" : "17",
      "shortCiteRegEx" : null,
      "year" : 2014
    }, {
      "title" : "A Ultra-Low-Energy Convolution Engine for Fast Brain-Inspired Vision in Multicore Clusters",
      "author" : [ "F. Conti", "L. Benini" ],
      "venue" : "Proc. DATE’15, 2015.",
      "citeRegEx" : "18",
      "shortCiteRegEx" : null,
      "year" : 2015
    }, {
      "title" : "Decomposing a scene into geometric and semantically consistent regions",
      "author" : [ "S. Gould", "R. Fulton", "D. Koller" ],
      "venue" : "Proc. IEEE ICCV’09, 2009.",
      "citeRegEx" : "19",
      "shortCiteRegEx" : null,
      "year" : 2009
    }, {
      "title" : "DRAM or no-DRAM ? Exploring Linear Solver Architectures for Image Domain Warping in 28 nm CMOS",
      "author" : [ "M. Schaffner", "F.K. Gürkaynak", "A. Smolic", "L. Benini" ],
      "venue" : "Proc. IEEE DATE’15, 2015.",
      "citeRegEx" : "20",
      "shortCiteRegEx" : null,
      "year" : 2015
    } ],
    "referenceMentions" : [ {
      "referenceID" : 0,
      "context" : "INTRODUCTION Today computer vision technologies are used with great success in many application areas, solving real-world problems in entertainment systems, robotics and surveillance [1].",
      "startOffset" : 183,
      "endOffset" : 186
    }, {
      "referenceID" : 1,
      "context" : "These “deep learning” techniques are achieving record-breaking results on very challenging problems and datasets, outperforming more mature concepts trying to model the specific problem at hand [2]–[4] or joining forces with them [5].",
      "startOffset" : 194,
      "endOffset" : 197
    }, {
      "referenceID" : 3,
      "context" : "These “deep learning” techniques are achieving record-breaking results on very challenging problems and datasets, outperforming more mature concepts trying to model the specific problem at hand [2]–[4] or joining forces with them [5].",
      "startOffset" : 198,
      "endOffset" : 201
    }, {
      "referenceID" : 4,
      "context" : "These “deep learning” techniques are achieving record-breaking results on very challenging problems and datasets, outperforming more mature concepts trying to model the specific problem at hand [2]–[4] or joining forces with them [5].",
      "startOffset" : 230,
      "endOffset" : 233
    }, {
      "referenceID" : 2,
      "context" : "Facebook, Google, Baidu, Microsoft, IBM), pushing towards deploying services based on braininspired machine learning to their customers within a production environment [3], [5], [6].",
      "startOffset" : 168,
      "endOffset" : 171
    }, {
      "referenceID" : 4,
      "context" : "Facebook, Google, Baidu, Microsoft, IBM), pushing towards deploying services based on braininspired machine learning to their customers within a production environment [3], [5], [6].",
      "startOffset" : 173,
      "endOffset" : 176
    }, {
      "referenceID" : 5,
      "context" : "Facebook, Google, Baidu, Microsoft, IBM), pushing towards deploying services based on braininspired machine learning to their customers within a production environment [3], [5], [6].",
      "startOffset" : 178,
      "endOffset" : 181
    }, {
      "referenceID" : 0,
      "context" : "This permits a new generation of distributed computer vision systems, which can bring huge value to a vast range of applications by reducing the costly data transmission, forwarding only the desired information [1], [7].",
      "startOffset" : 211,
      "endOffset" : 214
    }, {
      "referenceID" : 6,
      "context" : "This permits a new generation of distributed computer vision systems, which can bring huge value to a vast range of applications by reducing the costly data transmission, forwarding only the desired information [1], [7].",
      "startOffset" : 216,
      "endOffset" : 219
    }, {
      "referenceID" : 1,
      "context" : "Typical filter sizes range from to , sometimes even [2], [4], [9].",
      "startOffset" : 52,
      "endOffset" : 55
    }, {
      "referenceID" : 3,
      "context" : "Typical filter sizes range from to , sometimes even [2], [4], [9].",
      "startOffset" : 57,
      "endOffset" : 60
    }, {
      "referenceID" : 7,
      "context" : "Typical filter sizes range from to , sometimes even [2], [4], [9].",
      "startOffset" : 62,
      "endOffset" : 65
    }, {
      "referenceID" : 8,
      "context" : "While we keep our implementation runtime-configurable to a large extent, we use the ConvNet presented in [10] as a reference for performance evaluation.",
      "startOffset" : 105,
      "endOffset" : 109
    }, {
      "referenceID" : 9,
      "context" : "There are very fast and user-friendly frameworks publicly available such as Torch [11], Caffe [12] and cuDNN [13], in particular also due to the need to train the networks efficiently.",
      "startOffset" : 82,
      "endOffset" : 86
    }, {
      "referenceID" : 10,
      "context" : "There are very fast and user-friendly frameworks publicly available such as Torch [11], Caffe [12] and cuDNN [13], in particular also due to the need to train the networks efficiently.",
      "startOffset" : 94,
      "endOffset" : 98
    }, {
      "referenceID" : 11,
      "context" : "There are very fast and user-friendly frameworks publicly available such as Torch [11], Caffe [12] and cuDNN [13], in particular also due to the need to train the networks efficiently.",
      "startOffset" : 109,
      "endOffset" : 113
    }, {
      "referenceID" : 8,
      "context" : "4 GOp/s/W with differential power measurements can be obtained [10].",
      "startOffset" : 63,
      "endOffset" : 67
    }, {
      "referenceID" : 12,
      "context" : "A popular architecture is the one which started as CNP [14] and was further improved and renamed to NeuFlow [15], [16] and later on nn-X [17].",
      "startOffset" : 55,
      "endOffset" : 59
    }, {
      "referenceID" : 13,
      "context" : "A popular architecture is the one which started as CNP [14] and was further improved and renamed to NeuFlow [15], [16] and later on nn-X [17].",
      "startOffset" : 108,
      "endOffset" : 112
    }, {
      "referenceID" : 14,
      "context" : "A popular architecture is the one which started as CNP [14] and was further improved and renamed to NeuFlow [15], [16] and later on nn-X [17].",
      "startOffset" : 114,
      "endOffset" : 118
    }, {
      "referenceID" : 15,
      "context" : "A popular architecture is the one which started as CNP [14] and was further improved and renamed to NeuFlow [15], [16] and later on nn-X [17].",
      "startOffset" : 137,
      "endOffset" : 141
    }, {
      "referenceID" : 8,
      "context" : "Input size 240 320 117 157 55 75 Input channels 3 16 64 Output channels 16 64 256 # Operations 346 MOp 1682 MOp 5428 MOp # Filter values 2352 50176 802816 Figure 1: Computation time spent in different stages of our reference scene labeling ConvNet from [10].",
      "startOffset" : 253,
      "endOffset" : 257
    }, {
      "referenceID" : 14,
      "context" : "3 ASIC Implementations In 2012 an ASIC implementation of NeuFlow was published [16].",
      "startOffset" : 79,
      "endOffset" : 83
    }, {
      "referenceID" : 16,
      "context" : "To push the limits of what is possible in terms of energy efficiency, simulation (pre-silicon) results in ST 28nm FDSOI have recently been published [18].",
      "startOffset" : 149,
      "endOffset" : 153
    }, {
      "referenceID" : 12,
      "context" : "2 Fixed-Point Analysis Previous work is not conclusive on the required precision for ConvNets, 16 and 18 bit are the most common values [14], [15], [17], [18].",
      "startOffset" : 136,
      "endOffset" : 140
    }, {
      "referenceID" : 13,
      "context" : "2 Fixed-Point Analysis Previous work is not conclusive on the required precision for ConvNets, 16 and 18 bit are the most common values [14], [15], [17], [18].",
      "startOffset" : 142,
      "endOffset" : 146
    }, {
      "referenceID" : 15,
      "context" : "2 Fixed-Point Analysis Previous work is not conclusive on the required precision for ConvNets, 16 and 18 bit are the most common values [14], [15], [17], [18].",
      "startOffset" : 148,
      "endOffset" : 152
    }, {
      "referenceID" : 16,
      "context" : "2 Fixed-Point Analysis Previous work is not conclusive on the required precision for ConvNets, 16 and 18 bit are the most common values [14], [15], [17], [18].",
      "startOffset" : 154,
      "endOffset" : 158
    }, {
      "referenceID" : 17,
      "context" : "We used the other 565 images of the Stanford backgrounds dataset [19] to train the network.",
      "startOffset" : 65,
      "endOffset" : 69
    }, {
      "referenceID" : 14,
      "context" : "7 MB/GOp for the neuFlow ASIC [16] or 20 MB/GOp for nn-X [17].",
      "startOffset" : 30,
      "endOffset" : 34
    }, {
      "referenceID" : 15,
      "context" : "7 MB/GOp for the neuFlow ASIC [16] or 20 MB/GOp for nn-X [17].",
      "startOffset" : 57,
      "endOffset" : 61
    }, {
      "referenceID" : 16,
      "context" : "490 GOp/s/W for the NeuFlow ASIC, and 207 GOp/s/W or even 1375 GOp/s/W in [18].",
      "startOffset" : 74,
      "endOffset" : 78
    }, {
      "referenceID" : 18,
      "context" : "If we consider only the energy used for the data interface of these architectures and assume LPDDR3 memory and a 28 nm implementation, an energy usage of 21 pJ/bit for memory module and PHY with a reasonable output load is realistic with a very high page hit rate and a perfectly-dimensioned memory (based on [20] and the Micron System Power Calculator with values for LPDDR3).",
      "startOffset" : 309,
      "endOffset" : 313
    }, {
      "referenceID" : 16,
      "context" : "The implementation of [18] suffers from the same issues, their superior energy efficiency in the processing core is gained with FDSOI technology which could also be applied to our architecture.",
      "startOffset" : 22,
      "endOffset" : 26
    } ],
    "year" : 2015,
    "abstractText" : "Today advanced computer vision (CV) systems of ever increasing complexity are being deployed in a growing number of application scenarios with strong real-time and power constraints. Current trends in CV clearly show a rise of neural network-based algorithms, which have recently broken many object detection and localization records. These approaches are very flexible and can be used to tackle many different challenges by only changing their parameters. In this paper, we present the first convolutional network accelerator which is scalable to network sizes that are currently only handled by workstation GPUs, but remains within the power envelope of embedded systems. The architecture has been implemented on 3.09 mm core area in UMC 65 nm technology, capable of a throughput of 274 GOp/s at 369 GOp/s/W with an external memory bandwidth of just 525 MB/s full-duplex – a decrease of more than 90% from previous work.",
    "creator" : "Microsoft® Word 2010"
  }
}