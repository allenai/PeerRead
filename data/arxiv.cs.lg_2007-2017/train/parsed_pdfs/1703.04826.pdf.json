{
  "name" : "1703.04826.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : "Encoding Sentences with Graph Convolutional Networks for Semantic Role Labeling",
    "authors" : [ "Diego Marcheggiani", "Ivan Titov" ],
    "emails" : [ "marcheggiani@uva.nl", "titov@uva.nl" ],
    "sections" : [ {
      "heading" : "1 Introduction",
      "text" : "Semantic role labeling (SRL) (Gildea and Jurafsky, 2002) can be informally described as the task of discovering who did what to whom. For example, consider an SRL dependency graph shown above the sentence in Figure 1. Formally, the task includes (1) detection of predicates (e.g., makes); (2) labeling the predicates with a sense from a sense inventory (e.g.,\nmake.01); (3) identifying and assigning arguments to semantic roles (e.g., Sequa is A0, i.e., an agent / ‘doer’ for the corresponding predicate, and engines is A1, i.e., a patient / ‘an affected entity’). SRL is often regarded as an important step in the standard NLP pipeline, providing information to downstream tasks such as information extraction and question answering.\nThe semantic representations are closely related to syntactic ones, even though the syntax-semantics interface is far from trivial (Levin, 1993). For example, one can observe that many arcs in the syntactic dependency graph (shown in black below the sentence in Figure 1) are mirrored in the semantic dependency graph. Given these similarities and also because of availability of accurate syntactic parsers for many languages, it seems natural to exploit syntactic information when predicting semantics. Though historically most SRL approaches did rely on syntax (Thompson et al., 2003; Pradhan et al., 2005; Punyakanok et al., 2008; Johansson and Nugues, 2008), the last generation of SRL models put syntax aside in favour of neural sequence modar X\niv :1\n70 3.\n04 82\n6v 1\n[ cs\n.C L\n] 1\n4 M\nar 2\nels, namely LSTMs (Zhou and Xu, 2015; Marcheggiani et al., 2017), and outperformed syntacticallydriven methods on standard benchmarks. We believe that one of the reasons for this radical choice is the lack of simple and effective ways for neural networks to encode syntactic information at the level of words. In this work we aim to fill this gap.\nSpecifically, we rely on graph convolutional networks (GCNs) (Duvenaud et al., 2015; Kipf and Welling, 2016), a recent class of multilayer neural networks operating on graphs. For every node in the graph (in our case a word in a sentence), GCN encodes relevant information about its neighborhood as a real-valued feature vector. GCNs have been studied largely in the context of undirected unlabeled graphs and we are not aware of any previous application of GCNs to NLP. We introduce a generalization of GCNs of Kipf and Welling (2016) applicable to labeled directed graphs, as necessary for modeling syntactic dependency structures.\nOne layer GCN encodes only information about immediate neighbors and j layers are needed to encode j-order neighborhoods (i.e., information about nodes at most j hops aways). This contrasts with recurrent and recursive neural networks (Elman, 1990; Socher et al., 2013) which, at least in theory, can capture statistical dependencies across unbounded paths in a trees or in a sequence. However, as we will further discuss in Section 3.3, this is not a serous limitation when GCNs are used in combination with encoders based on recurrent networks (LSTMs). When we stack GCNs on top of LSTM layers, we obtain a substantial improvement over an already state-of-the-art LSTM SRL model, resulting in the best reported scores on the standard benchmark (CoNLL-2009), both for English and Chinese.\nInterestingly, again unlike recursive neural networks, GCNs do not constrain the graph to be a tree. We believe that there are many applications in NLP, where GCN-based encoders of sentences or even documents can be used to incorporate knowledge about linguistic structures (e.g., representations of syntax, semantics or discourse). For example, GCNs can take as input combined syntacticsemantic graphs (e.g., the entire graph from Figure 1), and be used within downstream tasks such as machine translation or question answering. However, we leave this for future work and here solely\nfocus on SRL. The contributions of this paper can be summarized as follows:\n• we are the first to apply GCNs to NLP (i.e., to encode sentences);\n• we propose a generalization of GCNs suited to encoding syntactic information at word level;\n• we propose a GCN-based SRL model and obtain state-of-the-art results on English and Chinese portions of the CoNLL-2009 dataset;\n• we show that bidirectional LSTMs and syntaxbased GCNs have complementary modeling power."
    }, {
      "heading" : "2 Graph Convolutional Networks",
      "text" : "In this section we describe GCNs introduced by Kipf and Welling (2016). GCNs are neural networks operating on graphs and inducing features of nodes (i.e., real-valued vectors / embeddings) based on properties of their neighborhoods. In Kipf and Welling (2016), they were shown very effective for the node classification task: the classifier was estimated jointly with a GCN, so that the induced node features were informative for the node classification problem. Depending on how many layers of convolution are used, GCNs can capture information only about immediate neighbors (with one layer of convolution) or any nodes at most k hops aways (if k layers are stacked on top of each other).\nMore formally, consider an undirected graph G = (V, E), where V (|V | = n) and E are sets of nodes and edges, respectively. Kipf and Welling (2016) assume that edges contain all the self-loops, i.e., (v, v) ∈ E for any v. We can define a matrix X ∈ Rm×n with each its column xv ∈ Rm (v ∈ V) encoding node features. The vectors can either encode genuine features (e.g., this vector can encode the title of a paper if citation graphs are considered) or be a one-hot vector. The node representation, encoding information about its immediate neighbors, is computed as\nhv = ρ cv ∑ u∈N (v) (Wxu + b)  , (1)\nwhere W ∈ Rm×m and b ∈ Rm are a weight matrix and a bias, respectively; N (v) are neighbors of v; cv is a normalization factor; ρ is an activation function (e.g., that of linear rectifier units, ReLU). Note that v ∈ N (v) (because of self-loops), so the input feature representation of v (i.e. xv) affects its induced representation hv. The normalization factor is needed to ensure that representations of all nodes are on the same scale. It is crucial for graphs with very large degree variations (e.g., citation graphs), and cv can be defined simply as 1|N (v)| . 1\nAs in standard convolutional networks (LeCun et al., 2001), by stacking GCN layers one can incorporate higher degree neighborhoods:\nh(j+1)v = ρ cv ∑ u∈N (v) W (j)h(j)u + b (j)  (2) where j denotes the layer number and h(1)v = xv."
    }, {
      "heading" : "3 Syntactic GCNs",
      "text" : "As GCNs were developed for undirected unlabeled graphs, whereas syntactic dependency trees are directed and labeled (we refer to the dependency labels as syntactic functions), we first need to modify the computation in order to incorporate label information (Section 3.1). In the subsequent section, we incorporate gates in GCNs, so that the model can decide which edges are more relevant to the task in question. Having gates is also important as we rely on automatically predicted syntactic representations, and the gates can detect and downweight potentially erroneous edges. We also discuss shortcomings of GCNs and how they are addressed when GCNs are used in tandem with LSTMs (Section 3.3)."
    }, {
      "heading" : "3.1 Incorporating directions and labels",
      "text" : "Now we introduce a generalization of GCNs appropriate for directed labeled graphs, such as syntactic dependency trees. First note that there is no reason to assume that information flows only along the syntactic dependency arcs (e.g., from makes to Sequa), so we allow it to flow in the opposite direction as\n1We refer the reader to Kipf and Welling (2016) for details and potential alternatives, including other normalization choices.\nwell (i.e., from dependents to heads2). We use a graph G = (V, E), where the edge set contains all pairs of nodes (i.e., words) adjacent in the dependency tree. In our example, both (Sequa, makes) and (makes, Sequa) belong to the edge set. The graph is labeled, and the labelL(u, v) for (u, v) ∈ E contains both information about the syntactic function and indicates whether the edge is in the same or opposite direction as the syntactic dependency arc. For example, the label for (makes, Sequa) is subj, whereas the label for (Sequa, makes) is subj′, with the apostrophe indicating that the edge is in the direction opposite to the corresponding syntactic arc. Similarly, self-loops will have label self . Consequently, we can simply assume that the GCN pa-\n2For syntactic dependency graphs we use the notation where edges point from syntactic heads to their dependents (see Figure 1), though other notations are used sometimes in literature.\nrameters are label-specific, resulting in the following computation, also illustrated in Figure 2:\nh(j+1)v = ρ  ∑ u∈N (v) W (j) L(u,v)h (j) u + b (j) L(u,v)  . Note that we also dropped the normalization because we believe that unlike previous GCN applications, in syntax, degree (e.g., verb valency) carries important information and the normalization makes the model largely agnostic to it. This model is overparameterized,3 especially given that SRL datasets are moderately sized, by deep learning standards. So instead of learning the GCN parameters directly, we define them as\nW (j) L(u,v) = V (j) dir(u,v), (3)\nwhere dir(u, v) indicates whether the edge (u, v) is directed (1) along, (2) in the opposite direction to the syntactic dependency arc, or (3) is a self-loop; V\n(j) dir(u,v) ∈ Rm×m. Our simplification captures the intuition that information should be propagated differently along edges depending whether this is a head-to-dependent or dependent-to-head edge (i.e., along or opposite the corresponding syntactic arc) and whether it is a self-loop. So we do not share any parameters between these three very different edge types. Syntactic functions are important, but perhaps less crucial, so they are encoded only in the feature vectors bL(u,v)."
    }, {
      "heading" : "3.2 Edge-wise gating",
      "text" : "Both uniform normalization, as in Kipf and Welling (2016), and dropping normalization (cv = 1), as we suggested in the preceding section, are problematic. Besides not capturing the degree information properly (as we discussed above), uniform normalization would dump activations of nodes with a high degree, and these nodes (e.g., many of them are verbs, central for SRL) carry important information. Overall, uniformly accepting information from all neighboring nodes may not be appropriate for the SRL setting. For example, we see in Figure 1 that many semantic arcs just mirror their syntactic counter-parts, so they may need to be up-weighted.\n3Chinese and English CoNLL 2009 datasets used 41 and 48 different syntactic functions, which would result in having 83 and 97 different matrices in every layer, respectively.\nMoreover, we rely on automatically predicted syntactic structures, and, even for English, syntactic parsers are far from being perfect, especially when used out-of-domain. It is risky for a downstream application to rely on a potentially wrong syntactic edge, so the corresponding message in the neural network may need to be down-weighted. We would like the model to automatically detect risky cases: for example, preposition attachment disambiguation is a hard problem for a parser, so it may need to learn that if u is a preposition then it should not trust an edge connecting it to its syntactic head.\nIn order to address the above issues, inspired by recent literature (van den Oord et al., 2016; Dauphin et al., 2016), we calculate for each edge node pair a scalar gate of the form\ng(j)u,v = σ ( h(j)u · v̂(j)dir(u,v) + b̂ (j) L(u,v) ) , (4)\nwhere σ is the logistic sigmoid function, v̂(j)dir(u,v) ∈ Rm and b̂(j)L(u,v) ∈ R are weights and a bias for the gate. With this additional gating mechanism, the final syntactic GCN computation is formulated as\nh(j+1)v =ρ( ∑\nu∈N (v)\ng(j)v,u(V (j) dir(u,v)h (j) u +b (j) L(u,v))). (5)"
    }, {
      "heading" : "3.3 Complementarity of GCNs and LSTMs",
      "text" : "The inability of GCNs to capture dependencies between nodes far away from each other in the graph, together with no parameter sharing across convolution layers, may seem like a serious problem, especially in the context of SRL: paths between predicates and arguments often include many dependency arcs (Roth and Lapata, 2016). However, when graph convolution is performed on top of LSTM states (i.e., LSTM states serves as input xv = h (0) v to GCN) rather than static word embeddings, GCN may not need to capture more than a couple of hops.\nTo elaborate on this, let us speculate what role GCNs would play when used in combinations with LSTMs, given that LSTMs have already been shown very effective for SRL (Zhou and Xu, 2015; Marcheggiani et al., 2017). Though LSTMs are capable of capturing at least some degree of syntax (Linzen et al., 2016) without explicit syntactic\nsupervision, SRL datasets are moderately sized, so LSTM models may still struggle with harder cases. Typically, harder cases for SRL involve arguments far away from their predicates. In fact, 20% and 30% of arguments are more than 5 tokens away from their predicate, in our English and Chinese collections, respectively. However, if we imagine that we can ‘teleport’ even over a single (longest) syntactic dependency edge, the ’distance’ would shrink: only 9% and 13% arguments will now be more than 5 LSTM steps away (again for English and Chinese, respectively). GCNs are providing this ‘teleportation’ capability. These observations suggest that LSTMs and GCNs may be complementary, and we will see that empirical results support this intuition."
    }, {
      "heading" : "4 Syntax-Aware Neural SRL Encoder",
      "text" : "In this work, we build our semantic role labeler on top of the syntax-agnostic LSTM-based SRL model of Marcheggiani et al. (2017), which already\nachieves state-of-the-art results on the CoNLL-2009 English dataset. Following their approach we employ the same bidirectional (BiLSTM) encoder and enrich it with a syntactic GCN.\nThe CoNLL 2009 benchmark assumes that predicate positions are already marked in the test set (e.g., we would know that makes, repairs and engines in Figure 1 are predicates), so no predicate identification is needed. Also, as we focus here solely on identifying arguments and labeling them with semantic roles, for predicate disambiguation (i.e., marking makes as make.01) we use of an offthe-shelf disambiguation model (Roth and Lapata, 2016; Björkelund et al., 2009). As in Marcheggiani et al. (2017) and in most previous work, we process individual predicates in isolation, so for each predicate, our tasks reduces to a sequence labeling problem. In other words, given a predicate (e.g., disputed in Figure 3) one needs to identify and label all its arguments (e.g., label estimates as A1).\nThe semantic role labeler we propose is composed of four components (see Figure 3):\n• a word representation component where the word representation is created (look-ups of embeddings of the word and its features);\n• a BiLSTM encoder that takes as input the word representation of each word in a sentence;\n• a syntax-based GCN encoder that re-encodes the BiLSTM representation based on the automatically predicted syntactic structure of the sentence;\n• a role classifier that take as input the GCN representation of the candidate argument and the representation of the predicate to predict the role associated with the candidate word (including ‘NULL’ to indicate that a word is not an argument of the predicate)."
    }, {
      "heading" : "4.1 Word representations",
      "text" : "For each word wi in the considered sentence, we create a sentence-specific word representation xi. We represent each word w as the concatenation of four vectors:4 a randomly initialized word embedding xre ∈ Rdw , a pre-trained word embedding\n4We drop the index i from the notation for the sake of brevity.\nxpe ∈ Rdw estimated on an external text collection, a randomly initialized part-of-speech tag embedding xpos ∈ Rdp and a randomly initialized lemma embedding xle ∈ Rdl (active only if the word is a predicate). The randomly initialized embeddings xre, xpos, and xle are fine-tuned during training, while the pre-trained ones are kept fixed. The final word representation is given by x = xre ◦xpe ◦xpos ◦xle, where ◦ represents the concatenation operator."
    }, {
      "heading" : "4.2 Bidirectional LSTM layer",
      "text" : "One of the most popular and effective ways to represent sequences, such as sentences (Mikolov et al., 2010), is to use recurrent neural networks (RNN) (Elman, 1990). In particular their gated versions, Long Short-Term Memory (LSTM) networks (Hochreiter and Schmidhuber, 1997) and Gated Recurrent Units (GRU) (Cho et al., 2014), have proven effective in modeling long sequences (Chiu and Nichols, 2016; Sutskever et al., 2014).\nFormally, an LSTM can be defined as a function LSTMθ(x1:i) that takes as input the sequence x1:i and returns a hidden state hi ∈ Rdh . This state can be regarded as a representation of the sentence from the start to the position i, or, in other words, it encodes the word at position i along with its left context. However, the right context is also important, so Bidirectional LSTMs (Graves, 2008) use two LSTMs: one for the forward pass, and another for the backward pass, LSTMF and LSTMB , respectively. By concatenating the states of both LSTMs, we create a complete context-aware representation of a word BiLSTM(x1:n, i) = LSTMF (x1:i) ◦ LSTMB(xn:i). We follow Marcheggiani et al. (2017) and stack k layers of bidirectional LSTMs, where each layer takes the lower layer as its input."
    }, {
      "heading" : "4.3 Graph convolutional layer",
      "text" : "The representation calculated with the BiLSTM encoder is fed as input to a GCN of the form defined in Equation (5). The neighboring nodes of a node v, namely N (v), are predicted by an external syntactic dependency parser. GCNs let us incorporate syntactic information in our neural SRL model in a straightforward way, and yield an effective and fast method."
    }, {
      "heading" : "4.4 Semantic role classifier",
      "text" : "The classifier predicts semantic roles of words given the predicate while relying on word representations provided by the GCN; we concatenate hidden states of the candidate argument word and the predicate word and use them as input to a classifier (Figure 3, top). The softmax classifier computes the probability of the role (including special ‘NULL’ role, encoding that the word is not an argument of the predicate):\np(r|ti, tp, l) ∝ exp(Wl,r(ti ◦ tp)), (6) where ti and tp are representations produced by the graph convolutional encoder, l is the lemma of predicate p and the symbol ∝ signifies proportionality.5 As FitzGerald et al. (2015) and Marcheggiani et al. (2017), instead of using a fixed matrix Wl,r or simply assuming that Wl,r = Wr, we jointly embed the role r and predicate lemma l using a non-linear transformation:\nWl,r = ReLU(U(ql ◦ qr)), (7) where U is a parameter matrix, whereas ql ∈ Rd ′ l and qr ∈ Rdr are randomly initialized embeddings of predicate lemmas and roles. In this way each role prediction is predicate-specific, and, at the same time, we expect to learn a good representation for roles associated with infrequent predicates. As our training objective we use the categorical crossentropy."
    }, {
      "heading" : "5 Experiments",
      "text" : ""
    }, {
      "heading" : "5.1 Datasets and parameters",
      "text" : "We tested the proposed SRL model on the English and Chinese CoNLL-2009 dataset with standard splits into training, test and development sets. For English, we used external embeddings of Dyer et al. (2015), learned using the structured skip ngram approach of Ling et al. (2015). For Chinese we used external embeddings produced with the neural language model of Bengio et al. (2003). As in (Kiperwasser and Goldberg, 2016), we applied word dropout at the word representation level (Iyyer et al., 2015): a word is replaced with a special unknown\n5We abuse the notation and define by p both the predicate word and its position in the sentence.\ntoken UNK with probability αfr(w)+α , where α is an hyper-parameter and fr(w) is the frequency of the word w. The predicted POS tags for both languages were provided by the CoNLL-2009 sharedtask organizers. For the predicate disambiguator we used the ones from Roth and Lapata (2016) for English and from Björkelund et al. (2009) for Chinese. We parsed English sentences with the BIST Parser (Kiperwasser and Goldberg, 2016), whereas for Chinese we used automatically predicted parses provided by the CoNLL-2009 shared-task organizers.\nWe used edge dropout in GCN: when computing h (j) v , we ignore each node v ∈ N (v) with probability β. Adam (Kingma and Ba, 2015) was used as an optimizer. The hyperparameter tuning and all model selection were performed on the English development set; the chosen values are shown in Table 1 and are the same for English and Chinese experiments (except for differences indicated below)."
    }, {
      "heading" : "5.2 Results and discussion",
      "text" : "In order to show that GCN layers are effective, we first compare our model against its version which lacks GCN layers. Importantly, to measure the genuine contribution of GCNs, we first tuned this syntax-agnostic model (e.g., the number of LSTM layers) to get best possible performance on the de-\nvelopment set.6\nWe compare the syntax-agnostic model with the syntax-aware one, with one layer of graph convolution over syntax (j = 1) and with two layers of graph convolution (j = 2). As we rely on the same off-the-shelf disambiguator for all versions of the model, in Table 2 and 3 we report SRL-only scores (i.e., predicate disambiguation is not evaluated) on the English and Chinese development sets. On the both datasets, the syntax-aware model with one GCN layers (j = 1) performs the best, outperforming the LSTM version by 1.9% and 0.6% for Chinese and English, respectively. Stacking two graph convolutional layers does not give any benefit, we will get back to this point in section 5.3, where we will see why and when having multiple layers is beneficial. Though the reasons for why the improvements on Chinese are much larger are not entirely clear (e.g., both languages are relative fixed word order ones, and the syntactic parses for Chinese are considerably less accurate), this may be attributed to a higher proportion of long-distance dependencies between predicates and arguments in Chinese (see Section 3.3).\nIn Figure 4, we show the F1 scores as a function of the distance, in terms of tokens, between a candidate argument and its predicate. As expected, GCNs appears to be more beneficial for long distance dependencies, as shorter ones are already accurately\n6For example, if we would have used only one layer of LSTMs, gains from using GCNs would be even larger.\ncaptured by the LSTM encoder. In order to compare to previous work, in Table 4 we report test results on the English in-domain (WSJ) evaluation data. Our model is local, as all the argument detection and labeling decisions are conditionally independent: their interaction is captured solely by the LSTM+GCN encoder. This makes our model fast and simple, though, as shown in previous work, global modeling of the structured output is beneficial.7 We leave this extension for future work. Interestingly, we outperform even the best joint model and the best ensemble of joint models, without using joint modeling or ensembles. When we create an ensemble of 3 models with the productof-expert combination rule, we improve by 1.2% over the best previous result, achieving 89.1% F1.\nWhen we study the Chinese results (Table 5), we can see that our best model outperforms the stateof-the-art model of Roth and Lapata (2016) by even larger margin of 3.1%.\n7As seen in Table 4, labelers of FitzGerald et al. (2015) and Roth and Lapata (2016) gained 0.6-1.0% from using global modeling.\nFor the CoNLL shared task, beside using the standard test, on English systems are also tested out of domain. Statistical models are typically less accurate when they are applied to out-of-domain data, i.e. on data different from the one they have been trained on. The training portion of the English CoNLL data (originating from the WSJ portion of Penn Treebank (Marcus et al., 1993)) consists of newswire, whereas the out-of-domain test set (based on the Brown corpus portion) contains such genres as fiction and humor. Consequently, the predicted syntax for the out-of-domain test set is of much lower quality, which negatively affects the quality of GCN embeddings. However, our model works surprisingly well on out-of-domain data (Table 6), substantially outperforming all the previous syntax-aware models. This suggest that our model is fairly robust to mistakes in syntax. As expected though, our model does not outperform the syntax-agnostic model of Marcheggiani et al. (2017). Nevertheless, the ensemble version obtains achieves a substantial improvement over the best previous approach (+1.6 % F1)."
    }, {
      "heading" : "5.3 Analysis of syntactic GCNs",
      "text" : "In this section we conduct an ablation study on the English CoNLL-2009 development set; we discuss the impact of predicted syntax and the behavior of different GCN architectures.\nFrom Table 7, it is clear that the quality of a\nparser translates into gains in performance from using GCNs. Whereas using predicted syntax resulted in an 0.6% improvement, relying on gold-standard (i.e., ‘perfectly correct’) syntax led to a further improvement of 3.1%.\nStill, when combining LSTMs and GCNs, we do not observe improvements from deep GCNs, unlike the nodel labeled task considered in Kipf and Welling (2016). We hypothesized that this has to do with the expressive power of BiLSTMs. To validate this hypothesis, we first reduce the number of BiLSTM layers to 1 (k = 1), and then we even substitute it with a fully connected non-linear layer (k = 0). Adding the non-linear layer is necessary, as we need to project the word embeddings up to the dimension-\nality of the GCN layer.\nFigure 7 shows that, when we reduce the number of BiLSTM layers to 1 and a second GCN layer is added, we obtain a small improvement of 0.1%. Interestingly, when BiLSTM layers are dropped altogether, stacking two layers (j = 2) of GCNs greatly improves the performance, resulting in a 4.2% jump in F1. Adding a 3rd layer of GCN (j = 3) further improves the performance by 1.1% to 83.7% F1. This confirms that, multilayer GCNs are in fact effective, but when they are used in a combination with LSTMs, only one layer is sufficent for SRL.8"
    }, {
      "heading" : "6 Related Work",
      "text" : "Perhaps the earliest methods modeling syntaxsemantics interface with RNNs are due to (Henderson et al., 2008; Titov et al., 2009; Gesmundo et al., 2009), they used shift-reduce parsers for joint SRL and syntactic parsing, and relied on RNNs to model statistical dependencies across syntactic and semantic parsing actions. A more modern (e.g., based on LSTMs) and effective reincarnation of this line of research has been proposed in Swayamdipta et al. (2016). Other recent work which considered incorporation of syntactic information in neural SRL models include: FitzGerald et al. (2015) who use standard syntactic features within an MLP calculating potentials of a CRF model; Roth and Lapata (2016) who enriched standard features for SRL with LSTM representations of syntactic paths between arguments and predicates; Lei et al. (2015) who relied on low-rank tensor factorizations for modeling syntax. Also Foland and Martin (2015) used (nongraph) convolutional neural networks and provided syntactic features (e.g., dependency paths) as input. A very different line of research, but with similar goals to ours (i.e. integrating syntax while minimizing the amount of feature engineering), focused on tree kernels and their applications to SRL (Moschitti et al., 2008).\nBeyond SRL, there have been many proposals on how to incorporate syntactic information in RNN models, for example, in the context of neural machine translation (Luong et al., 2015; Eriguchi et al., 2017; Sennrich and Haddow, 2016). One of\n8Note though that GCN layers are computationally cheaper than LSTM ones, even in our non-optimized implementation.\nthe most popular and attractive approaches is to use tree-structured recursive neural networks (Socher et al., 2013), which, though originally introduced for constituent syntax, can also be applied in the dependency parsing context (Le and Zuidema, 2014; Dyer et al., 2015). An approach of Mou et al. (2015) to sentiment analysis and question classification, introduced even before GCNs became popular in the machine learning community (Duvenaud et al., 2015; Kipf and Welling, 2016), is related to graph convolution. However, it is inherently single-layer and tree-specific, uses bottom-up computations, does not share parameters across syntactic functions and does not use gates.\nPrevious approaches to integrating syntactic information in neural models are mainly designed to induce representations of sentences or syntactic constituents. In contrast, the approach we presented incorporates syntactic information at word level. This may be attractive from the engineering perspective, as it can be used, as we have shown, instead or along with RNN models.\nGCNs or more generally applicable neural networks to graphs is now an active area of research in the machine learning community. Though most previous work have focused on undirected unlabeled graphs, the model of Pham et al. (2017) used directed graphs for the node classification task. Their model is different from ours in many respects. Importantly, they (as well as all previous GCN methods, as far as we are aware) focused on the set-up where training and testing is performed on the same (very large) graph. This contrasts with our setting, where we train and test on different small and automatically predicted graphs."
    }, {
      "heading" : "7 Conclusions and Future Work",
      "text" : "We demonstrated how GCNs can be used to incorporate syntactic information in neural models and specifically to construct a syntax-aware SRL model, resulting in state-of-the-art results for Chinese and English. There are relatively straightforward steps which can further improve the SRL results. For example, we relied on labeling arguments independently, whereas using a joint model is likely to significantly improve the performance. Also, in this paper we consider the dependency version of the\nSRL task, however the model can be generalized to the span-based version (i.e. labeling argument spans with roles rather that syntactic heads of arguments) in a relatively straightforward fashion.\nMore generally, given simplicity of GCNs and their applicability to general graph structures (not necessarily trees), we believe that there are many NLP tasks, where GCNs can be used to incorporate linguistic structures (e.g., syntactic and semantic representations of sentences and discourse parses or co-reference graphs for documents)."
    }, {
      "heading" : "Acknowledgements",
      "text" : "We would to thank Anton Frolov, Michael Schlichtkrull, Thomas Kipf, Michael Roth, Max Welling and Wilker Aziz for their suggestions and comments. The project was supported by the European Research Council (ERC StG BroadSem 678254), the Dutch National Science Foundation (NWO VIDI 639.022.518) and an Amazon Web Services (AWS) grant."
    } ],
    "references" : [ {
      "title" : "A neural probabilistic language model",
      "author" : [ "Yoshua Bengio", "Réjean Ducharme", "Pascal Vincent", "Christian Janvin." ],
      "venue" : "Journal of Machine Learning Research, 3:1137–1155.",
      "citeRegEx" : "Bengio et al\\.,? 2003",
      "shortCiteRegEx" : "Bengio et al\\.",
      "year" : 2003
    }, {
      "title" : "Multilingual semantic role labeling",
      "author" : [ "Anders Björkelund", "Love Hafdell", "Pierre Nugues." ],
      "venue" : "Proceedings of CoNLL Shared Task.",
      "citeRegEx" : "Björkelund et al\\.,? 2009",
      "shortCiteRegEx" : "Björkelund et al\\.",
      "year" : 2009
    }, {
      "title" : "A high-performance syntactic and semantic dependency parser",
      "author" : [ "Anders Björkelund", "Bernd Bohnet", "Love Hafdell", "Pierre Nugues." ],
      "venue" : "Proceedings of COLING: Demonstrations.",
      "citeRegEx" : "Björkelund et al\\.,? 2010",
      "shortCiteRegEx" : "Björkelund et al\\.",
      "year" : 2010
    }, {
      "title" : "Named entity recognition with bidirectional LSTM-CNNs",
      "author" : [ "Jason P.C. Chiu", "Eric Nichols." ],
      "venue" : "TACL, 4:357–370.",
      "citeRegEx" : "Chiu and Nichols.,? 2016",
      "shortCiteRegEx" : "Chiu and Nichols.",
      "year" : 2016
    }, {
      "title" : "Learning phrase representations using RNN encoder-decoder for statistical machine translation",
      "author" : [ "Kyunghyun Cho", "Bart van Merrienboer", "Çaglar Gülçehre", "Dzmitry Bahdanau", "Fethi Bougares", "Holger Schwenk", "Yoshua Bengio." ],
      "venue" : "Proceedings of EMNLP.",
      "citeRegEx" : "Cho et al\\.,? 2014",
      "shortCiteRegEx" : "Cho et al\\.",
      "year" : 2014
    }, {
      "title" : "Language modeling with gated convolutional networks",
      "author" : [ "Yann N. Dauphin", "Angela Fan", "Michael Auli", "David Grangier." ],
      "venue" : "CoRR, abs/1612.08083.",
      "citeRegEx" : "Dauphin et al\\.,? 2016",
      "shortCiteRegEx" : "Dauphin et al\\.",
      "year" : 2016
    }, {
      "title" : "Convolutional networks on graphs for learning molecular fingerprints",
      "author" : [ "David K Duvenaud", "Dougal Maclaurin", "Jorge Iparraguirre", "Rafael Bombarell", "Timothy Hirzel", "Alan Aspuru-Guzik", "Ryan P Adams." ],
      "venue" : "NIPS.",
      "citeRegEx" : "Duvenaud et al\\.,? 2015",
      "shortCiteRegEx" : "Duvenaud et al\\.",
      "year" : 2015
    }, {
      "title" : "Transitionbased dependency parsing with stack long short-term memory",
      "author" : [ "Chris Dyer", "Miguel Ballesteros", "Wang Ling", "Austin Matthews", "Noah A. Smith." ],
      "venue" : "Proceedings of ACL.",
      "citeRegEx" : "Dyer et al\\.,? 2015",
      "shortCiteRegEx" : "Dyer et al\\.",
      "year" : 2015
    }, {
      "title" : "Finding structure in time",
      "author" : [ "Jeffrey L. Elman." ],
      "venue" : "Cognitive Science, 14(2):179–211.",
      "citeRegEx" : "Elman.,? 1990",
      "shortCiteRegEx" : "Elman.",
      "year" : 1990
    }, {
      "title" : "Learning to parse and translate improves neural machine translation",
      "author" : [ "Akiko Eriguchi", "Yoshimasa Tsuruoka", "Kyunghyun Cho." ],
      "venue" : "arXiv preprint arXiv:1702.03525.",
      "citeRegEx" : "Eriguchi et al\\.,? 2017",
      "shortCiteRegEx" : "Eriguchi et al\\.",
      "year" : 2017
    }, {
      "title" : "Semantic role labeling with neural network factors",
      "author" : [ "Nicholas FitzGerald", "Oscar Täckström", "Kuzman Ganchev", "Dipanjan Das." ],
      "venue" : "Proceedings of EMNLP.",
      "citeRegEx" : "FitzGerald et al\\.,? 2015",
      "shortCiteRegEx" : "FitzGerald et al\\.",
      "year" : 2015
    }, {
      "title" : "Dependencybased semantic role labeling using convolutional neural networks",
      "author" : [ "William Foland", "James Martin." ],
      "venue" : "Proceedings of the Fourth Joint Conference on Lexical and Computational Semantics.",
      "citeRegEx" : "Foland and Martin.,? 2015",
      "shortCiteRegEx" : "Foland and Martin.",
      "year" : 2015
    }, {
      "title" : "Latent variable model of synchronous syntactic-semantic parsing for multiple languages",
      "author" : [ "Andrea Gesmundo", "James Henderson", "Paola Merlo", "Ivan Titov." ],
      "venue" : "Proceedings of CoNLL 2009 Shared Task.",
      "citeRegEx" : "Gesmundo et al\\.,? 2009",
      "shortCiteRegEx" : "Gesmundo et al\\.",
      "year" : 2009
    }, {
      "title" : "Automatic labeling of semantic roles",
      "author" : [ "Daniel Gildea", "Daniel Jurafsky." ],
      "venue" : "Computational linguistics, 28(3):245–288.",
      "citeRegEx" : "Gildea and Jurafsky.,? 2002",
      "shortCiteRegEx" : "Gildea and Jurafsky.",
      "year" : 2002
    }, {
      "title" : "Supervised sequence labelling with recurrent neural networks",
      "author" : [ "Alex Graves." ],
      "venue" : "Ph.D. thesis, München, Techn. Univ., Diss., 2008.",
      "citeRegEx" : "Graves.,? 2008",
      "shortCiteRegEx" : "Graves.",
      "year" : 2008
    }, {
      "title" : "A latent variable model of synchronous parsing for syntactic and semantic dependencies",
      "author" : [ "James Henderson", "Paola Merlo", "Gabriele Musillo", "Ivan Titov." ],
      "venue" : "Proceedings of CoNLL Shared Task.",
      "citeRegEx" : "Henderson et al\\.,? 2008",
      "shortCiteRegEx" : "Henderson et al\\.",
      "year" : 2008
    }, {
      "title" : "Long short-term memory",
      "author" : [ "Sepp Hochreiter", "Jürgen Schmidhuber." ],
      "venue" : "Neural Computation, 9(8):1735– 1780.",
      "citeRegEx" : "Hochreiter and Schmidhuber.,? 1997",
      "shortCiteRegEx" : "Hochreiter and Schmidhuber.",
      "year" : 1997
    }, {
      "title" : "Deep unordered composition rivals syntactic methods for text classification",
      "author" : [ "Mohit Iyyer", "Varun Manjunatha", "Jordan Boyd-Graber", "Hal Daumé III." ],
      "venue" : "Proceedings of ACL.",
      "citeRegEx" : "Iyyer et al\\.,? 2015",
      "shortCiteRegEx" : "Iyyer et al\\.",
      "year" : 2015
    }, {
      "title" : "The effect of syntactic representation on semantic role labeling",
      "author" : [ "Richard Johansson", "Pierre Nugues." ],
      "venue" : "COLING 2008, 22nd International Conference on Computational Linguistics, Proceedings of the Conference, 18-22 August 2008, Manchester, UK, pages",
      "citeRegEx" : "Johansson and Nugues.,? 2008",
      "shortCiteRegEx" : "Johansson and Nugues.",
      "year" : 2008
    }, {
      "title" : "Adam: A method for stochastic optimization",
      "author" : [ "Diederik Kingma", "Jimmy Ba." ],
      "venue" : "Proceedings of ICLR.",
      "citeRegEx" : "Kingma and Ba.,? 2015",
      "shortCiteRegEx" : "Kingma and Ba.",
      "year" : 2015
    }, {
      "title" : "Simple and accurate dependency parsing using bidirectional lstm feature representations",
      "author" : [ "Eliyahu Kiperwasser", "Yoav Goldberg." ],
      "venue" : "Transactions of the Association for Computational Linguistics, 4:313–327.",
      "citeRegEx" : "Kiperwasser and Goldberg.,? 2016",
      "shortCiteRegEx" : "Kiperwasser and Goldberg.",
      "year" : 2016
    }, {
      "title" : "Semisupervised classification with graph convolutional networks",
      "author" : [ "Thomas N. Kipf", "Max Welling." ],
      "venue" : "CoRR, abs/1609.02907.",
      "citeRegEx" : "Kipf and Welling.,? 2016",
      "shortCiteRegEx" : "Kipf and Welling.",
      "year" : 2016
    }, {
      "title" : "The insideoutside recursive neural network model for dependency parsing",
      "author" : [ "Phong Le", "Willem Zuidema." ],
      "venue" : "EMNLP.",
      "citeRegEx" : "Le and Zuidema.,? 2014",
      "shortCiteRegEx" : "Le and Zuidema.",
      "year" : 2014
    }, {
      "title" : "Gradient-based learning applied to document recognition",
      "author" : [ "Y. LeCun", "L. Bottou", "Y. Bengio", "P. Haffner." ],
      "venue" : "Intelligent Signal Processing, pages 306–351. IEEE Press.",
      "citeRegEx" : "LeCun et al\\.,? 2001",
      "shortCiteRegEx" : "LeCun et al\\.",
      "year" : 2001
    }, {
      "title" : "High-order lowrank tensors for semantic role labeling",
      "author" : [ "Tao Lei", "Yuan Zhang", "Lluı́s Màrquez", "Alessandro Moschitti", "Regina Barzilay" ],
      "venue" : "In Proceedings of NAACL",
      "citeRegEx" : "Lei et al\\.,? \\Q2015\\E",
      "shortCiteRegEx" : "Lei et al\\.",
      "year" : 2015
    }, {
      "title" : "English verb classes and alternations: A preliminary investigation",
      "author" : [ "Beth Levin." ],
      "venue" : "University of Chicago press.",
      "citeRegEx" : "Levin.,? 1993",
      "shortCiteRegEx" : "Levin.",
      "year" : 1993
    }, {
      "title" : "Two/too simple adaptations of word2vec for syntax problems",
      "author" : [ "Wang Ling", "Chris Dyer", "Alan W Black", "Isabel Trancoso." ],
      "venue" : "NAACL.",
      "citeRegEx" : "Ling et al\\.,? 2015",
      "shortCiteRegEx" : "Ling et al\\.",
      "year" : 2015
    }, {
      "title" : "Assessing the ability of lstms to learn syntaxsensitive dependencies",
      "author" : [ "Tal Linzen", "Emmanuel Dupoux", "Yoav Goldberg." ],
      "venue" : "TACL, 4:521–535.",
      "citeRegEx" : "Linzen et al\\.,? 2016",
      "shortCiteRegEx" : "Linzen et al\\.",
      "year" : 2016
    }, {
      "title" : "Multi-task sequence to sequence learning",
      "author" : [ "Minh-Thang Luong", "Quoc V. Le", "Ilya Sutskever", "Oriol Vinyals", "Lukasz Kaiser." ],
      "venue" : "CoRR, abs/1511.06114.",
      "citeRegEx" : "Luong et al\\.,? 2015",
      "shortCiteRegEx" : "Luong et al\\.",
      "year" : 2015
    }, {
      "title" : "A simple and accurate syntax-agnostic neural model for dependency-based semantic role labeling",
      "author" : [ "Diego Marcheggiani", "Anton Frolov", "Ivan Titov." ],
      "venue" : "CoRR, abs/1701.02593.",
      "citeRegEx" : "Marcheggiani et al\\.,? 2017",
      "shortCiteRegEx" : "Marcheggiani et al\\.",
      "year" : 2017
    }, {
      "title" : "Building a large annotated corpus of English: The Penn Treebank",
      "author" : [ "Mitchell P. Marcus", "Beatrice Santorini", "Mary Ann Marcinkiewicz." ],
      "venue" : "Computational Linguistics, 19(2):313–330.",
      "citeRegEx" : "Marcus et al\\.,? 1993",
      "shortCiteRegEx" : "Marcus et al\\.",
      "year" : 1993
    }, {
      "title" : "Recurrent neural network based language model",
      "author" : [ "Tomas Mikolov", "Martin Karafiát", "Lukás Burget", "Jan Cernocký", "Sanjeev Khudanpur." ],
      "venue" : "Proceedings of INTERSPEECH.",
      "citeRegEx" : "Mikolov et al\\.,? 2010",
      "shortCiteRegEx" : "Mikolov et al\\.",
      "year" : 2010
    }, {
      "title" : "Tree kernels for semantic role labeling",
      "author" : [ "Alessandro Moschitti", "Daniele Pighin", "Roberto Basili." ],
      "venue" : "Computational Linguistics, 34(2):193–224.",
      "citeRegEx" : "Moschitti et al\\.,? 2008",
      "shortCiteRegEx" : "Moschitti et al\\.",
      "year" : 2008
    }, {
      "title" : "Discriminative neural sentence modeling by tree-based convolution",
      "author" : [ "Lili Mou", "Hao Peng", "Ge Li", "Yan Xu", "Lu Zhang", "Zhi Jin." ],
      "venue" : "Proceedings of EMNLP.",
      "citeRegEx" : "Mou et al\\.,? 2015",
      "shortCiteRegEx" : "Mou et al\\.",
      "year" : 2015
    }, {
      "title" : "Column networks for collective classification",
      "author" : [ "Trang Pham", "Truyen Tran", "Dinh Q. Phung", "Svetha Venkatesh." ],
      "venue" : "Proceedings AAAI.",
      "citeRegEx" : "Pham et al\\.,? 2017",
      "shortCiteRegEx" : "Pham et al\\.",
      "year" : 2017
    }, {
      "title" : "Semantic role chunking combining complementary syntactic views",
      "author" : [ "Sameer Pradhan", "Kadri Hacioglu", "Wayne H. Ward", "James H. Martin", "Daniel Jurafsky." ],
      "venue" : "Proceedings of CoNLL.",
      "citeRegEx" : "Pradhan et al\\.,? 2005",
      "shortCiteRegEx" : "Pradhan et al\\.",
      "year" : 2005
    }, {
      "title" : "The importance of syntactic parsing and inference",
      "author" : [ "Vasin Punyakanok", "Dan Roth", "Wen-tau Yih" ],
      "venue" : null,
      "citeRegEx" : "Punyakanok et al\\.,? \\Q2008\\E",
      "shortCiteRegEx" : "Punyakanok et al\\.",
      "year" : 2008
    }, {
      "title" : "Neural semantic role labeling with dependency path embeddings",
      "author" : [ "Michael Roth", "Mirella Lapata." ],
      "venue" : "Proceedings of ACL.",
      "citeRegEx" : "Roth and Lapata.,? 2016",
      "shortCiteRegEx" : "Roth and Lapata.",
      "year" : 2016
    }, {
      "title" : "Linguistic input features improve neural machine translation",
      "author" : [ "Rico Sennrich", "Barry Haddow." ],
      "venue" : "Proceedings of WMT.",
      "citeRegEx" : "Sennrich and Haddow.,? 2016",
      "shortCiteRegEx" : "Sennrich and Haddow.",
      "year" : 2016
    }, {
      "title" : "Recursive deep models for semantic compositionality over a sentiment treebank",
      "author" : [ "Richard Socher", "Alex Perelygin", "Jean Wu", "Jason Chuang", "Christopher D. Manning", "Andrew Ng", "Christopher Potts." ],
      "venue" : "Proceedings of EMNLP.",
      "citeRegEx" : "Socher et al\\.,? 2013",
      "shortCiteRegEx" : "Socher et al\\.",
      "year" : 2013
    }, {
      "title" : "Sequence to sequence learning with neural networks",
      "author" : [ "Ilya Sutskever", "Oriol Vinyals", "Quoc V. Le." ],
      "venue" : "NIPS.",
      "citeRegEx" : "Sutskever et al\\.,? 2014",
      "shortCiteRegEx" : "Sutskever et al\\.",
      "year" : 2014
    }, {
      "title" : "Greedy, joint syntacticsemantic parsing with stack LSTMs",
      "author" : [ "Swabha Swayamdipta", "Miguel Ballesteros", "Chris Dyer", "Noah A. Smith." ],
      "venue" : "Proceedings of CoNLL.",
      "citeRegEx" : "Swayamdipta et al\\.,? 2016",
      "shortCiteRegEx" : "Swayamdipta et al\\.",
      "year" : 2016
    }, {
      "title" : "A generative model for semantic role labeling",
      "author" : [ "Cynthia A. Thompson", "Roger Levy", "Christopher D. Manning." ],
      "venue" : "Proceedings of ECML.",
      "citeRegEx" : "Thompson et al\\.,? 2003",
      "shortCiteRegEx" : "Thompson et al\\.",
      "year" : 2003
    }, {
      "title" : "Online projectivisation for synchronous parsing of semantic and syntactic dependencies",
      "author" : [ "Ivan Titov", "James Henderson", "Paola Merlo", "Gabriele Musillo." ],
      "venue" : "Proceedings of IJCAI.",
      "citeRegEx" : "Titov et al\\.,? 2009",
      "shortCiteRegEx" : "Titov et al\\.",
      "year" : 2009
    }, {
      "title" : "Conditional image generation with pixelcnn decoders",
      "author" : [ "Aäron van den Oord", "Nal Kalchbrenner", "Lasse Espeholt", "Koray Kavukcuoglu", "Oriol Vinyals", "Alex Graves." ],
      "venue" : "NIPS.",
      "citeRegEx" : "Oord et al\\.,? 2016",
      "shortCiteRegEx" : "Oord et al\\.",
      "year" : 2016
    }, {
      "title" : "Multilingual dependency learning: Exploiting rich features for tagging syntactic and semantic dependencies",
      "author" : [ "Hai Zhao", "Wenliang Chen", "Jun’ichi Kazama", "Kiyotaka Uchimoto", "Kentaro Torisawa" ],
      "venue" : "Proceedings of CoNLL",
      "citeRegEx" : "Zhao et al\\.,? \\Q2009\\E",
      "shortCiteRegEx" : "Zhao et al\\.",
      "year" : 2009
    }, {
      "title" : "End-to-end learning of semantic role labeling using recurrent neural networks",
      "author" : [ "Jie Zhou", "Wei Xu." ],
      "venue" : "Proceedings of ACL.",
      "citeRegEx" : "Zhou and Xu.,? 2015",
      "shortCiteRegEx" : "Zhou and Xu.",
      "year" : 2015
    } ],
    "referenceMentions" : [ {
      "referenceID" : 13,
      "context" : "Semantic role labeling (SRL) (Gildea and Jurafsky, 2002) can be informally described as the task of discovering who did what to whom.",
      "startOffset" : 29,
      "endOffset" : 56
    }, {
      "referenceID" : 25,
      "context" : "The semantic representations are closely related to syntactic ones, even though the syntax-semantics interface is far from trivial (Levin, 1993).",
      "startOffset" : 131,
      "endOffset" : 144
    }, {
      "referenceID" : 42,
      "context" : "Though historically most SRL approaches did rely on syntax (Thompson et al., 2003; Pradhan et al., 2005; Punyakanok et al., 2008; Johansson and Nugues, 2008), the last generation of SRL models put syntax aside in favour of neural sequence modar X iv :1 70 3.",
      "startOffset" : 59,
      "endOffset" : 157
    }, {
      "referenceID" : 35,
      "context" : "Though historically most SRL approaches did rely on syntax (Thompson et al., 2003; Pradhan et al., 2005; Punyakanok et al., 2008; Johansson and Nugues, 2008), the last generation of SRL models put syntax aside in favour of neural sequence modar X iv :1 70 3.",
      "startOffset" : 59,
      "endOffset" : 157
    }, {
      "referenceID" : 36,
      "context" : "Though historically most SRL approaches did rely on syntax (Thompson et al., 2003; Pradhan et al., 2005; Punyakanok et al., 2008; Johansson and Nugues, 2008), the last generation of SRL models put syntax aside in favour of neural sequence modar X iv :1 70 3.",
      "startOffset" : 59,
      "endOffset" : 157
    }, {
      "referenceID" : 18,
      "context" : "Though historically most SRL approaches did rely on syntax (Thompson et al., 2003; Pradhan et al., 2005; Punyakanok et al., 2008; Johansson and Nugues, 2008), the last generation of SRL models put syntax aside in favour of neural sequence modar X iv :1 70 3.",
      "startOffset" : 59,
      "endOffset" : 157
    }, {
      "referenceID" : 46,
      "context" : "els, namely LSTMs (Zhou and Xu, 2015; Marcheggiani et al., 2017), and outperformed syntacticallydriven methods on standard benchmarks.",
      "startOffset" : 18,
      "endOffset" : 64
    }, {
      "referenceID" : 29,
      "context" : "els, namely LSTMs (Zhou and Xu, 2015; Marcheggiani et al., 2017), and outperformed syntacticallydriven methods on standard benchmarks.",
      "startOffset" : 18,
      "endOffset" : 64
    }, {
      "referenceID" : 6,
      "context" : "Specifically, we rely on graph convolutional networks (GCNs) (Duvenaud et al., 2015; Kipf and Welling, 2016), a recent class of multilayer neural networks operating on graphs.",
      "startOffset" : 61,
      "endOffset" : 108
    }, {
      "referenceID" : 21,
      "context" : "Specifically, we rely on graph convolutional networks (GCNs) (Duvenaud et al., 2015; Kipf and Welling, 2016), a recent class of multilayer neural networks operating on graphs.",
      "startOffset" : 61,
      "endOffset" : 108
    }, {
      "referenceID" : 6,
      "context" : "Specifically, we rely on graph convolutional networks (GCNs) (Duvenaud et al., 2015; Kipf and Welling, 2016), a recent class of multilayer neural networks operating on graphs. For every node in the graph (in our case a word in a sentence), GCN encodes relevant information about its neighborhood as a real-valued feature vector. GCNs have been studied largely in the context of undirected unlabeled graphs and we are not aware of any previous application of GCNs to NLP. We introduce a generalization of GCNs of Kipf and Welling (2016) applicable to labeled directed graphs, as necessary for modeling syntactic dependency structures.",
      "startOffset" : 62,
      "endOffset" : 536
    }, {
      "referenceID" : 8,
      "context" : "This contrasts with recurrent and recursive neural networks (Elman, 1990; Socher et al., 2013) which, at least in theory, can capture statistical dependencies across unbounded paths in a trees or in a sequence.",
      "startOffset" : 60,
      "endOffset" : 94
    }, {
      "referenceID" : 39,
      "context" : "This contrasts with recurrent and recursive neural networks (Elman, 1990; Socher et al., 2013) which, at least in theory, can capture statistical dependencies across unbounded paths in a trees or in a sequence.",
      "startOffset" : 60,
      "endOffset" : 94
    }, {
      "referenceID" : 21,
      "context" : "In this section we describe GCNs introduced by Kipf and Welling (2016). GCNs are neural networks operating on graphs and inducing features of nodes (i.",
      "startOffset" : 47,
      "endOffset" : 71
    }, {
      "referenceID" : 21,
      "context" : "In this section we describe GCNs introduced by Kipf and Welling (2016). GCNs are neural networks operating on graphs and inducing features of nodes (i.e., real-valued vectors / embeddings) based on properties of their neighborhoods. In Kipf and Welling (2016), they were shown very effective for the node classification task: the classifier was estimated jointly with a GCN, so that the induced node features were informative for the node classification problem.",
      "startOffset" : 47,
      "endOffset" : 260
    }, {
      "referenceID" : 21,
      "context" : "In this section we describe GCNs introduced by Kipf and Welling (2016). GCNs are neural networks operating on graphs and inducing features of nodes (i.e., real-valued vectors / embeddings) based on properties of their neighborhoods. In Kipf and Welling (2016), they were shown very effective for the node classification task: the classifier was estimated jointly with a GCN, so that the induced node features were informative for the node classification problem. Depending on how many layers of convolution are used, GCNs can capture information only about immediate neighbors (with one layer of convolution) or any nodes at most k hops aways (if k layers are stacked on top of each other). More formally, consider an undirected graph G = (V, E), where V (|V | = n) and E are sets of nodes and edges, respectively. Kipf and Welling (2016) assume that edges contain all the self-loops, i.",
      "startOffset" : 47,
      "endOffset" : 839
    }, {
      "referenceID" : 23,
      "context" : "As in standard convolutional networks (LeCun et al., 2001), by stacking GCN layers one can incorporate higher degree neighborhoods:",
      "startOffset" : 38,
      "endOffset" : 58
    }, {
      "referenceID" : 21,
      "context" : "We refer the reader to Kipf and Welling (2016) for details and potential alternatives, including other normalization choices.",
      "startOffset" : 23,
      "endOffset" : 47
    }, {
      "referenceID" : 21,
      "context" : "Both uniform normalization, as in Kipf and Welling (2016), and dropping normalization (cv = 1), as we suggested in the preceding section, are problematic.",
      "startOffset" : 34,
      "endOffset" : 58
    }, {
      "referenceID" : 5,
      "context" : "In order to address the above issues, inspired by recent literature (van den Oord et al., 2016; Dauphin et al., 2016), we calculate for each edge node pair a scalar gate of the form",
      "startOffset" : 68,
      "endOffset" : 117
    }, {
      "referenceID" : 37,
      "context" : "The inability of GCNs to capture dependencies between nodes far away from each other in the graph, together with no parameter sharing across convolution layers, may seem like a serious problem, especially in the context of SRL: paths between predicates and arguments often include many dependency arcs (Roth and Lapata, 2016).",
      "startOffset" : 302,
      "endOffset" : 325
    }, {
      "referenceID" : 46,
      "context" : "To elaborate on this, let us speculate what role GCNs would play when used in combinations with LSTMs, given that LSTMs have already been shown very effective for SRL (Zhou and Xu, 2015; Marcheggiani et al., 2017).",
      "startOffset" : 167,
      "endOffset" : 213
    }, {
      "referenceID" : 29,
      "context" : "To elaborate on this, let us speculate what role GCNs would play when used in combinations with LSTMs, given that LSTMs have already been shown very effective for SRL (Zhou and Xu, 2015; Marcheggiani et al., 2017).",
      "startOffset" : 167,
      "endOffset" : 213
    }, {
      "referenceID" : 27,
      "context" : "Though LSTMs are capable of capturing at least some degree of syntax (Linzen et al., 2016) without explicit syntactic",
      "startOffset" : 69,
      "endOffset" : 90
    }, {
      "referenceID" : 37,
      "context" : "01) we use of an offthe-shelf disambiguation model (Roth and Lapata, 2016; Björkelund et al., 2009).",
      "startOffset" : 51,
      "endOffset" : 99
    }, {
      "referenceID" : 1,
      "context" : "01) we use of an offthe-shelf disambiguation model (Roth and Lapata, 2016; Björkelund et al., 2009).",
      "startOffset" : 51,
      "endOffset" : 99
    }, {
      "referenceID" : 27,
      "context" : "In this work, we build our semantic role labeler on top of the syntax-agnostic LSTM-based SRL model of Marcheggiani et al. (2017), which already achieves state-of-the-art results on the CoNLL-2009 English dataset.",
      "startOffset" : 103,
      "endOffset" : 130
    }, {
      "referenceID" : 1,
      "context" : "01) we use of an offthe-shelf disambiguation model (Roth and Lapata, 2016; Björkelund et al., 2009). As in Marcheggiani et al. (2017) and in most previous work, we process individual predicates in isolation, so for each predicate, our tasks reduces to a sequence labeling problem.",
      "startOffset" : 75,
      "endOffset" : 134
    }, {
      "referenceID" : 31,
      "context" : "One of the most popular and effective ways to represent sequences, such as sentences (Mikolov et al., 2010), is to use recurrent neural networks (RNN) (Elman, 1990).",
      "startOffset" : 85,
      "endOffset" : 107
    }, {
      "referenceID" : 8,
      "context" : ", 2010), is to use recurrent neural networks (RNN) (Elman, 1990).",
      "startOffset" : 51,
      "endOffset" : 64
    }, {
      "referenceID" : 16,
      "context" : "In particular their gated versions, Long Short-Term Memory (LSTM) networks (Hochreiter and Schmidhuber, 1997) and Gated Recurrent Units (GRU) (Cho et al.",
      "startOffset" : 75,
      "endOffset" : 109
    }, {
      "referenceID" : 4,
      "context" : "In particular their gated versions, Long Short-Term Memory (LSTM) networks (Hochreiter and Schmidhuber, 1997) and Gated Recurrent Units (GRU) (Cho et al., 2014), have proven effective in modeling long sequences (Chiu and Nichols, 2016; Sutskever et al.",
      "startOffset" : 142,
      "endOffset" : 160
    }, {
      "referenceID" : 3,
      "context" : ", 2014), have proven effective in modeling long sequences (Chiu and Nichols, 2016; Sutskever et al., 2014).",
      "startOffset" : 58,
      "endOffset" : 106
    }, {
      "referenceID" : 40,
      "context" : ", 2014), have proven effective in modeling long sequences (Chiu and Nichols, 2016; Sutskever et al., 2014).",
      "startOffset" : 58,
      "endOffset" : 106
    }, {
      "referenceID" : 14,
      "context" : "However, the right context is also important, so Bidirectional LSTMs (Graves, 2008) use two LSTMs: one for the forward pass, and another for the backward pass, LSTMF and LSTMB , respectively.",
      "startOffset" : 69,
      "endOffset" : 83
    }, {
      "referenceID" : 14,
      "context" : "However, the right context is also important, so Bidirectional LSTMs (Graves, 2008) use two LSTMs: one for the forward pass, and another for the backward pass, LSTMF and LSTMB , respectively. By concatenating the states of both LSTMs, we create a complete context-aware representation of a word BiLSTM(x1:n, i) = LSTMF (x1:i) ◦ LSTMB(xn:i). We follow Marcheggiani et al. (2017) and stack k layers of bidirectional LSTMs, where each layer takes the lower layer as its input.",
      "startOffset" : 70,
      "endOffset" : 378
    }, {
      "referenceID" : 10,
      "context" : "5 As FitzGerald et al. (2015) and Marcheggiani et al.",
      "startOffset" : 5,
      "endOffset" : 30
    }, {
      "referenceID" : 10,
      "context" : "5 As FitzGerald et al. (2015) and Marcheggiani et al. (2017), instead of using a fixed matrix Wl,r or simply assuming that Wl,r = Wr, we jointly embed the role r and predicate lemma l using a non-linear transformation:",
      "startOffset" : 5,
      "endOffset" : 61
    }, {
      "referenceID" : 20,
      "context" : "As in (Kiperwasser and Goldberg, 2016), we applied word dropout at the word representation level (Iyyer et al.",
      "startOffset" : 6,
      "endOffset" : 38
    }, {
      "referenceID" : 17,
      "context" : "As in (Kiperwasser and Goldberg, 2016), we applied word dropout at the word representation level (Iyyer et al., 2015): a word is replaced with a special unknown",
      "startOffset" : 97,
      "endOffset" : 117
    }, {
      "referenceID" : 6,
      "context" : "For English, we used external embeddings of Dyer et al. (2015), learned using the structured skip ngram approach of Ling et al.",
      "startOffset" : 44,
      "endOffset" : 63
    }, {
      "referenceID" : 6,
      "context" : "For English, we used external embeddings of Dyer et al. (2015), learned using the structured skip ngram approach of Ling et al. (2015). For Chinese we used external embeddings produced with the neural language model of Bengio et al.",
      "startOffset" : 44,
      "endOffset" : 135
    }, {
      "referenceID" : 0,
      "context" : "For Chinese we used external embeddings produced with the neural language model of Bengio et al. (2003). As in (Kiperwasser and Goldberg, 2016), we applied word dropout at the word representation level (Iyyer et al.",
      "startOffset" : 83,
      "endOffset" : 104
    }, {
      "referenceID" : 20,
      "context" : "We parsed English sentences with the BIST Parser (Kiperwasser and Goldberg, 2016), whereas for Chinese we used automatically predicted parses provided by the CoNLL-2009 shared-task organizers.",
      "startOffset" : 49,
      "endOffset" : 81
    }, {
      "referenceID" : 34,
      "context" : "For the predicate disambiguator we used the ones from Roth and Lapata (2016) for English and from Björkelund et al.",
      "startOffset" : 54,
      "endOffset" : 77
    }, {
      "referenceID" : 1,
      "context" : "For the predicate disambiguator we used the ones from Roth and Lapata (2016) for English and from Björkelund et al. (2009) for Chinese.",
      "startOffset" : 98,
      "endOffset" : 123
    }, {
      "referenceID" : 19,
      "context" : "Adam (Kingma and Ba, 2015) was used as an optimizer.",
      "startOffset" : 5,
      "endOffset" : 26
    }, {
      "referenceID" : 10,
      "context" : "6 FitzGerald et al. (2015) (local) - - 86.",
      "startOffset" : 2,
      "endOffset" : 27
    }, {
      "referenceID" : 29,
      "context" : "7 Marcheggiani et al. (2017) (local) 88.",
      "startOffset" : 2,
      "endOffset" : 29
    }, {
      "referenceID" : 1,
      "context" : "7 Björkelund et al. (2009) (global) 82.",
      "startOffset" : 2,
      "endOffset" : 27
    }, {
      "referenceID" : 1,
      "context" : "7 Björkelund et al. (2009) (global) 82.4 75.1 78.6 Roth and Lapata (2016) (global) 83.",
      "startOffset" : 2,
      "endOffset" : 74
    }, {
      "referenceID" : 37,
      "context" : "When we study the Chinese results (Table 5), we can see that our best model outperforms the stateof-the-art model of Roth and Lapata (2016) by even larger margin of 3.",
      "startOffset" : 117,
      "endOffset" : 140
    }, {
      "referenceID" : 10,
      "context" : "As seen in Table 4, labelers of FitzGerald et al. (2015) and Roth and Lapata (2016) gained 0.",
      "startOffset" : 32,
      "endOffset" : 57
    }, {
      "referenceID" : 10,
      "context" : "As seen in Table 4, labelers of FitzGerald et al. (2015) and Roth and Lapata (2016) gained 0.",
      "startOffset" : 32,
      "endOffset" : 84
    }, {
      "referenceID" : 30,
      "context" : "The training portion of the English CoNLL data (originating from the WSJ portion of Penn Treebank (Marcus et al., 1993)) consists of newswire, whereas the out-of-domain test set (based on the Brown corpus portion) contains such genres as fiction and humor.",
      "startOffset" : 98,
      "endOffset" : 119
    }, {
      "referenceID" : 29,
      "context" : "As expected though, our model does not outperform the syntax-agnostic model of Marcheggiani et al. (2017). Nevertheless, the ensemble version obtains achieves a substantial improvement over the best previous approach (+1.",
      "startOffset" : 79,
      "endOffset" : 106
    }, {
      "referenceID" : 10,
      "context" : "6 FitzGerald et al. (2015) (local) - - 75.",
      "startOffset" : 2,
      "endOffset" : 27
    }, {
      "referenceID" : 10,
      "context" : "6 FitzGerald et al. (2015) (local) - - 75.2 Roth and Lapata (2016) (local) 76.",
      "startOffset" : 2,
      "endOffset" : 67
    }, {
      "referenceID" : 10,
      "context" : "6 FitzGerald et al. (2015) (local) - - 75.2 Roth and Lapata (2016) (local) 76.9 73.8 75.3 Marcheggiani et al. (2017) (local) 78.",
      "startOffset" : 2,
      "endOffset" : 117
    }, {
      "referenceID" : 21,
      "context" : "Still, when combining LSTMs and GCNs, we do not observe improvements from deep GCNs, unlike the nodel labeled task considered in Kipf and Welling (2016). We hypothesized that this has to do with the expressive power of BiLSTMs.",
      "startOffset" : 129,
      "endOffset" : 153
    }, {
      "referenceID" : 15,
      "context" : "Perhaps the earliest methods modeling syntaxsemantics interface with RNNs are due to (Henderson et al., 2008; Titov et al., 2009; Gesmundo et al., 2009), they used shift-reduce parsers for joint SRL and syntactic parsing, and relied on RNNs to model statistical dependencies across syntactic and semantic parsing actions.",
      "startOffset" : 85,
      "endOffset" : 152
    }, {
      "referenceID" : 43,
      "context" : "Perhaps the earliest methods modeling syntaxsemantics interface with RNNs are due to (Henderson et al., 2008; Titov et al., 2009; Gesmundo et al., 2009), they used shift-reduce parsers for joint SRL and syntactic parsing, and relied on RNNs to model statistical dependencies across syntactic and semantic parsing actions.",
      "startOffset" : 85,
      "endOffset" : 152
    }, {
      "referenceID" : 12,
      "context" : "Perhaps the earliest methods modeling syntaxsemantics interface with RNNs are due to (Henderson et al., 2008; Titov et al., 2009; Gesmundo et al., 2009), they used shift-reduce parsers for joint SRL and syntactic parsing, and relied on RNNs to model statistical dependencies across syntactic and semantic parsing actions.",
      "startOffset" : 85,
      "endOffset" : 152
    }, {
      "referenceID" : 32,
      "context" : "integrating syntax while minimizing the amount of feature engineering), focused on tree kernels and their applications to SRL (Moschitti et al., 2008).",
      "startOffset" : 126,
      "endOffset" : 150
    }, {
      "referenceID" : 10,
      "context" : ", 2009; Gesmundo et al., 2009), they used shift-reduce parsers for joint SRL and syntactic parsing, and relied on RNNs to model statistical dependencies across syntactic and semantic parsing actions. A more modern (e.g., based on LSTMs) and effective reincarnation of this line of research has been proposed in Swayamdipta et al. (2016). Other recent work which considered incorporation of syntactic information in neural SRL models include: FitzGerald et al.",
      "startOffset" : 8,
      "endOffset" : 337
    }, {
      "referenceID" : 10,
      "context" : "Other recent work which considered incorporation of syntactic information in neural SRL models include: FitzGerald et al. (2015) who use standard syntactic features within an MLP calculating potentials of a CRF model; Roth and Lapata (2016) who enriched standard features for SRL with LSTM representations of syntactic paths between arguments and predicates; Lei et al.",
      "startOffset" : 104,
      "endOffset" : 129
    }, {
      "referenceID" : 10,
      "context" : "Other recent work which considered incorporation of syntactic information in neural SRL models include: FitzGerald et al. (2015) who use standard syntactic features within an MLP calculating potentials of a CRF model; Roth and Lapata (2016) who enriched standard features for SRL with LSTM representations of syntactic paths between arguments and predicates; Lei et al.",
      "startOffset" : 104,
      "endOffset" : 241
    }, {
      "referenceID" : 10,
      "context" : "Other recent work which considered incorporation of syntactic information in neural SRL models include: FitzGerald et al. (2015) who use standard syntactic features within an MLP calculating potentials of a CRF model; Roth and Lapata (2016) who enriched standard features for SRL with LSTM representations of syntactic paths between arguments and predicates; Lei et al. (2015) who relied on low-rank tensor factorizations for modeling syntax.",
      "startOffset" : 104,
      "endOffset" : 377
    }, {
      "referenceID" : 10,
      "context" : "Other recent work which considered incorporation of syntactic information in neural SRL models include: FitzGerald et al. (2015) who use standard syntactic features within an MLP calculating potentials of a CRF model; Roth and Lapata (2016) who enriched standard features for SRL with LSTM representations of syntactic paths between arguments and predicates; Lei et al. (2015) who relied on low-rank tensor factorizations for modeling syntax. Also Foland and Martin (2015) used (nongraph) convolutional neural networks and provided syntactic features (e.",
      "startOffset" : 104,
      "endOffset" : 473
    }, {
      "referenceID" : 28,
      "context" : "Beyond SRL, there have been many proposals on how to incorporate syntactic information in RNN models, for example, in the context of neural machine translation (Luong et al., 2015; Eriguchi et al., 2017; Sennrich and Haddow, 2016).",
      "startOffset" : 160,
      "endOffset" : 230
    }, {
      "referenceID" : 9,
      "context" : "Beyond SRL, there have been many proposals on how to incorporate syntactic information in RNN models, for example, in the context of neural machine translation (Luong et al., 2015; Eriguchi et al., 2017; Sennrich and Haddow, 2016).",
      "startOffset" : 160,
      "endOffset" : 230
    }, {
      "referenceID" : 38,
      "context" : "Beyond SRL, there have been many proposals on how to incorporate syntactic information in RNN models, for example, in the context of neural machine translation (Luong et al., 2015; Eriguchi et al., 2017; Sennrich and Haddow, 2016).",
      "startOffset" : 160,
      "endOffset" : 230
    }, {
      "referenceID" : 39,
      "context" : "the most popular and attractive approaches is to use tree-structured recursive neural networks (Socher et al., 2013), which, though originally introduced for constituent syntax, can also be applied in the dependency parsing context (Le and Zuidema, 2014; Dyer et al.",
      "startOffset" : 95,
      "endOffset" : 116
    }, {
      "referenceID" : 22,
      "context" : ", 2013), which, though originally introduced for constituent syntax, can also be applied in the dependency parsing context (Le and Zuidema, 2014; Dyer et al., 2015).",
      "startOffset" : 123,
      "endOffset" : 164
    }, {
      "referenceID" : 7,
      "context" : ", 2013), which, though originally introduced for constituent syntax, can also be applied in the dependency parsing context (Le and Zuidema, 2014; Dyer et al., 2015).",
      "startOffset" : 123,
      "endOffset" : 164
    }, {
      "referenceID" : 6,
      "context" : "(2015) to sentiment analysis and question classification, introduced even before GCNs became popular in the machine learning community (Duvenaud et al., 2015; Kipf and Welling, 2016), is related to graph convolution.",
      "startOffset" : 135,
      "endOffset" : 182
    }, {
      "referenceID" : 21,
      "context" : "(2015) to sentiment analysis and question classification, introduced even before GCNs became popular in the machine learning community (Duvenaud et al., 2015; Kipf and Welling, 2016), is related to graph convolution.",
      "startOffset" : 135,
      "endOffset" : 182
    }, {
      "referenceID" : 6,
      "context" : ", 2013), which, though originally introduced for constituent syntax, can also be applied in the dependency parsing context (Le and Zuidema, 2014; Dyer et al., 2015). An approach of Mou et al. (2015) to sentiment analysis and question classification, introduced even before GCNs became popular in the machine learning community (Duvenaud et al.",
      "startOffset" : 146,
      "endOffset" : 199
    }, {
      "referenceID" : 34,
      "context" : "Though most previous work have focused on undirected unlabeled graphs, the model of Pham et al. (2017) used directed graphs for the node classification task.",
      "startOffset" : 84,
      "endOffset" : 103
    } ],
    "year" : 2017,
    "abstractText" : "Semantic role labeling (SRL) is the task of identifying the predicate-argument structure of a sentence. It is typically regarded as an important step in the standard natural language processing pipeline, providing information to downstream tasks such as information extraction and question answering. As the semantic representations are closely related to syntactic ones, we exploit syntactic information in our model. We propose a version of graph convolutional networks (GCNs), a recent class of multilayer neural networks operating on graphs, suited to modeling syntactic dependency graphs. GCNs over syntactic dependency trees are used as sentence encoders, producing latent feature representations of words in a sentence and capturing information relevant to predicting the semantic representations. We observe that GCN layers are complementary to LSTM ones: when we stack both GCN and LSTM layers, we obtain a substantial improvement over an already stateof-the-art LSTM SRL model, resulting in the best reported scores on the standard benchmark (CoNLL-2009) both for Chinese and English.",
    "creator" : "LaTeX with hyperref package"
  }
}